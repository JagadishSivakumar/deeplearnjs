(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("../src/index"));

},{"../src/index":11}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var deeplearnjs_1 = require("../deeplearnjs");
var Piano = require('tone-piano').Piano;
var piano = new Piano({ velocities: 4 }).toMaster();
piano.load('https://tambien.github.io/Piano/Salamander/').then(function () {
    var reader = new deeplearnjs_1.CheckpointLoader('.');
    return reader.getAllVariables();
}).then(function (vars) {
    document.querySelector('#status').textContent = 'Playing';
    currentTime = piano.now();
    generateStep(vars);
});
var currentTime = 0;
var currentVelocity = 1;
var math = new deeplearnjs_1.NDArrayMathGPU();
var INPUT_SIZE = 388;
var PRIMER_IDX = 355;
var lastSample = PRIMER_IDX;
function generateStep(vars) {
    var lstmKernel1 = vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/kernel'];
    var lstmBias1 = vars['rnn/multi_rnn_cell/cell_0/basic_lstm_cell/bias'];
    var lstmKernel2 = vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/kernel'];
    var lstmBias2 = vars['rnn/multi_rnn_cell/cell_1/basic_lstm_cell/bias'];
    var lstmKernel3 = vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/kernel'];
    var lstmBias3 = vars['rnn/multi_rnn_cell/cell_2/basic_lstm_cell/bias'];
    var fullyConnectedBiases = vars['fully_connected/biases'];
    var fullyConnectedWeights = vars['fully_connected/weights'];
    math.scope(function (keep, track) {
        var forgetBias = track(deeplearnjs_1.Scalar.new(1.0));
        var lstm1 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel1, lstmBias1);
        var lstm2 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel2, lstmBias2);
        var lstm3 = math.basicLSTMCell.bind(math, forgetBias, lstmKernel3, lstmBias3);
        var c = [
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias1.shape[0] / 4])),
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias2.shape[0] / 4])),
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias3.shape[0] / 4])),
        ];
        var h = [
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias1.shape[0] / 4])),
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias2.shape[0] / 4])),
            track(deeplearnjs_1.Array2D.zeros([1, lstmBias3.shape[0] / 4])),
        ];
        var input = track(deeplearnjs_1.Array2D.zeros([1, INPUT_SIZE]));
        input.set(1.0, 0, lastSample);
        for (var i = 0; i < 100; i++) {
            var output = math.multiRNNCell([lstm1, lstm2, lstm3], input, c, h);
            c = output[0];
            h = output[1];
            var outputH = h[2];
            var weightedResult = math.matMul(outputH, fullyConnectedWeights);
            var logits = math.add(weightedResult, fullyConnectedBiases);
            var softmax = math.softmax(logits.as1D());
            var sampledOutput = sampleFromSoftmax(math, softmax);
            playOutput(sampledOutput);
            lastSample = sampledOutput;
            input = track(deeplearnjs_1.Array2D.zeros([1, INPUT_SIZE]));
            input.set(1.0, 0, lastSample);
        }
    });
    var delta = currentTime - piano.now();
    setTimeout(function () { return generateStep(vars); }, delta * 1000);
}
var MIN_MIDI_PITCH = 0;
var MAX_MIDI_PITCH = 127;
var VELOCITY_BINS = 32;
var MAX_SHIFT_STEPS = 100;
var STEPS_PER_SECOND = 100;
var EVENT_RANGES = [
    ['note_on', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['note_off', MIN_MIDI_PITCH, MAX_MIDI_PITCH],
    ['time_shift', 1, MAX_SHIFT_STEPS],
    ['velocity_change', 1, VELOCITY_BINS],
];
function playOutput(index) {
    var offset = 0;
    for (var _i = 0, EVENT_RANGES_1 = EVENT_RANGES; _i < EVENT_RANGES_1.length; _i++) {
        var eventRange = EVENT_RANGES_1[_i];
        var eventType = eventRange[0];
        var minValue = eventRange[1];
        var maxValue = eventRange[2];
        if (offset <= index && index <= offset + maxValue - minValue) {
            if (eventType === 'note_on') {
                return piano.keyDown(index - offset, currentTime, currentVelocity);
            }
            else if (eventType === 'note_off') {
                return piano.keyUp(index - offset, currentTime);
            }
            else if (eventType === 'time_shift') {
                currentTime += (index - offset + 1) / STEPS_PER_SECOND;
                return currentTime;
            }
            else if (eventType === 'velocity_change') {
                currentVelocity = (index - offset + 1) * Math.ceil(127 / VELOCITY_BINS);
                currentVelocity = currentVelocity / 127;
                return currentVelocity;
            }
            else {
                throw new Error('Could not decode eventType: ' + eventType);
            }
        }
        offset += maxValue - minValue + 1;
    }
    throw new Error('Could not decode index: ' + index);
}
function sampleFromSoftmax(math, softmax) {
    var softmaxValues = softmax.getValues();
    var rand = deeplearnjs_1.Scalar.randUniform([], 0, 1).get();
    var cdf = 0;
    for (var i = 0; i < softmaxValues.length; i++) {
        cdf += softmaxValues[i];
        if (cdf > rand) {
            return i;
        }
    }
    throw new Error('Could not sample from softmax.');
}

},{"../deeplearnjs":1,"tone-piano":3}],3:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("tone")):"function"==typeof define&&define.amd?define(["tone"],t):"object"==typeof exports?exports.Piano=t(require("tone")):e.Piano=t(e.tone)}(this,function(e){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=8)}([function(t,n){t.exports=e},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(2);t.default={getReleasesUrl:function(e){return"rel"+(e-20)+".[mp3|ogg]"},getHarmonicsUrl:function(e){return"harmL"+(0,r.midiToNote)(e).replace("#","s")+".[mp3|ogg]"},getNotesUrl:function(e,t){return(0,r.midiToNote)(e).replace("#","s")+"v"+t+".[mp3|ogg]"}}},function(e,t,n){"use strict";function r(e){return(0,s.Frequency)(e).toMidi()}function o(e){return(0,s.Frequency)(e,"midi").toNote()}function i(e){var t=e%3;return 1===t?[e-1,c.default.intervalToFrequencyRatio(1)]:2===t?[e+1,c.default.intervalToFrequencyRatio(-1)]:[e,1]}function u(e){return new s.BufferSource(e)}function a(e,t){return Math.random()*(t-e)+e}Object.defineProperty(t,"__esModule",{value:!0}),t.randomBetween=t.midiToFrequencyRatio=t.createSource=t.noteToMidi=t.midiToNote=void 0;var s=n(0),c=function(e){return e&&e.__esModule?e:{default:e}}(s);t.midiToNote=o,t.noteToMidi=r,t.createSource=u,t.midiToFrequencyRatio=i,t.randomBetween=a},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var u=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=n(0),s=function(e){return e&&e.__esModule?e:{default:e}}(a),c=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;r(this,t);var n=o(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n.volume=e,n}return i(t,e),u(t,[{key:"volume",get:function(){return s.default.gainToDb(this.output.gain.value)},set:function(e){this.output.gain.value=s.default.dbToGain(e)}}]),t}(a.AudioNode);t.default=c},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(1),c=r(s),l=n(3),f=r(l),p=n(2),h=n(0),d=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87],_=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108];o(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),r=d.findIndex(function(t){return t>=e[0]}),u=d.findIndex(function(t){return t>=e[1]});u=-1===u?u=d.length:u;var a=d.slice(r,u);n._samples={};var s=!0,l=!1,f=void 0;try{for(var p,h=a[Symbol.iterator]();!(s=(p=h.next()).done);s=!0){var _=p.value;n._samples[_]=c.default.getHarmonicsUrl(_)}}catch(e){l=!0,f=e}finally{try{!s&&h.return&&h.return()}finally{if(l)throw f}}return n}return u(t,e),a(t,[{key:"start",value:function(e,t,n){e>=d[0]&&e<=d[d.length-1]&&this._sampler.triggerAttack((0,p.midiToNote)(e),t,n*(0,p.randomBetween)(.5,1))}},{key:"load",value:function(e){var t=this;return new Promise(function(n,r){t._sampler=new h.Sampler(t._samples,n,e).connect(t.output),t._sampler.release=1})}}]),t}(f.default);t.default=_},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Notes=void 0;var a=function(){function e(e,t){var n=[],r=!0,o=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!t||n.length!==t);r=!0);}catch(e){o=!0,i=e}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),c=n(0),l=(r(c),n(1)),f=r(l),p=n(3),h=r(p),d=n(2),_={1:[8],2:[6,12],3:[1,8,15],4:[1,5,10,15],5:[1,4,8,12,16],6:[1,3,7,10,13,16],7:[1,3,6,9,11,13,16],8:[1,3,5,7,9,11,13,15],9:[1,3,5,7,9,11,13,15,16],10:[1,2,3,5,7,9,11,13,15,16],11:[1,2,3,5,7,9,11,13,14,15,16],12:[1,2,3,4,5,7,9,11,13,14,15,16],13:[1,2,3,4,5,7,9,11,12,13,14,15,16],14:[1,2,3,4,5,6,7,9,11,12,13,14,15,16],15:[1,2,3,4,5,6,7,9,10,11,12,13,14,15,16],16:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]},y=[21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99,102,105,108];t.Notes=function(e){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[21,108],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;o(this,t);var r=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this)),u=y.findIndex(function(t){return t>=e[0]}),a=y.findIndex(function(t){return t>=e[1]});a=-1===a?a=y.length:a+1;var s=y.slice(u,a);return r._samplers=_[n].slice(),r._activeNotes=new Map,r._samplers.forEach(function(e,t){r._samplers[t]={},s.forEach(function(n){r._samplers[t][n]=f.default.getNotesUrl(n,e)})}),r}return u(t,e),s(t,[{key:"_hasNote",value:function(e,t){return this._samplers.hasOwnProperty(t)&&this._samplers[t].has(e)}},{key:"_getNote",value:function(e,t){return this._samplers[t].get(e)}},{key:"stop",value:function(e,t,n){this._activeNotes.has(e)&&(this._activeNotes.get(e).forEach(function(e){e.stop(t+1,1)}),this._activeNotes.delete(e))}},{key:"start",value:function(e,t,n){var r=n*(this._samplers.length-1),o=Math.round(r),i=o-r,u=1-.5*i;1===this._samplers.length&&(u=n);var s=(0,d.midiToFrequencyRatio)(e),c=a(s,2),l=c[0],f=c[1];if(this._hasNote(l,o)){var p=(0,d.createSource)(this._getNote(l,o));p.playbackRate.value=f,p.connect(this.output),p.curve="exponential",p.start(t,0,void 0,u,0),this._activeNotes.has(e)||this._activeNotes.set(e,[]),this._activeNotes.get(e).push(p)}}},{key:"load",value:function(e){var t=this,n=[];return this._samplers.forEach(function(r,o){var i=new Promise(function(n){t._samplers[o]=new c.Buffers(r,n,e)});n.push(i)}),Promise.all(n)}}]),t}(h.default)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(3),c=r(s),l=n(1),f=(r(l),n(2)),p=n(0),h=(r(p),function(e){function t(){o(this,t);var e=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return e._downTime=1/0,e._currentSound=null,e._buffers=null,e}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new p.Buffers({up:"pedalU1.mp3",down:"pedalD1.mp3"},n,e)})}},{key:"_squash",value:function(e){this._currentSound&&this._currentSound.stop(e+.1,.1),this._currentSound=null}},{key:"_playSample",value:function(e,t){this._currentSound=(0,f.createSource)(this._buffers.get(t)),this._currentSound.curve="exponential",this._currentSound.connect(this.output).start(e,(0,f.randomBetween)(0,.01),void 0,.5*(0,f.randomBetween)(.5,1),.05)}},{key:"down",value:function(e){this._squash(e),this._downTime=e,this._playSample(e,"down")}},{key:"up",value:function(e){this._squash(e),this._downTime=1/0,this._playSample(e,"up")}},{key:"isDown",value:function(e){return e>this._downTime}}]),t}(c.default));t.default=h},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(1),c=r(s),l=n(3),f=r(l),p=n(2),h=n(0),d=function(e){function t(e){o(this,t);var n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));n._buffers={};for(var r=e[0];r<=e[1];r++)n._buffers[r]=c.default.getReleasesUrl(r);return n}return u(t,e),a(t,[{key:"load",value:function(e){var t=this;return new Promise(function(n){t._buffers=new h.Buffers(t._buffers,n,e)})}},{key:"start",value:function(e,t,n){if(this._buffers.has(e)){var r=(0,p.createSource)(this._buffers.get(e)).connect(this.output);n*=(0,p.randomBetween)(.5,1),r.start(t,0,void 0,.015*n,0)}}}]),t}(f.default);t.default=d},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function u(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.Piano=void 0;var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(0),c=r(s),l=n(6),f=r(l),p=n(5),h=n(4),d=r(h),_=n(7),y=r(_),v=n(1);r(v),t.Piano=function(e){function t(){o(this,t);var e=c.default.defaults(arguments,["range","velocities"],{velocities:1,range:[21,108],release:!0}),n=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.createInsOuts(0,1),n._loaded=!1,n._heldNotes=new Map,n._sustainedNotes=new Map,n._notes=new p.Notes(e.range,e.velocities).connect(n.output),n._pedal=(new f.default).connect(n.output),e.release&&(n._harmonics=new d.default(e.range).connect(n.output),n._release=new y.default(e.range).connect(n.output)),n}return u(t,e),a(t,[{key:"load",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"https://tambien.github.io/Piano/Salamander/",n=[this._notes.load(t),this._pedal.load(t)];return this._harmonics&&n.push(this._harmonics.load(t)),this._release&&n.push(this._release.load(t)),Promise.all(n).then(function(){e._loaded=!0})}},{key:"pedalDown",value:function(e){return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)||this._pedal.down(e)),this}},{key:"pedalUp",value:function(e){var t=this;return this.loaded&&(e=this.toSeconds(e),this._pedal.isDown(e)&&(this._pedal.up(e),this._sustainedNotes.forEach(function(n,r){t._heldNotes.has(r)||t._notes.stop(r,e)}),this._sustainedNotes.clear())),this}},{key:"keyDown",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;return this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e)||(this._heldNotes.set(e,{time:t,velocity:n}),this._notes.start(e,t,n))),this}},{key:"keyUp",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.default.now(),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;if(this.loaded&&(t=this.toSeconds(t),c.default.isString(e)&&(e=Math.round((0,s.Frequency)(e).toMidi())),this._heldNotes.has(e))){var r=this._heldNotes.get(e);this._heldNotes.delete(e),this._release&&this._release.start(e,t,n);var o=t-r.time,i=r.velocity,u=.5/Math.max(o,.1)+i+n;u=Math.pow(Math.log(Math.max(u,1)),2)/2,this._pedal.isDown(t)?this._sustainedNotes.has(e)||this._sustainedNotes.set(e,t):(this._notes.stop(e,t,n),this._harmonics&&this._harmonics.start(e,t,u))}return this}},{key:"setVolume",value:function(e,t){switch(e){case"note":this._notes.volume=t;break;case"pedal":this._pedal.volume=t;break;case"release":this._release&&(this._release.volume=t);break;case"harmonics":this._harmonics&&(this._harmonics.volume=t)}return this}},{key:"stopAll",value:function(){var e=this;return this.pedalUp(),this._heldNotes.forEach(function(t,n){e.keyUp(n)}),this}},{key:"progress",value:function(e){return s.Buffer.on("progress",e),this}},{key:"loaded",get:function(){return this._loaded}}]),t}(s.AudioNode)}])});

},{"tone":4}],4:[function(require,module,exports){
(function(root, factory){

	//UMD
	if ( typeof define === "function" && define.amd ) {
		define(function() {
			return factory();
		});
	} else if (typeof module === "object") {
		module.exports = factory();
 	} else {
		root.Tone = factory();
	}

}(this, function(){

	"use strict";
	
	var Tone;
	//constructs the main Tone object
	function Main(func){
		Tone = func();
	}
	//invokes each of the modules with the main Tone object as the argument
	function Module(func){
		func(Tone);
	}	/**
	 *  Tone.js
	 *  @author Yotam Mann
	 *  @license http://opensource.org/licenses/MIT MIT License
	 *  @copyright 2014-2017 Yotam Mann
	 */
	Main(function () {
	    
	    ///////////////////////////////////////////////////////////////////////////
	    //	TONE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @class  Tone is the base class of all other classes.
		 *  @constructor
		 */
	    var Tone = function () {
	    };
	    /**
		 *  @memberOf Tone#
		 *  @returns {string} returns the name of the class as a string
		 */
	    Tone.prototype.toString = function () {
	        for (var className in Tone) {
	            var isLetter = className[0].match(/^[A-Z]$/);
	            var sameConstructor = Tone[className] === this.constructor;
	            if (Tone.isFunction(Tone[className]) && isLetter && sameConstructor) {
	                return className;
	            }
	        }
	        return 'Tone';
	    };
	    /**
		 *  @memberOf Tone#
		 *  disconnect and dispose
		 *  @returns {Tone} this
		 */
	    Tone.prototype.dispose = function () {
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GET/SET
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Set the parameters at once. Either pass in an
		 *  object mapping parameters to values, or to set a
		 *  single parameter, by passing in a string and value.
		 *  The last argument is an optional ramp time which
		 *  will ramp any signal values to their destination value
		 *  over the duration of the rampTime.
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone} this
		 *  @memberOf Tone#
		 *  @example
		 * //set values using an object
		 * filter.set({
		 * 	"frequency" : 300,
		 * 	"type" : highpass
		 * });
		 *  @example
		 * filter.set("type", "highpass");
		 *  @example
		 * //ramp to the value 220 over 3 seconds.
		 * oscillator.set({
		 * 	"frequency" : 220
		 * }, 3);
		 */
	    Tone.prototype.set = function (params, value, rampTime) {
	        if (Tone.isObject(params)) {
	            rampTime = value;
	        } else if (Tone.isString(params)) {
	            var tmpObj = {};
	            tmpObj[params] = value;
	            params = tmpObj;
	        }
	        paramLoop:
	            for (var attr in params) {
	                value = params[attr];
	                var parent = this;
	                if (attr.indexOf('.') !== -1) {
	                    var attrSplit = attr.split('.');
	                    for (var i = 0; i < attrSplit.length - 1; i++) {
	                        parent = parent[attrSplit[i]];
	                        if (parent instanceof Tone) {
	                            attrSplit.splice(0, i + 1);
	                            var innerParam = attrSplit.join('.');
	                            parent.set(innerParam, value);
	                            continue paramLoop;
	                        }
	                    }
	                    attr = attrSplit[attrSplit.length - 1];
	                }
	                var param = parent[attr];
	                if (Tone.isUndef(param)) {
	                    continue;
	                }
	                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {
	                    if (param.value !== value) {
	                        if (Tone.isUndef(rampTime)) {
	                            param.value = value;
	                        } else {
	                            param.rampTo(value, rampTime);
	                        }
	                    }
	                } else if (param instanceof AudioParam) {
	                    if (param.value !== value) {
	                        param.value = value;
	                    }
	                } else if (param instanceof Tone) {
	                    param.set(value);
	                } else if (param !== value) {
	                    parent[attr] = value;
	                }
	            }
	        return this;
	    };
	    /**
		 *  Get the object's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @memberOf Tone#
		 *  @example
		 * osc.get();
		 * //returns {"type" : "sine", "frequency" : 440, ...etc}
		 *  @example
		 * osc.get("type");
		 * //returns { "type" : "sine"}
		 * @example
		 * //use dot notation to access deep properties
		 * synth.get(["envelope.attack", "envelope.release"]);
		 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
		 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return
		 *  					                  all available.
		 *  @returns {Object}
		 */
	    Tone.prototype.get = function (params) {
	        if (Tone.isUndef(params)) {
	            params = this._collectDefaults(this.constructor);
	        } else if (Tone.isString(params)) {
	            params = [params];
	        }
	        var ret = {};
	        for (var i = 0; i < params.length; i++) {
	            var attr = params[i];
	            var parent = this;
	            var subRet = ret;
	            if (attr.indexOf('.') !== -1) {
	                var attrSplit = attr.split('.');
	                for (var j = 0; j < attrSplit.length - 1; j++) {
	                    var subAttr = attrSplit[j];
	                    subRet[subAttr] = subRet[subAttr] || {};
	                    subRet = subRet[subAttr];
	                    parent = parent[subAttr];
	                }
	                attr = attrSplit[attrSplit.length - 1];
	            }
	            var param = parent[attr];
	            if (Tone.isObject(params[attr])) {
	                subRet[attr] = param.get();
	            } else if (Tone.Signal && param instanceof Tone.Signal) {
	                subRet[attr] = param.value;
	            } else if (Tone.Param && param instanceof Tone.Param) {
	                subRet[attr] = param.value;
	            } else if (param instanceof AudioParam) {
	                subRet[attr] = param.value;
	            } else if (param instanceof Tone) {
	                subRet[attr] = param.get();
	            } else if (!Tone.isFunction(param) && !Tone.isUndef(param)) {
	                subRet[attr] = param;
	            }
	        }
	        return ret;
	    };
	    /**
		 *  collect all of the default attributes in one
		 *  @private
		 *  @param {function} constr the constructor to find the defaults from
		 *  @return {Array} all of the attributes which belong to the class
		 */
	    Tone.prototype._collectDefaults = function (constr) {
	        var ret = [];
	        if (!Tone.isUndef(constr.defaults)) {
	            ret = Object.keys(constr.defaults);
	        }
	        if (!Tone.isUndef(constr._super)) {
	            var superDefs = this._collectDefaults(constr._super);
	            //filter out repeats
	            for (var i = 0; i < superDefs.length; i++) {
	                if (ret.indexOf(superDefs[i]) === -1) {
	                    ret.push(superDefs[i]);
	                }
	            }
	        }
	        return ret;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  @memberOf Tone
		 *  @param  {Array}  values  The arguments array
		 *  @param  {Array}  keys    The names of the arguments
		 *  @param {Function|Object} constr The class constructor
		 *  @return  {Object}  An object composed of the  defaults between the class' defaults
		 *                        and the passed in arguments.
		 */
	    Tone.defaults = function (values, keys, constr) {
	        var options = {};
	        if (values.length === 1 && Tone.isObject(values[0])) {
	            options = values[0];
	        } else {
	            for (var i = 0; i < keys.length; i++) {
	                options[keys[i]] = values[i];
	            }
	        }
	        if (!Tone.isUndef(constr.defaults)) {
	            return Tone.defaultArg(options, constr.defaults);
	        } else if (Tone.isObject(constr)) {
	            return Tone.defaultArg(options, constr);
	        } else {
	            return options;
	        }
	    };
	    /**
		 *  If the `given` parameter is undefined, use the `fallback`.
		 *  If both `given` and `fallback` are object literals, it will
		 *  return a deep copy which includes all of the parameters from both
		 *  objects. If a parameter is undefined in given, it will return
		 *  the fallback property.
		 *  <br><br>
		 *  WARNING: if object is self referential, it will go into an an
		 *  infinite recursive loop.
		 *  @memberOf Tone
		 *  @param  {*} given
		 *  @param  {*} fallback
		 *  @return {*}
		 */
	    Tone.defaultArg = function (given, fallback) {
	        if (Tone.isObject(given) && Tone.isObject(fallback)) {
	            var ret = {};
	            //make a deep copy of the given object
	            for (var givenProp in given) {
	                ret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);
	            }
	            for (var fallbackProp in fallback) {
	                ret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);
	            }
	            return ret;
	        } else {
	            return Tone.isUndef(given) ? fallback : given;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONNECTIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  connect together all of the arguments in series
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone}
		 *  @memberOf Tone
		 *  @static
		 */
	    Tone.connectSeries = function () {
	        var currentUnit = arguments[0];
	        for (var i = 1; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return Tone;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // TYPE CHECKING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  test if the arg is undefined
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is undefined
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isUndef = function (val) {
	        return typeof val === 'undefined';
	    };
	    /**
		 *  test if the arg is a function
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a function
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isFunction = function (val) {
	        return typeof val === 'function';
	    };
	    /**
		 *  Test if the argument is a number.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a number
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNumber = function (arg) {
	        return typeof arg === 'number';
	    };
	    /**
		 *  Test if the given argument is an object literal (i.e. `{}`);
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an object literal.
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isObject = function (arg) {
	        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;
	    };
	    /**
		 *  Test if the argument is a boolean.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a boolean
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isBoolean = function (arg) {
	        return typeof arg === 'boolean';
	    };
	    /**
		 *  Test if the argument is an Array
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is an array
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isArray = function (arg) {
	        return Array.isArray(arg);
	    };
	    /**
		 *  Test if the argument is a string.
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isString = function (arg) {
	        return typeof arg === 'string';
	    };
	    /**
		 *  Test if the argument is in the form of a note in scientific pitch notation.
		 *  e.g. "C4"
		 *  @param {*} arg the argument to test
		 *  @returns {boolean} true if the arg is a string
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.isNote = function (arg) {
	        return Tone.isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);
	    };
	    /**
		 *  An empty function.
		 *  @static
		 */
	    Tone.noOp = function () {
	    };
	    /**
		 *  Make the property not writable. Internal use only.
		 *  @private
		 *  @param  {string}  property  the property to make not writable
		 */
	    Tone.prototype._readOnly = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._readOnly(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, {
	                writable: false,
	                enumerable: true
	            });
	        }
	    };
	    /**
		 *  Make an attribute writeable. Interal use only.
		 *  @private
		 *  @param  {string}  property  the property to make writable
		 */
	    Tone.prototype._writable = function (property) {
	        if (Array.isArray(property)) {
	            for (var i = 0; i < property.length; i++) {
	                this._writable(property[i]);
	            }
	        } else {
	            Object.defineProperty(this, property, { writable: true });
	        }
	    };
	    /**
		 * Possible play states.
		 * @enum {string}
		 */
	    Tone.State = {
	        Started: 'started',
	        Stopped: 'stopped',
	        Paused: 'paused'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Equal power gain scale. Good for cross-fading.
		 *  @param  {NormalRange} percent (0-1)
		 *  @return {Number}         output gain (0-1)
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.equalPowerScale = function (percent) {
	        var piFactor = 0.5 * Math.PI;
	        return Math.sin(percent * piFactor);
	    };
	    /**
		 *  Convert decibels into gain.
		 *  @param  {Decibels} db
		 *  @return {Number}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.dbToGain = function (db) {
	        return Math.pow(2, db / 6);
	    };
	    /**
		 *  Convert gain to decibels.
		 *  @param  {Number} gain (0-1)
		 *  @return {Decibels}
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.gainToDb = function (gain) {
	        return 20 * (Math.log(gain) / Math.LN10);
	    };
	    /**
		 *  Convert an interval (in semitones) to a frequency ratio.
		 *  @param  {Interval} interval the number of semitones above the base note
		 *  @return {number}          the frequency ratio
		 *  @static
		 *  @memberOf Tone
		 *  @example
		 * tone.intervalToFrequencyRatio(0); // 1
		 * tone.intervalToFrequencyRatio(12); // 2
		 * tone.intervalToFrequencyRatio(-12); // 0.5
		 */
	    Tone.intervalToFrequencyRatio = function (interval) {
	        return Math.pow(2, interval / 12);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	TIMING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @memberOf Tone#
		 */
	    Tone.prototype.now = function () {
	        return Tone.context.now();
	    };
	    /**
		 *  Return the current time of the AudioContext clock.
		 *  @return {Number} the currentTime from the AudioContext
		 *  @static
		 *  @memberOf Tone
		 */
	    Tone.now = function () {
	        return Tone.context.now();
	    };
	    /**
		 * Adds warning in the console if the scheduled time has passed.
		 * @type {Time}
		 */
	    Tone.isPast = function (time) {
	        if (time < Tone.context.currentTime) {
	            console.warn('Time \'' + time + '\' is in the past. Scheduled time must be \u2265 AudioContext.currentTime');
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INHERITANCE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  have a child inherit all of Tone's (or a parent's) prototype
		 *  to inherit the parent's properties, make sure to call
		 *  Parent.call(this) in the child's constructor
		 *
		 *  based on closure library's inherit function
		 *
		 *  @memberOf Tone
		 *  @static
		 *  @param  {function} 	child
		 *  @param  {function=} parent (optional) parent to inherit from
		 *                             if no parent is supplied, the child
		 *                             will inherit from Tone
		 */
	    Tone.extend = function (child, parent) {
	        if (Tone.isUndef(parent)) {
	            parent = Tone;
	        }
	        function TempConstructor() {
	        }
	        TempConstructor.prototype = parent.prototype;
	        child.prototype = new TempConstructor();
	        /** @override */
	        child.prototype.constructor = child;
	        child._super = parent;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	CONTEXT
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  A static pointer to the audio context accessible as Tone.context.
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone
		 */
	    Object.defineProperty(Tone, 'context', {
	        get: function () {
	            return window.TONE_AUDIO_CONTEXT;
	        },
	        set: function (context) {
	            if (Tone.Context && context instanceof Tone.Context) {
	                window.TONE_AUDIO_CONTEXT = context;
	            } else {
	                window.TONE_AUDIO_CONTEXT = new Tone.Context(context);
	            }
	            //initialize the new audio context
	            Tone.Context.emit('init', window.TONE_AUDIO_CONTEXT);
	        }
	    });
	    /**
		 *  The AudioContext
		 *  @type {Tone.Context}
		 *  @name context
		 *  @memberOf Tone#
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'context', {
	        get: function () {
	            return Tone.context;
	        }
	    });
	    /**
		 *  Tone automatically creates a context on init, but if you are working
		 *  with other libraries which also create an AudioContext, it can be
		 *  useful to set your own. If you are going to set your own context,
		 *  be sure to do it at the start of your code, before creating any objects.
		 *  @static
		 *  @param {AudioContext} ctx The new audio context to set
		 */
	    Tone.setContext = function (ctx) {
	        Tone.context = ctx;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ATTRIBUTES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The number of seconds of 1 processing block (128 samples)
		 *  @type {Number}
		 *  @name blockTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'blockTime', {
	        get: function () {
	            return 128 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  The duration in seconds of one sample.
		 *  @type {Number}
		 *  @name sampleTime
		 *  @memberOf Tone
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.prototype, 'sampleTime', {
	        get: function () {
	            return 1 / this.context.sampleRate;
	        }
	    });
	    /**
		 *  Whether or not all the technologies that Tone.js relies on are supported by the current browser.
		 *  @type {Boolean}
		 *  @name supported
		 *  @memberOf Tone
		 *  @readOnly
		 *  @static
		 */
	    Object.defineProperty(Tone, 'supported', {
	        get: function () {
	            var hasAudioContext = window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext');
	            var hasPromises = window.hasOwnProperty('Promise');
	            var hasWorkers = window.hasOwnProperty('Worker');
	            return hasAudioContext && hasPromises && hasWorkers;
	        }
	    });
	    /**
		 *  Boolean value if the audio context has been initialized.
		 *  @type {Boolean}
		 *  @memberOf Tone
		 *  @static
		 *  @name initialized
		 */
	    Object.defineProperty(Tone, 'initialized', {
	        get: function () {
	            return !Tone.isUndef(window.TONE_AUDIO_CONTEXT);
	        }
	    });
	    /**
		 *  Get the context when it becomes available
		 *  @param  {Function}  resolve  Callback when the context is initialized
		 *  @return  {Tone}
		 */
	    Tone.getContext = function (resolve) {
	        if (Tone.initialized) {
	            resolve(Tone.context);
	        } else {
	            var resCallback = function () {
	                resolve(Tone.context);
	                Tone.Context.off('init', resCallback);
	            };
	            Tone.Context.on('init', resCallback);
	        }
	        return Tone;
	    };
	    /**
		 * The version number
		 * @type {String}
		 * @static
		 */
	    Tone.version = 'r12-dev';
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Emitter gives classes which extend it
		 *         the ability to listen for and emit events. 
		 *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).
		 *         MIT (c) 2011 Jerome Etienne.
		 *         
		 *  @extends {Tone}
		 */
	    Tone.Emitter = function () {
	        Tone.call(this);
	        /**
			 *  Contains all of the events.
			 *  @private
			 *  @type  {Object}
			 */
	        this._events = {};
	    };
	    Tone.extend(Tone.Emitter);
	    /**
		 *  Bind a callback to a specific event.
		 *  @param  {String}    event     The name of the event to listen for.
		 *  @param  {Function}  callback  The callback to invoke when the
		 *                                event is emitted
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.on = function (event, callback) {
	        //split the event
	        var events = event.split(/\W+/);
	        for (var i = 0; i < events.length; i++) {
	            var eventName = events[i];
	            if (!this._events.hasOwnProperty(eventName)) {
	                this._events[eventName] = [];
	            }
	            this._events[eventName].push(callback);
	        }
	        return this;
	    };
	    /**
		 *  Remove the event listener.
		 *  @param  {String}    event     The event to stop listening to.
		 *  @param  {Function=}  callback  The callback which was bound to 
		 *                                the event with Tone.Emitter.on.
		 *                                If no callback is given, all callbacks
		 *                                events are removed.
		 *  @return  {Tone.Emitter}    this
		 */
	    Tone.Emitter.prototype.off = function (event, callback) {
	        var events = event.split(/\W+/);
	        for (var ev = 0; ev < events.length; ev++) {
	            event = events[ev];
	            if (this._events.hasOwnProperty(event)) {
	                if (Tone.isUndef(callback)) {
	                    this._events[event] = [];
	                } else {
	                    var eventList = this._events[event];
	                    for (var i = 0; i < eventList.length; i++) {
	                        if (eventList[i] === callback) {
	                            eventList.splice(i, 1);
	                        }
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Invoke all of the callbacks bound to the event
		 *  with any arguments passed in. 
		 *  @param  {String}  event  The name of the event.
		 *  @param {*} args... The arguments to pass to the functions listening.
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.emit = function (event) {
	        if (this._events) {
	            var args = Array.apply(null, arguments).slice(1);
	            if (this._events.hasOwnProperty(event)) {
	                var eventList = this._events[event];
	                for (var i = 0, len = eventList.length; i < len; i++) {
	                    eventList[i].apply(this, args);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Add Emitter functions (on/off/emit) to the object
		 *  @param  {Object|Function}  object  The object or class to extend.
		 *  @returns {Tone.Emitter}
		 */
	    Tone.Emitter.mixin = function (object) {
	        var functions = [
	            'on',
	            'off',
	            'emit'
	        ];
	        object._events = {};
	        for (var i = 0; i < functions.length; i++) {
	            var func = functions[i];
	            var emitterFunc = Tone.Emitter.prototype[func];
	            object[func] = emitterFunc;
	        }
	        return Tone.Emitter;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Emitter}  this
		 */
	    Tone.Emitter.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._events = null;
	        return this;
	    };
	    return Tone.Emitter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Timeline class for scheduling and maintaining state
		 *         along a timeline. All events must have a "time" property.
		 *         Internally, events are stored in time order for fast
		 *         retrieval.
		 *  @extends {Tone}
		 *  @param {Positive} [memory=Infinity] The number of previous events that are retained.
		 */
	    Tone.Timeline = function () {
	        var options = Tone.defaults(arguments, ['memory'], Tone.Timeline);
	        Tone.call(this);
	        /**
			 *  The array of scheduled timeline events
			 *  @type  {Array}
			 *  @private
			 */
	        this._timeline = [];
	        /**
			 *  An array of items to remove from the list.
			 *  @type {Array}
			 *  @private
			 */
	        this._toRemove = [];
	        /**
			 *  An array of items to add from the list (once it's done iterating)
			 *  @type {Array}
			 *  @private
			 */
	        this._toAdd = [];
	        /**
			 *  Flag if the timeline is mid iteration
			 *  @private
			 *  @type {Boolean}
			 */
	        this._iterating = false;
	        /**
			 *  The memory of the timeline, i.e.
			 *  how many events in the past it will retain
			 *  @type {Positive}
			 */
	        this.memory = options.memory;
	    };
	    Tone.extend(Tone.Timeline);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Timeline.defaults = { 'memory': Infinity };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.Timeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Timeline.prototype, 'length', {
	        get: function () {
	            return this._timeline.length;
	        }
	    });
	    /**
		 *  Insert an event object onto the timeline. Events must have a "time" attribute.
		 *  @param  {Object}  event  The event object to insert into the
		 *                           timeline.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.add = function (event) {
	        //the event needs to have a time attribute
	        if (Tone.isUndef(event.time)) {
	            throw new Error('Tone.Timeline: events must have a time attribute');
	        }
	        if (this._iterating) {
	            this._toAdd.push(event);
	        } else {
	            var index = this._search(event.time);
	            this._timeline.splice(index + 1, 0, event);
	            //if the length is more than the memory, remove the previous ones
	            if (this.length > this.memory) {
	                var diff = this.length - this.memory;
	                this._timeline.splice(0, diff);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event object to remove from the list.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.remove = function (event) {
	        if (this._iterating) {
	            this._toRemove.push(event);
	        } else {
	            var index = this._timeline.indexOf(event);
	            if (index !== -1) {
	                this._timeline.splice(index, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the nearest event whose time is less than or equal to the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparator Which value in the object to compare
		 *  @returns {Object} The event object set after that time.
		 */
	    Tone.Timeline.prototype.get = function (time, comparator) {
	        comparator = Tone.defaultArg(comparator, 'time');
	        var index = this._search(time, comparator);
	        if (index !== -1) {
	            return this._timeline[index];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Return the first event in the timeline without removing it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.peek = function () {
	        return this._timeline[0];
	    };
	    /**
		 *  Return the first event in the timeline and remove it
		 *  @returns {Object} The first event object
		 */
	    Tone.Timeline.prototype.shift = function () {
	        return this._timeline.shift();
	    };
	    /**
		 *  Get the event which is scheduled after the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparator Which value in the object to compare
		 *  @returns {Object} The event object after the given time
		 */
	    Tone.Timeline.prototype.getAfter = function (time, comparator) {
	        comparator = Tone.defaultArg(comparator, 'time');
	        var index = this._search(time, comparator);
	        if (index + 1 < this._timeline.length) {
	            return this._timeline[index + 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Get the event before the event at the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @param  {String}  comparator Which value in the object to compare
		 *  @returns {Object} The event object before the given time
		 */
	    Tone.Timeline.prototype.getBefore = function (time, comparator) {
	        comparator = Tone.defaultArg(comparator, 'time');
	        var len = this._timeline.length;
	        //if it's after the last item, return the last item
	        if (len > 0 && this._timeline[len - 1][comparator] < time) {
	            return this._timeline[len - 1];
	        }
	        var index = this._search(time, comparator);
	        if (index - 1 >= 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Cancel events after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancel = function (after) {
	        if (this._timeline.length > 1) {
	            var index = this._search(after);
	            if (index >= 0) {
	                if (this._timeline[index].time === after) {
	                    //get the first item with that time
	                    for (var i = index; i >= 0; i--) {
	                        if (this._timeline[i].time === after) {
	                            index = i;
	                        } else {
	                            break;
	                        }
	                    }
	                    this._timeline = this._timeline.slice(0, index);
	                } else {
	                    this._timeline = this._timeline.slice(0, index + 1);
	                }
	            } else {
	                this._timeline = [];
	            }
	        } else if (this._timeline.length === 1) {
	            //the first item's time
	            if (this._timeline[0].time >= after) {
	                this._timeline = [];
	            }
	        }
	        return this;
	    };
	    /**
		 *  Cancel events before or equal to the given time.
		 *  @param  {Number}  time  The time to cancel before.
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.cancelBefore = function (time) {
	        var index = this._search(time);
	        if (index >= 0) {
	            this._timeline = this._timeline.slice(index + 1);
	        }
	        return this;
	    };
	    /**
		 * Returns the previous event if there is one. null otherwise
		 * @param  {Object} event The event to find the previous one of
		 * @return {Object}       The event right before the given event
		 */
	    Tone.Timeline.prototype.previousEvent = function (event) {
	        var index = this._timeline.indexOf(event);
	        if (index > 0) {
	            return this._timeline[index - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Does a binary search on the timeline array and returns the
		 *  nearest event index whose time is after or equal to the given time.
		 *  If a time is searched before the first index in the timeline, -1 is returned.
		 *  If the time is after the end, the index of the last item is returned.
		 *  @param  {Number}  time
		 *  @param  {String}  comparator Which value in the object to compare
		 *  @return  {Number} the index in the timeline array
		 *  @private
		 */
	    Tone.Timeline.prototype._search = function (time, comparator) {
	        if (this._timeline.length === 0) {
	            return -1;
	        }
	        comparator = Tone.defaultArg(comparator, 'time');
	        var beginning = 0;
	        var len = this._timeline.length;
	        var end = len;
	        if (len > 0 && this._timeline[len - 1][comparator] <= time) {
	            return len - 1;
	        }
	        while (beginning < end) {
	            // calculate the midpoint for roughly equal partition
	            var midPoint = Math.floor(beginning + (end - beginning) / 2);
	            var event = this._timeline[midPoint];
	            var nextEvent = this._timeline[midPoint + 1];
	            if (event[comparator] === time) {
	                //choose the last one that has the same time
	                for (var i = midPoint; i < this._timeline.length; i++) {
	                    var testEvent = this._timeline[i];
	                    if (testEvent[comparator] === time) {
	                        midPoint = i;
	                    }
	                }
	                return midPoint;
	            } else if (event[comparator] < time && nextEvent[comparator] > time) {
	                return midPoint;
	            } else if (event[comparator] > time) {
	                //search lower
	                end = midPoint;
	            } else {
	                //search upper
	                beginning = midPoint + 1;
	            }
	        }
	        return -1;
	    };
	    /**
		 *  Internal iterator. Applies extra safety checks for
		 *  removing items from the array.
		 *  @param  {Function}  callback
		 *  @param  {Number=}    lowerBound
		 *  @param  {Number=}    upperBound
		 *  @private
		 */
	    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {
	        this._iterating = true;
	        lowerBound = Tone.defaultArg(lowerBound, 0);
	        upperBound = Tone.defaultArg(upperBound, this._timeline.length - 1);
	        for (var i = lowerBound; i <= upperBound; i++) {
	            callback.call(this, this._timeline[i]);
	        }
	        this._iterating = false;
	        this._toRemove.forEach(function (event) {
	            this.remove(event);
	        }.bind(this));
	        this._toRemove = [];
	        this._toAdd.forEach(function (event) {
	            this.add(event);
	        }.bind(this));
	        this._toAdd = [];
	    };
	    /**
		 *  Iterate over everything in the array
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEach = function (callback) {
	        this._iterate(callback);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or before the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachBefore = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(callback, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array after the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAfter = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at or after the given time. Similar to
		 *  forEachAfter, but includes the item(s) at the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachFrom = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var lowerBound = this._search(time);
	        //work backwards until the event time is less than time
	        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {
	            lowerBound--;
	        }
	        this._iterate(callback, lowerBound + 1);
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array at the given time
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.Timeline} this
		 */
	    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {
	        //iterate over the items in reverse so that removing an item doesn't break things
	        var upperBound = this._search(time);
	        if (upperBound !== -1) {
	            this._iterate(function (event) {
	                if (event.time === time) {
	                    callback.call(this, event);
	                }
	            }, 0, upperBound);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Timeline}  this
		 */
	    Tone.Timeline.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._timeline = null;
	        this._toRemove = null;
	        this._toAdd = null;
	        return this;
	    };
	    return Tone.Timeline;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('AudioContext') && window.hasOwnProperty('webkitAudioContext')) {
	        window.AudioContext = window.webkitAudioContext;
	    }
	    /**
		 *  @class Wrapper around the native AudioContext.
		 *  @extends {Tone.Emitter}
		 *  @param {AudioContext=} context optionally pass in a context
		 */
	    Tone.Context = function () {
	        Tone.Emitter.call(this);
	        var options = Tone.defaults(arguments, ['context'], Tone.Context);
	        if (!options.context) {
	            options.context = new window.AudioContext();
	        }
	        this._context = options.context;
	        // extend all of the methods
	        for (var prop in this._context) {
	            this._defineProperty(this._context, prop);
	        }
	        /**
			 *  The default latency hint
			 *  @type  {String}
			 *  @private
			 */
	        this._latencyHint = options.latencyHint;
	        /**
			 *  An object containing all of the constants AudioBufferSourceNodes
			 *  @type  {Object}
			 *  @private
			 */
	        this._constants = {};
	        ///////////////////////////////////////////////////////////////////////
	        // WORKER
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  The amount of time events are scheduled
			 *  into the future
			 *  @type  {Number}
			 *  @private
			 */
	        this.lookAhead = options.lookAhead;
	        /**
			 *  A reference to the actual computed update interval
			 *  @type  {Number}
			 *  @private
			 */
	        this._computedUpdateInterval = 0;
	        /**
			 *  A reliable callback method
			 *  @private
			 *  @type  {Ticker}
			 */
	        this._ticker = new Ticker(this.emit.bind(this, 'tick'), options.clockSource, options.updateInterval);
	        ///////////////////////////////////////////////////////////////////////
	        // TIMEOUTS
	        ///////////////////////////////////////////////////////////////////////
	        /**
			 *  All of the setTimeout events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._timeouts = new Tone.Timeline();
	        /**
			 *  The timeout id counter
			 *  @private
			 *  @type {Number}
			 */
	        this._timeoutIds = 0;
	        this.on('tick', this._timeoutLoop.bind(this));
	    };
	    Tone.extend(Tone.Context, Tone.Emitter);
	    Tone.Emitter.mixin(Tone.Context);
	    /**
		 * defaults
		 * @static
		 * @type {Object}
		 */
	    Tone.Context.defaults = {
	        'clockSource': 'worker',
	        'latencyHint': 'interactive',
	        'lookAhead': 0.1,
	        'updateInterval': 0.03
	    };
	    /**
		 *  Define a property on this Tone.Context.
		 *  This is used to extend the native AudioContext
		 *  @param  {AudioContext}  context
		 *  @param  {String}  prop
		 *  @private
		 */
	    Tone.Context.prototype._defineProperty = function (context, prop) {
	        if (Tone.isUndef(this[prop])) {
	            Object.defineProperty(this, prop, {
	                get: function () {
	                    if (typeof context[prop] === 'function') {
	                        return context[prop].bind(context);
	                    } else {
	                        return context[prop];
	                    }
	                },
	                set: function (val) {
	                    context[prop] = val;
	                }
	            });
	        }
	    };
	    /**
		 *  The current audio context time
		 *  @return  {Number}
		 */
	    Tone.Context.prototype.now = function () {
	        return this._context.currentTime + this.lookAhead;
	    };
	    /**
		 *  Generate a looped buffer at some constant value.
		 *  @param  {Number}  val
		 *  @return  {BufferSourceNode}
		 */
	    Tone.Context.prototype.getConstant = function (val) {
	        if (this._constants[val]) {
	            return this._constants[val];
	        } else {
	            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
	            var arr = buffer.getChannelData(0);
	            for (var i = 0; i < arr.length; i++) {
	                arr[i] = val;
	            }
	            var constant = this._context.createBufferSource();
	            constant.channelCount = 1;
	            constant.channelCountMode = 'explicit';
	            constant.buffer = buffer;
	            constant.loop = true;
	            constant.start(0);
	            this._constants[val] = constant;
	            return constant;
	        }
	    };
	    /**
		 *  The private loop which keeps track of the context scheduled timeouts
		 *  Is invoked from the clock source
		 *  @private
		 */
	    Tone.Context.prototype._timeoutLoop = function () {
	        var now = this.now();
	        while (this._timeouts && this._timeouts.length && this._timeouts.peek().time <= now) {
	            this._timeouts.shift().callback();
	        }
	    };
	    /**
		 *  A setTimeout which is gaurenteed by the clock source.
		 *  Also runs in the offline context.
		 *  @param  {Function}  fn       The callback to invoke
		 *  @param  {Seconds}    timeout  The timeout in seconds
		 *  @returns {Number} ID to use when invoking Tone.Context.clearTimeout
		 */
	    Tone.Context.prototype.setTimeout = function (fn, timeout) {
	        this._timeoutIds++;
	        var now = this.now();
	        this._timeouts.add({
	            callback: fn,
	            time: now + timeout,
	            id: this._timeoutIds
	        });
	        return this._timeoutIds;
	    };
	    /**
		 *  Clears a previously scheduled timeout with Tone.context.setTimeout
		 *  @param  {Number}  id  The ID returned from setTimeout
		 *  @return  {Tone.Context}  this
		 */
	    Tone.Context.prototype.clearTimeout = function (id) {
	        this._timeouts.forEach(function (event) {
	            if (event.id === id) {
	                this.remove(event);
	            }
	        });
	        return this;
	    };
	    /**
		 *  How often the Web Worker callback is invoked.
		 *  This number corresponds to how responsive the scheduling
		 *  can be. Context.updateInterval + Context.lookAhead gives you the
		 *  total latency between scheduling an event and hearing it.
		 *  @type {Number}
		 *  @memberOf Tone.Context#
		 *  @name updateInterval
		 */
	    Object.defineProperty(Tone.Context.prototype, 'updateInterval', {
	        get: function () {
	            return this._ticker.updateInterval;
	        },
	        set: function (interval) {
	            this._ticker.updateInterval = interval;
	        }
	    });
	    /**
		 *  What the source of the clock is, either "worker" (Web Worker [default]),
		 *  "timeout" (setTimeout), or "offline" (none).
		 *  @type {String}
		 *  @memberOf Tone.Context#
		 *  @name clockSource
		 */
	    Object.defineProperty(Tone.Context.prototype, 'clockSource', {
	        get: function () {
	            return this._ticker.type;
	        },
	        set: function (type) {
	            this._ticker.type = type;
	        }
	    });
	    /**
		 *  The type of playback, which affects tradeoffs between audio
		 *  output latency and responsiveness.
		 *
		 *  In addition to setting the value in seconds, the latencyHint also
		 *  accepts the strings "interactive" (prioritizes low latency),
		 *  "playback" (prioritizes sustained playback), "balanced" (balances
		 *  latency and performance), and "fastest" (lowest latency, might glitch more often).
		 *  @type {String|Seconds}
		 *  @memberOf Tone.Context#
		 *  @name latencyHint
		 *  @example
		 * //set the lookAhead to 0.3 seconds
		 * Tone.context.latencyHint = 0.3;
		 */
	    Object.defineProperty(Tone.Context.prototype, 'latencyHint', {
	        get: function () {
	            return this._latencyHint;
	        },
	        set: function (hint) {
	            var lookAhead = hint;
	            this._latencyHint = hint;
	            if (Tone.isString(hint)) {
	                switch (hint) {
	                case 'interactive':
	                    lookAhead = 0.1;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'playback':
	                    lookAhead = 0.8;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'balanced':
	                    lookAhead = 0.25;
	                    this._context.latencyHint = hint;
	                    break;
	                case 'fastest':
	                    this._context.latencyHint = 'interactive';
	                    lookAhead = 0.01;
	                    break;
	                }
	            }
	            this.lookAhead = lookAhead;
	            this.updateInterval = lookAhead / 3;
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.Context} this
		 */
	    Tone.Context.prototype.dispose = function () {
	        Tone.Context.emit('close', this);
	        Tone.Emitter.prototype.dispose.call(this);
	        this._ticker.dispose();
	        this._ticker = null;
	        this._timeouts.dispose();
	        this._timeouts = null;
	        for (var con in this._constants) {
	            this._constants[con].disconnect();
	        }
	        this._constants = null;
	        this.close();
	        return this;
	    };
	    /**
		 * @class A class which provides a reliable callback using either
		 *        a Web Worker, or if that isn't supported, falls back to setTimeout.
		 * @private
		 */
	    var Ticker = function (callback, type, updateInterval) {
	        /**
			 * Either "worker" or "timeout"
			 * @type {String}
			 * @private
			 */
	        this._type = type;
	        /**
			 * The update interval of the worker
			 * @private
			 * @type {Number}
			 */
	        this._updateInterval = updateInterval;
	        /**
			 * The callback to invoke at regular intervals
			 * @type {Function}
			 * @private
			 */
	        this._callback = Tone.defaultArg(callback, Tone.noOp);
	        //create the clock source for the first time
	        this._createClock();
	    };
	    /**
		 * The possible ticker types
		 * @private
		 * @type {Object}
		 */
	    Ticker.Type = {
	        Worker: 'worker',
	        Timeout: 'timeout',
	        Offline: 'offline'
	    };
	    /**
		 *  Generate a web worker
		 *  @return  {WebWorker}
		 *  @private
		 */
	    Ticker.prototype._createWorker = function () {
	        //URL Shim
	        window.URL = window.URL || window.webkitURL;
	        var blob = new Blob([//the initial timeout time
	            'var timeoutTime = ' + (this._updateInterval * 1000).toFixed(1) + ';' + //onmessage callback
	            'self.onmessage = function(msg){' + '\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message
	            //and schedules a new tick
	            'function tick(){' + '\tsetTimeout(tick, timeoutTime);' + '\tself.postMessage(\'tick\');' + '}' + //call tick initially
	            'tick();']);
	        var blobUrl = URL.createObjectURL(blob);
	        var worker = new Worker(blobUrl);
	        worker.onmessage = this._callback.bind(this);
	        this._worker = worker;
	    };
	    /**
		 * Create a timeout loop
		 * @private
		 */
	    Ticker.prototype._createTimeout = function () {
	        this._timeout = setTimeout(function () {
	            this._createTimeout();
	            this._callback();
	        }.bind(this), this._updateInterval * 1000);
	    };
	    /**
		 * Create the clock source.
		 * @private
		 */
	    Ticker.prototype._createClock = function () {
	        if (this._type === Ticker.Type.Worker) {
	            try {
	                this._createWorker();
	            } catch (e) {
	                // workers not supported, fallback to timeout
	                this._type = Ticker.Type.Timeout;
	                this._createClock();
	            }
	        } else if (this._type === Ticker.Type.Timeout) {
	            this._createTimeout();
	        }
	    };
	    /**
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name updateInterval
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'updateInterval', {
	        get: function () {
	            return this._updateInterval;
	        },
	        set: function (interval) {
	            this._updateInterval = Math.max(interval, 128 / 44100);
	            if (this._type === Ticker.Type.Worker) {
	                this._worker.postMessage(Math.max(interval * 1000, 1));
	            }
	        }
	    });
	    /**
		 * The type of the ticker, either a worker or a timeout
		 * @memberOf Ticker#
		 * @type {Number}
		 * @name type
		 * @private
		 */
	    Object.defineProperty(Ticker.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._disposeClock();
	            this._type = type;
	            this._createClock();
	        }
	    });
	    /**
		 * Clean up the current clock source
		 * @private
		 */
	    Ticker.prototype._disposeClock = function () {
	        if (this._timeout) {
	            clearTimeout(this._timeout);
	            this._timeout = null;
	        }
	        if (this._worker) {
	            this._worker.terminate();
	            this._worker.onmessage = null;
	            this._worker = null;
	        }
	    };
	    /**
		 * Clean up
		 * @private
		 */
	    Ticker.prototype.dispose = function () {
	        this._disposeClock();
	        this._callback = null;
	    };
	    /**
		 *  Shim all connect/disconnect and some deprecated methods which are still in
		 *  some older implementations.
		 *  @private
		 */
	    Tone.getContext(function () {
	        var nativeConnect = AudioNode.prototype.connect;
	        var nativeDisconnect = AudioNode.prototype.disconnect;
	        //replace the old connect method
	        function toneConnect(B, outNum, inNum) {
	            if (B.input) {
	                inNum = Tone.defaultArg(inNum, 0);
	                if (Tone.isArray(B.input)) {
	                    this.connect(B.input[inNum]);
	                } else {
	                    this.connect(B.input, outNum, inNum);
	                }
	            } else {
	                try {
	                    if (B instanceof AudioNode) {
	                        nativeConnect.call(this, B, outNum, inNum);
	                    } else {
	                        nativeConnect.call(this, B, outNum);
	                    }
	                } catch (e) {
	                    throw new Error('error connecting to node: ' + B + '\n' + e);
	                }
	            }
	        }
	        //replace the old disconnect method
	        function toneDisconnect(B, outNum, inNum) {
	            if (B && B.input && Tone.isArray(B.input)) {
	                inNum = Tone.defaultArg(inNum, 0);
	                this.disconnect(B.input[inNum], outNum, 0);
	            } else if (B && B.input) {
	                this.disconnect(B.input, outNum, inNum);
	            } else {
	                try {
	                    nativeDisconnect.apply(this, arguments);
	                } catch (e) {
	                    throw new Error('error disconnecting node: ' + B + '\n' + e);
	                }
	            }
	        }
	        if (AudioNode.prototype.connect !== toneConnect) {
	            AudioNode.prototype.connect = toneConnect;
	            AudioNode.prototype.disconnect = toneDisconnect;
	        }
	    });
	    // set the audio context initially, and if one is not already created
	    if (Tone.supported && !Tone.initialized) {
	        Tone.context = new Tone.Context();
	        // log on first initialization
	        // allow optional silencing of this log
	        if (!window.TONE_SILENCE_VERSION_LOGGING) {
	            console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
	        }
	    } else if (!Tone.supported) {
	        console.warn('This browser does not support Tone.js');
	    }
	    return Tone.Context;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.AudioNode is the base class for classes which process audio.
		 *         AudioNodes have inputs and outputs.
		 *  @param	{AudioContext=} context	The audio context to use with the class
		 *  @extends {Tone}
		 */
	    Tone.AudioNode = function () {
	        Tone.call(this);
	        //use the default context if one is not passed in
	        var options = Tone.defaults(arguments, ['context'], { 'context': Tone.context });
	        /**
			 * The AudioContext of this instance
			 * @private
			 * @type {AudioContext}
			 */
	        this._context = options.context;
	    };
	    Tone.extend(Tone.AudioNode);
	    /**
		 * Get the audio context belonging to this instance.
		 * @type {Tone.Context}
		 * @memberOf Tone.AudioNode#
		 * @name context
		 * @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'context', {
	        get: function () {
	            return this._context;
	        }
	    });
	    /**
		 *  Create input and outputs for this object.
		 *  @param  {Number}  [input=0]   The number of inputs
		 *  @param  {Number}  [outputs=0]  The number of outputs
		 *  @return  {Tone.AudioNode}  this
		 *  @private
		 */
	    Tone.AudioNode.prototype.createInsOuts = function (inputs, outputs) {
	        if (inputs === 1) {
	            this.input = this.context.createGain();
	        } else if (inputs > 1) {
	            this.input = new Array(inputs);
	        }
	        if (outputs === 1) {
	            this.output = this.context.createGain();
	        } else if (outputs > 1) {
	            this.output = new Array(outputs);
	        }
	    };
	    /**
		 *  The number of inputs feeding into the AudioNode.
		 *  For source nodes, this will be 0.
		 *  @type {Number}
		 *  @name numberOfInputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfInputs', {
	        get: function () {
	            if (this.input) {
	                if (Tone.isArray(this.input)) {
	                    return this.input.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The number of outputs coming out of the AudioNode.
		 *  @type {Number}
		 *  @name numberOfOutputs
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.AudioNode.prototype, 'numberOfOutputs', {
	        get: function () {
	            if (this.output) {
	                if (Tone.isArray(this.output)) {
	                    return this.output.length;
	                } else {
	                    return 1;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
		 *  @param  {Tone | AudioParam | AudioNode} unit
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.connect = function (unit, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            outputNum = Tone.defaultArg(outputNum, 0);
	            this.output[outputNum].connect(unit, 0, inputNum);
	        } else {
	            this.output.connect(unit, outputNum, inputNum);
	        }
	        return this;
	    };
	    /**
		 *  disconnect the output
		 *  @param {Number|AudioNode} output Either the output index to disconnect
		 *                                   if the output is an array, or the
		 *                                   node to disconnect from.
		 *  @returns {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.disconnect = function (destination, outputNum, inputNum) {
	        if (Tone.isArray(this.output)) {
	            if (Tone.isNumber(destination)) {
	                this.output[destination].disconnect();
	            } else {
	                outputNum = Tone.defaultArg(outputNum, 0);
	                this.output[outputNum].disconnect(destination, 0, inputNum);
	            }
	        } else {
	            this.output.disconnect.apply(this.output, arguments);
	        }
	    };
	    /**
		 *  Connect the output of this node to the rest of the nodes in series.
		 *  @example
		 *  //connect a node to an effect, panVol and then to the master output
		 *  node.chain(effect, panVol, Tone.Master);
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 *  @private
		 */
	    Tone.AudioNode.prototype.chain = function () {
	        var currentUnit = this;
	        for (var i = 0; i < arguments.length; i++) {
	            var toUnit = arguments[i];
	            currentUnit.connect(toUnit);
	            currentUnit = toUnit;
	        }
	        return this;
	    };
	    /**
		 *  connect the output of this node to the rest of the nodes in parallel.
		 *  @param {...AudioParam|Tone|AudioNode} nodes
		 *  @returns {Tone.AudioNode} this
		 *  @private
		 */
	    Tone.AudioNode.prototype.fan = function () {
	        for (var i = 0; i < arguments.length; i++) {
	            this.connect(arguments[i]);
	        }
	        return this;
	    };
	    if (window.AudioNode) {
	        //give native nodes chain and fan methods
	        AudioNode.prototype.chain = Tone.AudioNode.prototype.chain;
	        AudioNode.prototype.fan = Tone.AudioNode.prototype.fan;
	    }
	    /**
		 * Dispose and disconnect
		 * @return {Tone.AudioNode} this
		 */
	    Tone.AudioNode.prototype.dispose = function () {
	        if (!Tone.isUndef(this.input)) {
	            if (this.input instanceof AudioNode) {
	                this.input.disconnect();
	            }
	            this.input = null;
	        }
	        if (!Tone.isUndef(this.output)) {
	            if (this.output instanceof AudioNode) {
	                this.output.disconnect();
	            }
	            this.output = null;
	        }
	        this._context = null;
	        return this;
	    };
	    return Tone.AudioNode;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for all Signals. Used Internally.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 */
	    Tone.SignalBase = function () {
	        Tone.AudioNode.call(this);
	    };
	    Tone.extend(Tone.SignalBase, Tone.AudioNode);
	    /**
		 *  When signals connect to other signals or AudioParams,
		 *  they take over the output value of that signal or AudioParam.
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>.
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
	        //zero it out so that the signal can have full control
	        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {
	            //cancel changes
	            node._param.cancelScheduledValues(0);
	            //reset the value
	            node._param.value = 0;
	            //mark the value as overridden
	            node.overridden = true;
	        } else if (node instanceof AudioParam) {
	            node.cancelScheduledValues(0);
	            node.value = 0;
	        }
	        Tone.AudioNode.prototype.connect.call(this, node, outputNumber, inputNumber);
	        return this;
	    };
	    return Tone.SignalBase;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Wraps the native Web Audio API 
		 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {function|Array|Number} mapping The function used to define the values. 
		 *                                    The mapping function should take two arguments: 
		 *                                    the first is the value at the current position 
		 *                                    and the second is the array position. 
		 *                                    If the argument is an array, that array will be
		 *                                    set as the wave shaping function. The input
		 *                                    signal is an AudioRange [-1, 1] value and the output
		 *                                    signal can take on any numerical values. 
		 *                                    
		 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
		 *  @example
		 * var timesTwo = new Tone.WaveShaper(function(val){
		 * 	return val * 2;
		 * }, 2048);
		 *  @example
		 * //a waveshaper can also be constructed with an array of values
		 * var invert = new Tone.WaveShaper([1, -1]);
		 */
	    Tone.WaveShaper = function (mapping, bufferLen) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the waveshaper
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = this.input = this.output = this.context.createWaveShaper();
	        /**
			 *  the waveshapers curve
			 *  @type {Float32Array}
			 *  @private
			 */
	        this._curve = null;
	        if (Array.isArray(mapping)) {
	            this.curve = mapping;
	        } else if (isFinite(mapping) || Tone.isUndef(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(mapping, 1024));
	        } else if (Tone.isFunction(mapping)) {
	            this._curve = new Float32Array(Tone.defaultArg(bufferLen, 1024));
	            this.setMap(mapping);
	        }
	    };
	    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
	    /**
		 *  Uses a mapping function to set the value of the curve. 
		 *  @param {function} mapping The function used to define the values. 
		 *                            The mapping function take two arguments: 
		 *                            the first is the value at the current position 
		 *                            which goes from -1 to 1 over the number of elements
		 *                            in the curve array. The second argument is the array position. 
		 *  @returns {Tone.WaveShaper} this
		 *  @example
		 * //map the input signal from [-1, 1] to [0, 10]
		 * shaper.setMap(function(val, index){
		 * 	return (val + 1) * 5;
		 * })
		 */
	    Tone.WaveShaper.prototype.setMap = function (mapping) {
	        for (var i = 0, len = this._curve.length; i < len; i++) {
	            var normalized = i / (len - 1) * 2 - 1;
	            this._curve[i] = mapping(normalized, i);
	        }
	        this._shaper.curve = this._curve;
	        return this;
	    };
	    /**
		 * The array to set as the waveshaper curve. For linear curves
		 * array length does not make much difference, but for complex curves
		 * longer arrays will provide smoother interpolation. 
		 * @memberOf Tone.WaveShaper#
		 * @type {Array}
		 * @name curve
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
	        get: function () {
	            return this._shaper.curve;
	        },
	        set: function (mapping) {
	            this._curve = new Float32Array(mapping);
	            this._shaper.curve = this._curve;
	        }
	    });
	    /**
		 * Specifies what type of oversampling (if any) should be used when 
		 * applying the shaping curve. Can either be "none", "2x" or "4x". 
		 * @memberOf Tone.WaveShaper#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            if ([
	                    'none',
	                    '2x',
	                    '4x'
	                ].indexOf(oversampling) !== -1) {
	                this._shaper.oversample = oversampling;
	            } else {
	                throw new RangeError('Tone.WaveShaper: oversampling must be either \'none\', \'2x\', or \'4x\'');
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.WaveShaper} this
		 */
	    Tone.WaveShaper.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.disconnect();
	        this._shaper = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.WaveShaper;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TimeBase is a flexible encoding of time
		 *         which can be evaluated to and from a string.
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *  @extends {Tone}
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @example
		 * Tone.TimeBase(4, "n")
		 * Tone.TimeBase(2, "t")
		 * Tone.TimeBase("2t").add("1m")
		 * Tone.TimeBase("2t + 1m");
		 */
	    Tone.TimeBase = function (val, units) {
	        //allows it to be constructed with or without 'new'
	        if (this instanceof Tone.TimeBase) {
	            /**
				 *  Any expressions parsed from the Time
				 *  @type  {Array}
				 *  @private
				 */
	            this._expr = this._noOp;
	            if (val instanceof Tone.TimeBase) {
	                this.copy(val);
	            } else if (!Tone.isUndef(units) || Tone.isNumber(val)) {
	                //default units
	                units = Tone.defaultArg(units, this._defaultUnits);
	                var method = this._primaryExpressions[units].method;
	                this._expr = method.bind(this, val);
	            } else if (Tone.isString(val)) {
	                this.set(val);
	            } else if (Tone.isUndef(val)) {
	                //default expression
	                this._expr = this._defaultExpr();
	            }
	        } else {
	            return new Tone.TimeBase(val, units);
	        }
	    };
	    Tone.extend(Tone.TimeBase);
	    /**
		 *  Repalce the current time value with the value
		 *  given by the expression string.
		 *  @param  {String}  exprString
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.set = function (exprString) {
	        this._expr = this._parseExprString(exprString);
	        return this;
	    };
	    /**
		 *  Return a clone of the TimeBase object.
		 *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase
		 */
	    Tone.TimeBase.prototype.clone = function () {
	        var instance = new this.constructor();
	        instance.copy(this);
	        return instance;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.TimeBase} time
		 *  @return  {TimeBase}
		 */
	    Tone.TimeBase.prototype.copy = function (time) {
	        var val = time._expr();
	        return this.set(val);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	ABSTRACT SYNTAX TREE PARSER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  All the primary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._primaryExpressions = {
	        'n': {
	            regexp: /^(\d+)n/i,
	            method: function (value) {
	                value = parseInt(value);
	                if (value === 1) {
	                    return this._beatsToUnits(this._timeSignature());
	                } else {
	                    return this._beatsToUnits(4 / value);
	                }
	            }
	        },
	        't': {
	            regexp: /^(\d+)t/i,
	            method: function (value) {
	                value = parseInt(value);
	                return this._beatsToUnits(8 / (parseInt(value) * 3));
	            }
	        },
	        'm': {
	            regexp: /^(\d+)m/i,
	            method: function (value) {
	                return this._beatsToUnits(parseInt(value) * this._timeSignature());
	            }
	        },
	        'i': {
	            regexp: /^(\d+)i/i,
	            method: function (value) {
	                return this._ticksToUnits(parseInt(value));
	            }
	        },
	        'hz': {
	            regexp: /^(\d+(?:\.\d+)?)hz/i,
	            method: function (value) {
	                return this._frequencyToUnits(parseFloat(value));
	            }
	        },
	        'tr': {
	            regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	            method: function (m, q, s) {
	                var total = 0;
	                if (m && m !== '0') {
	                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));
	                }
	                if (q && q !== '0') {
	                    total += this._beatsToUnits(parseFloat(q));
	                }
	                if (s && s !== '0') {
	                    total += this._beatsToUnits(parseFloat(s) / 4);
	                }
	                return total;
	            }
	        },
	        's': {
	            regexp: /^(\d+(?:\.\d+)?s)/,
	            method: function (value) {
	                return this._secondsToUnits(parseFloat(value));
	            }
	        },
	        'samples': {
	            regexp: /^(\d+)samples/,
	            method: function (value) {
	                return parseInt(value) / this.context.sampleRate;
	            }
	        },
	        'default': {
	            regexp: /^(\d+(?:\.\d+)?)/,
	            method: function (value) {
	                return this._primaryExpressions[this._defaultUnits].method.call(this, value);
	            }
	        }
	    };
	    /**
		 *  All the binary expressions that TimeBase can accept.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._binaryExpressions = {
	        '+': {
	            regexp: /^\+/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() + rh();
	            }
	        },
	        '-': {
	            regexp: /^\-/,
	            precedence: 2,
	            method: function (lh, rh) {
	                return lh() - rh();
	            }
	        },
	        '*': {
	            regexp: /^\*/,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() * rh();
	            }
	        },
	        '/': {
	            regexp: /^\//,
	            precedence: 1,
	            method: function (lh, rh) {
	                return lh() / rh();
	            }
	        }
	    };
	    /**
		 *  All the unary expressions.
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._unaryExpressions = {
	        'neg': {
	            regexp: /^\-/,
	            method: function (lh) {
	                return -lh();
	            }
	        }
	    };
	    /**
		 *  Syntactic glue which holds expressions together
		 *  @private
		 *  @type  {Object}
		 */
	    Tone.TimeBase.prototype._syntaxGlue = {
	        '(': { regexp: /^\(/ },
	        ')': { regexp: /^\)/ }
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.TimeBase.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr, this);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr, context) {
	            var expressions = [
	                '_binaryExpressions',
	                '_unaryExpressions',
	                '_primaryExpressions',
	                '_syntaxGlue'
	            ];
	            for (var i = 0; i < expressions.length; i++) {
	                var group = context[expressions[i]];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            method: op.method,
	                            precedence: op.precedence,
	                            regexp: op.regexp,
	                            value: match[0]
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  Given a token, find the value within the groupName
		 *  @param {Object} token
		 *  @param {String} groupName
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {
	        var ret = false;
	        if (!Tone.isUndef(token)) {
	            for (var opName in group) {
	                var op = group[opName];
	                if (op.regexp.test(token.value)) {
	                    if (!Tone.isUndef(prec)) {
	                        if (op.precedence === prec) {
	                            return op;
	                        }
	                    } else {
	                        return op;
	                    }
	                }
	            }
	        }
	        return ret;
	    };
	    /**
		 *  Match a binary expression given the token and the precedence
		 *  @param {Lexer} lexer
		 *  @param {Number} precedence
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {
	        if (Tone.isUndef(precedence)) {
	            precedence = 2;
	        }
	        var expr;
	        if (precedence < 0) {
	            expr = this._parseUnary(lexer);
	        } else {
	            expr = this._parseBinary(lexer, precedence - 1);
	        }
	        var token = lexer.peek();
	        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {
	            token = lexer.next();
	            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));
	            token = lexer.peek();
	        }
	        return expr;
	    };
	    /**
		 *  Match a unary expression.
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseUnary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        var op = this._matchGroup(token, this._unaryExpressions);
	        if (op) {
	            token = lexer.next();
	            expr = this._parseUnary(lexer);
	            return op.method.bind(this, expr);
	        }
	        return this._parsePrimary(lexer);
	    };
	    /**
		 *  Match a primary expression (a value).
		 *  @param {Lexer} lexer
		 *  @private
		 */
	    Tone.TimeBase.prototype._parsePrimary = function (lexer) {
	        var token, expr;
	        token = lexer.peek();
	        if (Tone.isUndef(token)) {
	            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');
	        }
	        if (this._matchGroup(token, this._primaryExpressions)) {
	            token = lexer.next();
	            var matching = token.value.match(token.regexp);
	            return token.method.bind(this, matching[1], matching[2], matching[3]);
	        }
	        if (token && token.value === '(') {
	            lexer.next();
	            expr = this._parseBinary(lexer);
	            token = lexer.next();
	            if (!(token && token.value === ')')) {
	                throw new SyntaxError('Expected )');
	            }
	            return expr;
	        }
	        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);
	    };
	    /**
		 *  Recursively parse the string expression into a syntax tree.
		 *  @param   {string} expr 
		 *  @return  {Function} the bound method to be evaluated later
		 *  @private
		 */
	    Tone.TimeBase.prototype._parseExprString = function (exprString) {
	        if (!Tone.isString(exprString)) {
	            exprString = exprString.toString();
	        }
	        var lexer = this._tokenize(exprString);
	        var tree = this._parseBinary(lexer);
	        return tree;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	DEFAULTS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  The initial expression value
		 *  @return  {Number}  The initial value 0
		 *  @private
		 */
	    Tone.TimeBase.prototype._noOp = function () {
	        return 0;
	    };
	    /**
		 *  The default expression value if no arguments are given
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultExpr = function () {
	        return this._noOp;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.TimeBase.prototype._defaultUnits = 's';
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {
	        return 1 / freq;
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._beatsToUnits = function (beats) {
	        return 60 / Tone.Transport.bpm.value * beats;
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {
	        return seconds;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {
	        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time signature.
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.TimeBase.prototype._timeSignature = function () {
	        return Tone.Transport.timeSignature;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Push an expression onto the expression list
		 *  @param  {Time}  val
		 *  @param  {String}  type
		 *  @param  {String}  units
		 *  @return  {Tone.TimeBase} 
		 *  @private
		 */
	    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {
	        //create the expression
	        if (!(val instanceof Tone.TimeBase)) {
	            val = new this.constructor(val, units);
	        }
	        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);
	        return this;
	    };
	    /**
		 *  Add to the current value.
		 *  @param  {Time}  val    The value to add
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").add("1m"); //"3m"
		 */
	    Tone.TimeBase.prototype.add = function (val, units) {
	        return this._pushExpr(val, '+', units);
	    };
	    /**
		 *  Subtract the value from the current time.
		 *  @param  {Time}  val    The value to subtract
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").sub("1m"); //"1m"
		 */
	    Tone.TimeBase.prototype.sub = function (val, units) {
	        return this._pushExpr(val, '-', units);
	    };
	    /**
		 *  Multiply the current value by the given time.
		 *  @param  {Time}  val    The value to multiply
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").mult("2"); //"4m"
		 */
	    Tone.TimeBase.prototype.mult = function (val, units) {
	        return this._pushExpr(val, '*', units);
	    };
	    /**
		 *  Divide the current value by the given time.
		 *  @param  {Time}  val    The value to divide by
		 *  @param  {String=}  units  Optional units to use with the value.
		 *  @return  {Tone.TimeBase}  this
		 *  @example
		 * Tone.TimeBase("2m").div(2); //"1m"
		 */
	    Tone.TimeBase.prototype.div = function (val, units) {
	        return this._pushExpr(val, '/', units);
	    };
	    /**
		 *  Evaluate the time value. Returns the time
		 *  in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.TimeBase.prototype.valueOf = function () {
	        return this._expr();
	    };
	    /**
		 *  Clean up
		 *  @return {Tone.TimeBase} this
		 */
	    Tone.TimeBase.prototype.dispose = function () {
	        this._expr = null;
	    };
	    return Tone.TimeBase;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Time is a primitive type for encoding Time values. 
		 *         Eventually all time values are evaluated to seconds
		 *         using the `eval` method. Tone.Time can be constructed
		 *         with or without the `new` keyword. Tone.Time can be passed
		 *         into the parameter of any method which takes time as an argument. 
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * var t = Tone.Time("4n");//encodes a quarter note
		 * t.mult(4); // multiply that value by 4
		 * t.toNotation(); //returns "1m"
		 */
	    Tone.Time = function (val, units) {
	        if (this instanceof Tone.Time) {
	            /**
				 *  If the current clock time should
				 *  be added to the output
				 *  @type  {Boolean}
				 *  @private
				 */
	            this._plusNow = false;
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Time(val, units);
	        }
	    };
	    Tone.extend(Tone.Time, Tone.TimeBase);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);
	    /*
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            return Tone.Transport.nextSubdivision(rh());
	        }
	    };
	    /*
		 *  Adds an additional unary expression
		 *  which adds the current clock time.
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Time.prototype._unaryExpressions.now = {
	        regexp: /^\+/,
	        method: function (lh) {
	            this._plusNow = true;
	            return lh();
	        }
	    };
	    /**
		 *  Quantize the time by the given subdivision. Optionally add a
		 *  percentage which will move the time value towards the ideal
		 *  quantized value by that percentage. 
		 *  @param  {Number|Time}  val    The subdivision to quantize to
		 *  @param  {NormalRange}  [percent=1]  Move the time value
		 *                                   towards the quantized value by
		 *                                   a percentage.
		 *  @return  {Tone.Time}  this
		 *  @example
		 * Tone.Time(21).quantize(2) //returns 22
		 * Tone.Time(0.6).quantize("4n", 0.5) //returns 0.55
		 */
	    Tone.Time.prototype.quantize = function (subdiv, percent) {
	        percent = Tone.defaultArg(percent, 1);
	        this._expr = function (expr, subdivision, percent) {
	            expr = expr();
	            subdivision = subdivision.toSeconds();
	            var multiple = Math.round(expr / subdivision);
	            var ideal = multiple * subdivision;
	            var diff = ideal - expr;
	            return expr + diff * percent;
	        }.bind(this, this._expr, new this.constructor(subdiv), percent);
	        return this;
	    };
	    /**
		 *  Adds the clock time to the time expression at the 
		 *  moment of evaluation. 
		 *  @return  {Tone.Time}  this
		 */
	    Tone.Time.prototype.addNow = function () {
	        this._plusNow = true;
	        return this;
	    };
	    /**
		 *  Override the default value return when no arguments are passed in.
		 *  The default value is 'now'
		 *  @override
		 *  @private
		 */
	    Tone.Time.prototype._defaultExpr = function () {
	        this._plusNow = true;
	        return this._noOp;
	    };
	    /**
		 *  Copies the value of time to this Time
		 *  @param {Tone.Time} time
		 *  @return  {Time}
		 */
	    Tone.Time.prototype.copy = function (time) {
	        Tone.TimeBase.prototype.copy.call(this, time);
	        this._plusNow = time._plusNow;
	        return this;
	    };
	    //CONVERSIONS//////////////////////////////////////////////////////////////
	    /**
		 *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. 
		 *  @return {Notation} 
		 *  @example
		 * //if the Transport is at 120bpm:
		 * Tone.Time(2).toNotation();//returns "1m"
		 */
	    Tone.Time.prototype.toNotation = function () {
	        var time = this.toSeconds();
	        var testNotations = [
	            '1m',
	            '2n',
	            '4n',
	            '8n',
	            '16n',
	            '32n',
	            '64n',
	            '128n'
	        ];
	        var retNotation = this._toNotationHelper(time, testNotations);
	        //try the same thing but with tripelets
	        var testTripletNotations = [
	            '1m',
	            '2n',
	            '2t',
	            '4n',
	            '4t',
	            '8n',
	            '8t',
	            '16n',
	            '16t',
	            '32n',
	            '32t',
	            '64n',
	            '64t',
	            '128n'
	        ];
	        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);
	        //choose the simpler expression of the two
	        if (retTripletNotation.split('+').length < retNotation.split('+').length) {
	            return retTripletNotation;
	        } else {
	            return retNotation;
	        }
	    };
	    /**
		 *  Helper method for Tone.toNotation
		 *  @param {Number} units 
		 *  @param {Array} testNotations
		 *  @return {String}
		 *  @private
		 */
	    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {
	        //the threshold is the last value in the array
	        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);
	        var retNotation = '';
	        for (var i = 0; i < testNotations.length; i++) {
	            var notationTime = this._notationToUnits(testNotations[i]);
	            //account for floating point errors (i.e. round up if the value is 0.999999)
	            var multiple = units / notationTime;
	            var floatingPointError = 0.000001;
	            if (1 - multiple % 1 < floatingPointError) {
	                multiple += floatingPointError;
	            }
	            multiple = Math.floor(multiple);
	            if (multiple > 0) {
	                if (multiple === 1) {
	                    retNotation += testNotations[i];
	                } else {
	                    retNotation += multiple.toString() + '*' + testNotations[i];
	                }
	                units -= multiple * notationTime;
	                if (units < threshold) {
	                    break;
	                } else {
	                    retNotation += ' + ';
	                }
	            }
	        }
	        if (retNotation === '') {
	            retNotation = '0';
	        }
	        return retNotation;
	    };
	    /**
		 *  Convert a notation value to the current units
		 *  @param  {Notation}  notation 
		 *  @return  {Number} 
		 *  @private
		 */
	    Tone.Time.prototype._notationToUnits = function (notation) {
	        var primaryExprs = this._primaryExpressions;
	        var notationExprs = [
	            primaryExprs.n,
	            primaryExprs.t,
	            primaryExprs.m
	        ];
	        for (var i = 0; i < notationExprs.length; i++) {
	            var expr = notationExprs[i];
	            var match = notation.match(expr.regexp);
	            if (match) {
	                return expr.method.call(this, match[1]);
	            }
	        }
	    };
	    /**
		 *  Return the time encoded as Bars:Beats:Sixteenths.
		 *  @return  {BarsBeatsSixteenths}
		 */
	    Tone.Time.prototype.toBarsBeatsSixteenths = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.toSeconds() / quarterTime;
	        var measures = Math.floor(quarters / this._timeSignature());
	        var sixteenths = quarters % 1 * 4;
	        quarters = Math.floor(quarters) % this._timeSignature();
	        sixteenths = sixteenths.toString();
	        if (sixteenths.length > 3) {
	            // the additional parseFloat removes insignificant trailing zeroes
	            sixteenths = parseFloat(parseFloat(sixteenths).toFixed(3));
	        }
	        var progress = [
	            measures,
	            quarters,
	            sixteenths
	        ];
	        return progress.join(':');
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.Time.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.round(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Return the time in samples
		 *  @return  {Samples}  
		 */
	    Tone.Time.prototype.toSamples = function () {
	        return this.toSeconds() * this.context.sampleRate;
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 *  @example
		 * Tone.Time(2).toFrequency(); //0.5
		 */
	    Tone.Time.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.toSeconds = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in milliseconds.
		 *  @return  {Milliseconds} 
		 */
	    Tone.Time.prototype.toMilliseconds = function () {
	        return this.toSeconds() * 1000;
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds} 
		 */
	    Tone.Time.prototype.valueOf = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? this.now() : 0);
	    };
	    return Tone.Time;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Frequency is a primitive type for encoding Frequency values.
		 *         Eventually all time values are evaluated to hertz
		 *         using the `eval` method.
		 *  @constructor
		 *  @extends {Tone.TimeBase}
		 *  @param  {String|Number}  val    The time value.
		 *  @param  {String=}  units  The units of the value.
		 *  @example
		 * Tone.Frequency("C3") // 261
		 * Tone.Frequency(38, "midi") //
		 * Tone.Frequency("C3").transpose(4);
		 */
	    Tone.Frequency = function (val, units) {
	        if (this instanceof Tone.Frequency) {
	            Tone.TimeBase.call(this, val, units);
	        } else {
	            return new Tone.Frequency(val, units);
	        }
	    };
	    Tone.extend(Tone.Frequency, Tone.TimeBase);
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT BASE EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    //clone the expressions so that
	    //we can add more without modifying the original
	    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);
	    /*
		 *  midi type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.midi = {
	        regexp: /^(\d+(?:\.\d+)?midi)/,
	        method: function (value) {
	            return this.midiToFrequency(value);
	        }
	    };
	    /*
		 *  note type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.note = {
	        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,
	        method: function (pitch, octave) {
	            var index = noteToScaleIndex[pitch.toLowerCase()];
	            var noteNumber = index + (parseInt(octave) + 1) * 12;
	            return this.midiToFrequency(noteNumber);
	        }
	    };
	    /*
		 *  BeatsBarsSixteenths type primary expression
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Frequency.prototype._primaryExpressions.tr = {
	        regexp: /^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,
	        method: function (m, q, s) {
	            var total = 1;
	            if (m && m !== '0') {
	                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));
	            }
	            if (q && q !== '0') {
	                total *= this._beatsToUnits(parseFloat(q));
	            }
	            if (s && s !== '0') {
	                total *= this._beatsToUnits(parseFloat(s) / 4);
	            }
	            return total;
	        }
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	EXPRESSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Transposes the frequency by the given number of semitones.
		 *  @param  {Interval}  interval
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").transpose(3); //"C5"
		 */
	    Tone.Frequency.prototype.transpose = function (interval) {
	        this._expr = function (expr, interval) {
	            var val = expr();
	            return val * Tone.intervalToFrequencyRatio(interval);
	        }.bind(this, this._expr, interval);
	        return this;
	    };
	    /**
		 *  Takes an array of semitone intervals and returns
		 *  an array of frequencies transposed by those intervals.
		 *  @param  {Array}  intervals
		 *  @return  {Tone.Frequency} this
		 *  @example
		 * Tone.Frequency("A4").harmonize([0, 3, 7]); //["A4", "C5", "E5"]
		 */
	    Tone.Frequency.prototype.harmonize = function (intervals) {
	        this._expr = function (expr, intervals) {
	            var val = expr();
	            var ret = [];
	            for (var i = 0; i < intervals.length; i++) {
	                ret[i] = val * Tone.intervalToFrequencyRatio(intervals[i]);
	            }
	            return ret;
	        }.bind(this, this._expr, intervals);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Return the value of the frequency as a MIDI note
		 *  @return  {MIDI}
		 *  @example
		 * Tone.Frequency("C4").toMidi(); //60
		 */
	    Tone.Frequency.prototype.toMidi = function () {
	        return this.frequencyToMidi(this.valueOf());
	    };
	    /**
		 *  Return the value of the frequency in Scientific Pitch Notation
		 *  @return  {Note}
		 *  @example
		 * Tone.Frequency(69, "midi").toNote(); //"A4"
		 */
	    Tone.Frequency.prototype.toNote = function () {
	        var freq = this.valueOf();
	        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;
	        var noteNumber = Math.round(12 * log) + 57;
	        var octave = Math.floor(noteNumber / 12);
	        if (octave < 0) {
	            noteNumber += -12 * octave;
	        }
	        var noteName = scaleIndexToNote[noteNumber % 12];
	        return noteName + octave.toString();
	    };
	    /**
		 *  Return the duration of one cycle in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.Frequency.prototype.toSeconds = function () {
	        return 1 / this.valueOf();
	    };
	    /**
		 *  Return the value in Hertz
		 *  @return  {Frequency}
		 */
	    Tone.Frequency.prototype.toFrequency = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the duration of one cycle in ticks
		 *  @return  {Ticks}
		 */
	    Tone.Frequency.prototype.toTicks = function () {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = this.valueOf() / quarterTime;
	        return Math.floor(quarters * Tone.Transport.PPQ);
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	UNIT CONVERSIONS HELPERS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value of a frequency in the current units
		 *  @param {Frequency} freq
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._frequencyToUnits = function (freq) {
	        return freq;
	    };
	    /**
		 *  Returns the value of a tick in the current time units
		 *  @param {Ticks} ticks
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._ticksToUnits = function (ticks) {
	        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));
	    };
	    /**
		 *  Return the value of the beats in the current units
		 *  @param {Number} beats
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._beatsToUnits = function (beats) {
	        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);
	    };
	    /**
		 *  Returns the value of a second in the current units
		 *  @param {Seconds} seconds
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.Frequency.prototype._secondsToUnits = function (seconds) {
	        return 1 / seconds;
	    };
	    /**
		 *  The default units if none are given.
		 *  @private
		 */
	    Tone.Frequency.prototype._defaultUnits = 'hz';
	    ///////////////////////////////////////////////////////////////////////////
	    //	FREQUENCY CONVERSIONS
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Note to scale index
		 *  @type  {Object}
		 */
	    var noteToScaleIndex = {
	        'cbb': -2,
	        'cb': -1,
	        'c': 0,
	        'c#': 1,
	        'cx': 2,
	        'dbb': 0,
	        'db': 1,
	        'd': 2,
	        'd#': 3,
	        'dx': 4,
	        'ebb': 2,
	        'eb': 3,
	        'e': 4,
	        'e#': 5,
	        'ex': 6,
	        'fbb': 3,
	        'fb': 4,
	        'f': 5,
	        'f#': 6,
	        'fx': 7,
	        'gbb': 5,
	        'gb': 6,
	        'g': 7,
	        'g#': 8,
	        'gx': 9,
	        'abb': 7,
	        'ab': 8,
	        'a': 9,
	        'a#': 10,
	        'ax': 11,
	        'bbb': 9,
	        'bb': 10,
	        'b': 11,
	        'b#': 12,
	        'bx': 13
	    };
	    /**
		 *  scale index to note (sharps)
		 *  @type  {Array}
		 */
	    var scaleIndexToNote = [
	        'C',
	        'C#',
	        'D',
	        'D#',
	        'E',
	        'F',
	        'F#',
	        'G',
	        'G#',
	        'A',
	        'A#',
	        'B'
	    ];
	    /**
		 *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)
		 *  A4's values in Hertz.
		 *  @type {Frequency}
		 *  @static
		 */
	    Tone.Frequency.A4 = 440;
	    /**
		 *  Convert a MIDI note to frequency value.
		 *  @param  {MIDI} midi The midi number to convert.
		 *  @return {Frequency} the corresponding frequency value
		 *  @example
		 * tone.midiToFrequency(69); // returns 440
		 */
	    Tone.Frequency.prototype.midiToFrequency = function (midi) {
	        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);
	    };
	    /**
		 *  Convert a frequency value to a MIDI note.
		 *  @param {Frequency} frequency The value to frequency value to convert.
		 *  @returns  {MIDI}
		 *  @example
		 * tone.midiToFrequency(440); // returns 69
		 */
	    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {
	        return 69 + Math.round(12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2);
	    };
	    return Tone.Frequency;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TransportTime is a the time along the Transport's
		 *         timeline. It is similar to Tone.Time, but instead of evaluating
		 *         against the AudioContext's clock, it is evaluated against
		 *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).
		 *  @constructor
		 *  @param  {Time}  val    The time value as a number or string
		 *  @param  {String=}  units  Unit values
		 *  @extends {Tone.Time}
		 */
	    Tone.TransportTime = function (val, units) {
	        if (this instanceof Tone.TransportTime) {
	            Tone.Time.call(this, val, units);
	        } else {
	            return new Tone.TransportTime(val, units);
	        }
	    };
	    Tone.extend(Tone.TransportTime, Tone.Time);
	    //clone the expressions so that 
	    //we can add more without modifying the original
	    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);
	    /**
		 *  Adds an additional unary expression
		 *  which quantizes values to the next subdivision
		 *  @type {Object}
		 *  @private
		 */
	    Tone.TransportTime.prototype._unaryExpressions.quantize = {
	        regexp: /^@/,
	        method: function (rh) {
	            var subdivision = this._secondsToTicks(rh());
	            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);
	            return this._ticksToUnits(multiple * subdivision);
	        }
	    };
	    /**
		 *  Convert seconds into ticks
		 *  @param {Seconds} seconds
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {
	        var quarterTime = this._beatsToUnits(1);
	        var quarters = seconds / quarterTime;
	        return Math.round(quarters * Tone.Transport.PPQ);
	    };
	    /**
		 *  Evaluate the time expression. Returns values in ticks
		 *  @return {Ticks}
		 */
	    Tone.TransportTime.prototype.valueOf = function () {
	        var val = this._secondsToTicks(this._expr());
	        return val + (this._plusNow ? Tone.Transport.ticks : 0);
	    };
	    /**
		 *  Return the time in ticks.
		 *  @return  {Ticks}
		 */
	    Tone.TransportTime.prototype.toTicks = function () {
	        return this.valueOf();
	    };
	    /**
		 *  Return the time in seconds.
		 *  @return  {Seconds}
		 */
	    Tone.TransportTime.prototype.toSeconds = function () {
	        var val = this._expr();
	        return val + (this._plusNow ? Tone.Transport.seconds : 0);
	    };
	    /**
		 *  Return the time as a frequency value
		 *  @return  {Frequency} 
		 */
	    Tone.TransportTime.prototype.toFrequency = function () {
	        return 1 / this.toSeconds();
	    };
	    return Tone.TransportTime;
	});
	Module(function (Tone) {
	    ///////////////////////////////////////////////////////////////////////////
	    //	TYPES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 * Units which a value can take on.
		 * @enum {String}
		 */
	    Tone.Type = {
	        /**
			 *  Default units
			 *  @typedef {Default}
			 */
	        Default: 'number',
	        /**
			 *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).
			 *
			 *  * Numbers, which will be taken literally as the time (in seconds).
			 *  * Notation, ("4n", "8t") describes time in BPM and time signature relative values.
			 *  * TransportTime, ("4:3:2") will also provide tempo and time signature relative times
			 *  in the form BARS:QUARTERS:SIXTEENTHS.
			 *  * Frequency, ("8hz") is converted to the length of the cycle in seconds.
			 *  * Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as
			 *  "the current time plus whatever expression follows".
			 *  * Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined
			 *  into a mathematical expression which will be evaluated to compute the desired time.
			 *  * No Argument, for methods which accept time, no argument will be interpreted as
			 *  "now" (i.e. the currentTime).
			 *
			 *  @typedef {Time}
			 */
	        Time: 'time',
	        /**
			 *  Frequency can be described similar to time, except ultimately the
			 *  values are converted to frequency instead of seconds. A number
			 *  is taken literally as the value in hertz. Additionally any of the
			 *  Time encodings can be used. Note names in the form
			 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
			 *  frequency value.
			 *  @typedef {Frequency}
			 */
	        Frequency: 'frequency',
	        /**
			 *  TransportTime describes a position along the Transport's timeline. It is
			 *  similar to Time in that it uses all the same encodings, but TransportTime specifically
			 *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.
			 *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)
			 *  @typedef {TransportTime}
			 */
	        TransportTime: 'transportTime',
	        /**
			 *  Ticks are the basic subunit of the Transport. They are
			 *  the smallest unit of time that the Transport supports.
			 *  @typedef {Ticks}
			 */
	        Ticks: 'ticks',
	        /**
			 *  Normal values are within the range [0, 1].
			 *  @typedef {NormalRange}
			 */
	        NormalRange: 'normalRange',
	        /**
			 *  AudioRange values are between [-1, 1].
			 *  @typedef {AudioRange}
			 */
	        AudioRange: 'audioRange',
	        /**
			 *  Decibels are a logarithmic unit of measurement which is useful for volume
			 *  because of the logarithmic way that we perceive loudness. 0 decibels
			 *  means no change in volume. -10db is approximately half as loud and 10db
			 *  is twice is loud.
			 *  @typedef {Decibels}
			 */
	        Decibels: 'db',
	        /**
			 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
			 *  @typedef {Interval}
			 */
	        Interval: 'interval',
	        /**
			 *  Beats per minute.
			 *  @typedef {BPM}
			 */
	        BPM: 'bpm',
	        /**
			 *  The value must be greater than or equal to 0.
			 *  @typedef {Positive}
			 */
	        Positive: 'positive',
	        /**
			 *  Gain is the ratio between input and output of a signal.
			 *  A gain of 0 is the same as silencing the signal. A gain of
			 *  1, causes no change to the incoming signal.
			 *  @typedef {Gain}
			 */
	        Gain: 'gain',
	        /**
			 *  A cent is a hundredth of a semitone.
			 *  @typedef {Cents}
			 */
	        Cents: 'cents',
	        /**
			 *  Angle between 0 and 360.
			 *  @typedef {Degrees}
			 */
	        Degrees: 'degrees',
	        /**
			 *  A number representing a midi note.
			 *  @typedef {MIDI}
			 */
	        MIDI: 'midi',
	        /**
			 *  A colon-separated representation of time in the form of
			 *  Bars:Beats:Sixteenths.
			 *  @typedef {BarsBeatsSixteenths}
			 */
	        BarsBeatsSixteenths: 'barsBeatsSixteenths',
	        /**
			 *  Sampling is the reduction of a continuous signal to a discrete signal.
			 *  Audio is typically sampled 44100 times per second.
			 *  @typedef {Samples}
			 */
	        Samples: 'samples',
	        /**
			 *  Hertz are a frequency representation defined as one cycle per second.
			 *  @typedef {Hertz}
			 */
	        Hertz: 'hertz',
	        /**
			 *  A frequency represented by a letter name,
			 *  accidental and octave. This system is known as
			 *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).
			 *  @typedef {Note}
			 */
	        Note: 'note',
	        /**
			 *  One millisecond is a thousandth of a second.
			 *  @typedef {Milliseconds}
			 */
	        Milliseconds: 'milliseconds',
	        /**
			 *  Seconds are the time unit of the AudioContext. In the end,
			 *  all values need to be evaluated to seconds.
			 *  @typedef {Seconds}
			 */
	        Seconds: 'seconds',
	        /**
			 *  A string representing a duration relative to a measure.
			 *  * "4n" = quarter note
			 *  * "2m" = two measures
			 *  * "8t" = eighth-note triplet
			 *  @typedef {Notation}
			 */
	        Notation: 'notation'
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Convert Time into seconds.
		 *
		 *  Unlike the method which it overrides, this takes into account
		 *  transporttime and musical notation.
		 *
		 *  Time : 1.40
		 *  Notation: 4n or 1m or 2t
		 *  Now Relative: +3n
		 *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)
		 *
		 *  @param  {Time} time
		 *  @return {Seconds}
		 */
	    Tone.prototype.toSeconds = function (time) {
	        if (Tone.isNumber(time)) {
	            return time;
	        } else if (Tone.isUndef(time)) {
	            return this.now();
	        } else if (Tone.isString(time)) {
	            return new Tone.Time(time).toSeconds();
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toSeconds();
	        }
	    };
	    /**
		 *  Convert a frequency representation into a number.
		 *  @param  {Frequency} freq
		 *  @return {Hertz}      the frequency in hertz
		 */
	    Tone.prototype.toFrequency = function (freq) {
	        if (Tone.isNumber(freq)) {
	            return freq;
	        } else if (Tone.isString(freq) || Tone.isUndef(freq)) {
	            return new Tone.Frequency(freq).valueOf();
	        } else if (freq instanceof Tone.TimeBase) {
	            return freq.toFrequency();
	        }
	    };
	    /**
		 *  Convert a time representation into ticks.
		 *  @param  {Time} time
		 *  @return {Ticks}  the time in ticks
		 */
	    Tone.prototype.toTicks = function (time) {
	        if (Tone.isNumber(time) || Tone.isString(time)) {
	            return new Tone.TransportTime(time).toTicks();
	        } else if (Tone.isUndef(time)) {
	            return Tone.Transport.ticks;
	        } else if (time instanceof Tone.TimeBase) {
	            return time.toTicks();
	        }
	    };
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Param wraps the native Web Audio's AudioParam to provide
		 *         additional unit conversion functionality. It also
		 *         serves as a base-class for classes which have a single,
		 *         automatable parameter.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioParam}  param  The parameter to wrap.
		 *  @param  {Tone.Type} units The units of the audio param.
		 *  @param  {Boolean} convert If the param should be converted.
		 */
	    Tone.Param = function () {
	        var options = Tone.defaults(arguments, [
	            'param',
	            'units',
	            'convert'
	        ], Tone.Param);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native parameter to control
			 *  @type  {AudioParam}
			 *  @private
			 */
	        this._param = this.input = options.param;
	        /**
			 *  The units of the parameter
			 *  @type {Tone.Type}
			 */
	        this.units = options.units;
	        /**
			 *  If the value should be converted or not
			 *  @type {Boolean}
			 */
	        this.convert = options.convert;
	        /**
			 *  True if the signal value is being overridden by
			 *  a connected signal.
			 *  @readOnly
			 *  @type  {boolean}
			 *  @private
			 */
	        this.overridden = false;
	        if (!Tone.isUndef(options.value)) {
	            this.value = options.value;
	        }
	    };
	    Tone.extend(Tone.Param, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Param.defaults = {
	        'units': Tone.Type.Default,
	        'convert': true,
	        'param': undefined
	    };
	    /**
		 * The current value of the parameter.
		 * @memberOf Tone.Param#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Param.prototype, 'value', {
	        get: function () {
	            return this._toUnits(this._param.value);
	        },
	        set: function (value) {
	            var convertedVal = this._fromUnits(value);
	            this._param.cancelScheduledValues(0);
	            this._param.value = convertedVal;
	        }
	    });
	    /**
		 *  Convert the given value from the type specified by Tone.Param.units
		 *  into the destination value (such as Gain or Frequency).
		 *  @private
		 *  @param  {*} val the value to convert
		 *  @return {number}     the number which the value should be set to
		 */
	    Tone.Param.prototype._fromUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Time:
	                return this.toSeconds(val);
	            case Tone.Type.Frequency:
	                return this.toFrequency(val);
	            case Tone.Type.Decibels:
	                return Tone.dbToGain(val);
	            case Tone.Type.NormalRange:
	                return Math.min(Math.max(val, 0), 1);
	            case Tone.Type.AudioRange:
	                return Math.min(Math.max(val, -1), 1);
	            case Tone.Type.Positive:
	                return Math.max(val, 0);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 * Convert the parameters value into the units specified by Tone.Param.units.
		 * @private
		 * @param  {number} val the value to convert
		 * @return {number}
		 */
	    Tone.Param.prototype._toUnits = function (val) {
	        if (this.convert || Tone.isUndef(this.convert)) {
	            switch (this.units) {
	            case Tone.Type.Decibels:
	                return Tone.gainToDb(val);
	            default:
	                return val;
	            }
	        } else {
	            return val;
	        }
	    };
	    /**
		 *  the minimum output value
		 *  @type {Number}
		 *  @private
		 */
	    Tone.Param.prototype._minOutput = 0.00001;
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now.
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.Param.prototype.setValueAtTime = function (value, time) {
	        time = this.toSeconds(time);
	        Tone.isPast(time);
	        this._param.setValueAtTime(this._fromUnits(value), time);
	        return this;
	    };
	    /**
		 *  Creates a schedule point with the current value at the current time.
		 *  This is useful for creating an automation anchor point in order to
		 *  schedule changes from the current value.
		 *
		 *  @param {number=} now (Optionally) pass the now value in.
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setRampPoint = function (now) {
	        now = Tone.defaultArg(now, this.now());
	        this.cancelAndHoldAtTime(this.context.currentTime);
	        var currentVal = this._param.value;
	        if (currentVal === 0) {
	            currentVal = this._minOutput;
	        }
	        // cancel and hold at the given time
	        this._param.setValueAtTime(currentVal, now);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the
		 *  previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        endTime = this.toSeconds(endTime);
	        Tone.isPast(endTime);
	        this._param.linearRampToValueAtTime(value, endTime);
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        endTime = this.toSeconds(endTime);
	        Tone.isPast(endTime);
	        this._param.exponentialRampToValueAtTime(value, endTime);
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //exponentially ramp to the value 2 over 4 seconds.
		 * signal.exponentialRampTo(2, 4);
		 */
	    Tone.Param.prototype.exponentialRampTo = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Schedules an linear continuous change in parameter value from
		 *  the current time and current value to the given value over the
		 *  duration of the rampTime.
		 *
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //linearly ramp to the value 4 over 3 seconds.
		 * signal.linearRampTo(4, 3);
		 */
	    Tone.Param.prototype.linearRampTo = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time. Since it
		 *  is an exponential approach it will continue approaching after the ramp duration. The
		 *  rampTime is the time that it takes to reach over 99% of the way towards the value.
		 *  @param  {number} value   The value to ramp to.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //exponentially ramp to the value 2 over 4 seconds.
		 * signal.exponentialRampTo(2, 4);
		 */
	    Tone.Param.prototype.targetRampTo = function (value, rampTime, startTime) {
	        startTime = this.toSeconds(startTime);
	        this.setRampPoint(startTime);
	        this.exponentialAppraochValueAtTime(value, startTime, rampTime);
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time. Since it
		 *  is an exponential approach it will continue approaching after the ramp duration. The
		 *  rampTime is the time that it takes to reach over 99% of the way towards the value. This methods
		 *  is similar to setTargetAtTime except the third argument is a time instead of a 'timeConstant'
		 *  @param  {number} value   The value to ramp to.
		 *  @param {Time}	time 	When the ramp should start.
		 *  @param  {Time} rampTime the time that it takes the
		 *                               value to ramp from it's current value
		 *  @returns {Tone.Param} this
		 *  @example
		 * //exponentially ramp to the value 2 over 4 seconds.
		 * signal.exponentialRampTo(2, 4);
		 */
	    Tone.Param.prototype.exponentialAppraochValueAtTime = function (value, time, rampTime) {
	        var timeConstant = Math.log(this.toSeconds(rampTime) + 1) / Math.log(200);
	        time = this.toSeconds(time);
	        Tone.isPast(time);
	        return this.setTargetAtTime(value, time, timeConstant);
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        // The value will never be able to approach without timeConstant > 0.
	        if (timeConstant <= 0) {
	            throw new Error('timeConstant must be greater than 0');
	        }
	        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
	        return this;
	    };
	    /**
		 *  Sets an array of arbitrary parameter values starting at the given time
		 *  for the given duration.
		 *
		 *  @param {Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        this.setValueAtTime(values[0], startTime);
	        var segTime = duration / (values.length - 1);
	        for (var i = 1; i < values.length; i++) {
	            this._param.linearRampToValueAtTime(this._fromUnits(values[i]), startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *
		 *  @param  {Time} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.cancelScheduledValues = function (startTime) {
	        this._param.cancelScheduledValues(this.toSeconds(startTime));
	        return this;
	    };
	    /**
		 *  This is similar to [cancelScheduledValues](#cancelScheduledValues) except
		 *  it holds the automated value at cancelTime until the next automated event.
		 *  @param  {Time} cancelTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.cancelAndHoldAtTime = function (cancelTime) {
	        cancelTime = this.toSeconds(cancelTime);
	        if (this._param.cancelAndHoldAtTime) {
	            this._param.cancelAndHoldAtTime(cancelTime);
	        } else {
	            //fallback for unsupported browsers
	            //can't cancel and hold at any time in the future
	            //just do it immediately for gapless automation curves
	            var now = this.context.currentTime;
	            this._param.cancelScheduledValues(now);
	            var currentVal = this._param.value;
	            if (currentVal === 0) {
	                currentVal = this._minOutput;
	            }
	            this._param.setValueAtTime(currentVal, now + this.sampleTime);
	        }
	        return this;
	    };
	    /**
		 *  Ramps to the given value over the duration of the rampTime.
		 *  Automatically selects the best ramp type (exponential or linear)
		 *  depending on the `units` of the signal
		 *
		 *  @param  {number} value
		 *  @param  {Time} rampTime 	The time that it takes the
		 *                              value to ramp from it's current value
		 *  @param {Time}	[startTime=now] 	When the ramp should start.
		 *  @returns {Tone.Param} this
		 *  @example
		 * //ramp to the value either linearly or exponentially
		 * //depending on the "units" value of the signal
		 * signal.rampTo(0, 10);
		 *  @example
		 * //schedule it to ramp starting at a specific time
		 * signal.rampTo(0, 10, 5)
		 */
	    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {
	        rampTime = Tone.defaultArg(rampTime, 0.1);
	        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {
	            this.exponentialRampTo(value, rampTime, startTime);
	        } else {
	            this.linearRampTo(value, rampTime, startTime);
	        }
	        return this;
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.Param} this
		 */
	    Tone.Param.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._param = null;
	        return this;
	    };
	    return Tone.Param;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createGain shim
		 *  @private
		 */
	    if (window.GainNode && !AudioContext.prototype.createGain) {
	        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
	    }
	    /**
		 *  @class A thin wrapper around the Native Web Audio GainNode.
		 *         The GainNode is a basic building block of the Web Audio
		 *         API and is useful for routing audio and adjusting gains.
		 *  @extends {Tone}
		 *  @param  {Number=}  gain  The initial gain of the GainNode
		 *  @param {Tone.Type=} units The units of the gain parameter.
		 */
	    Tone.Gain = function () {
	        var options = Tone.defaults(arguments, [
	            'gain',
	            'units'
	        ], Tone.Gain);
	        Tone.AudioNode.call(this);
	        /**
			 *  The GainNode
			 *  @type  {GainNode}
			 *  @private
			 */
	        this.input = this.output = this._gainNode = this.context.createGain();
	        /**
			 *  The gain parameter of the gain node.
			 *  @type {Gain}
			 *  @signal
			 */
	        this.gain = new Tone.Param({
	            'param': this._gainNode.gain,
	            'units': options.units,
	            'value': options.gain,
	            'convert': options.convert
	        });
	        this._readOnly('gain');
	    };
	    Tone.extend(Tone.Gain, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Gain.defaults = {
	        'gain': 1,
	        'convert': true
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Gain}  this
		 */
	    Tone.Gain.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._gainNode.disconnect();
	        this._gainNode = null;
	        this._writable('gain');
	        this.gain.dispose();
	        this.gain = null;
	    };
	    return Tone.Gain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
		 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
		 *          has all of the methods available to native Web Audio 
		 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
		 *          as well as additional conveniences. Read more about working with signals 
		 *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
		 *
		 *  @constructor
		 *  @extends {Tone.Param}
		 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
		 *                                     is passed in, that parameter will be wrapped
		 *                                     and controlled by the Signal. 
		 *  @param {string} [units=Number] unit The units the signal is in. 
		 *  @example
		 * var signal = new Tone.Signal(10);
		 */
	    Tone.Signal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        var gainNode = Tone.context.createGain();
	        options.param = gainNode.gain;
	        Tone.Param.call(this, options);
	        /**
			 * The node where the constant signal value is scaled.
			 * @type {GainNode}
			 * @private
			 */
	        this.output = gainNode;
	        /**
			 * The node where the value is set.
			 * @type {Tone.Param}
			 * @private
			 */
	        this.input = this._param = this.output.gain;
	        //connect the const output to the node output
	        this.context.getConstant(1).connect(this.output);
	    };
	    Tone.extend(Tone.Signal, Tone.Param);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Signal.defaults = {
	        'value': 0,
	        'units': Tone.Type.Default,
	        'convert': true
	    };
	    /**
		 *  When signals connect to other signals or AudioParams, 
		 *  they take over the output value of that signal or AudioParam. 
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.SignalBase} this
		 *  @method
		 */
	    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Signal} this
		 */
	    Tone.Signal.prototype.dispose = function () {
	        Tone.Param.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Signal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A signal which adds the method getValueAtTime.
		 *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline
		 *  @extends {Tone.Signal}
		 *  @param {Number=} value The initial value of the signal
		 *  @param {String=} units The conversion units of the signal.
		 */
	    Tone.TimelineSignal = function () {
	        var options = Tone.defaults(arguments, [
	            'value',
	            'units'
	        ], Tone.Signal);
	        Tone.Signal.call(this, options);
	        /**
			 *  The scheduled events
			 *  @type {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline(100);
	        /**
			 *  The initial scheduled value
			 *  @type {Number}
			 *  @private
			 */
	        this._initial = this._fromUnits(this._param.value);
	        this.value = options.value;
	        //delete the input node so that nothing can overwrite the signal value
	        delete this.input;
	    };
	    Tone.extend(Tone.TimelineSignal, Tone.Signal);
	    /**
		 *  The event types of a schedulable signal.
		 *  @enum {String}
		 *  @private
		 */
	    Tone.TimelineSignal.Type = {
	        Linear: 'linear',
	        Exponential: 'exponential',
	        Target: 'target',
	        Set: 'set'
	    };
	    /**
		 * The current value of the signal.
		 * @memberOf Tone.TimelineSignal#
		 * @type {Number}
		 * @name value
		 */
	    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {
	        get: function () {
	            var now = this.now();
	            var val = this.getValueAtTime(now);
	            return this._toUnits(val);
	        },
	        set: function (value) {
	            if (this._events) {
	                var convertedVal = this._fromUnits(value);
	                this._initial = convertedVal;
	                this.cancelScheduledValues();
	                this._param.value = convertedVal;
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    //	SCHEDULING
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedules a parameter value change at the given time.
		 *  @param {*}	value The value to set the signal.
		 *  @param {Time}  time The time when the change should occur.
		 *  @returns {Tone.TimelineSignal} this
		 *  @example
		 * //set the frequency to "G4" in exactly 1 second from now.
		 * freq.setValueAtTime("G4", "+1");
		 */
	    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {
	        value = this._fromUnits(value);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Set,
	            'value': value,
	            'time': startTime
	        });
	        //invoke the original event
	        this._param.setValueAtTime(value, startTime);
	        return this;
	    };
	    /**
		 *  Schedules a linear continuous change in parameter value from the
		 *  previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {
	        value = this._fromUnits(value);
	        endTime = this.toSeconds(endTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Linear,
	            'value': value,
	            'time': endTime
	        });
	        this._param.linearRampToValueAtTime(value, endTime);
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
	        //get the previous event and make sure it's not starting from 0
	        endTime = this.toSeconds(endTime);
	        var beforeEvent = this._searchBefore(endTime);
	        if (beforeEvent && beforeEvent.value === 0) {
	            //reschedule that event
	            this.setValueAtTime(this._minOutput, beforeEvent.time);
	        }
	        value = this._fromUnits(value);
	        var setValue = Math.max(value, this._minOutput);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Exponential,
	            'value': setValue,
	            'time': endTime
	        });
	        //if the ramped to value is 0, make it go to the min output, and then set to 0.
	        if (value < this._minOutput) {
	            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);
	            this.setValueAtTime(0, endTime);
	        } else {
	            this._param.exponentialRampToValueAtTime(value, endTime);
	        }
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        value = this._fromUnits(value);
	        value = Math.max(this._minOutput, value);
	        timeConstant = Math.max(this._minOutput, timeConstant);
	        startTime = this.toSeconds(startTime);
	        this._events.add({
	            'type': Tone.TimelineSignal.Type.Target,
	            'value': value,
	            'time': startTime,
	            'constant': timeConstant
	        });
	        this._param.setTargetAtTime(value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        scaling = Tone.defaultArg(scaling, 1);
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        var segTime = duration / (values.length - 1);
	        this.setValueAtTime(values[0] * scaling, startTime);
	        for (var i = 1; i < values.length; i++) {
	            this.linearRampToValueAtTime(values[i] * scaling, startTime + i * segTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *  @param  {Time} startTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {
	        after = this.toSeconds(after);
	        this._events.cancel(after);
	        this._param.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to cancelTime and sets the output of the signal to be the value
		 *  at cancelTime. Similar to (cancelScheduledValues)[#cancelscheduledvalues].
		 *  @param  {Time} cancelTime
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.cancelAndHoldAtTime = function (cancelTime) {
	        this.setRampPoint(this.toSeconds(cancelTime));
	        return this;
	    };
	    /**
		 *  Sets the computed value at the given time. This provides
		 *  a point from which a linear or exponential curve
		 *  can be scheduled after. Will cancel events after
		 *  the given time and shorten the currently scheduled
		 *  linear or exponential ramp so that it ends at `time` .
		 *  This is to avoid discontinuities and clicks in envelopes.
		 *  @param {Time} time When to set the ramp point
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.setRampPoint = function (time) {
	        time = this.toSeconds(time);
	        //get the value at the given time
	        var val = this._toUnits(this.getValueAtTime(time));
	        //if there is an event at the given time
	        //and that even is not a "set"
	        var before = this._searchBefore(time);
	        if (before && before.time === time) {
	            //remove everything after
	            this.cancelScheduledValues(time + this.sampleTime);
	        } else {
	            //reschedule the next event to end at the given time
	            var after = this._searchAfter(time);
	            if (after) {
	                //cancel the next event(s)
	                this.cancelScheduledValues(time);
	                if (after.type === Tone.TimelineSignal.Type.Linear) {
	                    this.linearRampToValueAtTime(val, time);
	                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	                    this.exponentialRampToValueAtTime(val, time);
	                }
	            }
	        }
	        this.setValueAtTime(val, time);
	        return this;
	    };
	    /**
		 *  Do a linear ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the linear ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.linearRampToValueAtTime(value, finish);
	        return this;
	    };
	    /**
		 *  Do a exponential ramp to the given value between the start and finish times.
		 *  @param {Number} value The value to ramp to.
		 *  @param {Time} start The beginning anchor point to do the exponential ramp
		 *  @param {Time} finish The ending anchor point by which the value of
		 *                       the signal will equal the given value.
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {
	        this.setRampPoint(start);
	        this.exponentialRampToValueAtTime(value, finish);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	GETTING SCHEDULED VALUES
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the value before or equal to the given time
		 *  @param  {Number}  time  The time to query
		 *  @return  {Object}  The event at or before the given time.
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchBefore = function (time) {
	        return this._events.get(time);
	    };
	    /**
		 *  The event after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @return  {Object}  The next event after the given time
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._searchAfter = function (time) {
	        return this._events.getAfter(time);
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toSeconds(time);
	        var after = this._searchAfter(time);
	        var before = this._searchBefore(time);
	        var value = this._initial;
	        //if it was set by
	        if (before === null) {
	            value = this._initial;
	        } else if (before.type === Tone.TimelineSignal.Type.Target) {
	            var previous = this._events.getBefore(before.time);
	            var previousVal;
	            if (previous === null) {
	                previousVal = this._initial;
	            } else {
	                previousVal = previous.value;
	            }
	            value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, time);
	        } else if (after === null) {
	            value = before.value;
	        } else if (after.type === Tone.TimelineSignal.Type.Linear) {
	            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);
	        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {
	            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);
	        } else {
	            value = before.value;
	        }
	        return value;
	    };
	    /**
		 *  When signals connect to other signals or AudioParams,
		 *  they take over the output value of that signal or AudioParam.
		 *  For all other nodes, the behavior is the same as a default <code>connect</code>.
		 *
		 *  @override
		 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node
		 *  @param {number} [outputNumber=0] The output number to connect from.
		 *  @param {number} [inputNumber=0] The input number to connect to.
		 *  @returns {Tone.TimelineSignal} this
		 *  @method
		 */
	    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUTOMATION CURVE CALCULATIONS
	    //	MIT License, copyright (c) 2014 Jordan Santell
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Calculates the the value along the curve produced by setTargetAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
	        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
	    };
	    /**
		 *  Calculates the the value along the curve produced by linearRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
	        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
	    };
	    /**
		 *  Calculates the the value along the curve produced by exponentialRampToValueAtTime
		 *  @private
		 */
	    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
	        v0 = Math.max(this._minOutput, v0);
	        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.TimelineSignal} this
		 */
	    Tone.TimelineSignal.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._events.dispose();
	        this._events = null;
	    };
	    return Tone.TimelineSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Pow applies an exponent to the incoming signal. The incoming signal
		 *         must be AudioRange.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. 
		 *  @example
		 * var pow = new Tone.Pow(2);
		 * var sig = new Tone.Signal(0.5).connect(pow);
		 * //output of pow is 0.25. 
		 */
	    Tone.Pow = function (exp) {
	        Tone.SignalBase.call(this);
	        /**
			 * the exponent
			 * @private
			 * @type {number}
			 */
	        this._exp = Tone.defaultArg(exp, 1);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
	    };
	    Tone.extend(Tone.Pow, Tone.SignalBase);
	    /**
		 * The value of the exponent.
		 * @memberOf Tone.Pow#
		 * @type {number}
		 * @name value
		 */
	    Object.defineProperty(Tone.Pow.prototype, 'value', {
	        get: function () {
	            return this._exp;
	        },
	        set: function (exp) {
	            this._exp = exp;
	            this._expScaler.setMap(this._expFunc(this._exp));
	        }
	    });
	    /**
		 *  the function which maps the waveshaper
		 *  @param   {number} exp
		 *  @return {function}
		 *  @private
		 */
	    Tone.Pow.prototype._expFunc = function (exp) {
	        return function (val) {
	            return Math.pow(Math.abs(val), exp);
	        };
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Pow} this
		 */
	    Tone.Pow.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._expScaler.dispose();
	        this._expScaler = null;
	        return this;
	    };
	    return Tone.Pow;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
		 *          envelope generator. Tone.Envelope outputs a signal which
		 *          can be connected to an AudioParam or Tone.Signal.
		 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time} [attack] The amount of time it takes for the envelope to go from
		 *                         0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * //an amplitude envelope
		 * var gainNode = Tone.context.createGain();
		 * var env = new Tone.Envelope({
		 * 	"attack" : 0.1,
		 * 	"decay" : 0.2,
		 * 	"sustain" : 1,
		 * 	"release" : 0.8,
		 * });
		 * env.connect(gainNode.gain);
		 */
	    Tone.Envelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.AudioNode.call(this);
	        /**
			 *  When triggerAttack is called, the attack time is the amount of
			 *  time it takes for the envelope to reach it's maximum value.
			 *  @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 *  After the attack portion of the envelope, the value will fall
			 *  over the duration of the decay time to it's sustain value.
			 *  @type {Time}
			 */
	        this.decay = options.decay;
	        /**
			 * 	The sustain value is the value
			 * 	which the envelope rests at after triggerAttack is
			 * 	called, but before triggerRelease is invoked.
			 *  @type {NormalRange}
			 */
	        this.sustain = options.sustain;
	        /**
			 *  After triggerRelease is called, the envelope's
			 *  value will fall to it's miminum value over the
			 *  duration of the release time.
			 *  @type {Time}
			 */
	        this.release = options.release;
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._attackCurve = 'linear';
	        /**
			 *  the next time the envelope is at standby
			 *  @type {number}
			 *  @private
			 */
	        this._releaseCurve = 'exponential';
	        /**
			 *  the signal
			 *  @type {Tone.TimelineSignal}
			 *  @private
			 */
	        this._sig = this.output = new Tone.TimelineSignal();
	        this._sig.setValueAtTime(0, 0);
	        //set the attackCurve initially
	        this.attackCurve = options.attackCurve;
	        this.releaseCurve = options.releaseCurve;
	    };
	    Tone.extend(Tone.Envelope, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 */
	    Tone.Envelope.defaults = {
	        'attack': 0.01,
	        'decay': 0.1,
	        'sustain': 0.5,
	        'release': 1,
	        'attackCurve': 'linear',
	        'releaseCurve': 'exponential'
	    };
	    /**
		 * Read the current value of the envelope. Useful for
		 * syncronizing visual output to the envelope.
		 * @memberOf Tone.Envelope#
		 * @type {Number}
		 * @name value
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'value', {
	        get: function () {
	            return this.getValueAtTime(this.now());
	        }
	    });
	    /**
		 * The shape of the attack.
		 * Can be any of these strings:
		 * <ul>
		 *   <li>linear</li>
		 *   <li>exponential</li>
		 *   <li>sine</li>
		 *   <li>cosine</li>
		 *   <li>bounce</li>
		 *   <li>ripple</li>
		 *   <li>step</li>
		 * </ul>
		 * Can also be an array which describes the curve. Values
		 * in the array are evenly subdivided and linearly
		 * interpolated over the duration of the attack.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name attackCurve
		 * @example
		 * env.attackCurve = "linear";
		 * @example
		 * //can also be an array
		 * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
	        get: function () {
	            if (Tone.isString(this._attackCurve)) {
	                return this._attackCurve;
	            } else if (Tone.isArray(this._attackCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].In === this._attackCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._attackCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._attackCurve = curveDef.In;
	                } else {
	                    this._attackCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._attackCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 * The shape of the release. See the attack curve types.
		 * @memberOf Tone.Envelope#
		 * @type {String|Array}
		 * @name releaseCurve
		 * @example
		 * env.releaseCurve = "linear";
		 */
	    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {
	        get: function () {
	            if (Tone.isString(this._releaseCurve)) {
	                return this._releaseCurve;
	            } else if (Tone.isArray(this._releaseCurve)) {
	                //look up the name in the curves array
	                for (var type in Tone.Envelope.Type) {
	                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {
	                        return type;
	                    }
	                }
	                //otherwise just return the array
	                return this._releaseCurve;
	            }
	        },
	        set: function (curve) {
	            //check if it's a valid type
	            if (Tone.Envelope.Type.hasOwnProperty(curve)) {
	                var curveDef = Tone.Envelope.Type[curve];
	                if (Tone.isObject(curveDef)) {
	                    this._releaseCurve = curveDef.Out;
	                } else {
	                    this._releaseCurve = curveDef;
	                }
	            } else if (Tone.isArray(curve)) {
	                this._releaseCurve = curve;
	            } else {
	                throw new Error('Tone.Envelope: invalid curve: ' + curve);
	            }
	        }
	    });
	    /**
		 *  Trigger the attack/decay portion of the ADSR envelope.
		 *  @param  {Time} [time=now] When the attack should start.
		 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
		 *                               number between 0-1
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
		 *  env.triggerAttack("+0.5", 0.2);
		 */
	    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        var originalAttack = this.toSeconds(this.attack);
	        var attack = originalAttack;
	        var decay = this.toSeconds(this.decay);
	        velocity = Tone.defaultArg(velocity, 1);
	        //check if it's not a complete attack
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            //subtract the current value from the attack time
	            var attackRate = 1 / attack;
	            var remainingDistance = 1 - currentValue;
	            //the attack is now the remaining time
	            attack = remainingDistance / attackRate;
	        }
	        //attack
	        if (this._attackCurve === 'linear') {
	            this._sig.linearRampTo(velocity, attack, time);
	        } else if (this._attackCurve === 'exponential') {
	            this._sig.targetRampTo(velocity, attack, time);
	        } else if (attack > 0) {
	            this._sig.setRampPoint(time);
	            var curve = this._attackCurve;
	            //take only a portion of the curve
	            if (attack < originalAttack) {
	                var percentComplete = 1 - attack / originalAttack;
	                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);
	                curve = this._attackCurve.slice(sliceIndex);
	                //the first index is the current value
	                curve[0] = currentValue;
	            }
	            this._sig.setValueCurveAtTime(curve, time, attack, velocity);
	        }
	        //decay
	        this._sig.targetRampTo(velocity * this.sustain, decay, attack + time);
	        return this;
	    };
	    /**
		 *  Triggers the release of the envelope.
		 *  @param  {Time} [time=now] When the release portion of the envelope should start.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 *  //trigger release immediately
		 *  env.triggerRelease();
		 */
	    Tone.Envelope.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        var currentValue = this.getValueAtTime(time);
	        if (currentValue > 0) {
	            var release = this.toSeconds(this.release);
	            if (this._releaseCurve === 'linear') {
	                this._sig.linearRampTo(0, release, time);
	            } else if (this._releaseCurve === 'exponential') {
	                this._sig.targetRampTo(0, release, time);
	            } else {
	                var curve = this._releaseCurve;
	                if (Tone.isArray(curve)) {
	                    this._sig.setRampPoint(time);
	                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {Number}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.Envelope.prototype.getValueAtTime = function (time) {
	        return this._sig.getValueAtTime(time);
	    };
	    /**
		 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
		 *  some duration, then triggerRelease.
		 *  @param {Time} duration The duration of the sustain.
		 *  @param {Time} [time=now] When the attack should be triggered.
		 *  @param {number} [velocity=1] The velocity of the envelope.
		 *  @returns {Tone.Envelope} this
		 *  @example
		 * //trigger the attack and then the release after 0.6 seconds.
		 * env.triggerAttackRelease(0.6);
		 */
	    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + this.toSeconds(duration));
	        return this;
	    };
	    /**
		 *  Cancels all scheduled envelope changes after the given time.
		 *  @param  {Time} after
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.cancel = function (after) {
	        this._sig.cancelScheduledValues(after);
	        return this;
	    };
	    /**
		 *  Borrows the connect method from Tone.Signal.
		 *  @function
		 *  @private
		 */
	    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
	    /**
	 	 *  Generate some complex envelope curves.
	 	 */
	    (function _createCurves() {
	        var curveLen = 128;
	        var i, k;
	        //cosine curve
	        var cosineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));
	        }
	        //ripple curve
	        var rippleCurve = [];
	        var rippleCurveFreq = 6.4;
	        for (i = 0; i < curveLen - 1; i++) {
	            k = i / (curveLen - 1);
	            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;
	            rippleCurve[i] = sineWave / 10 + k * 0.83;
	        }
	        rippleCurve[curveLen - 1] = 1;
	        //stairs curve
	        var stairsCurve = [];
	        var steps = 5;
	        for (i = 0; i < curveLen; i++) {
	            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;
	        }
	        //in-out easing curve
	        var sineCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));
	        }
	        //a bounce curve
	        var bounceCurve = [];
	        for (i = 0; i < curveLen; i++) {
	            k = i / (curveLen - 1);
	            var freq = Math.pow(k, 3) * 4 + 0.2;
	            var val = Math.cos(freq * Math.PI * 2 * k);
	            bounceCurve[i] = Math.abs(val * (1 - k));
	        }
	        /**
			 *  Invert a value curve to make it work for the release
			 *  @private
			 */
	        function invertCurve(curve) {
	            var out = new Array(curve.length);
	            for (var j = 0; j < curve.length; j++) {
	                out[j] = 1 - curve[j];
	            }
	            return out;
	        }
	        /**
			 *  reverse the curve
			 *  @private
			 */
	        function reverseCurve(curve) {
	            return curve.slice(0).reverse();
	        }
	        /**
			 *  attack and release curve arrays
			 *  @type  {Object}
			 *  @private
			 */
	        Tone.Envelope.Type = {
	            'linear': 'linear',
	            'exponential': 'exponential',
	            'bounce': {
	                In: invertCurve(bounceCurve),
	                Out: bounceCurve
	            },
	            'cosine': {
	                In: cosineCurve,
	                Out: reverseCurve(cosineCurve)
	            },
	            'step': {
	                In: stairsCurve,
	                Out: invertCurve(stairsCurve)
	            },
	            'ripple': {
	                In: rippleCurve,
	                Out: invertCurve(rippleCurve)
	            },
	            'sine': {
	                In: sineCurve,
	                Out: invertCurve(sineCurve)
	            }
	        };
	    }());
	    /**
		 *  Disconnect and dispose.
		 *  @returns {Tone.Envelope} this
		 */
	    Tone.Envelope.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._sig.dispose();
	        this._sig = null;
	        this._attackCurve = null;
	        this._releaseCurve = null;
	        return this;
	    };
	    return Tone.Envelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node.
		 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
		 *          an audio signal as the input and will apply the envelope to the amplitude
		 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
		 *
		 *  @constructor
		 *  @extends {Tone.Envelope}
		 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from
		 *                               0 to it's maximum value.
		 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
		 *                       	to fall to the sustain value.
		 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
		 *                                	the release is triggered.
		 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0.
		 *  @example
		 * var ampEnv = new Tone.AmplitudeEnvelope({
		 * 	"attack": 0.1,
		 * 	"decay": 0.2,
		 * 	"sustain": 1.0,
		 * 	"release": 0.8
		 * }).toMaster();
		 * //create an oscillator and connect it
		 * var osc = new Tone.Oscillator().connect(ampEnv).start();
		 * //trigger the envelopes attack and release "8t" apart
		 * ampEnv.triggerAttackRelease("8t");
		 */
	    Tone.AmplitudeEnvelope = function () {
	        Tone.Envelope.apply(this, arguments);
	        /**
			 *  the input node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.input = this.output = new Tone.Gain();
	        this._sig.connect(this.output.gain);
	    };
	    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
	    /**
		 *  Clean up
		 *  @return  {Tone.AmplitudeEnvelope}  this
		 */
	    Tone.AmplitudeEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.AmplitudeEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AnalyserNode.getFloatTimeDomainData polyfill
		 *  @private
		 */
	    if (window.AnalyserNode && !AnalyserNode.prototype.getFloatTimeDomainData) {
	        //referenced https://github.com/mohayonao/get-float-time-domain-data
	        AnalyserNode.prototype.getFloatTimeDomainData = function (array) {
	            var uint8 = new Uint8Array(array.length);
	            this.getByteTimeDomainData(uint8);
	            for (var i = 0; i < uint8.length; i++) {
	                array[i] = (uint8[i] - 128) / 128;
	            }
	        };
	    }
	    /**
		 *  @class  Wrapper around the native Web Audio's
		 *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).
		 *          Extracts FFT or Waveform data from the incoming signal.
		 *  @extends {Tone.AudioNode}
		 *  @param {String=} type The return type of the analysis, either "fft", or "waveform".
		 *  @param {Number=} size The size of the FFT. Value must be a power of
		 *                       two in the range 32 to 32768.
		 */
	    Tone.Analyser = function () {
	        var options = Tone.defaults(arguments, [
	            'type',
	            'size'
	        ], Tone.Analyser);
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node.
			 *  @private
			 *  @type {AnalyserNode}
			 */
	        this._analyser = this.input = this.output = this.context.createAnalyser();
	        /**
			 *  The analysis type
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The buffer that the FFT data is written to
			 *  @type {TypedArray}
			 *  @private
			 */
	        this._buffer = null;
	        //set the values initially
	        this.size = options.size;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.Analyser, Tone.AudioNode);
	    /**
		 *  The default values.
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Analyser.defaults = {
	        'size': 1024,
	        'type': 'fft',
	        'smoothing': 0.8
	    };
	    /**
		 *  Possible return types of analyser.getValue()
		 *  @enum {String}
		 */
	    Tone.Analyser.Type = {
	        Waveform: 'waveform',
	        FFT: 'fft'
	    };
	    /**
		 *  Run the analysis given the current settings and return the
		 *  result as a TypedArray.
		 *  @returns {TypedArray}
		 */
	    Tone.Analyser.prototype.getValue = function () {
	        if (this._type === Tone.Analyser.Type.FFT) {
	            this._analyser.getFloatFrequencyData(this._buffer);
	        } else if (this._type === Tone.Analyser.Type.Waveform) {
	            this._analyser.getFloatTimeDomainData(this._buffer);
	        }
	        return this._buffer;
	    };
	    /**
		 *  The size of analysis. This must be a power of two in the range 32 to 32768.
		 *  @memberOf Tone.Analyser#
		 *  @type {Number}
		 *  @name size
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'size', {
	        get: function () {
	            return this._analyser.frequencyBinCount;
	        },
	        set: function (size) {
	            this._analyser.fftSize = size * 2;
	            this._buffer = new Float32Array(size);
	        }
	    });
	    /**
		 *  The analysis function returned by analyser.getValue(), either "fft" or "waveform".
		 *  @memberOf Tone.Analyser#
		 *  @type {String}
		 *  @name type
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {
	                throw new TypeError('Tone.Analyser: invalid type: ' + type);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  0 represents no time averaging with the last analysis frame.
		 *  @memberOf Tone.Analyser#
		 *  @type {NormalRange}
		 *  @name smoothing
		 */
	    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {
	        get: function () {
	            return this._analyser.smoothingTimeConstant;
	        },
	        set: function (val) {
	            this._analyser.smoothingTimeConstant = val;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.Analyser}  this
		 */
	    Tone.Analyser.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.disconnect();
	        this._analyser = null;
	        this._buffer = null;
	    };
	    return Tone.Analyser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Compressor is a thin wrapper around the Web Audio
		 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
		 *         Compression reduces the volume of loud sounds or amplifies quiet sounds
		 *         by narrowing or "compressing" an audio signal's dynamic range.
		 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
		 *  @param {Positive} [ratio] The gain reduction ratio.
		 *  @example
		 * var comp = new Tone.Compressor(-30, 3);
		 */
	    Tone.Compressor = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'ratio'
	        ], Tone.Compressor);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor node
			 *  @type {DynamicsCompressorNode}
			 *  @private
			 */
	        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
	        /**
			 *  the threshold vaue
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.threshold = new Tone.Param({
	            'param': this._compressor.threshold,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The attack parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);
	        /**
			 *  The release parameter
			 *  @type {Time}
			 *  @signal
			 */
	        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);
	        /**
			 *  The knee parameter
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.knee = new Tone.Param({
	            'param': this._compressor.knee,
	            'units': Tone.Type.Decibels,
	            'convert': false
	        });
	        /**
			 *  The ratio value
			 *  @type {Number}
			 *  @signal
			 */
	        this.ratio = new Tone.Param({
	            'param': this._compressor.ratio,
	            'convert': false
	        });
	        //set the defaults
	        this._readOnly([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this.set(options);
	    };
	    Tone.extend(Tone.Compressor, Tone.AudioNode);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Compressor.defaults = {
	        'ratio': 12,
	        'threshold': -24,
	        'release': 0.25,
	        'attack': 0.003,
	        'knee': 30
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Compressor} this
		 */
	    Tone.Compressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'knee',
	            'release',
	            'attack',
	            'ratio',
	            'threshold'
	        ]);
	        this._compressor.disconnect();
	        this._compressor = null;
	        this.attack.dispose();
	        this.attack = null;
	        this.release.dispose();
	        this.release = null;
	        this.threshold.dispose();
	        this.threshold = null;
	        this.ratio.dispose();
	        this.ratio = null;
	        this.knee.dispose();
	        this.knee = null;
	        return this;
	    };
	    return Tone.Compressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Add a signal and a number or two signals. When no value is
		 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
		 *         and <code>input[1]</code>. If a value is passed into the constructor, 
		 *         the it will be added to the input.
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value If no value is provided, Tone.Add will sum the first
		 *                         and second inputs. 
		 *  @example
		 * var signal = new Tone.Signal(2);
		 * var add = new Tone.Add(2);
		 * signal.connect(add);
		 * //the output of add equals 4
		 *  @example
		 * //if constructed with no arguments
		 * //it will add the first and second inputs
		 * var add = new Tone.Add();
		 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
		 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
		 * //the output of add equals 7. 
		 */
	    Tone.Add = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();
	        /**
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.connect(this._sum);
	    };
	    Tone.extend(Tone.Add, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Add} this
		 */
	    Tone.Add.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._sum.dispose();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Add;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
		 *          multiplies the incoming signal by that value. 
		 *
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number=} value Constant value to multiple. If no value is provided,
		 *                         it will return the product of the first and second inputs
		 *  @example
		 * var mult = new Tone.Multiply();
		 * var sigA = new Tone.Signal(3);
		 * var sigB = new Tone.Signal(4);
		 * sigA.connect(mult, 0, 0);
		 * sigB.connect(mult, 0, 1);
		 * //output of mult is 12.
		 *  @example
		 * var mult = new Tone.Multiply(10);
		 * var sig = new Tone.Signal(2).connect(mult);
		 * //the output of mult is 20. 
		 */
	    Tone.Multiply = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the input node is the same as the output node
			 *  it is also the GainNode which handles the scaling of incoming signal
			 *  
			 *  @type {GainNode}
			 *  @private
			 */
	        this._mult = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  the scaling parameter
			 *  @type {AudioParam}
			 *  @private
			 */
	        this._param = this.input[1] = this.output.gain;
	        this._param.value = Tone.defaultArg(value, 0);
	    };
	    Tone.extend(Tone.Multiply, Tone.Signal);
	    /**
		 *  clean up
		 *  @returns {Tone.Multiply} this
		 */
	    Tone.Multiply.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._mult.dispose();
	        this._mult = null;
	        this._param = null;
	        return this;
	    };
	    return Tone.Multiply;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var neg = new Tone.Negate();
		 * var sig = new Tone.Signal(-2).connect(neg);
		 * //output of neg is positive 2. 
		 */
	    Tone.Negate = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  negation is done by multiplying by -1
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = this.input = this.output = new Tone.Multiply(-1);
	    };
	    Tone.extend(Tone.Negate, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.Negate} this
		 */
	    Tone.Negate.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._multiply.dispose();
	        this._multiply = null;
	        return this;
	    };
	    return Tone.Negate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
		 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
		 *         signals <code>.value</code> will be subtracted from the incoming signal.
		 *
		 *  @extends {Tone.Signal}
		 *  @constructor
		 *  @param {number=} value The value to subtract from the incoming signal. If the value
		 *                         is omitted, it will subtract the second signal from the first.
		 *  @example
		 * var sub = new Tone.Subtract(1);
		 * var sig = new Tone.Signal(4).connect(sub);
		 * //the output of sub is 3. 
		 *  @example
		 * var sub = new Tone.Subtract();
		 * var sigA = new Tone.Signal(10);
		 * var sigB = new Tone.Signal(2.5);
		 * sigA.connect(sub, 0, 0);
		 * sigB.connect(sub, 0, 1);
		 * //output of sub is 7.5
		 */
	    Tone.Subtract = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  the summing node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._sum = this.input[0] = this.output = new Tone.Gain();
	        /**
			 *  negate the input of the second input before connecting it
			 *  to the summing node.
			 *  @type {Tone.Negate}
			 *  @private
			 */
	        this._neg = new Tone.Negate();
	        /**
			 *  the node where the value is set
			 *  @private
			 *  @type {Tone.Signal}
			 */
	        this._param = this.input[1] = new Tone.Signal(value);
	        this._param.chain(this._neg, this._sum);
	    };
	    Tone.extend(Tone.Subtract, Tone.Signal);
	    /**
		 *  Clean up.
		 *  @returns {Tone.SignalBase} this
		 */
	    Tone.Subtract.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._neg.dispose();
	        this._neg = null;
	        this._sum.disconnect();
	        this._sum = null;
	        return this;
	    };
	    return Tone.Subtract;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var gt0 = new Tone.GreaterThanZero();
		 * var sig = new Tone.Signal(0.01).connect(gt0);
		 * //the output of gt0 is 1. 
		 * sig.value = 0;
		 * //the output of gt0 is 0. 
		 */
	    Tone.GreaterThanZero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = this.output = new Tone.WaveShaper(function (val) {
	            if (val <= 0) {
	                return 0;
	            } else {
	                return 1;
	            }
	        }, 127);
	        /**
			 *  scale the first thresholded signal by a large value.
			 *  this will help with values which are very close to 0
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(10000);
	        //connections
	        this._scale.connect(this._thresh);
	    };
	    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThanZero} this
		 */
	    Tone.GreaterThanZero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        return this;
	    };
	    return Tone.GreaterThanZero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
		 *          can compare two signals or a signal and a number. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Signal}
		 *  @param {number} [value=0] the value to compare to the incoming signal
		 *  @example
		 * var gt = new Tone.GreaterThan(2);
		 * var sig = new Tone.Signal(4).connect(gt);
		 * //output of gt is equal 1. 
		 */
	    Tone.GreaterThan = function (value) {
	        Tone.Signal.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  subtract the amount from the incoming signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._param = this.input[0] = new Tone.Subtract(value);
	        this.input[1] = this._param.input[1];
	        /**
			 *  compare that amount to zero
			 *  @type {Tone.GreaterThanZero}
			 *  @private
			 */
	        this._gtz = this.output = new Tone.GreaterThanZero();
	        //connect
	        this._param.connect(this._gtz);
	    };
	    Tone.extend(Tone.GreaterThan, Tone.Signal);
	    /**
		 *  dispose method
		 *  @returns {Tone.GreaterThan} this
		 */
	    Tone.GreaterThan.prototype.dispose = function () {
	        Tone.Signal.prototype.dispose.call(this);
	        this._gtz.dispose();
	        this._gtz = null;
	        return this;
	    };
	    return Tone.GreaterThan;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Return the absolute value of an incoming signal. 
		 *  
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @example
		 * var signal = new Tone.Signal(-1);
		 * var abs = new Tone.Abs();
		 * signal.connect(abs);
		 * //the output of abs is 1. 
		 */
	    Tone.Abs = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.LessThan}
			 *  @private
			 */
	        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (val === 0) {
	                return 0;
	            } else {
	                return Math.abs(val);
	            }
	        }, 127);
	    };
	    Tone.extend(Tone.Abs, Tone.SignalBase);
	    /**
		 *  dispose method
		 *  @returns {Tone.Abs} this
		 */
	    Tone.Abs.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._abs.dispose();
	        this._abs = null;
	        return this;
	    };
	    return Tone.Abs;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
		 *         values in the NormalRange. 
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {NormalRange} modulus The modulus to apply.
		 *  @example
		 * var mod = new Tone.Modulo(0.2)
		 * var sig = new Tone.Signal(0.5).connect(mod);
		 * //mod outputs 0.1
		 */
	    Tone.Modulo = function (modulus) {
	        Tone.SignalBase.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  A waveshaper gets the integer multiple of 
			 *  the input signal and the modulus.
			 *  @private
			 *  @type {Tone.WaveShaper}
			 */
	        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
	        /**
			 *  the integer multiple is multiplied by the modulus
			 *  @type  {Tone.Multiply}
			 *  @private
			 */
	        this._multiply = new Tone.Multiply();
	        /**
			 *  and subtracted from the input signal
			 *  @type  {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = this.output = new Tone.Subtract();
	        /**
			 *  the modulus signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._modSignal = new Tone.Signal(modulus);
	        //connections
	        this.input.fan(this._shaper, this._subtract);
	        this._modSignal.connect(this._multiply, 0, 0);
	        this._shaper.connect(this._multiply, 0, 1);
	        this._multiply.connect(this._subtract, 0, 1);
	        this._setWaveShaper(modulus);
	    };
	    Tone.extend(Tone.Modulo, Tone.SignalBase);
	    /**
		 *  @param  {number}  mod  the modulus to apply
		 *  @private
		 */
	    Tone.Modulo.prototype._setWaveShaper = function (mod) {
	        this._shaper.setMap(function (val) {
	            var multiple = Math.floor((val + 0.0001) / mod);
	            return multiple;
	        });
	    };
	    /**
		 * The modulus value.
		 * @memberOf Tone.Modulo#
		 * @type {NormalRange}
		 * @name value
		 */
	    Object.defineProperty(Tone.Modulo.prototype, 'value', {
	        get: function () {
	            return this._modSignal.value;
	        },
	        set: function (mod) {
	            this._modSignal.value = mod;
	            this._setWaveShaper(mod);
	        }
	    });
	    /**
		 * clean up
		 *  @returns {Tone.Modulo} this
		 */
	    Tone.Modulo.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        this._multiply.dispose();
	        this._multiply = null;
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modSignal.dispose();
	        this._modSignal = null;
	        return this;
	    };
	    return Tone.Modulo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
		 *         See Tone.GainToAudio.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 *  var a2g = new Tone.AudioToGain();
		 */
	    Tone.AudioToGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return (x + 1) / 2;
	        });
	    };
	    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.AudioToGain} this
		 */
	    Tone.AudioToGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.AudioToGain;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Evaluate an expression at audio rate. <br><br>
		 *         Parsing code modified from https://code.google.com/p/tapdigit/
		 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {string} expr the expression to generate
		 *  @example
		 * //adds the signals from input[0] and input[1].
		 * var expr = new Tone.Expr("$0 + $1");
		 */
	    Tone.Expr = function () {
	        Tone.SignalBase.call(this);
	        var expr = this._replacements(Array.prototype.slice.call(arguments));
	        var inputCount = this._parseInputs(expr);
	        /**
			 *  hold onto all of the nodes for disposal
			 *  @type {Array}
			 *  @private
			 */
	        this._nodes = [];
	        /**
			 *  The inputs. The length is determined by the expression. 
			 *  @type {Array}
			 */
	        this.input = new Array(inputCount);
	        //create a gain for each input
	        for (var i = 0; i < inputCount; i++) {
	            this.input[i] = this.context.createGain();
	        }
	        //parse the syntax tree
	        var tree = this._parseTree(expr);
	        //evaluate the results
	        var result;
	        try {
	            result = this._eval(tree);
	        } catch (e) {
	            this._disposeNodes();
	            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);
	        }
	        /**
			 *  The output node is the result of the expression
			 *  @type {Tone}
			 */
	        this.output = result;
	    };
	    Tone.extend(Tone.Expr, Tone.SignalBase);
	    //some helpers to cut down the amount of code
	    function applyBinary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        self._eval(args[1]).connect(op, 0, 1);
	        return op;
	    }
	    function applyUnary(Constructor, args, self) {
	        var op = new Constructor();
	        self._eval(args[0]).connect(op, 0, 0);
	        return op;
	    }
	    function getNumber(arg) {
	        return arg ? parseFloat(arg) : undefined;
	    }
	    function literalNumber(arg) {
	        return arg && arg.args ? parseFloat(arg.args) : undefined;
	    }
	    /*
		 *  the Expressions that Tone.Expr can parse.
		 *
		 *  each expression belongs to a group and contains a regexp 
		 *  for selecting the operator as well as that operators method
		 *  
		 *  @type {Object}
		 *  @private
		 */
	    Tone.Expr._Expressions = {
	        //values
	        'value': {
	            'signal': {
	                regexp: /^\d+\.\d+|^\d+/,
	                method: function (arg) {
	                    var sig = new Tone.Signal(getNumber(arg));
	                    return sig;
	                }
	            },
	            'input': {
	                regexp: /^\$\d/,
	                method: function (arg, self) {
	                    return self.input[getNumber(arg.substr(1))];
	                }
	            }
	        },
	        //syntactic glue
	        'glue': {
	            '(': { regexp: /^\(/ },
	            ')': { regexp: /^\)/ },
	            ',': { regexp: /^,/ }
	        },
	        //functions
	        'func': {
	            'abs': {
	                regexp: /^abs/,
	                method: applyUnary.bind(this, Tone.Abs)
	            },
	            'mod': {
	                regexp: /^mod/,
	                method: function (args, self) {
	                    var modulus = literalNumber(args[1]);
	                    var op = new Tone.Modulo(modulus);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'pow': {
	                regexp: /^pow/,
	                method: function (args, self) {
	                    var exp = literalNumber(args[1]);
	                    var op = new Tone.Pow(exp);
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            },
	            'a2g': {
	                regexp: /^a2g/,
	                method: function (args, self) {
	                    var op = new Tone.AudioToGain();
	                    self._eval(args[0]).connect(op);
	                    return op;
	                }
	            }
	        },
	        //binary expressions
	        'binary': {
	            '+': {
	                regexp: /^\+/,
	                precedence: 1,
	                method: applyBinary.bind(this, Tone.Add)
	            },
	            '-': {
	                regexp: /^\-/,
	                precedence: 1,
	                method: function (args, self) {
	                    //both unary and binary op
	                    if (args.length === 1) {
	                        return applyUnary(Tone.Negate, args, self);
	                    } else {
	                        return applyBinary(Tone.Subtract, args, self);
	                    }
	                }
	            },
	            '*': {
	                regexp: /^\*/,
	                precedence: 0,
	                method: applyBinary.bind(this, Tone.Multiply)
	            }
	        },
	        //unary expressions
	        'unary': {
	            '-': {
	                regexp: /^\-/,
	                method: applyUnary.bind(this, Tone.Negate)
	            },
	            '!': {
	                regexp: /^\!/,
	                method: applyUnary.bind(this, Tone.NOT)
	            }
	        }
	    };
	    /**
		 *  @param   {string} expr the expression string
		 *  @return  {number}      the input count
		 *  @private
		 */
	    Tone.Expr.prototype._parseInputs = function (expr) {
	        var inputArray = expr.match(/\$\d/g);
	        var inputMax = 0;
	        if (inputArray !== null) {
	            for (var i = 0; i < inputArray.length; i++) {
	                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
	                inputMax = Math.max(inputMax, inputNum);
	            }
	        }
	        return inputMax;
	    };
	    /**
		 *  @param   {Array} args 	an array of arguments
		 *  @return  {string} the results of the replacements being replaced
		 *  @private
		 */
	    Tone.Expr.prototype._replacements = function (args) {
	        var expr = args.shift();
	        for (var i = 0; i < args.length; i++) {
	            expr = expr.replace(/\%/i, args[i]);
	        }
	        return expr;
	    };
	    /**
		 *  tokenize the expression based on the Expressions object
		 *  @param   {string} expr 
		 *  @return  {Object}      returns two methods on the tokenized list, next and peek
		 *  @private
		 */
	    Tone.Expr.prototype._tokenize = function (expr) {
	        var position = -1;
	        var tokens = [];
	        while (expr.length > 0) {
	            expr = expr.trim();
	            var token = getNextToken(expr);
	            tokens.push(token);
	            expr = expr.substr(token.value.length);
	        }
	        function getNextToken(expr) {
	            for (var type in Tone.Expr._Expressions) {
	                var group = Tone.Expr._Expressions[type];
	                for (var opName in group) {
	                    var op = group[opName];
	                    var reg = op.regexp;
	                    var match = expr.match(reg);
	                    if (match !== null) {
	                        return {
	                            type: type,
	                            value: match[0],
	                            method: op.method
	                        };
	                    }
	                }
	            }
	            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);
	        }
	        return {
	            next: function () {
	                return tokens[++position];
	            },
	            peek: function () {
	                return tokens[position + 1];
	            }
	        };
	    };
	    /**
		 *  recursively parse the string expression into a syntax tree
		 *  
		 *  @param   {string} expr 
		 *  @return  {Object}
		 *  @private
		 */
	    Tone.Expr.prototype._parseTree = function (expr) {
	        var lexer = this._tokenize(expr);
	        var isUndef = Tone.isUndef.bind(this);
	        function matchSyntax(token, syn) {
	            return !isUndef(token) && token.type === 'glue' && token.value === syn;
	        }
	        function matchGroup(token, groupName, prec) {
	            var ret = false;
	            var group = Tone.Expr._Expressions[groupName];
	            if (!isUndef(token)) {
	                for (var opName in group) {
	                    var op = group[opName];
	                    if (op.regexp.test(token.value)) {
	                        if (!isUndef(prec)) {
	                            if (op.precedence === prec) {
	                                return true;
	                            }
	                        } else {
	                            return true;
	                        }
	                    }
	                }
	            }
	            return ret;
	        }
	        function parseExpression(precedence) {
	            if (isUndef(precedence)) {
	                precedence = 5;
	            }
	            var expr;
	            if (precedence < 0) {
	                expr = parseUnary();
	            } else {
	                expr = parseExpression(precedence - 1);
	            }
	            var token = lexer.peek();
	            while (matchGroup(token, 'binary', precedence)) {
	                token = lexer.next();
	                expr = {
	                    operator: token.value,
	                    method: token.method,
	                    args: [
	                        expr,
	                        parseExpression(precedence - 1)
	                    ]
	                };
	                token = lexer.peek();
	            }
	            return expr;
	        }
	        function parseUnary() {
	            var token, expr;
	            token = lexer.peek();
	            if (matchGroup(token, 'unary')) {
	                token = lexer.next();
	                expr = parseUnary();
	                return {
	                    operator: token.value,
	                    method: token.method,
	                    args: [expr]
	                };
	            }
	            return parsePrimary();
	        }
	        function parsePrimary() {
	            var token, expr;
	            token = lexer.peek();
	            if (isUndef(token)) {
	                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');
	            }
	            if (token.type === 'func') {
	                token = lexer.next();
	                return parseFunctionCall(token);
	            }
	            if (token.type === 'value') {
	                token = lexer.next();
	                return {
	                    method: token.method,
	                    args: token.value
	                };
	            }
	            if (matchSyntax(token, '(')) {
	                lexer.next();
	                expr = parseExpression();
	                token = lexer.next();
	                if (!matchSyntax(token, ')')) {
	                    throw new SyntaxError('Expected )');
	                }
	                return expr;
	            }
	            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);
	        }
	        function parseFunctionCall(func) {
	            var token, args = [];
	            token = lexer.next();
	            if (!matchSyntax(token, '(')) {
	                throw new SyntaxError('Tone.Expr: Expected ( in a function call "' + func.value + '"');
	            }
	            token = lexer.peek();
	            if (!matchSyntax(token, ')')) {
	                args = parseArgumentList();
	            }
	            token = lexer.next();
	            if (!matchSyntax(token, ')')) {
	                throw new SyntaxError('Tone.Expr: Expected ) in a function call "' + func.value + '"');
	            }
	            return {
	                method: func.method,
	                args: args,
	                name: name
	            };
	        }
	        function parseArgumentList() {
	            var token, expr, args = [];
	            while (true) {
	                expr = parseExpression();
	                if (isUndef(expr)) {
	                    // TODO maybe throw exception?
	                    break;
	                }
	                args.push(expr);
	                token = lexer.peek();
	                if (!matchSyntax(token, ',')) {
	                    break;
	                }
	                lexer.next();
	            }
	            return args;
	        }
	        return parseExpression();
	    };
	    /**
		 *  recursively evaluate the expression tree
		 *  @param   {Object} tree 
		 *  @return  {AudioNode}      the resulting audio node from the expression
		 *  @private
		 */
	    Tone.Expr.prototype._eval = function (tree) {
	        if (!Tone.isUndef(tree)) {
	            var node = tree.method(tree.args, this);
	            this._nodes.push(node);
	            return node;
	        }
	    };
	    /**
		 *  dispose all the nodes
		 *  @private
		 */
	    Tone.Expr.prototype._disposeNodes = function () {
	        for (var i = 0; i < this._nodes.length; i++) {
	            var node = this._nodes[i];
	            if (Tone.isFunction(node.dispose)) {
	                node.dispose();
	            } else if (Tone.isFunction(node.disconnect)) {
	                node.disconnect();
	            }
	            node = null;
	            this._nodes[i] = null;
	        }
	        this._nodes = null;
	    };
	    /**
		 *  clean up
		 */
	    Tone.Expr.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._disposeNodes();
	    };
	    return Tone.Expr;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var eqPowGain = new Tone.EqualPowerGain();
		 */
	    Tone.EqualPowerGain = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
	            if (Math.abs(val) < 0.001) {
	                //should output 0 when input is 0
	                return 0;
	            } else {
	                return Tone.equalPowerScale(val);
	            }
	        }.bind(this), 4096);
	    };
	    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.EqualPowerGain} this
		 */
	    Tone.EqualPowerGain.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._eqPower.dispose();
	        this._eqPower = null;
	        return this;
	    };
	    return Tone.EqualPowerGain;
	});
	Module(function (Tone) {
	    
	    /**
		 * @class  Tone.Crossfade provides equal power fading between two inputs.
		 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
		 *
		 * @constructor
		 * @extends {Tone.AudioNode}
		 * @param {NormalRange} [initialFade=0.5]
		 * @example
		 * var crossFade = new Tone.CrossFade(0.5);
		 * //connect effect A to crossfade from
		 * //effect output 0 to crossfade input 0
		 * effectA.connect(crossFade, 0, 0);
		 * //connect effect B to crossfade from
		 * //effect output 0 to crossfade input 1
		 * effectB.connect(crossFade, 0, 1);
		 * crossFade.fade.value = 0;
		 * // ^ only effectA is output
		 * crossFade.fade.value = 1;
		 * // ^ only effectB is output
		 * crossFade.fade.value = 0.5;
		 * // ^ the two signals are mixed equally.
		 */
	    Tone.CrossFade = function (initialFade) {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 1);
	        /**
			 *  Alias for <code>input[0]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.a = this.input[0] = new Tone.Gain();
	        /**
			 *  Alias for <code>input[1]</code>.
			 *  @type {Tone.Gain}
			 */
	        this.b = this.input[1] = new Tone.Gain();
	        /**
			 * 	The mix between the two inputs. A fade value of 0
			 * 	will output 100% <code>input[0]</code> and
			 * 	a value of 1 will output 100% <code>input[1]</code>.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.fade = new Tone.Signal(Tone.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerA = new Tone.EqualPowerGain();
	        /**
			 *  equal power gain cross fade
			 *  @private
			 *  @type {Tone.EqualPowerGain}
			 */
	        this._equalPowerB = new Tone.EqualPowerGain();
	        /**
			 *  invert the incoming signal
			 *  @private
			 *  @type {Tone}
			 */
	        this._invert = new Tone.Expr('1 - $0');
	        //connections
	        this.a.connect(this.output);
	        this.b.connect(this.output);
	        this.fade.chain(this._equalPowerB, this.b.gain);
	        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
	        this._readOnly('fade');
	    };
	    Tone.extend(Tone.CrossFade, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.CrossFade} this
		 */
	    Tone.CrossFade.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('fade');
	        this._equalPowerA.dispose();
	        this._equalPowerA = null;
	        this._equalPowerB.dispose();
	        this._equalPowerB = null;
	        this.fade.dispose();
	        this.fade = null;
	        this._invert.dispose();
	        this._invert = null;
	        this.a.dispose();
	        this.a = null;
	        this.b.dispose();
	        this.b = null;
	        return this;
	    };
	    return Tone.CrossFade;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Filter is a filter which allows for all of the same native methods
		 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).
		 *          Tone.Filter has the added ability to set the filter rolloff at -12
		 *          (default), -24 and -48.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
		 *  @param {string=} type The type of filter.
		 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
		 *                            3 choices: -12, -24, and -48
		 *  @example
		 *  var filter = new Tone.Filter(200, "highpass");
		 */
	    Tone.Filter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'rolloff'
	        ], Tone.Filter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the filter(s)
			 *  @type {Array}
			 *  @private
			 */
	        this._filters = [];
	        /**
			 *  The cutoff frequency of the filter.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune parameter
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(0, Tone.Type.Cents);
	        /**
			 *  The gain of the filter, only used in certain filter types
			 *  @type {Number}
			 *  @signal
			 */
	        this.gain = new Tone.Signal({
	            'value': options.gain,
	            'convert': false
	        });
	        /**
			 *  The Q or Quality of the filter
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        /**
			 *  the type of the filter
			 *  @type {string}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  the rolloff value of the filter
			 *  @type {number}
			 *  @private
			 */
	        this._rolloff = options.rolloff;
	        //set the rolloff;
	        this.rolloff = options.rolloff;
	        this._readOnly([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Filter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Filter.defaults = {
	        'type': 'lowpass',
	        'frequency': 350,
	        'rolloff': -12,
	        'Q': 1,
	        'gain': 0
	    };
	    /**
		 * The type of the filter. Types: "lowpass", "highpass",
		 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking".
		 * @memberOf Tone.Filter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var types = [
	                'lowpass',
	                'highpass',
	                'bandpass',
	                'lowshelf',
	                'highshelf',
	                'notch',
	                'allpass',
	                'peaking'
	            ];
	            if (types.indexOf(type) === -1) {
	                throw new TypeError('Tone.Filter: invalid type ' + type);
	            }
	            this._type = type;
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].type = type;
	            }
	        }
	    });
	    /**
		 * The rolloff of the filter which is the drop in db
		 * per octave. Implemented internally by cascading filters.
		 * Only accepts the values -12, -24, -48 and -96.
		 * @memberOf Tone.Filter#
		 * @type {number}
		 * @name rolloff
		 */
	    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
	        get: function () {
	            return this._rolloff;
	        },
	        set: function (rolloff) {
	            rolloff = parseInt(rolloff, 10);
	            var possibilities = [
	                -12,
	                -24,
	                -48,
	                -96
	            ];
	            var cascadingCount = possibilities.indexOf(rolloff);
	            //check the rolloff is valid
	            if (cascadingCount === -1) {
	                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');
	            }
	            cascadingCount += 1;
	            this._rolloff = rolloff;
	            //first disconnect the filters and throw them away
	            this.input.disconnect();
	            for (var i = 0; i < this._filters.length; i++) {
	                this._filters[i].disconnect();
	                this._filters[i] = null;
	            }
	            this._filters = new Array(cascadingCount);
	            for (var count = 0; count < cascadingCount; count++) {
	                var filter = this.context.createBiquadFilter();
	                filter.type = this._type;
	                this.frequency.connect(filter.frequency);
	                this.detune.connect(filter.detune);
	                this.Q.connect(filter.Q);
	                this.gain.connect(filter.gain);
	                this._filters[count] = filter;
	            }
	            //connect them up
	            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
	            Tone.connectSeries.apply(Tone, connectionChain);
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.Filter} this
		 */
	    Tone.Filter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        for (var i = 0; i < this._filters.length; i++) {
	            this._filters[i].disconnect();
	            this._filters[i] = null;
	        }
	        this._filters = null;
	        this._writable([
	            'detune',
	            'frequency',
	            'gain',
	            'Q'
	        ]);
	        this.frequency.dispose();
	        this.Q.dispose();
	        this.frequency = null;
	        this.Q = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.gain.dispose();
	        this.gain = null;
	        return this;
	    };
	    return Tone.Filter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Split the incoming signal into three bands (low, mid, high)
		 *         with two crossover frequency controls.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
		 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
		 */
	    Tone.MultibandSplit = function () {
	        var options = Tone.defaults(arguments, [
	            'lowFrequency',
	            'highFrequency'
	        ], Tone.MultibandSplit);
	        Tone.AudioNode.call(this);
	        /**
			 *  the input
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.input = new Tone.Gain();
	        /**
			 *  the outputs
			 *  @type {Array}
			 *  @private
			 */
	        this.output = new Array(3);
	        /**
			 *  The low band. Alias for <code>output[0]</code>
			 *  @type {Tone.Filter}
			 */
	        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  the lower filter of the mid band
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._lowMidFilter = new Tone.Filter(0, 'highpass');
	        /**
			 *  The mid band output. Alias for <code>output[1]</code>
			 *  @type {Tone.Filter}
			 */
	        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
	        /**
			 *  The high band output. Alias for <code>output[2]</code>
			 *  @type {Tone.Filter}
			 */
	        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
	        /**
			 *  The quality of all the filters
			 *  @type {Number}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q);
	        this.input.fan(this.low, this.high);
	        this.input.chain(this._lowMidFilter, this.mid);
	        //the frequency control signal
	        this.lowFrequency.connect(this.low.frequency);
	        this.lowFrequency.connect(this._lowMidFilter.frequency);
	        this.highFrequency.connect(this.mid.frequency);
	        this.highFrequency.connect(this.high.frequency);
	        //the Q value
	        this.Q.connect(this.low.Q);
	        this.Q.connect(this._lowMidFilter.Q);
	        this.Q.connect(this.mid.Q);
	        this.Q.connect(this.high.Q);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandSplit, Tone.AudioNode);
	    /**
		 *  @private
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandSplit.defaults = {
	        'lowFrequency': 400,
	        'highFrequency': 2500,
	        'Q': 1
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MultibandSplit} this
		 */
	    Tone.MultibandSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.low = null;
	        this._lowMidFilter.dispose();
	        this._lowMidFilter = null;
	        this.mid.dispose();
	        this.mid = null;
	        this.high.dispose();
	        this.high = null;
	        this.lowFrequency.dispose();
	        this.lowFrequency = null;
	        this.highFrequency.dispose();
	        this.highFrequency = null;
	        this.Q.dispose();
	        this.Q = null;
	        return this;
	    };
	    return Tone.MultibandSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
		 *         well as the low and high crossover frequencies.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *
		 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
		 *  @param {Decibels} [midLevel] The gain applied to the mid.
		 *  @param {Decibels} [highLevel] The gain applied to the high.
		 *  @example
		 * var eq = new Tone.EQ3(-10, 3, -20);
		 */
	    Tone.EQ3 = function () {
	        var options = Tone.defaults(arguments, [
	            'low',
	            'mid',
	            'high'
	        ], Tone.EQ3);
	        Tone.AudioNode.call(this);
	        /**
			 *  the output node
			 *  @type {GainNode}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  the multiband split
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._multibandSplit = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  The gain for the lower signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);
	        /**
			 *  The gain for the mid signals
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the high part
			 * @type {Tone.Gain}
			 * @private
			 */
	        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);
	        /**
			 * The gain in decibels of the low part
			 * @type {Decibels}
			 * @signal
			 */
	        this.low = this._lowGain.gain;
	        /**
			 * The gain in decibels of the mid part
			 * @type {Decibels}
			 * @signal
			 */
	        this.mid = this._midGain.gain;
	        /**
			 * The gain in decibels of the high part
			 * @type {Decibels}
			 * @signal
			 */
	        this.high = this._highGain.gain;
	        /**
			 *  The Q value for all of the filters.
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = this._multibandSplit.Q;
	        /**
			 *  The low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._multibandSplit.lowFrequency;
	        /**
			 *  The mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._multibandSplit.highFrequency;
	        //the frequency bands
	        this._multibandSplit.low.chain(this._lowGain, this.output);
	        this._multibandSplit.mid.chain(this._midGain, this.output);
	        this._multibandSplit.high.chain(this._highGain, this.output);
	        this._readOnly([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	    };
	    Tone.extend(Tone.EQ3, Tone.AudioNode);
	    /**
		 *  the default values
		 */
	    Tone.EQ3.defaults = {
	        'low': 0,
	        'mid': 0,
	        'high': 0,
	        'lowFrequency': 400,
	        'highFrequency': 2500
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.EQ3} this
		 */
	    Tone.EQ3.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'low',
	            'mid',
	            'high',
	            'lowFrequency',
	            'highFrequency'
	        ]);
	        this._multibandSplit.dispose();
	        this._multibandSplit = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        this._lowGain.dispose();
	        this._lowGain = null;
	        this._midGain.dispose();
	        this._midGain = null;
	        this._highGain.dispose();
	        this._highGain = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.EQ3;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Performs a linear scaling on an input signal.
		 *          Scales a NormalRange input to between
		 *          outputMin and outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @example
		 * var scale = new Tone.Scale(50, 100);
		 * var signal = new Tone.Signal(0.5).connect(scale);
		 * //the output of scale equals 75
		 */
	    Tone.Scale = function (outputMin, outputMax) {
	        Tone.SignalBase.call(this);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMin = Tone.defaultArg(outputMin, 0);
	        /** 
			 *  @private
			 *  @type {number}
			 */
	        this._outputMax = Tone.defaultArg(outputMax, 1);
	        /** 
			 *  @private
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.input = new Tone.Multiply(1);
	        /** 
			 *  @private
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._add = this.output = new Tone.Add(0);
	        this._scale.connect(this._add);
	        this._setRange();
	    };
	    Tone.extend(Tone.Scale, Tone.SignalBase);
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'min', {
	        get: function () {
	            return this._outputMin;
	        },
	        set: function (min) {
	            this._outputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.Scale#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Scale.prototype, 'max', {
	        get: function () {
	            return this._outputMax;
	        },
	        set: function (max) {
	            this._outputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Scale.prototype._setRange = function () {
	        this._add.value = this._outputMin;
	        this._scale.value = this._outputMax - this._outputMin;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Scale} this
		 */
	    Tone.Scale.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._add.dispose();
	        this._add = null;
	        this._scale.dispose();
	        this._scale = null;
	        return this;
	    };
	    return Tone.Scale;
	});
	Module(function (Tone) {
	    /**
		 *  @class  Performs an exponential scaling on an input signal.
		 *          Scales a NormalRange value [0,1] exponentially
		 *          to the output range of outputMin to outputMax.
		 *
		 *  @constructor
		 *  @extends {Tone.SignalBase}
		 *  @param {number} [outputMin=0] The output value when the input is 0. 
		 *  @param {number} [outputMax=1]	The output value when the input is 1. 
		 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
		 *  @example
		 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
		 * var signal = new Tone.Signal(0.5).connect(scaleExp);
		 */
	    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
	        Tone.SignalBase.call(this);
	        /**
			 *  scale the input to the output range
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
	        /**
			 *  @private
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.input = new Tone.Pow(Tone.defaultArg(exponent, 2));
	        this._exp.connect(this._scale);
	    };
	    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
	    /**
		 * Instead of interpolating linearly between the <code>min</code> and 
		 * <code>max</code> values, setting the exponent will interpolate between
		 * the two values with an exponential curve. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 * The minimum output value. This number is output when 
		 * the value input value is 0. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The maximum output value. This number is output when 
		 * the value input value is 1. 
		 * @memberOf Tone.ScaleExp#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.ScaleExp} this
		 */
	    Tone.ScaleExp.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaleExp;
	});
	Module(function (Tone) {
	    
	    /**
		 *  createDelay shim
		 *  @private
		 */
	    if (window.DelayNode && !AudioContext.prototype.createDelay) {
	        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
	    }
	    /**
		 *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).
		 *  @extends {Tone}
		 *  @param {Time=} delayTime The delay applied to the incoming signal.
		 *  @param {Time=} maxDelay The maximum delay time.
		 */
	    Tone.Delay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'maxDelay'
	        ], Tone.Delay);
	        Tone.AudioNode.call(this);
	        /**
			 *  The native delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));
	        /**
			 *  The amount of time the incoming signal is
			 *  delayed.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Param({
	            'param': this._delayNode.delayTime,
	            'units': Tone.Type.Time,
	            'value': options.delayTime
	        });
	        this._readOnly('delayTime');
	    };
	    Tone.extend(Tone.Delay, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Delay.defaults = {
	        'maxDelay': 1,
	        'delayTime': 0
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Delay}  this
		 */
	    Tone.Delay.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._delayNode.disconnect();
	        this._delayNode = null;
	        this._writable('delayTime');
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.Delay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Comb filters are basic building blocks for physical modeling. Read more
		 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the filter.
		 *  @param {NormalRange=} resonance The amount of feedback the filter has.
		 */
	    Tone.FeedbackCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance'
	        ], Tone.FeedbackCombFilter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the feedback node
			 *  @type {GainNode}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        this._delay.chain(this._feedback, this._delay);
	        this._readOnly([
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.FeedbackCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.FeedbackCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackCombFilter} this
		 */
	    Tone.FeedbackCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'resonance',
	            'delayTime'
	        ]);
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._feedback.dispose();
	        this._feedback = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.FeedbackCombFilter;
	});
	Module(function (Tone) {
	    /**
		 *  @class  Get the current waveform data of the connected audio source.
		 *  @extends {Tone.AudioNode}
		 *  @param {Number=} size The size of the FFT. Value must be a power of
		 *                       two in the range 32 to 32768.
		 */
	    Tone.FFT = function () {
	        var options = Tone.defaults(arguments, ['size'], Tone.FFT);
	        options.type = Tone.Analyser.Type.FFT;
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node.
			 *  @private
			 *  @type {Tone.Analyser}
			 */
	        this._analyser = this.input = this.output = new Tone.Analyser(options);
	    };
	    Tone.extend(Tone.FFT, Tone.AudioNode);
	    /**
		 *  The default values.
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FFT.defaults = { 'size': 1024 };
	    /**
		 *  Gets the waveform of the audio source. Returns the waveform data
		 *  of length [size](#size) as a Float32Array with values between -1 and 1.
		 *  @returns {TypedArray}
		 */
	    Tone.FFT.prototype.getValue = function () {
	        return this._analyser.getValue();
	    };
	    /**
		 *  The size of analysis. This must be a power of two in the range 32 to 32768.
		 *  @memberOf Tone.FFT#
		 *  @type {Number}
		 *  @name size
		 */
	    Object.defineProperty(Tone.FFT.prototype, 'size', {
	        get: function () {
	            return this._analyser.size;
	        },
	        set: function (size) {
	            this._analyser.size = size;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.FFT}  this
		 */
	    Tone.FFT.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.dispose();
	        this._analyser = null;
	    };
	    return Tone.FFT;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Follower is a  crude envelope follower which will follow
		 *          the amplitude of an incoming signal.
		 *          Take care with small (< 0.02) attack or decay values
		 *          as follower has some ripple which is exaggerated
		 *          at these values. Read more about envelope followers (also known
		 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Time|Object} [attack] The rate at which the follower rises.
		 *  @param {Time=} release The rate at which the folower falls.
		 *  @example
		 * var follower = new Tone.Follower(0.2, 0.4);
		 */
	    Tone.Follower = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'release'
	        ], Tone.Follower);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Abs}
			 *  @private
			 */
	        this._abs = new Tone.Abs();
	        /**
			 *  the lowpass filter which smooths the input
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._filter = this.context.createBiquadFilter();
	        this._filter.type = 'lowpass';
	        this._filter.frequency.value = 0;
	        this._filter.Q.value = -100;
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._frequencyValues = new Tone.WaveShaper();
	        /**
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._sub = new Tone.Subtract();
	        /**
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delay = new Tone.Delay(this.blockTime);
	        /**
			 *  this keeps it far from 0, even for very small differences
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._mult = new Tone.Multiply(10000);
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._attack = options.attack;
	        /**
			 *  @private
			 *  @type {number}
			 */
	        this._release = options.release;
	        //the smoothed signal to get the values
	        this.input.chain(this._abs, this._filter, this.output);
	        //the difference path
	        this._abs.connect(this._sub, 0, 1);
	        this._filter.chain(this._delay, this._sub);
	        //threshold the difference and use the thresh to set the frequency
	        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
	        //set the attack and release values in the table
	        this._setAttackRelease(this._attack, this._release);
	    };
	    Tone.extend(Tone.Follower, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Follower.defaults = {
	        'attack': 0.05,
	        'release': 0.5
	    };
	    /**
		 *  sets the attack and release times in the wave shaper
		 *  @param   {Time} attack
		 *  @param   {Time} release
		 *  @private
		 */
	    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
	        var minTime = this.blockTime;
	        attack = Tone.Time(attack).toFrequency();
	        release = Tone.Time(release).toFrequency();
	        attack = Math.max(attack, minTime);
	        release = Math.max(release, minTime);
	        this._frequencyValues.setMap(function (val) {
	            if (val <= 0) {
	                return attack;
	            } else {
	                return release;
	            }
	        });
	    };
	    /**
		 * The attack time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'attack', {
	        get: function () {
	            return this._attack;
	        },
	        set: function (attack) {
	            this._attack = attack;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 * The release time.
		 * @memberOf Tone.Follower#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Follower.prototype, 'release', {
	        get: function () {
	            return this._release;
	        },
	        set: function (release) {
	            this._release = release;
	            this._setAttackRelease(this._attack, this._release);
	        }
	    });
	    /**
		 *  Borrows the connect method from Signal so that the output can be used
		 *  as a Tone.Signal control signal.
		 *  @function
		 */
	    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
	    /**
		 *  dispose
		 *  @returns {Tone.Follower} this
		 */
	    Tone.Follower.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._filter.disconnect();
	        this._filter = null;
	        this._frequencyValues.disconnect();
	        this._frequencyValues = null;
	        this._delay.dispose();
	        this._delay = null;
	        this._sub.disconnect();
	        this._sub = null;
	        this._abs.dispose();
	        this._abs = null;
	        this._mult.dispose();
	        this._mult = null;
	        this._curve = null;
	        return this;
	    };
	    return Tone.Follower;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
		 *         to any range. It's useful for applying an envelope 
		 *         to a frequency or any other non-NormalRange signal 
		 *         parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var scaledEnv = new Tone.ScaledEnvelope({
		 *  	"attack" : 0.2,
		 *  	"min" : 200,
		 *  	"max" : 2000
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.ScaledEnvelope = function () {
	        //get all of the defaults
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.Envelope.call(this, options);
	        options = Tone.defaultArg(options, Tone.ScaledEnvelope.defaults);
	        /** 
			 *  scale the incoming signal by an exponent
			 *  @type {Tone.Pow}
			 *  @private
			 */
	        this._exp = this.output = new Tone.Pow(options.exponent);
	        /**
			 *  scale the signal to the desired range
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = this.output = new Tone.Scale(options.min, options.max);
	        this._sig.chain(this._exp, this._scale);
	    };
	    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.ScaledEnvelope.defaults = {
	        'min': 0,
	        'max': 1,
	        'exponent': 1
	    };
	    /**
		 * The envelope's min output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = min;
	        }
	    });
	    /**
		 * The envelope's max output value. In other words, the value
		 * at the peak of the attack portion of the envelope. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
	        get: function () {
	            return this._scale.max;
	        },
	        set: function (max) {
	            this._scale.max = max;
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.ScaledEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.ScaledEnvelope} this
		 */
	    Tone.ScaledEnvelope.prototype.dispose = function () {
	        Tone.Envelope.prototype.dispose.call(this);
	        this._scale.dispose();
	        this._scale = null;
	        this._exp.dispose();
	        this._exp = null;
	        return this;
	    };
	    return Tone.ScaledEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`
		 *         it's got a `baseFrequency` and `octaves` parameter. 
		 *
		 *  @extends {Tone.Envelope}
		 *  @constructor
		 *  @param {Time|Object} [attack]	the attack time in seconds
		 *  @param {Time} [decay]	the decay time in seconds
		 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
		 *  @param {Time} [release]	the release time in seconds
		 *  @example
		 *  var env = new Tone.FrequencyEnvelope({
		 *  	"attack" : 0.2,
		 *  	"baseFrequency" : "C2",
		 *  	"octaves" : 4
		 *  });
		 *  scaledEnv.connect(oscillator.frequency);
		 */
	    Tone.FrequencyEnvelope = function () {
	        var options = Tone.defaults(arguments, [
	            'attack',
	            'decay',
	            'sustain',
	            'release'
	        ], Tone.Envelope);
	        Tone.ScaledEnvelope.call(this, options);
	        //merge it with the frequency envelope defaults
	        options = Tone.defaultArg(options, Tone.FrequencyEnvelope.defaults);
	        /**
			 *  Stores the octave value
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        //setup
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);
	    /**
		 *  the default parameters
		 *  @static
		 */
	    Tone.FrequencyEnvelope.defaults = {
	        'baseFrequency': 200,
	        'octaves': 4,
	        'exponent': 2
	    };
	    /**
		 * The envelope's mininum output value. This is the value which it
		 * starts at. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {
	        get: function () {
	            return this._scale.min;
	        },
	        set: function (min) {
	            this._scale.min = this.toFrequency(min);
	            //also update the octaves
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The number of octaves above the baseFrequency that the
		 * envelope will scale to.
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._scale.max = this.baseFrequency * Math.pow(2, octaves);
	        }
	    });
	    /**
		 * The envelope's exponent value. 
		 * @memberOf Tone.FrequencyEnvelope#
		 * @type {number}
		 * @name exponent
		 */
	    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {
	        get: function () {
	            return this._exp.value;
	        },
	        set: function (exp) {
	            this._exp.value = exp;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.FrequencyEnvelope} this
		 */
	    Tone.FrequencyEnvelope.prototype.dispose = function () {
	        Tone.ScaledEnvelope.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.FrequencyEnvelope;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Gate only passes a signal through when the incoming
		 *          signal exceeds a specified threshold. To do this, Gate uses
		 *          a Tone.Follower to follow the amplitude of the incoming signal.
		 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open.
		 *  @param {Time=} attack The follower's attack time
		 *  @param {Time=} release The follower's release time
		 *  @example
		 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
		 * var mic = new Tone.UserMedia().connect(gate);
		 * //the gate will only pass through the incoming
		 * //signal when it's louder than -30db
		 */
	    Tone.Gate = function () {
	        var options = Tone.defaults(arguments, [
	            'threshold',
	            'attack',
	            'release'
	        ], Tone.Gate);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this._follower = new Tone.Follower(options.attack, options.release);
	        /**
			 *  @type {Tone.GreaterThan}
			 *  @private
			 */
	        this._gt = new Tone.GreaterThan(Tone.dbToGain(options.threshold));
	        //the connections
	        this.input.connect(this.output);
	        //the control signal
	        this.input.chain(this._gt, this._follower, this.output.gain);
	    };
	    Tone.extend(Tone.Gate, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Gate.defaults = {
	        'attack': 0.1,
	        'release': 0.1,
	        'threshold': -40
	    };
	    /**
		 * The threshold of the gate in decibels
		 * @memberOf Tone.Gate#
		 * @type {Decibels}
		 * @name threshold
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
	        get: function () {
	            return Tone.gainToDb(this._gt.value);
	        },
	        set: function (thresh) {
	            this._gt.value = Tone.dbToGain(thresh);
	        }
	    });
	    /**
		 * The attack speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name attack
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'attack', {
	        get: function () {
	            return this._follower.attack;
	        },
	        set: function (attackTime) {
	            this._follower.attack = attackTime;
	        }
	    });
	    /**
		 * The release speed of the gate
		 * @memberOf Tone.Gate#
		 * @type {Time}
		 * @name release
		 */
	    Object.defineProperty(Tone.Gate.prototype, 'release', {
	        get: function () {
	            return this._follower.release;
	        },
	        set: function (releaseTime) {
	            this._follower.release = releaseTime;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Gate} this
		 */
	    Tone.Gate.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._follower.dispose();
	        this._gt.dispose();
	        this._follower = null;
	        this._gt = null;
	        return this;
	    };
	    return Tone.Gate;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TickSignal extends Tone.TimelineSignal, but adds the capability
		 *        to calculate the number of elapsed ticks. exponential and target curves
		 *        are approximated with multiple linear ramps.
		 *
		 *        Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos, for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
		 *        describing integrating timing functions for tempo calculations.
		 *
		 * @param {Number} value The initial value of the signal
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TickSignal = function (value) {
	        value = Tone.defaultArg(value, 1);
	        Tone.TimelineSignal.call(this, {
	            'units': Tone.Type.Ticks,
	            'value': value
	        });
	        //extend the memory
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TickSignal, Tone.TimelineSignal);
	    /**
		 * Wraps Tone.TimelineSignal methods so that they also
		 * record the ticks.
		 * @param  {Function} method
		 * @return {Function}
		 * @private
		 */
	    function _wrapScheduleMethods(method) {
	        return function (value, time) {
	            time = this.toSeconds(time);
	            method.apply(this, arguments);
	            var event = this._events.get(time);
	            var previousEvent = this._events.previousEvent(event);
	            var ticksUntilTime = this._getTickUntilEvent(previousEvent, time - this.sampleTime);
	            event.ticks = Math.max(ticksUntilTime, 0);
	            return this;
	        };
	    }
	    Tone.TickSignal.prototype.setValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.setValueAtTime);
	    Tone.TickSignal.prototype.linearRampToValueAtTime = _wrapScheduleMethods(Tone.TimelineSignal.prototype.linearRampToValueAtTime);
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {Time} startTime
		 *  @param {number} timeConstant
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.setTargetAtTime = function (value, time, constant) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        this.setRampPoint(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        var segments = 5;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = constant * i + time;
	            var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, value, constant, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 *  Schedules an exponential continuous change in parameter value from
		 *  the previous scheduled parameter value to the given value.
		 *  @param  {number} value
		 *  @param  {Time} endTime
		 *  @returns {Tone.TickSignal} this
		 */
	    Tone.TickSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        //aproximate it with multiple linear ramps
	        time = this.toSeconds(time);
	        value = this._fromUnits(value);
	        //start from previously scheduled value
	        var prevEvent = this._events.get(time);
	        if (prevEvent === null) {
	            prevEvent = {
	                'value': this._initial,
	                'time': 0
	            };
	        }
	        var segments = 5;
	        var segmentDur = (time - prevEvent.time) / segments;
	        for (var i = 0; i <= segments; i++) {
	            var segTime = segmentDur * i + prevEvent.time;
	            var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, value, segTime);
	            this.linearRampToValueAtTime(this._toUnits(rampVal), segTime);
	        }
	        return this;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @private
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype._getTickUntilEvent = function (event, time) {
	        if (event === null) {
	            event = {
	                'ticks': 0,
	                'time': 0
	            };
	        }
	        var val0 = this.getValueAtTime(event.time);
	        var val1 = this.getValueAtTime(time);
	        return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;
	    };
	    /**
		 * Returns the tick value at the time. Takes into account
		 * any automation curves scheduled on the signal.
		 * @param  {Time} time The time to get the tick count at
		 * @return {Ticks}      The number of ticks which have elapsed at the time
		 *                          given any automations.
		 */
	    Tone.TickSignal.prototype.getTickAtTime = function (time) {
	        time = this.toSeconds(time);
	        var event = this._events.get(time);
	        return this._getTickUntilEvent(event, time);
	    };
	    /**
		 * Return the elapsed time of the number of ticks from the given time
		 * @param {Ticks} ticks The number of ticks to calculate
		 * @param  {Time} time The time to get the next tick from
		 * @return {Seconds} The duration of the number of ticks from the given time in seconds
		 */
	    Tone.TickSignal.prototype.getDurationOfTicks = function (ticks, time) {
	        time = this.toSeconds(time);
	        var currentTick = this.getTickAtTime(time);
	        return this.getTimeOfTick(currentTick + ticks) - time;
	    };
	    /**
		 * Given a tick, returns the time that tick occurs at.
		 * @param  {Ticks} tick
		 * @return {Time}      The time that the tick occurs.
		 */
	    Tone.TickSignal.prototype.getTimeOfTick = function (tick) {
	        var before = this._events.get(tick, 'ticks');
	        var after = this._events.getAfter(tick, 'ticks');
	        if (before && before.ticks === tick) {
	            return before.time;
	        } else if (before && after && after.type === Tone.TimelineSignal.Type.Linear && before.value !== after.value) {
	            var val0 = this.getValueAtTime(before.time);
	            var val1 = this.getValueAtTime(after.time);
	            var delta = (val1 - val0) / (after.time - before.time);
	            var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));
	            var sol1 = (-val0 + k) / delta;
	            var sol2 = (-val0 - k) / delta;
	            return (sol1 > 0 ? sol1 : sol2) + before.time;
	        } else if (before) {
	            if (before.value === 0) {
	                return Infinity;
	            } else {
	                return before.time + (tick - before.ticks) / before.value;
	            }
	        } else {
	            return tick / this._initial;
	        }
	    };
	    return Tone.TickSignal;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A Timeline State. Provides the methods: <code>setStateAtTime("state", time)</code>
		 *          and <code>getValueAtTime(time)</code>.
		 *
		 *  @extends {Tone.Timeline}
		 *  @param {String} initial The initial state of the TimelineState. 
		 *                          Defaults to <code>undefined</code>
		 */
	    Tone.TimelineState = function (initial) {
	        Tone.Timeline.call(this);
	        /**
			 *  The initial state
			 *  @private
			 *  @type {String}
			 */
	        this._initial = initial;
	    };
	    Tone.extend(Tone.TimelineState, Tone.Timeline);
	    /**
		 *  Returns the scheduled state scheduled before or at
		 *  the given time.
		 *  @param  {Number}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 */
	    Tone.TimelineState.prototype.getValueAtTime = function (time) {
	        var event = this.get(time);
	        if (event !== null) {
	            return event.state;
	        } else {
	            return this._initial;
	        }
	    };
	    /**
		 *  Add a state to the timeline.
		 *  @param  {String}  state The name of the state to set.
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.TimelineState} this
		 */
	    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {
	        this.add({
	            'state': state,
	            'time': time
	        });
	        return this;
	    };
	    return Tone.TimelineState;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A sample accurate clock which provides a callback at the given rate. 
		 *          While the callback is not sample-accurate (it is still susceptible to
		 *          loose JS timing), the time passed in as the argument to the callback
		 *          is precise. For most applications, it is better to use Tone.Transport
		 *          instead of the Clock by itself since you can synchronize multiple callbacks.
		 *
		 * 	@constructor
		 *  @extends {Tone.Emitter}
		 * 	@param {function} callback The callback to be invoked with the time of the audio event
		 * 	@param {Frequency} frequency The rate of the callback
		 * 	@example
		 * //the callback will be invoked approximately once a second
		 * //and will print the time exactly once a second apart.
		 * var clock = new Tone.Clock(function(time){
		 * 	console.log(time);
		 * }, 1);
		 */
	    Tone.Clock = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'frequency'
	        ], Tone.Clock);
	        Tone.Emitter.call(this);
	        /**
			 *  The callback function to invoke at the scheduled tick.
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The next time the callback is scheduled.
			 *  @type {Number}
			 *  @private
			 */
	        this._nextTick = 0;
	        /**
			 *  The last state of the clock.
			 *  @type  {State}
			 *  @private
			 */
	        this._lastState = Tone.State.Stopped;
	        /**
			 *  The rate the callback function should be invoked. 
			 *  @type  {BPM}
			 *  @signal
			 */
	        this.frequency = new Tone.TickSignal(options.frequency, Tone.Type.Frequency);
	        this._readOnly('frequency');
	        /**
			 *  The number of times the callback was invoked. Starts counting at 0
			 *  and increments after the callback was invoked. 
			 *  @type {Ticks}
			 *  @readOnly
			 */
	        this.ticks = 0;
	        /**
			 *  The state timeline
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The loop function bound to its context. 
			 *  This is necessary to remove the event in the end.
			 *  @type {Function}
			 *  @private
			 */
	        this._boundLoop = this._loop.bind(this);
	        //bind a callback to the worker thread
	        this.context.on('tick', this._boundLoop);
	    };
	    Tone.extend(Tone.Clock, Tone.Emitter);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Clock.defaults = {
	        'callback': Tone.noOp,
	        'frequency': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped" or "paused".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Clock#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Clock.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the clock at the given time. Optionally pass in an offset
		 *  of where to start the tick counter from.
		 *  @param  {Time=}  time    The time the clock should start
		 *  @param  {Ticks=}  offset  Where the tick counter starts counting from.
		 *  @return  {Tone.Clock}  this
		 */
	    Tone.Clock.prototype.start = function (time, offset) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) !== Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Started, time);
	            this._state.get(time).offset = offset;
	        }
	        return this;
	    };
	    /**
		 *  Stop the clock. Stopping the clock resets the tick counter to 0.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 *  @example
		 * clock.stop();
		 */
	    Tone.Clock.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        return this;
	    };
	    /**
		 *  Pause the clock. Pausing does not reset the tick counter.
		 *  @param {Time} [time=now] The time when the clock should stop.
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.pause = function (time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Paused, time);
	        }
	        return this;
	    };
	    /**
		 *  The scheduling loop.
		 *  @private
		 */
	    Tone.Clock.prototype._loop = function () {
	        //the end of the update interval
	        var endTime = this.now() + this.context.updateInterval;
	        //the current event at the time of the loop
	        var event = this._state.get(endTime);
	        if (event) {
	            //state change events
	            if (event.state !== this._lastState) {
	                this._lastState = event.state;
	                switch (event.state) {
	                case Tone.State.Started:
	                    if (!Tone.isUndef(event.offset)) {
	                        this.ticks = event.offset;
	                    }
	                    this._nextTick = event.time;
	                    this.emit('start', event.time, this.ticks);
	                    break;
	                case Tone.State.Stopped:
	                    this.ticks = 0;
	                    this.emit('stop', event.time);
	                    break;
	                case Tone.State.Paused:
	                    this.emit('pause', event.time);
	                    break;
	                }
	            }
	            //all the tick events
	            while (endTime > this._nextTick && this._state) {
	                var tickTime = this._nextTick;
	                if (this.frequency) {
	                    this._nextTick += this.frequency.getDurationOfTicks(1, this._nextTick);
	                    if (event.state === Tone.State.Started) {
	                        try {
	                            this.callback(tickTime);
	                            this.ticks++;
	                        } catch (e) {
	                            this.ticks++;
	                            throw e;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
		 *  Returns the scheduled state at the given time.
		 *  @param  {Time}  time  The time to query.
		 *  @return  {String}  The name of the state input in setStateAtTime.
		 *  @example
		 * clock.start("+0.1");
		 * clock.getStateAtTime("+0.1"); //returns "started"
		 */
	    Tone.Clock.prototype.getStateAtTime = function (time) {
	        time = this.toSeconds(time);
	        return this._state.getValueAtTime(time);
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.Clock} this
		 */
	    Tone.Clock.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this.context.off('tick', this._boundLoop);
	        this._writable('frequency');
	        this.frequency.dispose();
	        this.frequency = null;
	        this._boundLoop = null;
	        this._nextTick = Infinity;
	        this.callback = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Clock;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Similar to Tone.Timeline, but all events represent
		 *         intervals with both "time" and "duration" times. The 
		 *         events are placed in a tree structure optimized
		 *         for querying an intersection point with the timeline
		 *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)
		 *         to represent the data.
		 *  @extends {Tone}
		 */
	    Tone.IntervalTimeline = function () {
	        Tone.call(this);
	        /**
			 *  The root node of the inteval tree
			 *  @type  {IntervalNode}
			 *  @private
			 */
	        this._root = null;
	        /**
			 *  Keep track of the length of the timeline.
			 *  @type  {Number}
			 *  @private
			 */
	        this._length = 0;
	    };
	    Tone.extend(Tone.IntervalTimeline);
	    /**
		 *  The event to add to the timeline. All events must 
		 *  have a time and duration value
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.add = function (event) {
	        if (Tone.isUndef(event.time) || Tone.isUndef(event.duration)) {
	            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');
	        }
	        var node = new IntervalNode(event.time, event.time + event.duration, event);
	        if (this._root === null) {
	            this._root = node;
	        } else {
	            this._root.insert(node);
	        }
	        this._length++;
	        // Restructure tree to be balanced
	        while (node !== null) {
	            node.updateHeight();
	            node.updateMax();
	            this._rebalance(node);
	            node = node.parent;
	        }
	        return this;
	    };
	    /**
		 *  Remove an event from the timeline.
		 *  @param  {Object}  event  The event to remove from the timeline
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.remove = function (event) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(event.time, results);
	            for (var i = 0; i < results.length; i++) {
	                var node = results[i];
	                if (node.event === event) {
	                    this._removeNode(node);
	                    this._length--;
	                    break;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  The number of items in the timeline.
		 *  @type {Number}
		 *  @memberOf Tone.IntervalTimeline#
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {
	        get: function () {
	            return this._length;
	        }
	    });
	    /**
		 *  Remove events whose time time is after the given time
		 *  @param  {Number}  time  The time to query.
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.cancel = function (after) {
	        this.forEachAfter(after, function (event) {
	            this.remove(event);
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Set the root node as the given node
		 *  @param {IntervalNode} node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._setRoot = function (node) {
	        this._root = node;
	        if (this._root !== null) {
	            this._root.parent = null;
	        }
	    };
	    /**
		 *  Replace the references to the node in the node's parent
		 *  with the replacement node.
		 *  @param  {IntervalNode}  node        
		 *  @param  {IntervalNode}  replacement 
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {
	        if (node.parent !== null) {
	            if (node.isLeftChild()) {
	                node.parent.left = replacement;
	            } else {
	                node.parent.right = replacement;
	            }
	            this._rebalance(node.parent);
	        } else {
	            this._setRoot(replacement);
	        }
	    };
	    /**
		 *  Remove the node from the tree and replace it with 
		 *  a successor which follows the schema.
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._removeNode = function (node) {
	        if (node.left === null && node.right === null) {
	            this._replaceNodeInParent(node, null);
	        } else if (node.right === null) {
	            this._replaceNodeInParent(node, node.left);
	        } else if (node.left === null) {
	            this._replaceNodeInParent(node, node.right);
	        } else {
	            var balance = node.getBalance();
	            var replacement, temp;
	            if (balance > 0) {
	                if (node.left.right === null) {
	                    replacement = node.left;
	                    replacement.right = node.right;
	                    temp = replacement;
	                } else {
	                    replacement = node.left.right;
	                    while (replacement.right !== null) {
	                        replacement = replacement.right;
	                    }
	                    replacement.parent.right = replacement.left;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            } else {
	                if (node.right.left === null) {
	                    replacement = node.right;
	                    replacement.left = node.left;
	                    temp = replacement;
	                } else {
	                    replacement = node.right.left;
	                    while (replacement.left !== null) {
	                        replacement = replacement.left;
	                    }
	                    replacement.parent = replacement.parent;
	                    replacement.parent.left = replacement.right;
	                    temp = replacement.parent;
	                    replacement.left = node.left;
	                    replacement.right = node.right;
	                }
	            }
	            if (node.parent !== null) {
	                if (node.isLeftChild()) {
	                    node.parent.left = replacement;
	                } else {
	                    node.parent.right = replacement;
	                }
	            } else {
	                this._setRoot(replacement);
	            }
	            // this._replaceNodeInParent(node, replacement);
	            this._rebalance(temp);
	        }
	        node.dispose();
	    };
	    /**
		 *  Rotate the tree to the left
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.right the new root of this sub tree (instead of node)
	        var pivotNode = node.right;
	        node.right = pivotNode.left;
	        pivotNode.left = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Rotate the tree to the right
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rotateRight = function (node) {
	        var parent = node.parent;
	        var isLeftChild = node.isLeftChild();
	        // Make node.left the new root of this sub tree (instead of node)
	        var pivotNode = node.left;
	        node.left = pivotNode.right;
	        pivotNode.right = node;
	        if (parent !== null) {
	            if (isLeftChild) {
	                parent.left = pivotNode;
	            } else {
	                parent.right = pivotNode;
	            }
	        } else {
	            this._setRoot(pivotNode);
	        }
	    };
	    /**
		 *  Balance the BST
		 *  @param  {IntervalNode}  node
		 *  @private
		 */
	    Tone.IntervalTimeline.prototype._rebalance = function (node) {
	        var balance = node.getBalance();
	        if (balance > 1) {
	            if (node.left.getBalance() < 0) {
	                this._rotateLeft(node.left);
	            } else {
	                this._rotateRight(node);
	            }
	        } else if (balance < -1) {
	            if (node.right.getBalance() > 0) {
	                this._rotateRight(node.right);
	            } else {
	                this._rotateLeft(node);
	            }
	        }
	    };
	    /**
		 *  Get an event whose time and duration span the give time. Will
		 *  return the match whose "time" value is closest to the given time.
		 *  @param  {Object}  event  The event to add to the timeline
		 *  @return  {Object}  The event which spans the desired time
		 */
	    Tone.IntervalTimeline.prototype.get = function (time) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            if (results.length > 0) {
	                var max = results[0];
	                for (var i = 1; i < results.length; i++) {
	                    if (results[i].low > max.low) {
	                        max = results[i];
	                    }
	                }
	                return max.event;
	            }
	        }
	        return null;
	    };
	    /**
		 *  Iterate over everything in the timeline.
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEach = function (callback) {
	        if (this._root !== null) {
	            var allNodes = [];
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	            for (var i = 0; i < allNodes.length; i++) {
	                var ev = allNodes[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the given time
		 *  overlaps with the time and duration time of the event.
		 *  @param  {Number}  time The time to check if items are overlapping
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.search(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                if (ev) {
	                    callback(ev);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Iterate over everything in the array in which the time is greater
		 *  than the given time.
		 *  @param  {Number}  time The time to check if items are before
		 *  @param  {Function}  callback The callback to invoke with every item
		 *  @returns {Tone.IntervalTimeline} this
		 */
	    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {
	        if (this._root !== null) {
	            var results = [];
	            this._root.searchAfter(time, results);
	            for (var i = results.length - 1; i >= 0; i--) {
	                var ev = results[i].event;
	                callback(ev);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.IntervalTimeline}  this
		 */
	    Tone.IntervalTimeline.prototype.dispose = function () {
	        var allNodes = [];
	        if (this._root !== null) {
	            this._root.traverse(function (node) {
	                allNodes.push(node);
	            });
	        }
	        for (var i = 0; i < allNodes.length; i++) {
	            allNodes[i].dispose();
	        }
	        allNodes = null;
	        this._root = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Represents a node in the binary search tree, with the addition
		 *  of a "high" value which keeps track of the highest value of
		 *  its children. 
		 *  References: 
		 *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/
		 *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf
		 *  @param {Number} low
		 *  @param {Number} high
		 *  @private
		 */
	    var IntervalNode = function (low, high, event) {
	        //the event container
	        this.event = event;
	        //the low value
	        this.low = low;
	        //the high value
	        this.high = high;
	        //the high value for this and all child nodes
	        this.max = this.high;
	        //the nodes to the left
	        this._left = null;
	        //the nodes to the right
	        this._right = null;
	        //the parent node
	        this.parent = null;
	        //the number of child nodes
	        this.height = 0;
	    };
	    /** 
		 *  Insert a node into the correct spot in the tree
		 *  @param  {IntervalNode}  node
		 */
	    IntervalNode.prototype.insert = function (node) {
	        if (node.low <= this.low) {
	            if (this.left === null) {
	                this.left = node;
	            } else {
	                this.left.insert(node);
	            }
	        } else {
	            if (this.right === null) {
	                this.right = node;
	            } else {
	                this.right.insert(node);
	            }
	        }
	    };
	    /**
		 *  Search the tree for nodes which overlap 
		 *  with the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.search = function (point, results) {
	        // If p is to the right of the rightmost point of any interval
	        // in this node and all children, there won't be any matches.
	        if (point > this.max) {
	            return;
	        }
	        // Search left children
	        if (this.left !== null) {
	            this.left.search(point, results);
	        }
	        // Check this node
	        if (this.low <= point && this.high > point) {
	            results.push(this);
	        }
	        // If p is to the left of the time of this interval,
	        // then it can't be in any child to the right.
	        if (this.low > point) {
	            return;
	        }
	        // Search right children
	        if (this.right !== null) {
	            this.right.search(point, results);
	        }
	    };
	    /**
		 *  Search the tree for nodes which are less 
		 *  than the given point
		 *  @param  {Number}  point  The point to query
		 *  @param  {Array}  results  The array to put the results
		 */
	    IntervalNode.prototype.searchAfter = function (point, results) {
	        // Check this node
	        if (this.low >= point) {
	            results.push(this);
	            if (this.left !== null) {
	                this.left.searchAfter(point, results);
	            }
	        }
	        // search the right side
	        if (this.right !== null) {
	            this.right.searchAfter(point, results);
	        }
	    };
	    /**
		 *  Invoke the callback on this element and both it's branches
		 *  @param  {Function}  callback
		 */
	    IntervalNode.prototype.traverse = function (callback) {
	        callback(this);
	        if (this.left !== null) {
	            this.left.traverse(callback);
	        }
	        if (this.right !== null) {
	            this.right.traverse(callback);
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateHeight = function () {
	        if (this.left !== null && this.right !== null) {
	            this.height = Math.max(this.left.height, this.right.height) + 1;
	        } else if (this.right !== null) {
	            this.height = this.right.height + 1;
	        } else if (this.left !== null) {
	            this.height = this.left.height + 1;
	        } else {
	            this.height = 0;
	        }
	    };
	    /**
		 *  Update the height of the node
		 */
	    IntervalNode.prototype.updateMax = function () {
	        this.max = this.high;
	        if (this.left !== null) {
	            this.max = Math.max(this.max, this.left.max);
	        }
	        if (this.right !== null) {
	            this.max = Math.max(this.max, this.right.max);
	        }
	    };
	    /**
		 *  The balance is how the leafs are distributed on the node
		 *  @return  {Number}  Negative numbers are balanced to the right
		 */
	    IntervalNode.prototype.getBalance = function () {
	        var balance = 0;
	        if (this.left !== null && this.right !== null) {
	            balance = this.left.height - this.right.height;
	        } else if (this.left !== null) {
	            balance = this.left.height + 1;
	        } else if (this.right !== null) {
	            balance = -(this.right.height + 1);
	        }
	        return balance;
	    };
	    /**
		 *  @returns {Boolean} true if this node is the left child
		 *  of its parent
		 */
	    IntervalNode.prototype.isLeftChild = function () {
	        return this.parent !== null && this.parent.left === this;
	    };
	    /**
		 *  get/set the left node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'left', {
	        get: function () {
	            return this._left;
	        },
	        set: function (node) {
	            this._left = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  get/set the right node
		 *  @type {IntervalNode}
		 */
	    Object.defineProperty(IntervalNode.prototype, 'right', {
	        get: function () {
	            return this._right;
	        },
	        set: function (node) {
	            this._right = node;
	            if (node !== null) {
	                node.parent = this;
	            }
	            this.updateHeight();
	            this.updateMax();
	        }
	    });
	    /**
		 *  null out references.
		 */
	    IntervalNode.prototype.dispose = function () {
	        this.parent = null;
	        this._left = null;
	        this._right = null;
	        this.event = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	END INTERVAL NODE HELPER
	    ///////////////////////////////////////////////////////////////////////////
	    return Tone.IntervalTimeline;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TransportEvent is an internal class used by (Tone.Transport)[Transport]
		 *         to schedule events. Do no invoke this class directly, it is
		 *         handled from within Tone.Transport.
		 *  @extends {Tone}
		 *  @param {Object} options
		 */
	    Tone.TransportEvent = function (Transport, options) {
	        options = Tone.defaultArg(options, Tone.TransportEvent.defaults);
	        Tone.call(this);
	        /**
			 * Reference to the Transport that created it
			 * @type {Tone.Transport}
			 */
	        this.Transport = Transport;
	        /**
			 * The unique id of the event
			 * @type {Number}
			 */
	        this.id = Tone.TransportEvent._eventId++;
	        /**
			 * The time the event starts
			 * @type {Ticks}
			 */
	        this.time = options.time;
	        /**
			 * The callback to invoke
			 * @type {Function}
			 */
	        this.callback = options.callback;
	        /**
			 * If the event should be removed after being created.
			 * @type {Boolean}
			 * @private
			 */
	        this._once = options.once;
	    };
	    Tone.extend(Tone.TransportEvent);
	    /**
		 * The defaults
		 * @static
		 * @type {Object}
		 */
	    Tone.TransportEvent.defaults = {
	        'once': false,
	        'callback': Tone.noOp
	    };
	    /**
		 * Current ID counter
		 * @private
		 * @static
		 * @type {Number}
		 */
	    Tone.TransportEvent._eventId = 0;
	    /**
		 * Invoke the callback even callback.
		 * @param  {Time} time  The AudioContext time in seconds of the event
		 */
	    Tone.TransportEvent.prototype.invoke = function (time) {
	        if (this.callback) {
	            this.callback(time);
	            if (this._once && this.Transport) {
	                this.Transport.clear(this.id);
	            }
	        }
	    };
	    /**
		 * Clean up
		 * @return {Tone.TransportEvent} this
		 */
	    Tone.TransportEvent.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this.Transport = null;
	        this.callback = null;
	        return this;
	    };
	    return Tone.TransportEvent;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.TransportRepeatEvent is an internal class used by Tone.Transport
		 *         to schedule repeat events. This class should not be instantiated directly.
		 *  @extends {Tone.TransportEvent}
		 *  @param {Object} options
		 */
	    Tone.TransportRepeatEvent = function (Transport, options) {
	        Tone.TransportEvent.call(this, Transport, options);
	        options = Tone.defaultArg(options, Tone.TransportRepeatEvent.defaults);
	        /**
			 * When the event should stop repeating
			 * @type {Ticks}
			 * @private
			 */
	        this.duration = options.duration;
	        /**
			 * The interval of the repeated event
			 * @type {Ticks}
			 * @private
			 */
	        this._interval = options.interval;
	        /**
			 * The ID of the current timeline event
			 * @type {Number}
			 * @private
			 */
	        this._currentId = -1;
	        /**
			 * The ID of the next timeline event
			 * @type {Number}
			 * @private
			 */
	        this._nextId = -1;
	        /**
			  * The time of the next event
			  * @type {Ticks}
			  * @private
			  */
	        this._nextTick = this.time;
	        /**
			 * a reference to the bound start method
			 * @type {Function}
			 * @private
			 */
	        this._boundRestart = this._restart.bind(this);
	        this.Transport.on('start loopStart', this._boundRestart);
	        this._restart();
	    };
	    Tone.extend(Tone.TransportRepeatEvent, Tone.TransportEvent);
	    /**
		 * The defaults
		 * @static
		 * @type {Object}
		 */
	    Tone.TransportRepeatEvent.defaults = {
	        'duration': Infinity,
	        'interval': 1
	    };
	    /**
		 * Invoke the callback. Returns the tick time which
		 * the next event should be scheduled at.
		 * @param  {Number} time  The AudioContext time in seconds of the event
		 */
	    Tone.TransportRepeatEvent.prototype.invoke = function (time) {
	        //create more events if necessary
	        this._createEvents();
	        //call the super class
	        Tone.TransportEvent.prototype.invoke.call(this, time);
	    };
	    /**
		 * Push more events onto the timeline to keep up with the position of the timeline
		 * @private
		 */
	    Tone.TransportRepeatEvent.prototype._createEvents = function () {
	        // schedule the next event
	        var ticks = this.Transport.ticks;
	        if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {
	            this._nextTick += this._interval;
	            this._currentId = this._nextId;
	            this._nextId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.TransportTime(this._nextTick, 'i'));
	        }
	    };
	    /**
		 * Push more events onto the timeline to keep up with the position of the timeline
		 * @private
		 */
	    Tone.TransportRepeatEvent.prototype._restart = function () {
	        this.Transport.clear(this._currentId);
	        this.Transport.clear(this._nextId);
	        var ticks = this.Transport.ticks;
	        this._nextTick = this.time;
	        if (ticks > this.time) {
	            this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;
	        }
	        this._currentId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.TransportTime(this._nextTick, 'i'));
	        this._nextTick += this._interval;
	        this._nextId = this.Transport.scheduleOnce(this.invoke.bind(this), Tone.TransportTime(this._nextTick, 'i'));
	    };
	    /**
		 * Clean up
		 * @return {Tone.TransportRepeatEvent} this
		 */
	    Tone.TransportRepeatEvent.prototype.dispose = function () {
	        this.Transport.clear(this._currentId);
	        this.Transport.clear(this._nextId);
	        this.Transport.off('start loopStart', this._boundRestart);
	        this._boundCreateEvents = null;
	        Tone.TransportEvent.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.TransportRepeatEvent;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Transport for timing musical events.
		 *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)
		 *          Tone.Transport timing events pass in the exact time of the scheduled event
		 *          in the argument of the callback function. Pass that time value to the object
		 *          you're scheduling. <br><br>
		 *          A single transport is created for you when the library is initialized.
		 *          <br><br>
		 *          The transport emits the events: "start", "stop", "pause", and "loop" which are
		 *          called with the time of that event as the argument.
		 *
		 *  @extends {Tone.Emitter}
		 *  @singleton
		 *  @example
		 * //repeated event every 8th note
		 * Tone.Transport.scheduleRepeat(function(time){
		 * 	//do something with the time
		 * }, "8n");
		 *  @example
		 * //schedule an event on the 16th measure
		 * Tone.Transport.schedule(function(time){
		 * 	//do something with the time
		 * }, "16:0:0");
		 */
	    Tone.Transport = function () {
	        Tone.Emitter.call(this);
	        Tone.getContext(function () {
	            ///////////////////////////////////////////////////////////////////////
	            //	LOOPING
	            //////////////////////////////////////////////////////////////////////
	            /**
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
	            this.loop = false;
	            /**
				 * 	The loop start position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopStart = 0;
	            /**
				 * 	The loop end position in ticks
				 *  @type {Ticks}
				 *  @private
				 */
	            this._loopEnd = 0;
	            ///////////////////////////////////////////////////////////////////////
	            //	CLOCK/TEMPO
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  Pulses per quarter is the number of ticks per quarter note.
				 *  @private
				 *  @type  {Number}
				 */
	            this._ppq = TransportConstructor.defaults.PPQ;
	            /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  @private
				 *  @type {Tone.Clock}
				 */
	            this._clock = new Tone.Clock({
	                'callback': this._processTick.bind(this),
	                'frequency': 0
	            });
	            this._bindClockEvents();
	            /**
				 *  The Beats Per Minute of the Transport.
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
	            this.bpm = this._clock.frequency;
	            this.bpm._toUnits = this._toUnits.bind(this);
	            this.bpm._fromUnits = this._fromUnits.bind(this);
	            this.bpm.units = Tone.Type.BPM;
	            this.bpm.value = TransportConstructor.defaults.bpm;
	            this._readOnly('bpm');
	            /**
				 *  The time signature, or more accurately the numerator
				 *  of the time signature over a denominator of 4.
				 *  @type {Number}
				 *  @private
				 */
	            this._timeSignature = TransportConstructor.defaults.timeSignature;
	            ///////////////////////////////////////////////////////////////////////
	            //	TIMELINE EVENTS
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  All the events in an object to keep track by ID
				 *  @type {Object}
				 *  @private
				 */
	            this._scheduledEvents = {};
	            /**
				 * 	The scheduled events.
				 *  @type {Tone.Timeline}
				 *  @private
				 */
	            this._timeline = new Tone.Timeline();
	            /**
				 *  Repeated events
				 *  @type {Array}
				 *  @private
				 */
	            this._repeatedEvents = new Tone.IntervalTimeline();
	            /**
				 *  All of the synced Signals
				 *  @private
				 *  @type {Array}
				 */
	            this._syncedSignals = [];
	            ///////////////////////////////////////////////////////////////////////
	            //	SWING
	            //////////////////////////////////////////////////////////////////////
	            /**
				 *  The subdivision of the swing
				 *  @type  {Ticks}
				 *  @private
				 */
	            this._swingTicks = TransportConstructor.defaults.PPQ / 2;
	            //8n
	            /**
				 *  The swing amount
				 *  @type {NormalRange}
				 *  @private
				 */
	            this._swingAmount = 0;
	        }.bind(this));
	    };
	    Tone.extend(Tone.Transport, Tone.Emitter);
	    /**
		 *  the defaults
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Transport.defaults = {
	        'bpm': 120,
	        'swing': 0,
	        'swingSubdivision': '8n',
	        'timeSignature': 4,
	        'loopStart': 0,
	        'loopEnd': '4m',
	        'PPQ': 192
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	TICKS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  called on every tick
		 *  @param   {number} tickTime clock relative tick time
		 *  @private
		 */
	    Tone.Transport.prototype._processTick = function (tickTime) {
	        var ticks = this._clock.ticks;
	        //handle swing
	        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat
	            ticks % (this._swingTicks * 2) !== 0) {
	            //add some swing
	            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);
	            var amount = Math.sin(progress * Math.PI) * this._swingAmount;
	            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i') * amount;
	        }
	        //do the loop test
	        if (this.loop) {
	            if (ticks >= this._loopEnd) {
	                this.emit('loopEnd', tickTime);
	                this._clock.ticks = this._loopStart;
	                ticks = this._loopStart;
	                this.emit('loopStart', tickTime, this.seconds);
	                this.emit('loop', tickTime);
	            }
	        }
	        //invoke the timeline events scheduled on this tick
	        this._timeline.forEachAtTime(ticks, function (event) {
	            event.invoke(tickTime);
	        });
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SCHEDULABLE EVENTS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Schedule an event along the timeline.
		 *  @param {Function} callback The callback to be invoked at the time.
		 *  @param {TransportTime}  time The time to invoke the callback at.
		 *  @return {Number} The id of the event which can be used for canceling the event.
		 *  @example
		 * //trigger the callback when the Transport reaches the desired time
		 * Tone.Transport.schedule(function(time){
		 * 	envelope.triggerAttack(time);
		 * }, "128i");
		 */
	    Tone.Transport.prototype.schedule = function (callback, time) {
	        var event = new Tone.TransportEvent(this, {
	            'time': this.toTicks(time),
	            'callback': callback
	        });
	        return this._addEvent(event, this._timeline);
	    };
	    /**
		 *  Schedule a repeated event along the timeline. The event will fire
		 *  at the `interval` starting at the `startTime` and for the specified
		 *  `duration`.
		 *  @param  {Function}  callback   The callback to invoke.
		 *  @param  {Time}    interval   The duration between successive
		 *                               callbacks. Must be a positive number.
		 *  @param  {TimelinePosition=}    startTime  When along the timeline the events should
		 *                               start being invoked.
		 *  @param {Time} [duration=Infinity] How long the event should repeat.
		 *  @return  {Number}    The ID of the scheduled event. Use this to cancel
		 *                           the event.
		 *  @example
		 * //a callback invoked every eighth note after the first measure
		 * Tone.Transport.scheduleRepeat(callback, "8n", "1m");
		 */
	    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {
	        var event = new Tone.TransportRepeatEvent(this, {
	            'callback': callback,
	            'interval': this.toTicks(interval),
	            'time': this.toTicks(startTime),
	            'duration': this.toTicks(Tone.defaultArg(duration, Infinity))
	        });
	        //kick it off if the Transport is started
	        return this._addEvent(event, this._repeatedEvents);
	    };
	    /**
		 *  Schedule an event that will be removed after it is invoked.
		 *  Note that if the given time is less than the current transport time,
		 *  the event will be invoked immediately.
		 *  @param {Function} callback The callback to invoke once.
		 *  @param {TransportTime} time The time the callback should be invoked.
		 *  @returns {Number} The ID of the scheduled event.
		 */
	    Tone.Transport.prototype.scheduleOnce = function (callback, time) {
	        var event = new Tone.TransportEvent(this, {
	            'time': this.toTicks(time),
	            'callback': callback,
	            'once': true
	        });
	        return this._addEvent(event, this._timeline);
	    };
	    /**
		 *  Clear the passed in event id from the timeline
		 *  @param {Number} eventId The id of the event.
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.clear = function (eventId) {
	        if (this._scheduledEvents.hasOwnProperty(eventId)) {
	            var item = this._scheduledEvents[eventId.toString()];
	            item.timeline.remove(item.event);
	            item.event.dispose();
	            delete this._scheduledEvents[eventId.toString()];
	        }
	        return this;
	    };
	    /**
		 * Add an event to the correct timeline. Keep track of the
		 * timeline it was added to.
		 * @param {Tone.TransportEvent}	event
		 * @param {Tone.Timeline} timeline
		 * @returns {Number} the event id which was just added
		 * @private
		 */
	    Tone.Transport.prototype._addEvent = function (event, timeline) {
	        this._scheduledEvents[event.id.toString()] = {
	            'event': event,
	            'timeline': timeline
	        };
	        timeline.add(event);
	        return event.id;
	    };
	    /**
		 *  Remove scheduled events from the timeline after
		 *  the given time. Repeated events will be removed
		 *  if their startTime is after the given time
		 *  @param {TransportTime} [after=0] Clear all events after
		 *                          this time.
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.cancel = function (after) {
	        after = Tone.defaultArg(after, 0);
	        after = this.toTicks(after);
	        this._timeline.cancel(after);
	        this._repeatedEvents.cancel(after);
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	START/STOP/PAUSE
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Bind start/stop/pause events from the clock and emit them.
		 *  @private
		 */
	    Tone.Transport.prototype._bindClockEvents = function () {
	        this._clock.on('start', function (time, offset) {
	            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();
	            this.emit('start', time, offset);
	        }.bind(this));
	        this._clock.on('stop', function (time) {
	            this.emit('stop', time);
	        }.bind(this));
	        this._clock.on('pause', function (time) {
	            this.emit('pause', time);
	        }.bind(this));
	    };
	    /**
		 *  Returns the playback state of the source, either "started", "stopped", or "paused"
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Transport#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'state', {
	        get: function () {
	            return this._clock.getStateAtTime(this.now());
	        }
	    });
	    /**
		 *  Start the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should start.
		 *  @param  {TransportTime=} offset The timeline offset to start the transport.
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //start the transport in one second starting at beginning of the 5th measure.
		 * Tone.Transport.start("+1", "4:0:0");
		 */
	    Tone.Transport.prototype.start = function (time, offset) {
	        //start the clock
	        if (!Tone.isUndef(offset)) {
	            offset = this.toTicks(offset);
	        }
	        this._clock.start(time, offset);
	        return this;
	    };
	    /**
		 *  Stop the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now] The time when the transport should stop.
		 *  @returns {Tone.Transport} this
		 *  @example
		 * Tone.Transport.stop();
		 */
	    Tone.Transport.prototype.stop = function (time) {
	        this._clock.stop(time);
	        return this;
	    };
	    /**
		 *  Pause the transport and all sources synced to the transport.
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.pause = function (time) {
	        this._clock.pause(time);
	        return this;
	    };
	    /**
		 * Toggle the current state of the transport. If it is
		 * started, it will stop it, otherwise it will start the Transport.
		 * @param  {Time=} time The time of the event
		 * @return {Tone.Transport}      this
		 */
	    Tone.Transport.prototype.toggle = function (time) {
	        time = this.toSeconds(time);
	        if (this._clock.getStateAtTime(time) !== Tone.State.Started) {
	            this.start(time);
	        } else {
	            this.stop(time);
	        }
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SETTERS/GETTERS
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  The time signature as just the numerator over 4.
		 *  For example 4/4 would be just 4 and 6/8 would be 3.
		 *  @memberOf Tone.Transport#
		 *  @type {Number|Array}
		 *  @name timeSignature
		 *  @example
		 * //common time
		 * Tone.Transport.timeSignature = 4;
		 * // 7/8
		 * Tone.Transport.timeSignature = [7, 8];
		 * //this will be reduced to a single number
		 * Tone.Transport.timeSignature; //returns 3.5
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
	        get: function () {
	            return this._timeSignature;
	        },
	        set: function (timeSig) {
	            if (Tone.isArray(timeSig)) {
	                timeSig = timeSig[0] / timeSig[1] * 4;
	            }
	            this._timeSignature = timeSig;
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the starting position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toSeconds();
	        },
	        set: function (startPosition) {
	            this._loopStart = this.toTicks(startPosition);
	        }
	    });
	    /**
		 * When the Tone.Transport.loop = true, this is the ending position of the loop.
		 * @memberOf Tone.Transport#
		 * @type {TransportTime}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();
	        },
	        set: function (endPosition) {
	            this._loopEnd = this.toTicks(endPosition);
	        }
	    });
	    /**
		 *  Set the loop start and stop at the same time.
		 *  @param {TransportTime} startPosition
		 *  @param {TransportTime} endPosition
		 *  @returns {Tone.Transport} this
		 *  @example
		 * //loop over the first measure
		 * Tone.Transport.setLoopPoints(0, "1m");
		 * Tone.Transport.loop = true;
		 */
	    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
	        this.loopStart = startPosition;
	        this.loopEnd = endPosition;
	        return this;
	    };
	    /**
		 *  The swing value. Between 0-1 where 1 equal to
		 *  the note + half the subdivision.
		 *  @memberOf Tone.Transport#
		 *  @type {NormalRange}
		 *  @name swing
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swing', {
	        get: function () {
	            return this._swingAmount;
	        },
	        set: function (amount) {
	            //scale the values to a normal range
	            this._swingAmount = amount;
	        }
	    });
	    /**
		 *  Set the subdivision which the swing will be applied to.
		 *  The default value is an 8th note. Value must be less
		 *  than a quarter note.
		 *
		 *  @memberOf Tone.Transport#
		 *  @type {Time}
		 *  @name swingSubdivision
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
	        get: function () {
	            return Tone.Time(this._swingTicks, 'i').toNotation();
	        },
	        set: function (subdivision) {
	            this._swingTicks = this.toTicks(subdivision);
	        }
	    });
	    /**
		 *  The Transport's position in Bars:Beats:Sixteenths.
		 *  Setting the value will jump to that position right away.
		 *  @memberOf Tone.Transport#
		 *  @type {BarsBeatsSixteenths}
		 *  @name position
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'position', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's position in seconds
		 *  Setting the value will jump to that position right away.
		 *  @memberOf Tone.Transport#
		 *  @type {Seconds}
		 *  @name seconds
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'seconds', {
	        get: function () {
	            return Tone.TransportTime(this.ticks, 'i').toSeconds();
	        },
	        set: function (progress) {
	            var ticks = this.toTicks(progress);
	            this.ticks = ticks;
	        }
	    });
	    /**
		 *  The Transport's loop position as a normalized value. Always
		 *  returns 0 if the transport if loop is not true.
		 *  @memberOf Tone.Transport#
		 *  @name progress
		 *  @type {NormalRange}
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'progress', {
	        get: function () {
	            if (this.loop) {
	                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  The transports current tick position.
		 *
		 *  @memberOf Tone.Transport#
		 *  @type {Ticks}
		 *  @name ticks
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'ticks', {
	        get: function () {
	            return this._clock.ticks;
	        },
	        set: function (t) {
	            if (this._clock.ticks !== t) {
	                var now = this.now();
	                //stop everything synced to the transport
	                if (this.state === Tone.State.Started) {
	                    this.emit('stop', now);
	                    this._clock.ticks = t;
	                    //restart it with the new time
	                    this.emit('start', now, this.seconds);
	                } else {
	                    this._clock.ticks = t;
	                }
	            }
	        }
	    });
	    /**
		 *  Pulses Per Quarter note. This is the smallest resolution
		 *  the Transport timing supports. This should be set once
		 *  on initialization and not set again. Changing this value
		 *  after other objects have been created can cause problems.
		 *
		 *  @memberOf Tone.Transport#
		 *  @type {Number}
		 *  @name PPQ
		 */
	    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {
	        get: function () {
	            return this._ppq;
	        },
	        set: function (ppq) {
	            var bpm = this.bpm.value;
	            this._ppq = ppq;
	            this.bpm.value = bpm;
	        }
	    });
	    /**
		 *  Convert from BPM to frequency (factoring in PPQ)
		 *  @param  {BPM}  bpm The BPM value to convert to frequency
		 *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.
		 *  @private
		 */
	    Tone.Transport.prototype._fromUnits = function (bpm) {
	        return 1 / (60 / bpm / this.PPQ);
	    };
	    /**
		 *  Convert from frequency (with PPQ) into BPM
		 *  @param  {Frequency}  freq The clocks frequency to convert to BPM
		 *  @return  {BPM}  The frequency value as BPM.
		 *  @private
		 */
	    Tone.Transport.prototype._toUnits = function (freq) {
	        return freq / this.PPQ * 60;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	SYNCING
	    ///////////////////////////////////////////////////////////////////////////////
	    /**
		 *  Returns the time aligned to the next subdivision
		 *  of the Transport. If the Transport is not started,
		 *  it will return 0.
		 *  Note: this will not work precisely during tempo ramps.
		 *  @param  {Time}  subdivision  The subdivision to quantize to
		 *  @return  {Number}  The context time of the next subdivision.
		 *  @example
		 * Tone.Transport.start(); //the transport must be started
		 * Tone.Transport.nextSubdivision("4n");
		 */
	    Tone.Transport.prototype.nextSubdivision = function (subdivision) {
	        subdivision = this.toSeconds(subdivision);
	        //if the transport's not started, return 0
	        var now;
	        if (this.state === Tone.State.Started) {
	            now = this._clock._nextTick;
	        } else {
	            return 0;
	        }
	        var transportPos = Tone.Time(this.ticks, 'i');
	        var remainingTime = subdivision - transportPos % subdivision;
	        if (remainingTime === 0) {
	            remainingTime = subdivision;
	        }
	        return now + remainingTime;
	    };
	    /**
		 *  Attaches the signal to the tempo control signal so that
		 *  any changes in the tempo will change the signal in the same
		 *  ratio.
		 *
		 *  @param  {Tone.Signal} signal
		 *  @param {number=} ratio Optionally pass in the ratio between
		 *                         the two signals. Otherwise it will be computed
		 *                         based on their current values.
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
	        if (!ratio) {
	            //get the sync ratio
	            if (signal._param.value !== 0) {
	                ratio = signal._param.value / this.bpm._param.value;
	            } else {
	                ratio = 0;
	            }
	        }
	        var ratioSignal = new Tone.Gain(ratio);
	        this.bpm.chain(ratioSignal, signal._param);
	        this._syncedSignals.push({
	            'ratio': ratioSignal,
	            'signal': signal,
	            'initial': signal._param.value
	        });
	        signal._param.value = 0;
	        return this;
	    };
	    /**
		 *  Unsyncs a previously synced signal from the transport's control.
		 *  See Tone.Transport.syncSignal.
		 *  @param  {Tone.Signal} signal
		 *  @returns {Tone.Transport} this
		 */
	    Tone.Transport.prototype.unsyncSignal = function (signal) {
	        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {
	            var syncedSignal = this._syncedSignals[i];
	            if (syncedSignal.signal === signal) {
	                syncedSignal.ratio.dispose();
	                syncedSignal.signal._param.value = syncedSignal.initial;
	                this._syncedSignals.splice(i, 1);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Transport} this
		 *  @private
		 */
	    Tone.Transport.prototype.dispose = function () {
	        Tone.Emitter.prototype.dispose.call(this);
	        this._clock.dispose();
	        this._clock = null;
	        this._writable('bpm');
	        this.bpm = null;
	        this._timeline.dispose();
	        this._timeline = null;
	        this._repeatedEvents.dispose();
	        this._repeatedEvents = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////////
	    //	INITIALIZATION
	    ///////////////////////////////////////////////////////////////////////////////
	    var TransportConstructor = Tone.Transport;
	    Tone.Transport = new TransportConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            Tone.Transport = context.Transport;
	        } else {
	            Tone.Transport = new TransportConstructor();
	        }
	        //store the Transport on the context so it can be retrieved later
	        context.Transport = Tone.Transport;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Transport instanceof TransportConstructor) {
	            context.Transport.dispose();
	        }
	    });
	    return Tone.Transport;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Decibels} [volume=0] the initial volume
		 *  @example
		 * var vol = new Tone.Volume(-12);
		 * instrument.chain(vol, Tone.Master);
		 */
	    Tone.Volume = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.Volume);
	        Tone.AudioNode.call(this);
	        /**
			 * the output node
			 * @type {GainNode}
			 * @private
			 */
	        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);
	        /**
			 * The unmuted volume
			 * @type {Decibels}
			 * @private
			 */
	        this._unmutedVolume = options.volume;
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this.output.gain;
	        this._readOnly('volume');
	        //set the mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Volume, Tone.AudioNode);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Volume.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Volume#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * volume.mute = true;
		 */
	    Object.defineProperty(Tone.Volume.prototype, 'mute', {
	        get: function () {
	            return this.volume.value === -Infinity;
	        },
	        set: function (mute) {
	            if (!this.mute && mute) {
	                this._unmutedVolume = this.volume.value;
	                //maybe it should ramp here?
	                this.volume.value = -Infinity;
	            } else if (this.mute && !mute) {
	                this.volume.value = this._unmutedVolume;
	            }
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Volume} this
		 */
	    Tone.Volume.prototype.dispose = function () {
	        this.input.dispose();
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this.volume.dispose();
	        this.volume = null;
	        return this;
	    };
	    return Tone.Volume;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A single master output which is connected to the
		 *          AudioDestinationNode (aka your speakers).
		 *          It provides useful conveniences such as the ability
		 *          to set the volume and mute the entire application.
		 *          It also gives you the ability to apply master effects to your application.
		 *          <br><br>
		 *          Like Tone.Transport, A single Tone.Master is created
		 *          on initialization and you do not need to explicitly construct one.
		 *
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 *  @example
		 * //the audio will go from the oscillator to the speakers
		 * oscillator.connect(Tone.Master);
		 * //a convenience for connecting to the master output is also provided:
		 * oscillator.toMaster();
		 * //the above two examples are equivalent.
		 */
	    Tone.Master = function () {
	        Tone.AudioNode.call(this);
	        Tone.getContext(function () {
	            this.createInsOuts(1, 0);
	            /**
				 *  The private volume node
				 *  @type  {Tone.Volume}
				 *  @private
				 */
	            this._volume = this.output = new Tone.Volume();
	            /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
	            this.volume = this._volume.volume;
	            this._readOnly('volume');
	            //connections
	            this.input.chain(this.output, this.context.destination);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Master, Tone.AudioNode);
	    /**
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Master.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Master#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * Tone.Master.mute = true;
		 */
	    Object.defineProperty(Tone.Master.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously
		 *  chained in the master effects chain.
		 *  @param {AudioNode|Tone} args... All arguments will be connected in a row
		 *                                  and the Master will be routed through it.
		 *  @return  {Tone.Master}  this
		 *  @example
		 * //some overall compression to keep the levels in check
		 * var masterCompressor = new Tone.Compressor({
		 * 	"threshold" : -6,
		 * 	"ratio" : 3,
		 * 	"attack" : 0.5,
		 * 	"release" : 0.1
		 * });
		 * //give a little boost to the lows
		 * var lowBump = new Tone.Filter(200, "lowshelf");
		 * //route everything through the filter
		 * //and compressor before going to the speakers
		 * Tone.Master.chain(lowBump, masterCompressor);
		 */
	    Tone.Master.prototype.chain = function () {
	        this.input.disconnect();
	        this.input.chain.apply(this.input, arguments);
	        arguments[arguments.length - 1].connect(this.output);
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Master}  this
		 */
	    Tone.Master.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    //	AUGMENT TONE's PROTOTYPE
	    ///////////////////////////////////////////////////////////////////////////
	    /**
		 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
		 *  @returns {Tone.AudioNode} this
		 *  @example
		 * //connect an oscillator to the master output
		 * var osc = new Tone.Oscillator().toMaster();
		 */
	    Tone.AudioNode.prototype.toMaster = function () {
	        this.connect(Tone.Master);
	        return this;
	    };
	    if (window.AudioNode) {
	        // Also augment AudioNode's prototype to include toMaster as a convenience
	        AudioNode.prototype.toMaster = function () {
	            this.connect(Tone.Master);
	            return this;
	        };
	    }
	    /**
		 *  initialize the module and listen for new audio contexts
		 */
	    var MasterConstructor = Tone.Master;
	    Tone.Master = new MasterConstructor();
	    Tone.Context.on('init', function (context) {
	        // if it already exists, just restore it
	        if (context.Master instanceof MasterConstructor) {
	            Tone.Master = context.Master;
	        } else {
	            Tone.Master = new MasterConstructor();
	        }
	        context.Master = Tone.Master;
	    });
	    Tone.Context.on('close', function (context) {
	        if (context.Master instanceof MasterConstructor) {
	            context.Master.dispose();
	        }
	    });
	    return Tone.Master;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base class for sources. Sources have start/stop methods
		 *          and the ability to be synced to the
		 *          start/stop of Tone.Transport.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * //Multiple state change events can be chained together,
		 * //but must be set in the correct order and with ascending times
		 *
		 * // OK
		 * state.start().stop("+0.2");
		 * // AND
		 * state.start().stop("+0.2").start("+0.4").stop("+0.7")
		 *
		 * // BAD
		 * state.stop("+0.2").start();
		 * // OR
		 * state.start("+0.3").stop("+0.2");
		 *
		 */
	    Tone.Source = function (options) {
	        options = Tone.defaultArg(options, Tone.Source.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        /**
			 * 	Keep track of the scheduled state.
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        this._state.memory = 10;
	        /**
			 *  The synced `start` callback function from the transport
			 *  @type {Function}
			 *  @private
			 */
	        this._synced = false;
	        /**
			 *  Keep track of all of the scheduled event ids
			 *  @type  {Array}
			 *  @private
			 */
	        this._scheduled = [];
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.Source, Tone.AudioNode);
	    /**
		 *  The default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Source.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.Source#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Source.prototype, 'state', {
	        get: function () {
	            if (this._synced) {
	                if (Tone.Transport.state === Tone.State.Started) {
	                    return this._state.getValueAtTime(Tone.Transport.seconds);
	                } else {
	                    return Tone.State.Stopped;
	                }
	            } else {
	                return this._state.getValueAtTime(this.now());
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Source.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    //overwrite these functions
	    Tone.Source.prototype._start = Tone.noOp;
	    Tone.Source.prototype._stop = Tone.noOp;
	    /**
		 *  Start the source at the specified time. If no time is given,
		 *  start the source now.
		 *  @param  {Time} [time=now] When the source should be started.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.start("+0.5"); //starts the source 0.5 seconds from now
		 */
	    Tone.Source.prototype.start = function (time, offset, duration) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        //if it's started, stop it and restart it
	        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {
	            this.stop(time);
	        }
	        this._state.setStateAtTime(Tone.State.Started, time);
	        if (this._synced) {
	            // add the offset time to the event
	            var event = this._state.get(time);
	            event.offset = Tone.defaultArg(offset, 0);
	            event.duration = duration;
	            var sched = Tone.Transport.schedule(function (t) {
	                this._start(t, offset, duration);
	            }.bind(this), time);
	            this._scheduled.push(sched);
	        } else {
	            this._start.apply(this, arguments);
	        }
	        return this;
	    };
	    /**
		 *  Stop the source at the specified time. If no time is given,
		 *  stop the source now.
		 *  @param  {Time} [time=now] When the source should be stopped.
		 *  @returns {Tone.Source} this
		 *  @example
		 * source.stop(); // stops the source immediately
		 */
	    Tone.Source.prototype.stop = function (time) {
	        if (Tone.isUndef(time) && this._synced) {
	            time = Tone.Transport.seconds;
	        } else {
	            time = this.toSeconds(time);
	        }
	        this._state.cancel(time);
	        this._state.setStateAtTime(Tone.State.Stopped, time);
	        if (!this._synced) {
	            this._stop.apply(this, arguments);
	        } else {
	            var sched = Tone.Transport.schedule(this._stop.bind(this), time);
	            this._scheduled.push(sched);
	        }
	        return this;
	    };
	    /**
		 *  Sync the source to the Transport so that all subsequent
		 *  calls to `start` and `stop` are synced to the TransportTime
		 *  instead of the AudioContext time.
		 *
		 *  @returns {Tone.Source} this
		 *  @example
		 * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline
		 * source.sync().start(0).stop(0.3);
		 * //start the transport.
		 * Tone.Transport.start();
		 *
		 *  @example
		 * //start the transport with an offset and the sync'ed sources
		 * //will start in the correct position
		 * source.sync().start(0.1);
		 * //the source will be invoked with an offset of 0.4
		 * Tone.Transport.start("+0.5", 0.5);
		 */
	    Tone.Source.prototype.sync = function () {
	        this._synced = true;
	        this._syncedStart = function (time, offset) {
	            if (offset > 0) {
	                // get the playback state at that time
	                var stateEvent = this._state.get(offset);
	                // listen for start events which may occur in the middle of the sync'ed time
	                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {
	                    // get the offset
	                    var startOffset = offset - this.toSeconds(stateEvent.time);
	                    var duration;
	                    if (stateEvent.duration) {
	                        duration = this.toSeconds(stateEvent.duration) - startOffset;
	                    }
	                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);
	                }
	            }
	        }.bind(this);
	        this._syncedStop = function (time) {
	            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {
	                this._stop(time);
	            }
	        }.bind(this);
	        Tone.Transport.on('start loopStart', this._syncedStart);
	        Tone.Transport.on('stop pause loopEnd', this._syncedStop);
	        return this;
	    };
	    /**
		 *  Unsync the source to the Transport. See Tone.Source.sync
		 *  @returns {Tone.Source} this
		 */
	    Tone.Source.prototype.unsync = function () {
	        if (this._synced) {
	            Tone.Transport.off('stop pause loopEnd', this._syncedStop);
	            Tone.Transport.off('start loopStart', this._syncedStart);
	        }
	        this._synced = false;
	        // clear all of the scheduled ids
	        for (var i = 0; i < this._scheduled.length; i++) {
	            var id = this._scheduled[i];
	            Tone.Transport.clear(id);
	        }
	        this._scheduled = [];
	        this._state.cancel(0);
	        return this;
	    };
	    /**
		 *	Clean up.
		 *  @return {Tone.Source} this
		 */
	    Tone.Source.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.unsync();
	        this._scheduled = null;
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        this._state.dispose();
	        this._state = null;
	    };
	    return Tone.Source;
	});
	Module(function (Tone) {
	    
	    /**
		 *  OscillatorNode shim
		 *  @private
		 */
	    if (window.OscillatorNode && !OscillatorNode.prototype.start) {
	        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
	        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
	        if (!OscillatorNode.prototype.setPeriodicWave) {
	            OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
	        }
	        if (!AudioContext.prototype.createPeriodicWave) {
	            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
	        }
	    }
	    /**
		 *  @class Tone.Oscillator supports a number of features including
		 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type),
		 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] Starting frequency
		 *  @param {string} [type] The oscillator type. Read more about type below.
		 *  @example
		 * //make and start a 440hz sine tone
		 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
		 */
	    Tone.Oscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the main oscillator
			 *  @type {OscillatorNode}
			 *  @private
			 */
	        this._oscillator = null;
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the periodic wave
			 *  @type {PeriodicWave}
			 *  @private
			 */
	        this._wave = null;
	        /**
			 *  The partials of the oscillator
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, [1]);
	        /**
			 *  the phase of the oscillator
			 *  between 0 - 360
			 *  @type {number}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  the type of the oscillator
			 *  @type {string}
			 *  @private
			 */
	        this._type = null;
	        //setup
	        this.type = options.type;
	        this.phase = this._phase;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.Oscillator, Tone.Source);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Oscillator.defaults = {
	        'type': 'sine',
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'partials': []
	    };
	    /**
		 *  The Oscillator types
		 *  @enum {String}
		 */
	    Tone.Oscillator.Type = {
	        Sine: 'sine',
	        Triangle: 'triangle',
	        Sawtooth: 'sawtooth',
	        Square: 'square',
	        Custom: 'custom'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.Oscillator.prototype._start = function (time) {
	        //new oscillator with previous values
	        this._oscillator = this.context.createOscillator();
	        this._oscillator.setPeriodicWave(this._wave);
	        //connect the control signal to the oscillator frequency & detune
	        this._oscillator.connect(this.output);
	        this.frequency.connect(this._oscillator.frequency);
	        this.detune.connect(this._oscillator.detune);
	        //start the oscillator
	        time = this.toSeconds(time);
	        Tone.isPast(time);
	        this._oscillator.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @private
		 *  @param  {Time} [time=now] (optional) timing parameter
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype._stop = function (time) {
	        if (this._oscillator) {
	            time = this.toSeconds(time);
	            Tone.isPast(time);
	            this._oscillator.stop(time);
	            this._oscillator = null;
	        }
	        return this;
	    };
	    /**
		 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
		 *  will also affect the oscillators frequency.
		 *  @returns {Tone.Oscillator} this
		 *  @example
		 * Tone.Transport.bpm.value = 120;
		 * osc.frequency.value = 440;
		 * //the ration between the bpm and the frequency will be maintained
		 * osc.syncFrequency();
		 * Tone.Transport.bpm.value = 240;
		 * // the frequency of the oscillator is doubled to 880
		 */
	    Tone.Oscillator.prototype.syncFrequency = function () {
	        Tone.Transport.syncSignal(this.frequency);
	        return this;
	    };
	    /**
		 *  Unsync the oscillator's frequency from the Transport.
		 *  See Tone.Oscillator.syncFrequency
		 *  @returns {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.unsyncFrequency = function () {
	        Tone.Transport.unsyncSignal(this.frequency);
	        return this;
	    };
	    /**
		 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
		 * setting the first x number of partials of the oscillator. For example: "sine4" would
		 * set be the first 4 partials of the sine wave and "triangle8" would set the first
		 * 8 partials of the triangle wave.
		 * <br><br>
		 * Uses PeriodicWave internally even for native types so that it can set the phase.
		 * PeriodicWave equations are from the
		 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
		 *
		 * @memberOf Tone.Oscillator#
		 * @type {string}
		 * @name type
		 * @example
		 * //set it to a square wave
		 * osc.type = "square";
		 * @example
		 * //set the first 6 partials of a sawtooth wave
		 * osc.type = "sawtooth6";
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            var coefs = this._getRealImaginary(type, this._phase);
	            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);
	            this._wave = periodicWave;
	            if (this._oscillator !== null) {
	                this._oscillator.setPeriodicWave(this._wave);
	            }
	            this._type = type;
	        }
	    });
	    /**
		 *  Returns the real and imaginary components based
		 *  on the oscillator type.
		 *  @returns {Array} [real, imaginary]
		 *  @private
		 */
	    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {
	        var fftSize = 4096;
	        var periodicWaveSize = fftSize / 2;
	        var real = new Float32Array(periodicWaveSize);
	        var imag = new Float32Array(periodicWaveSize);
	        var partialCount = 1;
	        if (type === Tone.Oscillator.Type.Custom) {
	            partialCount = this._partials.length + 1;
	            periodicWaveSize = partialCount;
	        } else {
	            var partial = /^(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
	            if (partial) {
	                partialCount = parseInt(partial[2]) + 1;
	                type = partial[1];
	                partialCount = Math.max(partialCount, 2);
	                periodicWaveSize = partialCount;
	            }
	        }
	        for (var n = 1; n < periodicWaveSize; ++n) {
	            var piFactor = 2 / (n * Math.PI);
	            var b;
	            switch (type) {
	            case Tone.Oscillator.Type.Sine:
	                b = n <= partialCount ? 1 : 0;
	                break;
	            case Tone.Oscillator.Type.Square:
	                b = n & 1 ? 2 * piFactor : 0;
	                break;
	            case Tone.Oscillator.Type.Sawtooth:
	                b = piFactor * (n & 1 ? 1 : -1);
	                break;
	            case Tone.Oscillator.Type.Triangle:
	                if (n & 1) {
	                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
	                } else {
	                    b = 0;
	                }
	                break;
	            case Tone.Oscillator.Type.Custom:
	                b = this._partials[n - 1];
	                break;
	            default:
	                throw new TypeError('Tone.Oscillator: invalid type: ' + type);
	            }
	            if (b !== 0) {
	                real[n] = -b * Math.sin(phase * n);
	                imag[n] = b * Math.cos(phase * n);
	            } else {
	                real[n] = 0;
	                imag[n] = 0;
	            }
	        }
	        return [
	            real,
	            imag
	        ];
	    };
	    /**
		 *  Compute the inverse FFT for a given phase.
		 *  @param  {Float32Array}  real
		 *  @param  {Float32Array}  imag
		 *  @param  {NormalRange}  phase
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {
	        var sum = 0;
	        var len = real.length;
	        for (var i = 0; i < len; i++) {
	            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);
	        }
	        return sum;
	    };
	    /**
		 *  Returns the initial value of the oscillator.
		 *  @return  {AudioRange}
		 *  @private
		 */
	    Tone.Oscillator.prototype._getInitialValue = function () {
	        var coefs = this._getRealImaginary(this._type, 0);
	        var real = coefs[0];
	        var imag = coefs[1];
	        var maxValue = 0;
	        var twoPi = Math.PI * 2;
	        //check for peaks in 8 places
	        for (var i = 0; i < 8; i++) {
	            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);
	        }
	        return -this._inverseFFT(real, imag, this._phase) / maxValue;
	    };
	    /**
		 * The partials of the waveform. A partial represents
		 * the amplitude at a harmonic. The first harmonic is the
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series.
		 * Setting this value will automatically set the type to "custom".
		 * The value is an empty array when the type is not "custom".
		 * @memberOf Tone.Oscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {
	        get: function () {
	            if (this._type !== Tone.Oscillator.Type.Custom) {
	                return [];
	            } else {
	                return this._partials;
	            }
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this.type = Tone.Oscillator.Type.Custom;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.Oscillator#
		 * @type {Degrees}
		 * @name phase
		 * @example
		 * osc.phase = 180; //flips the phase of the oscillator
		 */
	    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase * (180 / Math.PI);
	        },
	        set: function (phase) {
	            this._phase = phase * Math.PI / 180;
	            //reset the type
	            this.type = this._type;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Oscillator} this
		 */
	    Tone.Oscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._oscillator !== null) {
	            this._oscillator.disconnect();
	            this._oscillator = null;
	        }
	        this._wave = null;
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.Oscillator;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be
		 *         it's own class is that many browsers optimize out Tone.Signal
		 *         with a value of 0 and will not process nodes further down the graph.
		 *  @extends {Tone.SignalBase}
		 */
	    Tone.Zero = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  The gain node
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gain = this.input = this.output = new Tone.Gain();
	        this.context.getConstant(0).connect(this._gain);
	    };
	    Tone.extend(Tone.Zero, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @return  {Tone.Zero}  this
		 */
	    Tone.Zero.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._gain.dispose();
	        this._gain = null;
	        return this;
	    };
	    return Tone.Zero;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal
		 *          which can be attached to an AudioParam or Tone.Signal
		 *          in order to modulate that parameter with an oscillator. The LFO can
		 *          also be synced to the transport to start/stop and change when the tempo changes.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
		 *                               in the frequency range of 0.1 to 10 hertz.
		 *  @param {number=} min The minimum output value of the LFO.
		 *  @param {number=} max The maximum value of the LFO.
		 *  @example
		 * var lfo = new Tone.LFO("4n", 400, 4000);
		 * lfo.connect(filter.frequency);
		 */
	    Tone.LFO = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'min',
	            'max'
	        ], Tone.LFO);
	        Tone.AudioNode.call(this);
	        /**
			 *  The oscillator.
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'type': options.type
	        });
	        /**
			 *  the lfo's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._oscillator.frequency;
	        /**
			 * The amplitude of the LFO, which controls the output range between
			 * the min and max output. For example if the min is -10 and the max
			 * is 10, setting the amplitude to 0.5 would make the LFO modulate
			 * between -5 and 5.
			 * @type {Number}
			 * @signal
			 */
	        this.amplitude = this._oscillator.volume;
	        this.amplitude.units = Tone.Type.NormalRange;
	        this.amplitude.value = options.amplitude;
	        /**
			 *  The signal which is output when the LFO is stopped
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);
	        /**
			 *  Just outputs zeros.
			 *  @type {Tone.Zero}
			 *  @private
			 */
	        this._zeros = new Tone.Zero();
	        /**
			 *  The value that the LFO outputs when it's stopped
			 *  @type {AudioRange}
			 *  @private
			 */
	        this._stoppedValue = 0;
	        /**
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._a2g = new Tone.AudioToGain();
	        /**
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaler = this.output = new Tone.Scale(options.min, options.max);
	        /**
			 *  the units of the LFO (used for converting)
			 *  @type {Tone.Type}
			 *  @private
			 */
	        this._units = Tone.Type.Default;
	        this.units = options.units;
	        //connect it up
	        this._oscillator.chain(this._a2g, this._scaler);
	        this._zeros.connect(this._a2g);
	        this._stoppedSignal.connect(this._a2g);
	        this._readOnly([
	            'amplitude',
	            'frequency'
	        ]);
	        this.phase = options.phase;
	    };
	    Tone.extend(Tone.LFO, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LFO.defaults = {
	        'type': 'sine',
	        'min': 0,
	        'max': 1,
	        'phase': 0,
	        'frequency': '4n',
	        'amplitude': 1,
	        'units': Tone.Type.Default
	    };
	    /**
		 *  Start the LFO.
		 *  @param  {Time} [time=now] the time the LFO will start
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.start = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(0, time);
	        this._oscillator.start(time);
	        return this;
	    };
	    /**
		 *  Stop the LFO.
		 *  @param  {Time} [time=now] the time the LFO will stop
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.stop = function (time) {
	        time = this.toSeconds(time);
	        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);
	        this._oscillator.stop(time);
	        return this;
	    };
	    /**
		 *  Sync the start/stop/pause to the transport
		 *  and the frequency to the bpm of the transport
		 *  @returns {Tone.LFO} this
		 *  @example
		 *  lfo.frequency.value = "8n";
		 *  lfo.sync().start(0)
		 *  //the rate of the LFO will always be an eighth note,
		 *  //even as the tempo changes
		 */
	    Tone.LFO.prototype.sync = function () {
	        this._oscillator.sync();
	        this._oscillator.syncFrequency();
	        return this;
	    };
	    /**
		 *  unsync the LFO from transport control
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.unsync = function () {
	        this._oscillator.unsync();
	        this._oscillator.unsyncFrequency();
	        return this;
	    };
	    /**
		 * The miniumum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'min', {
	        get: function () {
	            return this._toUnits(this._scaler.min);
	        },
	        set: function (min) {
	            min = this._fromUnits(min);
	            this._scaler.min = min;
	        }
	    });
	    /**
		 * The maximum output of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'max', {
	        get: function () {
	            return this._toUnits(this._scaler.max);
	        },
	        set: function (max) {
	            max = this._fromUnits(max);
	            this._scaler.max = max;
	        }
	    });
	    /**
		 * The type of the oscillator: sine, square, sawtooth, triangle.
		 * @memberOf Tone.LFO#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'type', {
	        get: function () {
	            return this._oscillator.type;
	        },
	        set: function (type) {
	            this._oscillator.type = type;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The phase of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	            this._stoppedValue = this._oscillator._getInitialValue();
	            this._stoppedSignal.value = this._stoppedValue;
	        }
	    });
	    /**
		 * The output units of the LFO.
		 * @memberOf Tone.LFO#
		 * @type {Tone.Type}
		 * @name units
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'units', {
	        get: function () {
	            return this._units;
	        },
	        set: function (val) {
	            var currentMin = this.min;
	            var currentMax = this.max;
	            //convert the min and the max
	            this._units = val;
	            this.min = currentMin;
	            this.max = currentMax;
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.LFO#
		 * @type {Boolean}
		 * @name mute
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'mute', {
	        get: function () {
	            return this._oscillator.mute;
	        },
	        set: function (mute) {
	            this._oscillator.mute = mute;
	        }
	    });
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.LFO#
		 *  @name state
		 */
	    Object.defineProperty(Tone.LFO.prototype, 'state', {
	        get: function () {
	            return this._oscillator.state;
	        }
	    });
	    /**
		 *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node.
		 *  Tone.LFO will automatically convert to the destination units of the
		 *  will get the units from the connected node.
		 *  @param  {Tone | AudioParam | AudioNode} node
		 *  @param {number} [outputNum=0] optionally which output to connect from
		 *  @param {number} [inputNum=0] optionally which input to connect to
		 *  @returns {Tone.LFO} this
		 *  @private
		 */
	    Tone.LFO.prototype.connect = function (node) {
	        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {
	            this.convert = node.convert;
	            this.units = node.units;
	        }
	        Tone.Signal.prototype.connect.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  private method borrowed from Param converts
		 *  units from their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;
	    /**
		 *  private method borrowed from Param converts
		 *  units to their destination value
		 *  @function
		 *  @private
		 */
	    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;
	    /**
		 *  disconnect and dispose
		 *  @returns {Tone.LFO} this
		 */
	    Tone.LFO.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'amplitude',
	            'frequency'
	        ]);
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._stoppedSignal.dispose();
	        this._stoppedSignal = null;
	        this._zeros.dispose();
	        this._zeros = null;
	        this._scaler.dispose();
	        this._scaler = null;
	        this._a2g.dispose();
	        this._a2g = null;
	        this.frequency = null;
	        this.amplitude = null;
	        return this;
	    };
	    return Tone.LFO;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Limiter will limit the loudness of an incoming signal.
		 *         It is composed of a Tone.Compressor with a fast attack
		 *         and release. Limiters are commonly used to safeguard against
		 *         signal clipping. Unlike a compressor, limiters do not provide
		 *         smooth gain reduction and almost completely prevent
		 *         additional gain above the threshold.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {number} threshold The theshold above which the limiting is applied.
		 *  @example
		 *  var limiter = new Tone.Limiter(-6);
		 */
	    Tone.Limiter = function () {
	        var options = Tone.defaults(arguments, ['threshold'], Tone.Limiter);
	        Tone.AudioNode.call(this);
	        /**
			 *  the compressor
			 *  @private
			 *  @type {Tone.Compressor}
			 */
	        this._compressor = this.input = this.output = new Tone.Compressor({
	            'attack': 0.001,
	            'decay': 0.001,
	            'threshold': options.threshold
	        });
	        /**
			 * The threshold of of the limiter
			 * @type {Decibel}
			 * @signal
			 */
	        this.threshold = this._compressor.threshold;
	        this._readOnly('threshold');
	    };
	    Tone.extend(Tone.Limiter, Tone.AudioNode);
	    /**
		 *  The default value
		 *  @type {Object}
		 *  @const
		 *  @static
		 */
	    Tone.Limiter.defaults = { 'threshold': -12 };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Limiter} this
		 */
	    Tone.Limiter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._compressor.dispose();
	        this._compressor = null;
	        this._writable('threshold');
	        this.threshold = null;
	        return this;
	    };
	    return Tone.Limiter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to
		 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Time|Object} [delayTime] The delay time of the comb filter
		 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
		 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
		 *                                signal as it is fedback.
		 */
	    Tone.LowpassCombFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'resonance',
	            'dampening'
	        ], Tone.LowpassCombFilter);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the delay node
			 *  @type {DelayNode}
			 *  @private
			 */
	        this._delay = this.input = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the comb filter.
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delay.delayTime;
	        /**
			 *  the lowpass filter
			 *  @type  {BiquadFilterNode}
			 *  @private
			 */
	        this._lowpass = this.output = this.context.createBiquadFilter();
	        this._lowpass.Q.value = -3.0102999566398125;
	        this._lowpass.type = 'lowpass';
	        /**
			 *  The dampening control of the feedback
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Param({
	            'param': this._lowpass.frequency,
	            'units': Tone.Type.Frequency,
	            'value': options.dampening
	        });
	        /**
			 *  the feedback gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);
	        /**
			 *  The amount of feedback of the delayed signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._feedback.gain;
	        //connections
	        this._delay.chain(this._lowpass, this._feedback, this._delay);
	        this._readOnly([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	    };
	    Tone.extend(Tone.LowpassCombFilter, Tone.AudioNode);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.LowpassCombFilter.defaults = {
	        'delayTime': 0.1,
	        'resonance': 0.5,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.LowpassCombFilter} this
		 */
	    Tone.LowpassCombFilter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'dampening',
	            'resonance',
	            'delayTime'
	        ]);
	        this.dampening.dispose();
	        this.dampening = null;
	        this.resonance.dispose();
	        this.resonance = null;
	        this._delay.dispose();
	        this._delay = null;
	        this.delayTime = null;
	        this._lowpass.disconnect();
	        this._lowpass = null;
	        this._feedback.disconnect();
	        this._feedback = null;
	        return this;
	    };
	    return Tone.LowpassCombFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Merge brings two signals into the left and right
		 *          channels of a single stereo channel.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var merge = new Tone.Merge().toMaster();
		 * //routing a sine tone in the left channel
		 * //and noise in the right channel
		 * var osc = new Tone.Oscillator().connect(merge.left);
		 * var noise = new Tone.Noise().connect(merge.right);
		 * //starting our oscillators
		 * noise.start();
		 * osc.start();
		 */
	    Tone.Merge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The left input channel.
			 *  Alias for <code>input[0]</code>
			 *  @type {GainNode}
			 */
	        this.left = this.input[0] = new Tone.Gain();
	        /**
			 *  The right input channel.
			 *  Alias for <code>input[1]</code>.
			 *  @type {GainNode}
			 */
	        this.right = this.input[1] = new Tone.Gain();
	        /**
			 *  the merger node for the two channels
			 *  @type {ChannelMergerNode}
			 *  @private
			 */
	        this._merger = this.output = this.context.createChannelMerger(2);
	        //connections
	        this.left.connect(this._merger, 0, 0);
	        this.right.connect(this._merger, 0, 1);
	        this.left.channelCount = 1;
	        this.right.channelCount = 1;
	        this.left.channelCountMode = 'explicit';
	        this.right.channelCountMode = 'explicit';
	    };
	    Tone.extend(Tone.Merge, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Merge} this
		 */
	    Tone.Merge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._merger.disconnect();
	        this._merger = null;
	        return this;
	    };
	    return Tone.Merge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
		 *          of an input signal with some averaging applied. It can also get the raw
		 *          value of the input signal.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Number} smoothing The amount of smoothing applied between frames.
		 *  @example
		 * var meter = new Tone.Meter();
		 * var mic = new Tone.UserMedia().open();
		 * //connect mic to the meter
		 * mic.connect(meter);
		 * //the current level of the mic input in decibels
		 * var level = meter.getValue();
		 */
	    Tone.Meter = function () {
	        var options = Tone.defaults(arguments, ['smoothing'], Tone.Meter);
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node which computes the levels.
			 *  @private
			 *  @type  {Tone.Analyser}
			 */
	        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 1024);
	        /**
			 *  The amount of carryover between the current and last frame.
			 *  Only applied meter for "level" type.
			 *  @type  {Number}
			 */
	        this.smoothing = options.smoothing;
	    };
	    Tone.extend(Tone.Meter, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type {Object}
		 *  @static
		 *  @const
		 */
	    Tone.Meter.defaults = { 'smoothing': 0.8 };
	    /**
		 *  Get the current decibel value of the incoming signal
		 *  @returns {Decibels}
		 */
	    Tone.Meter.prototype.getLevel = function () {
	        this._analyser.type = 'fft';
	        var values = this._analyser.getValue();
	        var offset = 28;
	        // normalizes most signal levels
	        // TODO: compute loudness from FFT
	        return Math.max.apply(this, values) + offset;
	    };
	    /**
		 *  Get the signal value of the incoming signal
		 *  @returns {Number}
		 */
	    Tone.Meter.prototype.getValue = function () {
	        this._analyser.type = 'waveform';
	        var value = this._analyser.getValue();
	        return value[0];
	    };
	    /**
		 * A value from 0 -> 1 where 0 represents no time averaging with the last analysis frame.
		 * @memberOf Tone.Meter#
		 * @type {Number}
		 * @name smoothing
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Meter.prototype, 'smoothing', {
	        get: function () {
	            return this._analyser.smoothing;
	        },
	        set: function (val) {
	            this._analyser.smoothing = val;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Meter} this
		 */
	    Tone.Meter.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.dispose();
	        this._analyser = null;
	        return this;
	    };
	    return Tone.Meter;
	});
	Module(function (Tone) {
	    
	    /**
		 *	@class  Tone.Split splits an incoming signal into left and right channels.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var split = new Tone.Split();
		 * stereoSignal.connect(split);
		 */
	    Tone.Split = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  @type {ChannelSplitterNode}
			 *  @private
			 */
	        this._splitter = this.input = this.context.createChannelSplitter(2);
	        this._splitter.channelCount = 2;
	        this._splitter.channelCountMode = 'explicit';
	        /**
			 *  Left channel output.
			 *  Alias for <code>output[0]</code>
			 *  @type {Tone.Gain}
			 */
	        this.left = this.output[0] = new Tone.Gain();
	        /**
			 *  Right channel output.
			 *  Alias for <code>output[1]</code>
			 *  @type {Tone.Gain}
			 */
	        this.right = this.output[1] = new Tone.Gain();
	        //connections
	        this._splitter.connect(this.left, 0, 0);
	        this._splitter.connect(this.right, 1, 0);
	    };
	    Tone.extend(Tone.Split, Tone.AudioNode);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Split} this
		 */
	    Tone.Split.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.disconnect();
	        this.left.dispose();
	        this.left = null;
	        this.right.dispose();
	        this.right = null;
	        this._splitter = null;
	        return this;
	    };
	    return Tone.Split;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels). <br><br>
		 *         <code>
		 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
		 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideSplit = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(0, 2);
	        /**
			 *  split the incoming signal into left and right channels
			 *  @type  {Tone.Split}
			 *  @private
			 */
	        this._split = this.input = new Tone.Split();
	        /**
			 *  The mid send. Connect to mid processing. Alias for
			 *  <code>output[0]</code>
			 *  @type {Tone.Expr}
			 */
	        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side output. Connect to side processing. Alias for
			 *  <code>output[1]</code>
			 *  @type {Tone.Expr}
			 */
	        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
	        this._split.connect(this.mid, 0, 0);
	        this._split.connect(this.mid, 1, 1);
	        this._split.connect(this.side, 0, 0);
	        this._split.connect(this.side, 1, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this.mid, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this.side, 0, 2);
	    };
	    Tone.extend(Tone.MidSideSplit, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideSplit} this
		 */
	    Tone.MidSideSplit.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._split.dispose();
	        this._split = null;
	        return this;
	    };
	    return Tone.MidSideSplit;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal
		 *         (which comes out of both the left and the right channel)
		 *         and the 'side' (which only comes out of the the side channels).
		 *         MidSideMerge merges the mid and side signal after they've been seperated
		 *         by Tone.MidSideSplit.<br><br>
		 *         <code>
		 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
		 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
		 *         </code>
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.MidSideMerge = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(2, 0);
	        /**
			 *  The mid signal input. Alias for
			 *  <code>input[0]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.mid = this.input[0] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Left
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._left = new Tone.Expr('($0 + $1) * $2');
	        /**
			 *  The side signal input. Alias for
			 *  <code>input[1]</code>
			 *  @type  {Tone.Gain}
			 */
	        this.side = this.input[1] = new Tone.Gain();
	        /**
			 *  recombine the mid/side into Right
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._right = new Tone.Expr('($0 - $1) * $2');
	        /**
			 *  Merge the left/right signal back into a stereo signal.
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.mid.connect(this._left, 0, 0);
	        this.side.connect(this._left, 0, 1);
	        this.mid.connect(this._right, 0, 0);
	        this.side.connect(this._right, 0, 1);
	        this._left.connect(this._merge, 0, 0);
	        this._right.connect(this._merge, 0, 1);
	        this.context.getConstant(Math.SQRT1_2).connect(this._left, 0, 2);
	        this.context.getConstant(Math.SQRT1_2).connect(this._right, 0, 2);
	    };
	    Tone.extend(Tone.MidSideMerge, Tone.AudioNode);
	    /**
		 *  clean up
		 *  @returns {Tone.MidSideMerge} this
		 */
	    Tone.MidSideMerge.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._left.dispose();
	        this._left = null;
	        this._right.dispose();
	        this._right = null;
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.MidSideMerge;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.MidSideCompressor applies two different compressors to the mid
		 *         and side signal components. See Tone.MidSideSplit.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} options The options that are passed to the mid and side
		 *                          compressors.
		 *  @constructor
		 */
	    Tone.MidSideCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(options, Tone.MidSideCompressor.defaults);
	        /**
			 *  the mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = this.input = new Tone.MidSideSplit();
	        /**
			 *  the mid/side recombination
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = this.output = new Tone.MidSideMerge();
	        /**
			 *  The compressor applied to the mid signal
			 *  @type  {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the side signal
			 *  @type  {Tone.Compressor}
			 */
	        this.side = new Tone.Compressor(options.side);
	        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
	        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
	        this._readOnly([
	            'mid',
	            'side'
	        ]);
	    };
	    Tone.extend(Tone.MidSideCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MidSideCompressor.defaults = {
	        'mid': {
	            'ratio': 3,
	            'threshold': -24,
	            'release': 0.03,
	            'attack': 0.02,
	            'knee': 16
	        },
	        'side': {
	            'ratio': 6,
	            'threshold': -30,
	            'release': 0.25,
	            'attack': 0.03,
	            'knee': 10
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MidSideCompressor} this
		 */
	    Tone.MidSideCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'mid',
	            'side'
	        ]);
	        this.mid.dispose();
	        this.mid = null;
	        this.side.dispose();
	        this.side = null;
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        return this;
	    };
	    return Tone.MidSideCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
		 *         where both left and right channels have the same value. This can be useful
		 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 */
	    Tone.Mono = function () {
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 0);
	        /**
			 *  merge the signal
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = this.output = new Tone.Merge();
	        this.input.connect(this._merge, 0, 0);
	        this.input.connect(this._merge, 0, 1);
	        this.input.gain.value = Tone.dbToGain(-10);
	    };
	    Tone.extend(Tone.Mono);
	    /**
		 *  clean up
		 *  @returns {Tone.Mono} this
		 */
	    Tone.Mono.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._merge.dispose();
	        this._merge = null;
	        return this;
	    };
	    return Tone.Mono;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A compressor with seperate controls over low/mid/high dynamics
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {Object} options The low/mid/high compressor settings.
		 *  @example
		 *  var multiband = new Tone.MultibandCompressor({
		 *  	"lowFrequency" : 200,
		 *  	"highFrequency" : 1300
		 *  	"low" : {
		 *  		"threshold" : -12
		 *  	}
		 *  })
		 */
	    Tone.MultibandCompressor = function (options) {
	        Tone.AudioNode.call(this);
	        options = Tone.defaultArg(arguments, Tone.MultibandCompressor.defaults);
	        /**
			 *  split the incoming signal into high/mid/low
			 *  @type {Tone.MultibandSplit}
			 *  @private
			 */
	        this._splitter = this.input = new Tone.MultibandSplit({
	            'lowFrequency': options.lowFrequency,
	            'highFrequency': options.highFrequency
	        });
	        /**
			 *  low/mid crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.lowFrequency = this._splitter.lowFrequency;
	        /**
			 *  mid/high crossover frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.highFrequency = this._splitter.highFrequency;
	        /**
			 *  the output
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.output = new Tone.Gain();
	        /**
			 *  The compressor applied to the low frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.low = new Tone.Compressor(options.low);
	        /**
			 *  The compressor applied to the mid frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.mid = new Tone.Compressor(options.mid);
	        /**
			 *  The compressor applied to the high frequencies.
			 *  @type {Tone.Compressor}
			 */
	        this.high = new Tone.Compressor(options.high);
	        //connect the compressor
	        this._splitter.low.chain(this.low, this.output);
	        this._splitter.mid.chain(this.mid, this.output);
	        this._splitter.high.chain(this.high, this.output);
	        this._readOnly([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	    };
	    Tone.extend(Tone.MultibandCompressor, Tone.AudioNode);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MultibandCompressor.defaults = {
	        'low': Tone.Compressor.defaults,
	        'mid': Tone.Compressor.defaults,
	        'high': Tone.Compressor.defaults,
	        'lowFrequency': 250,
	        'highFrequency': 2000
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MultibandCompressor} this
		 */
	    Tone.MultibandCompressor.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._splitter.dispose();
	        this._writable([
	            'high',
	            'mid',
	            'low',
	            'highFrequency',
	            'lowFrequency'
	        ]);
	        this.low.dispose();
	        this.mid.dispose();
	        this.high.dispose();
	        this._splitter = null;
	        this.low = null;
	        this.mid = null;
	        this.high = null;
	        this.lowFrequency = null;
	        this.highFrequency = null;
	        return this;
	    };
	    return Tone.MultibandCompressor;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
		 *          support 3D. Panner uses the StereoPannerNode when available.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange} [initialPan=0] The initail panner value (center).
		 *  @example
		 *  //pan the input signal hard right.
		 *  var panner = new Tone.Panner(1);
		 */
	    Tone.Panner = function (initialPan) {
	        Tone.AudioNode.call(this);
	        if (Tone.Panner.hasStereoPanner) {
	            /**
				 *  the panner node
				 *  @type {StereoPannerNode}
				 *  @private
				 */
	            this._panner = this.input = this.output = this.context.createStereoPanner();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {NormalRange}
				 *  @signal
				 */
	            this.pan = this._panner.pan;
	        } else {
	            /**
				 *  the dry/wet knob
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
	            this._crossFade = new Tone.CrossFade();
	            /**
				 *  @type {Tone.Merge}
				 *  @private
				 */
	            this._merger = this.output = new Tone.Merge();
	            /**
				 *  @type {Tone.Split}
				 *  @private
				 */
	            this._splitter = this.input = new Tone.Split();
	            /**
				 *  The pan control. -1 = hard left, 1 = hard right.
				 *  @type {AudioRange}
				 *  @signal
				 */
	            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);
	            /**
				 *  always sends 0
				 *  @type {Tone.Zero}
				 *  @private
				 */
	            this._zero = new Tone.Zero();
	            /**
				 *  The analog to gain conversion
				 *  @type  {Tone.AudioToGain}
				 *  @private
				 */
	            this._a2g = new Tone.AudioToGain();
	            //CONNECTIONS:
	            this._zero.connect(this._a2g);
	            this.pan.chain(this._a2g, this._crossFade.fade);
	            //left channel is a, right channel is b
	            this._splitter.connect(this._crossFade, 0, 0);
	            this._splitter.connect(this._crossFade, 1, 1);
	            //merge it back together
	            this._crossFade.a.connect(this._merger, 0, 0);
	            this._crossFade.b.connect(this._merger, 0, 1);
	        }
	        //initial value
	        this.pan.value = Tone.defaultArg(initialPan, 0);
	        this._readOnly('pan');
	    };
	    Tone.extend(Tone.Panner, Tone.AudioNode);
	    /**
		 *  Indicates if the panner is using the new StereoPannerNode internally
		 *  @type  {Boolean}
		 *  @static
		 *  @private
		 *  @readOnly
		 */
	    Tone.Panner.hasStereoPanner = Tone.context && Tone.isFunction(Tone.context.createStereoPanner);
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner} this
		 */
	    Tone.Panner.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable('pan');
	        if (Tone.Panner.hasStereoPanner) {
	            this._panner.disconnect();
	            this._panner = null;
	            this.pan = null;
	        } else {
	            this._zero.dispose();
	            this._zero = null;
	            this._crossFade.dispose();
	            this._crossFade = null;
	            this._splitter.dispose();
	            this._splitter = null;
	            this._merger.dispose();
	            this._merger = null;
	            this.pan.dispose();
	            this.pan = null;
	            this._a2g.dispose();
	            this._a2g = null;
	        }
	        return this;
	    };
	    return Tone.Panner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  A spatialized panner node which supports equalpower or HRTF panning.
		 *          Tries to normalize the API across various browsers. See Tone.Listener
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Number} positionX The initial x position.
		 *  @param {Number} positionY The initial y position.
		 *  @param {Number} positionZ The initial z position.
		 */
	    Tone.Panner3D = function () {
	        var options = Tone.defaults(arguments, [
	            'positionX',
	            'positionY',
	            'positionZ'
	        ], Tone.Panner3D);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panner node
			 *  @type {PannerNode}
			 *  @private
			 */
	        this._panner = this.input = this.output = this.context.createPanner();
	        //set some values
	        this._panner.panningModel = options.panningModel;
	        this._panner.maxDistance = options.maxDistance;
	        this._panner.distanceModel = options.distanceModel;
	        this._panner.coneOuterGain = options.coneOuterGain;
	        this._panner.coneOuterAngle = options.coneOuterAngle;
	        this._panner.coneInnerAngle = options.coneInnerAngle;
	        this._panner.refDistance = options.refDistance;
	        this._panner.rolloffFactor = options.rolloffFactor;
	        /**
			 *  Holds the current orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            options.orientationX,
	            options.orientationY,
	            options.orientationZ
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            options.positionX,
	            options.positionY,
	            options.positionZ
	        ];
	        // set the default position/orientation
	        this.orientationX = options.orientationX;
	        this.orientationY = options.orientationY;
	        this.orientationZ = options.orientationZ;
	        this.positionX = options.positionX;
	        this.positionY = options.positionY;
	        this.positionZ = options.positionZ;
	    };
	    Tone.extend(Tone.Panner3D, Tone.AudioNode);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Panner3D.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'orientationX': 0,
	        'orientationY': 0,
	        'orientationZ': 0,
	        'panningModel': 'equalpower',
	        'maxDistance': 10000,
	        'distanceModel': 'inverse',
	        'coneOuterGain': 0,
	        'coneOuterAngle': 360,
	        'coneInnerAngle': 360,
	        'refDistance': 1,
	        'rolloffFactor': 1
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Panner3D.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setPosition = function (x, y, z) {
	        if (this._panner.positionX) {
	            var now = this.now();
	            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the source in 3d space.
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {
	        if (this._panner.orientationX) {
	            var now = this.now();
	            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this._panner.setOrientation(x, y, z);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationX
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationY
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z orientation of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name orientationZ
		 */
	    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  Proxy a property on the panner to an exposed public propery
		 *  @param  {String}  prop
		 *  @private
		 */
	    Tone.Panner3D._aliasProperty = function (prop) {
	        Object.defineProperty(Tone.Panner3D.prototype, prop, {
	            set: function (val) {
	                this._panner[prop] = val;
	            },
	            get: function () {
	                return this._panner[prop];
	            }
	        });
	    };
	    /**
		 *  The panning model. Either "equalpower" or "HRTF".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name panningModel
		 */
	    Tone.Panner3D._aliasProperty('panningModel');
	    /**
		 *  A reference distance for reducing volume as source move further from the listener
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name refDistance
		 */
	    Tone.Panner3D._aliasProperty('refDistance');
	    /**
		 *  Describes how quickly the volume is reduced as source moves away from listener.
		 *  @type {Number}
		 *  @memberOf Tone.Panner3D#
		 *  @name rolloffFactor
		 */
	    Tone.Panner3D._aliasProperty('rolloffFactor');
	    /**
		 *  The distance model used by,  "linear", "inverse", or "exponential".
		 *  @type {String}
		 *  @memberOf Tone.Panner3D#
		 *  @name distanceModel
		 */
	    Tone.Panner3D._aliasProperty('distanceModel');
	    /**
		 *  The angle, in degrees, inside of which there will be no volume reduction
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneInnerAngle
		 */
	    Tone.Panner3D._aliasProperty('coneInnerAngle');
	    /**
		 *  The angle, in degrees, outside of which the volume will be reduced
		 *  to a constant value of coneOuterGain
		 *  @type {Degrees}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterAngle
		 */
	    Tone.Panner3D._aliasProperty('coneOuterAngle');
	    /**
		 *  The gain outside of the coneOuterAngle
		 *  @type {Gain}
		 *  @memberOf Tone.Panner3D#
		 *  @name coneOuterGain
		 */
	    Tone.Panner3D._aliasProperty('coneOuterGain');
	    /**
		 *  The maximum distance between source and listener,
		 *  after which the volume will not be reduced any further.
		 *  @type {Positive}
		 *  @memberOf Tone.Panner3D#
		 *  @name maxDistance
		 */
	    Tone.Panner3D._aliasProperty('maxDistance');
	    /**
		 *  Clean up.
		 *  @returns {Tone.Panner3D} this
		 */
	    Tone.Panner3D.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._panner.disconnect();
	        this._panner = null;
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    return Tone.Panner3D;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
		 *
		 *  @extends {Tone.AudioNode}
		 *  @constructor
		 *  @param {AudioRange} pan the initial pan
		 *  @param {number} volume The output volume.
		 *  @example
		 * //pan the incoming signal left and drop the volume
		 * var panVol = new Tone.PanVol(-0.25, -12);
		 */
	    Tone.PanVol = function () {
	        var options = Tone.defaults(arguments, [
	            'pan',
	            'volume'
	        ], Tone.PanVol);
	        Tone.AudioNode.call(this);
	        /**
			 *  The panning node
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = this.input = new Tone.Panner(options.pan);
	        /**
			 *  The L/R panning control.
			 *  @type {AudioRange}
			 *  @signal
			 */
	        this.pan = this._panner.pan;
	        /**
			 *  The volume node
			 *  @type {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 *  The volume control in decibels.
			 *  @type {Decibels}
			 *  @signal
			 */
	        this.volume = this._volume.volume;
	        //connections
	        this._panner.connect(this._volume);
	        this.mute = options.mute;
	        this._readOnly([
	            'pan',
	            'volume'
	        ]);
	    };
	    Tone.extend(Tone.PanVol, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 *  @static
		 */
	    Tone.PanVol.defaults = {
	        'pan': 0,
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 * Mute/unmute the volume
		 * @memberOf Tone.PanVol#
		 * @name mute
		 * @type {Boolean}
		 */
	    Object.defineProperty(Tone.PanVol.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.PanVol} this
		 */
	    Tone.PanVol.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._writable([
	            'pan',
	            'volume'
	        ]);
	        this._panner.dispose();
	        this._panner = null;
	        this.pan = null;
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    return Tone.PanVol;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Solo lets you isolate a specific audio stream. When
		 *         an instance is set to `solo=true`, it will mute all other instances.
		 *  @extends {Tone.AudioNode}
		 *  @example
		 * var soloA = new Tone.Solo()
		 * var soloB = new Tone.Solo()
		 * soloA.solo = true
		 * //no audio will pass through soloB
		 */
	    Tone.Solo = function () {
	        var options = Tone.defaults(arguments, ['solo'], Tone.Solo);
	        Tone.AudioNode.call(this);
	        /**
			 *  The input and output node
			 *  @type  {Tone.Gain}
			 */
	        this.input = this.output = new Tone.Gain();
	        /**
			 *  A bound _soloed method
			 *  @type  {Function}
			 *  @private
			 */
	        this._soloBind = this._soloed.bind(this);
	        //listen for solo events class-wide.
	        this.context.on('solo', this._soloBind);
	        //set initially
	        this.solo = options.solo;
	    };
	    Tone.extend(Tone.Solo, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.Solo.defaults = { solo: false };
	    /**
		 *  Isolates this instance and mutes all other instances of Tone.Solo.
		 *  Only one instance can be soloed at a time. A soloed
		 *  instance will report `solo=false` when another instance is soloed.
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name solo
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'solo', {
	        get: function () {
	            return this._isSoloed();
	        },
	        set: function (solo) {
	            if (solo) {
	                this._addSolo();
	            } else {
	                this._removeSolo();
	            }
	            this.context.emit('solo', this);
	        }
	    });
	    /**
		 *  If the current instance is muted, i.e. another instance is soloed
		 *  @memberOf Tone.Solo#
		 *  @type {Boolean}
		 *  @name muted
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Solo.prototype, 'muted', {
	        get: function () {
	            return this.input.gain.value === 0;
	        }
	    });
	    /**
		 * Add this to the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._addSolo = function () {
	        if (!Tone.isArray(this.context._currentSolo)) {
	            this.context._currentSolo = [];
	        }
	        if (!this._isSoloed()) {
	            this.context._currentSolo.push(this);
	        }
	    };
	    /**
		 * Remove this from the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._removeSolo = function () {
	        if (this._isSoloed()) {
	            var index = this.context._currentSolo.indexOf(this);
	            this.context._currentSolo.splice(index, 1);
	        }
	    };
	    /**
		 * @return {Boolean} Is this on the soloed array
		 * @private
		 */
	    Tone.Solo.prototype._isSoloed = function () {
	        if (Tone.isArray(this.context._currentSolo)) {
	            return this.context._currentSolo.length !== 0 && this.context._currentSolo.indexOf(this) !== -1;
	        } else {
	            return false;
	        }
	    };
	    /**
		 * @return {Boolean} Returns true if no one is soloed
		 * @private
		 */
	    Tone.Solo.prototype._noSolos = function () {
	        return !Tone.isArray(this.context._currentSolo) || this.context._currentSolo.length === 0;
	    };
	    /**
		 *  Solo the current instance and unsolo all other instances.
		 *  @param  {Tone.Solo}  instance  The instance which is being soloed/unsoloed.
		 *  @private
		 */
	    Tone.Solo.prototype._soloed = function () {
	        if (this._isSoloed()) {
	            this.input.gain.value = 1;
	        } else if (this._noSolos()) {
	            //no one is soloed
	            this.input.gain.value = 1;
	        } else {
	            this.input.gain.value = 0;
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.Solo}  this
		 */
	    Tone.Solo.prototype.dispose = function () {
	        this.context.off('solo', this._soloBind);
	        this._removeSolo();
	        this._soloBind = null;
	        Tone.AudioNode.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Solo;
	});
	Module(function (Tone) {
	    /**
		 *  @class  Get the current waveform data of the connected audio source.
		 *  @extends {Tone.AudioNode}
		 *  @param {Number=} size The size of the FFT. Value must be a power of
		 *                       two in the range 32 to 32768.
		 */
	    Tone.Waveform = function () {
	        var options = Tone.defaults(arguments, ['size'], Tone.Waveform);
	        options.type = Tone.Analyser.Type.Waveform;
	        Tone.AudioNode.call(this);
	        /**
			 *  The analyser node.
			 *  @private
			 *  @type {Tone.Analyser}
			 */
	        this._analyser = this.input = this.output = new Tone.Analyser(options);
	    };
	    Tone.extend(Tone.Waveform, Tone.AudioNode);
	    /**
		 *  The default values.
		 *  @type {Object}
		 *  @const
		 */
	    Tone.Waveform.defaults = { 'size': 1024 };
	    /**
		 *  Gets the waveform of the audio source. Returns the waveform data
		 *  of length [size](#size) as a Float32Array with values between -1 and 1.
		 *  @returns {TypedArray}
		 */
	    Tone.Waveform.prototype.getValue = function () {
	        return this._analyser.getValue();
	    };
	    /**
		 *  The size of analysis. This must be a power of two in the range 32 to 32768.
		 *  @memberOf Tone.Waveform#
		 *  @type {Number}
		 *  @name size
		 */
	    Object.defineProperty(Tone.Waveform.prototype, 'size', {
	        get: function () {
	            return this._analyser.size;
	        },
	        set: function (size) {
	            this._analyser.size = size;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.Waveform}  this
		 */
	    Tone.Waveform.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._analyser.dispose();
	        this._analyser = null;
	    };
	    return Tone.Waveform;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlInterpolate will interpolate between given values based
		 *         on the "index" property. Passing in an array or object literal
		 *         will interpolate each of the parameters. Note (i.e. "C3")
		 *         and Time (i.e. "4n + 2") can be interpolated. All other values are
		 *         assumed to be numbers. 
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);
		 * interp.index = 0.75;
		 * interp.value; //returns 1.5
		 *
		 *  @example
		 * var interp = new Tone.CtrlInterpolate([
		 * 	[2, 4, 5],
		 * 	[9, 3, 2],
		 * ]);
		 * @param {Array} values The array of values to interpolate over
		 * @param {Positive} index The initial interpolation index.
		 * @extends {Tone}
		 */
	    Tone.CtrlInterpolate = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'index'
	        ], Tone.CtrlInterpolate);
	        Tone.call(this);
	        /**
			 *  The values to interpolate between
			 *  @type  {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The interpolated index between values. For example: a value of 1.5
			 *  would interpolate equally between the value at index 1
			 *  and the value at index 2. 
			 *  @example
			 * interp.index = 0; 
			 * interp.value; //returns the value at 0
			 * interp.index = 0.5;
			 * interp.value; //returns the value between indices 0 and 1. 
			 *  @type  {Positive}
			 */
	        this.index = options.index;
	    };
	    Tone.extend(Tone.CtrlInterpolate);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlInterpolate.defaults = {
	        'index': 0,
	        'values': []
	    };
	    /**
		 *  The current interpolated value based on the index
		 *  @readOnly
		 *  @memberOf Tone.CtrlInterpolate#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {
	        get: function () {
	            var index = this.index;
	            index = Math.min(index, this.values.length - 1);
	            var lowerPosition = Math.floor(index);
	            var lower = this.values[lowerPosition];
	            var upper = this.values[Math.ceil(index)];
	            return this._interpolate(index - lowerPosition, lower, upper);
	        }
	    });
	    /**
		 *  Internal interpolation routine
		 *  @param  {NormalRange}  index  The index between the lower and upper
		 *  @param  {*}  lower 
		 *  @param  {*}  upper 
		 *  @return  {*}  The interpolated value
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {
	        if (Tone.isArray(lower)) {
	            var retArray = [];
	            for (var i = 0; i < lower.length; i++) {
	                retArray[i] = this._interpolate(index, lower[i], upper[i]);
	            }
	            return retArray;
	        } else if (Tone.isObject(lower)) {
	            var retObj = {};
	            for (var attr in lower) {
	                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);
	            }
	            return retObj;
	        } else {
	            lower = this._toNumber(lower);
	            upper = this._toNumber(upper);
	            return (1 - index) * lower + index * upper;
	        }
	    };
	    /**
		 *  Convert from the given type into a number
		 *  @param  {Number|String}  value
		 *  @return  {Number}
		 *  @private
		 */
	    Tone.CtrlInterpolate.prototype._toNumber = function (val) {
	        if (Tone.isNumber(val)) {
	            return val;
	        } else {
	            //otherwise assume that it's Time...
	            return this.toSeconds(val);
	        }
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlInterpolate}  this
		 */
	    Tone.CtrlInterpolate.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlInterpolate;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.CtrlMarkov represents a Markov Chain where each call
		 *         to Tone.CtrlMarkov.next will move to the next state. If the next
		 *         state choice is an array, the next state is chosen randomly with
		 *         even probability for all of the choices. For a weighted probability
		 *         of the next choices, pass in an object with "state" and "probability" attributes. 
		 *         The probabilities will be normalized and then chosen. If no next options
		 *         are given for the current state, the state will stay there. 
		 *  @extends {Tone}
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : ["end", "middle"],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" or "middle" with 50% probability
		 *
		 *  @example
		 * var chain = new Tone.CtrlMarkov({
		 * 	"beginning" : [{"value" : "end", "probability" : 0.8}, 
		 * 					{"value" : "middle", "probability" : 0.2}],
		 * 	"middle" : "end"
		 * });
		 * chain.value = "beginning";
		 * chain.next(); //returns "end" with 80% probability or "middle" with 20%.
		 *  @param {Object} values An object with the state names as the keys
		 *                         and the next state(s) as the values. 
		 */
	    Tone.CtrlMarkov = function (values, initial) {
	        Tone.call(this);
	        /**
			 *  The Markov values with states as the keys
			 *  and next state(s) as the values. 
			 *  @type {Object}
			 */
	        this.values = Tone.defaultArg(values, {});
	        /**
			 *  The current state of the Markov values. The next
			 *  state will be evaluated and returned when Tone.CtrlMarkov.next
			 *  is invoked.
			 *  @type {String}
			 */
	        this.value = Tone.defaultArg(initial, Object.keys(this.values)[0]);
	    };
	    Tone.extend(Tone.CtrlMarkov);
	    /**
		 *  Returns the next state of the Markov values. 
		 *  @return  {String}
		 */
	    Tone.CtrlMarkov.prototype.next = function () {
	        if (this.values.hasOwnProperty(this.value)) {
	            var next = this.values[this.value];
	            if (Tone.isArray(next)) {
	                var distribution = this._getProbDistribution(next);
	                var rand = Math.random();
	                var total = 0;
	                for (var i = 0; i < distribution.length; i++) {
	                    var dist = distribution[i];
	                    if (rand > total && rand < total + dist) {
	                        var chosen = next[i];
	                        if (Tone.isObject(chosen)) {
	                            this.value = chosen.value;
	                        } else {
	                            this.value = chosen;
	                        }
	                    }
	                    total += dist;
	                }
	            } else {
	                this.value = next;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Choose randomly from an array weighted options in the form 
		 *  {"state" : string, "probability" : number} or an array of values
		 *  @param  {Array}  options 
		 *  @return  {Array}  The randomly selected choice
		 *  @private
		 */
	    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {
	        var distribution = [];
	        var total = 0;
	        var needsNormalizing = false;
	        for (var i = 0; i < options.length; i++) {
	            var option = options[i];
	            if (Tone.isObject(option)) {
	                needsNormalizing = true;
	                distribution[i] = option.probability;
	            } else {
	                distribution[i] = 1 / options.length;
	            }
	            total += distribution[i];
	        }
	        if (needsNormalizing) {
	            //normalize the values
	            for (var j = 0; j < distribution.length; j++) {
	                distribution[j] = distribution[j] / total;
	            }
	        }
	        return distribution;
	    };
	    /**
		 *  Clean up
		 *  @return  {Tone.CtrlMarkov}  this
		 */
	    Tone.CtrlMarkov.prototype.dispose = function () {
	        this.values = null;
	    };
	    return Tone.CtrlMarkov;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Generate patterns from an array of values.
		 *         Has a number of arpeggiation and randomized
		 *         selection patterns. 
		 *           <ul>
		 *  	        <li>"up" - cycles upward</li>
		 *  			<li>"down" - cycles downward</li>
		 *  			<li>"upDown" - up then and down</li>
		 *  			<li>"downUp" - cycles down then and up</li>
		 *  			<li>"alternateUp" - jump up two and down one</li>
		 *  			<li>"alternateDown" - jump down two and up one</li>
		 *  			<li>"random" - randomly select an index</li>
		 *  			<li>"randomWalk" - randomly moves one index away from the current position</li>
		 *  			<li>"randomOnce" - randomly select an index without repeating until all values have been chosen.</li>
		 *     		</ul>
		 *  @param  {Array}  values   An array of options to choose from.
		 *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.
		 *  @extends {Tone}
		 */
	    Tone.CtrlPattern = function () {
	        var options = Tone.defaults(arguments, [
	            'values',
	            'type'
	        ], Tone.CtrlPattern);
	        Tone.call(this);
	        /**
			 *  The array of values to arpeggiate over
			 *  @type {Array}
			 */
	        this.values = options.values;
	        /**
			 *  The current position in the values array
			 *  @type  {Number}
			 */
	        this.index = 0;
	        /**
			 *  The type placeholder
			 *  @type {Tone.CtrlPattern.Type}
			 *  @private
			 */
	        this._type = null;
	        /**
			 *  Shuffled values for the RandomOnce type
			 *  @type {Array}
			 *  @private
			 */
	        this._shuffled = null;
	        /**
			 *  The direction of the movement
			 *  @type {String}
			 *  @private
			 */
	        this._direction = null;
	        this.type = options.type;
	    };
	    Tone.extend(Tone.CtrlPattern);
	    /**
		 *  The Control Patterns
		 *  @type  {Object}
		 *  @static
		 */
	    Tone.CtrlPattern.Type = {
	        Up: 'up',
	        Down: 'down',
	        UpDown: 'upDown',
	        DownUp: 'downUp',
	        AlternateUp: 'alternateUp',
	        AlternateDown: 'alternateDown',
	        Random: 'random',
	        RandomWalk: 'randomWalk',
	        RandomOnce: 'randomOnce'
	    };
	    /**
		 *  The default values. 
		 *  @type  {Object}
		 */
	    Tone.CtrlPattern.defaults = {
	        'type': Tone.CtrlPattern.Type.Up,
	        'values': []
	    };
	    /**
		 *  The value at the current index of the pattern.
		 *  @readOnly
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {
	        get: function () {
	            //some safeguards
	            if (this.values.length === 0) {
	                return;
	            } else if (this.values.length === 1) {
	                return this.values[0];
	            }
	            this.index = Math.min(this.index, this.values.length - 1);
	            var val = this.values[this.index];
	            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {
	                if (this.values.length !== this._shuffled.length) {
	                    this._shuffleValues();
	                }
	                val = this.values[this._shuffled[this.index]];
	            }
	            return val;
	        }
	    });
	    /**
		 *  The pattern used to select the next
		 *  item from the values array
		 *  @memberOf Tone.CtrlPattern#
		 *  @type {Tone.CtrlPattern.Type}
		 *  @name type
		 */
	    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._shuffled = null;
	            //the first index
	            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this.index = 0;
	            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this.index = this.values.length - 1;
	            }
	            //the direction
	            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	            //randoms
	            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {
	                this._shuffleValues();
	            } else if (this._type === Tone.CtrlPattern.Random) {
	                this.index = Math.floor(Math.random() * this.values.length);
	            }
	        }
	    });
	    /**
		 *  Return the next value given the current position
		 *  and pattern.
		 *  @return {*} The next value
		 */
	    Tone.CtrlPattern.prototype.next = function () {
	        var type = this.type;
	        //choose the next index
	        if (type === Tone.CtrlPattern.Type.Up) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Down) {
	            this.index--;
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	            }
	        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index++;
	            } else {
	                this.index--;
	            }
	            if (this.index < 0) {
	                this.index = 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            } else if (this.index >= this.values.length) {
	                this.index = this.values.length - 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        } else if (type === Tone.CtrlPattern.Type.Random) {
	            this.index = Math.floor(Math.random() * this.values.length);
	        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {
	            if (Math.random() < 0.5) {
	                this.index--;
	                this.index = Math.max(this.index, 0);
	            } else {
	                this.index++;
	                this.index = Math.min(this.index, this.values.length - 1);
	            }
	        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {
	            this.index++;
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                //reshuffle the values for next time
	                this._shuffleValues();
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 2;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 1;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index >= this.values.length) {
	                this.index = 0;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {
	            if (this._direction === Tone.CtrlPattern.Type.Up) {
	                this.index += 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            } else {
	                this.index -= 2;
	                this._direction = Tone.CtrlPattern.Type.Up;
	            }
	            if (this.index < 0) {
	                this.index = this.values.length - 1;
	                this._direction = Tone.CtrlPattern.Type.Down;
	            }
	        }
	        return this.value;
	    };
	    /**
		 *  Shuffles the values and places the results into the _shuffled
		 *  @private
		 */
	    Tone.CtrlPattern.prototype._shuffleValues = function () {
	        var copy = [];
	        this._shuffled = [];
	        for (var i = 0; i < this.values.length; i++) {
	            copy[i] = i;
	        }
	        while (copy.length > 0) {
	            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);
	            this._shuffled.push(randVal[0]);
	        }
	    };
	    /**
		 *  Clean up
		 *  @returns {Tone.CtrlPattern} this
		 */
	    Tone.CtrlPattern.prototype.dispose = function () {
	        this._shuffled = null;
	        this.values = null;
	    };
	    return Tone.CtrlPattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Choose a random value.
		 *  @extends {Tone}
		 *  @example
		 * var randomWalk = new Tone.CtrlRandom({
		 * 	"min" : 0,
		 * 	"max" : 10,
		 * 	"integer" : true
		 * });
		 * randomWalk.eval();
		 *
		 *  @param {Number|Time=} min The minimum return value.
		 *  @param {Number|Time=} max The maximum return value.
		 */
	    Tone.CtrlRandom = function () {
	        var options = Tone.defaults(arguments, [
	            'min',
	            'max'
	        ], Tone.CtrlRandom);
	        Tone.call(this);
	        /**
			 *  The minimum return value
			 *  @type  {Number|Time}
			 */
	        this.min = options.min;
	        /**
			 *  The maximum return value
			 *  @type  {Number|Time}
			 */
	        this.max = options.max;
	        /**
			 *  If the return value should be an integer
			 *  @type  {Boolean}
			 */
	        this.integer = options.integer;
	    };
	    Tone.extend(Tone.CtrlRandom);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.CtrlRandom.defaults = {
	        'min': 0,
	        'max': 1,
	        'integer': false
	    };
	    /**
		 *  Return a random value between min and max. 
		 *  @readOnly
		 *  @memberOf Tone.CtrlRandom#
		 *  @type {*}
		 *  @name value
		 */
	    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {
	        get: function () {
	            var min = this.toSeconds(this.min);
	            var max = this.toSeconds(this.max);
	            var rand = Math.random();
	            var val = rand * min + (1 - rand) * max;
	            if (this.integer) {
	                val = Math.floor(val);
	            }
	            return val;
	        }
	    });
	    return Tone.CtrlRandom;
	});
	Module(function (Tone) {
	    
	    /**
		 *  AudioBuffer.copyToChannel polyfill
		 *  @private
		 */
	    if (window.AudioBuffer && !AudioBuffer.prototype.copyToChannel) {
	        AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < channel.length; i++) {
	                channel[i + start] = src[i];
	            }
	        };
	        AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {
	            var channel = this.getChannelData(chanNum);
	            start = start || 0;
	            for (var i = 0; i < dest.length; i++) {
	                dest[i] = channel[i + start];
	            }
	        };
	    }
	    /**
		 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
		 *          classes that make requests for audio files such as Tone.Player,
		 *          Tone.Sampler and Tone.Convolver.
		 *          
		 *          Aside from load callbacks from individual buffers, Tone.Buffer 
		 *  		provides events which keep track of the loading progress 
		 *  		of _all_ of the buffers. These are Tone.Buffer.on("load" / "progress" / "error")
		 *
		 *  @constructor 
		 *  @extends {Tone}
		 *  @param {AudioBuffer|String} url The url to load, or the audio buffer to set. 
		 *  @param {Function=} onload A callback which is invoked after the buffer is loaded. 
		 *                            It's recommended to use `Tone.Buffer.on('load', callback)` instead 
		 *                            since it will give you a callback when _all_ buffers are loaded.
		 *  @param {Function=} onerror The callback to invoke if there is an error
		 *  @example
		 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
		 * 	//the buffer is now available.
		 * 	var buff = buffer.get();
		 * });
		 *  @example
		 * //can load provide fallback extension types if the first type is not supported.
		 * var buffer = new Tone.Buffer("path/to/sound.[mp3|ogg|wav]");
		 */
	    Tone.Buffer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload',
	            'onerror'
	        ], Tone.Buffer);
	        Tone.call(this);
	        /**
			 *  stores the loaded AudioBuffer
			 *  @type {AudioBuffer}
			 *  @private
			 */
	        this._buffer = null;
	        /**
			 *  indicates if the buffer should be reversed or not
			 *  @type {Boolean}
			 *  @private
			 */
	        this._reversed = options.reverse;
	        /**
			 *  The XHR
			 *  @type  {XMLHttpRequest}
			 *  @private
			 */
	        this._xhr = null;
	        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {
	            this.set(options.url);
	            // invoke the onload callback
	            if (options.onload) {
	                options.onload(this);
	            }
	        } else if (Tone.isString(options.url)) {
	            this.load(options.url, options.onload, options.onerror);
	        }
	    };
	    Tone.extend(Tone.Buffer);
	    /**
		 *  the default parameters
		 *  @type {Object}
		 */
	    Tone.Buffer.defaults = {
	        'url': undefined,
	        'reverse': false
	    };
	    /**
		 *  Pass in an AudioBuffer or Tone.Buffer to set the value
		 *  of this buffer.
		 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.set = function (buffer) {
	        if (buffer instanceof Tone.Buffer) {
	            this._buffer = buffer.get();
	        } else {
	            this._buffer = buffer;
	        }
	        return this;
	    };
	    /**
		 *  @return {AudioBuffer} The audio buffer stored in the object.
		 */
	    Tone.Buffer.prototype.get = function () {
	        return this._buffer;
	    };
	    /**
		 *  Makes an xhr reqest for the selected url then decodes
		 *  the file as an audio buffer. Invokes
		 *  the callback once the audio buffer loads.
		 *  @param {String} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer
		 */
	    Tone.Buffer.prototype.load = function (url, onload, onerror) {
	        var promise = new Promise(function (load, error) {
	            this._xhr = Tone.Buffer.load(url, //success
	            function (buff) {
	                this._xhr = null;
	                this.set(buff);
	                load(this);
	                if (onload) {
	                    onload(this);
	                }
	            }.bind(this), //error
	            function (err) {
	                this._xhr = null;
	                error(err);
	                if (onerror) {
	                    onerror(err);
	                }
	            }.bind(this));
	        }.bind(this));
	        return promise;
	    };
	    /**
		 *  dispose and disconnect
		 *  @returns {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        this._buffer = null;
	        if (this._xhr) {
	            Tone.Buffer._removeFromDownloadQueue(this._xhr);
	            this._xhr.abort();
	            this._xhr = null;
	        }
	        return this;
	    };
	    /**
		 * If the buffer is loaded or not
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {
	        get: function () {
	            return this.length > 0;
	        }
	    });
	    /**
		 * The duration of the buffer. 
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name duration
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.duration;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The length of the buffer in samples
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name length
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'length', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.length;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 * The number of discrete audio channels. Returns 0 if no buffer
		 * is loaded.
		 * @memberOf Tone.Buffer#
		 * @type {Number}
		 * @name numberOfChannels
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {
	        get: function () {
	            if (this._buffer) {
	                return this._buffer.numberOfChannels;
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Set the audio buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.fromArray = function (array) {
	        var isMultidimensional = array[0].length > 0;
	        var channels = isMultidimensional ? array.length : 1;
	        var len = isMultidimensional ? array[0].length : array.length;
	        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);
	        if (!isMultidimensional && channels === 1) {
	            array = [array];
	        }
	        for (var c = 0; c < channels; c++) {
	            buffer.copyToChannel(array[c], c);
	        }
	        this._buffer = buffer;
	        return this;
	    };
	    /**
		 * 	Sums muliple channels into 1 channel
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toMono = function (chanNum) {
	        if (Tone.isNumber(chanNum)) {
	            this.fromArray(this.toArray(chanNum));
	        } else {
	            var outputArray = new Float32Array(this.length);
	            var numChannels = this.numberOfChannels;
	            for (var channel = 0; channel < numChannels; channel++) {
	                var channelArray = this.toArray(channel);
	                for (var i = 0; i < channelArray.length; i++) {
	                    outputArray[i] += channelArray[i];
	                }
	            }
	            //divide by the number of channels
	            outputArray = outputArray.map(function (sample) {
	                return sample / numChannels;
	            });
	            this.fromArray(outputArray);
	        }
	        return this;
	    };
	    /**
		 * 	Get the buffer as an array. Single channel buffers will return a 1-dimensional 
		 * 	Float32Array, and multichannel buffers will return multidimensional arrays.
		 *  @param {Number=} channel Optionally only copy a single channel from the array.
		 *  @return {Array}
		 */
	    Tone.Buffer.prototype.toArray = function (channel) {
	        if (Tone.isNumber(channel)) {
	            return this.getChannelData(channel);
	        } else if (this.numberOfChannels === 1) {
	            return this.toArray(0);
	        } else {
	            var ret = [];
	            for (var c = 0; c < this.numberOfChannels; c++) {
	                ret[c] = this.getChannelData(c);
	            }
	            return ret;
	        }
	    };
	    /**
		 *  Returns the Float32Array representing the PCM audio data for the specific channel.
		 *  @param  {Number}  channel  The channel number to return
		 *  @return  {Float32Array}  The audio as a TypedArray
		 */
	    Tone.Buffer.prototype.getChannelData = function (channel) {
	        return this._buffer.getChannelData(channel);
	    };
	    /**
		 *  Cut a subsection of the array and return a buffer of the
		 *  subsection. Does not modify the original buffer
		 *  @param {Time} start The time to start the slice
		 *  @param {Time=} end The end time to slice. If none is given
		 *                     will default to the end of the buffer
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype.slice = function (start, end) {
	        end = Tone.defaultArg(end, this.duration);
	        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));
	        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));
	        var replacement = [];
	        for (var i = 0; i < this.numberOfChannels; i++) {
	            replacement[i] = this.toArray(i).slice(startSamples, endSamples);
	        }
	        var retBuffer = new Tone.Buffer().fromArray(replacement);
	        return retBuffer;
	    };
	    /**
		 *  Reverse the buffer.
		 *  @private
		 *  @return {Tone.Buffer} this
		 */
	    Tone.Buffer.prototype._reverse = function () {
	        if (this.loaded) {
	            for (var i = 0; i < this.numberOfChannels; i++) {
	                Array.prototype.reverse.call(this.getChannelData(i));
	            }
	        }
	        return this;
	    };
	    /**
		 * Reverse the buffer.
		 * @memberOf Tone.Buffer#
		 * @type {Boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
	        get: function () {
	            return this._reversed;
	        },
	        set: function (rev) {
	            if (this._reversed !== rev) {
	                this._reversed = rev;
	                this._reverse();
	            }
	        }
	    });
	    ///////////////////////////////////////////////////////////////////////////
	    // STATIC METHODS
	    ///////////////////////////////////////////////////////////////////////////
	    //statically inherits Emitter methods
	    Tone.Emitter.mixin(Tone.Buffer);
	    /**
		 *  the static queue for all of the xhr requests
		 *  @type {Array}
		 *  @private
		 */
	    Tone.Buffer._downloadQueue = [];
	    /**
		 *  A path which is prefixed before every url.
		 *  @type  {String}
		 *  @static
		 */
	    Tone.Buffer.baseUrl = '';
	    /**
		 *  Create a Tone.Buffer from the array. To create a multichannel AudioBuffer,
		 *  pass in a multidimensional array. 
		 *  @param {Float32Array} array The array to fill the audio buffer
		 *  @return {Tone.Buffer} A Tone.Buffer created from the array
		 */
	    Tone.Buffer.fromArray = function (array) {
	        return new Tone.Buffer().fromArray(array);
	    };
	    /**
		 * Remove an xhr request from the download queue
		 * @private
		 */
	    Tone.Buffer._removeFromDownloadQueue = function (request) {
	        var index = Tone.Buffer._downloadQueue.indexOf(request);
	        if (index !== -1) {
	            Tone.Buffer._downloadQueue.splice(index, 1);
	        }
	    };
	    /**
		 *  Loads a url using XMLHttpRequest.
		 *  @param {String} url
		 *  @param {Function} onload
		 *  @param {Function} onerror
		 *  @param {Function} onprogress
		 *  @return {XMLHttpRequest}
		 */
	    Tone.Buffer.load = function (url, onload, onerror) {
	        //default
	        onload = Tone.defaultArg(onload, Tone.noOp);
	        // test if the url contains multiple extensions
	        var matches = url.match(/\[(.+\|?)+\]$/);
	        if (matches) {
	            var extensions = matches[1].split('|');
	            var extension = extensions[0];
	            for (var i = 0; i < extensions.length; i++) {
	                if (Tone.Buffer.supportsType(extensions[i])) {
	                    extension = extensions[i];
	                    break;
	                }
	            }
	            url = url.replace(matches[0], extension);
	        }
	        function onError(e) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            Tone.Buffer.emit('error', e);
	            if (onerror) {
	                onerror(e);
	            } else {
	                throw e;
	            }
	        }
	        function onProgress() {
	            //calculate the progress
	            var totalProgress = 0;
	            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {
	                totalProgress += Tone.Buffer._downloadQueue[i].progress;
	            }
	            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);
	        }
	        var request = new XMLHttpRequest();
	        request.open('GET', Tone.Buffer.baseUrl + url, true);
	        request.responseType = 'arraybuffer';
	        //start out as 0
	        request.progress = 0;
	        Tone.Buffer._downloadQueue.push(request);
	        request.addEventListener('load', function () {
	            if (request.status === 200) {
	                Tone.context.decodeAudioData(request.response, function (buff) {
	                    request.progress = 1;
	                    onProgress();
	                    onload(buff);
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    if (Tone.Buffer._downloadQueue.length === 0) {
	                        //emit the event at the end
	                        Tone.Buffer.emit('load');
	                    }
	                }, function () {
	                    Tone.Buffer._removeFromDownloadQueue(request);
	                    onError('Tone.Buffer: could not decode audio data: ' + url);
	                });
	            } else {
	                onError('Tone.Buffer: could not locate file: ' + url);
	            }
	        });
	        request.addEventListener('error', onError);
	        request.addEventListener('progress', function (event) {
	            if (event.lengthComputable) {
	                //only go to 95%, the last 5% is when the audio is decoded
	                request.progress = event.loaded / event.total * 0.95;
	                onProgress();
	            }
	        });
	        request.send();
	        return request;
	    };
	    /**
		 *  Stop all of the downloads in progress
		 *  @return {Tone.Buffer}
		 *  @static
		 */
	    Tone.Buffer.cancelDownloads = function () {
	        Tone.Buffer._downloadQueue.slice().forEach(function (request) {
	            Tone.Buffer._removeFromDownloadQueue(request);
	            request.abort();
	        });
	        return Tone.Buffer;
	    };
	    /**
		 *  Checks a url's extension to see if the current browser can play that file type.
		 *  @param {String} url The url/extension to test
		 *  @return {Boolean} If the file extension can be played
		 *  @static
		 *  @example
		 * Tone.Buffer.supportsType("wav"); //returns true
		 * Tone.Buffer.supportsType("path/to/file.wav"); //returns true
		 */
	    Tone.Buffer.supportsType = function (url) {
	        var extension = url.split('.');
	        extension = extension[extension.length - 1];
	        var response = document.createElement('audio').canPlayType('audio/' + extension);
	        return response !== '';
	    };
	    /**
		 *  Returns a Promise which resolves when all of the buffers have loaded
		 *  @return {Promise}
		 */
	    Tone.loaded = function () {
	        var onload, onerror;
	        function removeEvents() {
	            //remove the events when it's resolved
	            Tone.Buffer.off('load', onload);
	            Tone.Buffer.off('error', onerror);
	        }
	        return new Promise(function (success, fail) {
	            onload = function () {
	                success();
	            };
	            onerror = function () {
	                fail();
	            };
	            //add the event listeners
	            Tone.Buffer.on('load', onload);
	            Tone.Buffer.on('error', onerror);
	        }).then(removeEvents).catch(function (e) {
	            removeEvents();
	            throw new Error(e);
	        });
	    };
	    return Tone.Buffer;
	});
	Module(function (Tone) {
	    /**
		 *  @class A data structure for holding multiple buffers.
		 *  
		 *  @param  {Object|Array}    urls      An object literal or array
		 *                                      of urls to load.
		 *  @param  {Function=}  callback  The callback to invoke when
		 *                                 the buffers are loaded. 
		 *  @extends {Tone}
		 *  @example
		 * //load a whole bank of piano samples
		 * var pianoSamples = new Tone.Buffers({
		 * 	"C4" : "path/to/C4.mp3"
		 * 	"C#4" : "path/to/C#4.mp3"
		 * 	"D4" : "path/to/D4.mp3"
		 * 	"D#4" : "path/to/D#4.mp3"
		 * 	...
		 * }, function(){
		 * 	//play one of the samples when they all load
		 * 	player.buffer = pianoSamples.get("C4");
		 * 	player.start();
		 * });
		 * 	@example
		 * //To pass in additional parameters in the second parameter
		 * var buffers = new Tone.Buffers(urls, {
		 * 	"onload" : callback,
		 * 	"baseUrl" : "../path/to/audio/"
		 * })
		 */
	    Tone.Buffers = function (urls) {
	        //remove the urls from the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Buffers);
	        Tone.call(this);
	        /**
			 *  All of the buffers
			 *  @type  {Object}
			 *  @private
			 */
	        this._buffers = {};
	        /**
			 *  A path which is prefixed before every url.
			 *  @type  {String}
			 */
	        this.baseUrl = options.baseUrl;
	        this._loadingCount = 0;
	        //add each one
	        for (var key in urls) {
	            this._loadingCount++;
	            this.add(key, urls[key], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Buffers);
	    /**
		 *  Defaults
		 *  @type  {Object}
		 */
	    Tone.Buffers.defaults = {
	        'onload': Tone.noOp,
	        'baseUrl': ''
	    };
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Buffers.prototype.has = function (name) {
	        return this._buffers.hasOwnProperty(name);
	    };
	    /**
		 *  Get a buffer by name. If an array was loaded, 
		 *  then use the array index.
		 *  @param  {String|Number}  name  The key or index of the 
		 *                                 buffer.
		 *  @return  {Tone.Buffer}
		 */
	    Tone.Buffers.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._buffers[name];
	        } else {
	            throw new Error('Tone.Buffers: no buffer named ' + name);
	        }
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback 
		 *  @private
		 */
	    Tone.Buffers.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Buffers#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            for (var buffName in this._buffers) {
	                var buff = this.get(buffName);
	                isLoaded = isLoaded && buff.loaded;
	            }
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a buffer by name and url to the Buffers
		 *  @param  {String}    name      A unique name to give
		 *                                the buffer
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, 
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke 
		 *                                 when the url is loaded.
		 */
	    Tone.Buffers.prototype.add = function (name, url, callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        if (url instanceof Tone.Buffer) {
	            this._buffers[name] = url;
	            callback(this);
	        } else if (url instanceof AudioBuffer) {
	            this._buffers[name] = new Tone.Buffer(url);
	            callback(this);
	        } else if (Tone.isString(url)) {
	            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @return  {Tone.Buffers} this
		 */
	    Tone.Buffers.prototype.dispose = function () {
	        Tone.prototype.dispose.call(this);
	        for (var name in this._buffers) {
	            this._buffers[name].dispose();
	        }
	        this._buffers = null;
	        return this;
	    };
	    return Tone.Buffers;
	});
	Module(function (Tone) {
	    
	    /**
		 *  buses are another way of routing audio
		 *
		 *  augments Tone.prototype to include send and recieve
		 */
	    /**
		  *  All of the routes
		  *  
		  *  @type {Object}
		  *  @static
		  *  @private
		  */
	    var Buses = {};
	    /**
		 *  Send this signal to the channel name. 
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Decibels} amount The amount of the source to send to the bus. 
		 *  @return {GainNode} The gain node which connects this node to the desired channel. 
		 *                     Can be used to adjust the levels of the send.
		 *  @example
		 * source.send("reverb", -12);
		 */
	    Tone.prototype.send = function (channelName, amount) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        amount = Tone.defaultArg(amount, 0);
	        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);
	        this.output.chain(sendKnob, Buses[channelName]);
	        return sendKnob;
	    };
	    /**
		 *  Recieve the input from the desired channelName to the input
		 *
		 *  @param  {String} channelName A named channel to send the signal to.
		 *  @param  {Number=} channelNumber The channel to connect to
		 *  @returns {Tone} this
		 *  @example
		 * reverbEffect.receive("reverb");
		 */
	    Tone.prototype.receive = function (channelName, inputNum) {
	        if (!Buses.hasOwnProperty(channelName)) {
	            Buses[channelName] = this.context.createGain();
	        }
	        Buses[channelName].connect(this, 0, inputNum);
	        return this;
	    };
	    //remove all the send/receives when a new audio context is passed in
	    Tone.Context.on('init', function (context) {
	        if (context.Buses) {
	            Buses = context.Buses;
	        } else {
	            Buses = {};
	            context.Buses = Buses;
	        }
	    });
	    return Tone;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Draw is useful for synchronizing visuals and audio events.
		 *         Callbacks from Tone.Transport or any of the Tone.Event classes
		 *         always happen _before_ the scheduled time and are not synchronized
		 *         to the animation frame so they are not good for triggering tightly
		 *         synchronized visuals and sound. Tone.Draw makes it easy to schedule
		 *         callbacks using the AudioContext time and uses requestAnimationFrame.
		 *         
		 *  @singleton
		 *  @extends {Tone}
		 *  @example
		 * Tone.Transport.schedule(function(time){
		 * 	//use the time argument to schedule a callback with Tone.Draw
		 * 	Tone.Draw.schedule(function(){
		 * 		//do drawing or DOM manipulation here
		 * 	}, time)
		 * }, "+0.5")
		 */
	    Tone.Draw = function () {
	        Tone.call(this);
	        /**
			 *  All of the events.
			 *  @type  {Tone.Timeline}
			 *  @private
			 */
	        this._events = new Tone.Timeline();
	        /**
			 *  The duration after which events are not invoked.
			 *  @type  {Number}
			 *  @default 0.25
			 */
	        this.expiration = 0.25;
	        /**
			 *  The amount of time before the scheduled time 
			 *  that the callback can be invoked. Default is
			 *  half the time of an animation frame (0.008 seconds).
			 *  @type  {Number}
			 *  @default 0.008
			 */
	        this.anticipation = 0.008;
	        /**
			 *  The draw loop
			 *  @type  {Function}
			 *  @private
			 */
	        this._boundDrawLoop = this._drawLoop.bind(this);
	    };
	    Tone.extend(Tone.Draw);
	    /**
		 *  Schedule a function at the given time to be invoked
		 *  on the nearest animation frame.
		 *  @param  {Function}  callback  Callback is invoked at the given time.
		 *  @param  {Time}    time      The time relative to the AudioContext time
		 *                              to invoke the callback.
		 *  @return  {Tone.Draw}    this
		 */
	    Tone.Draw.prototype.schedule = function (callback, time) {
	        this._events.add({
	            callback: callback,
	            time: this.toSeconds(time)
	        });
	        //start the draw loop on the first event
	        if (this._events.length === 1) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	        return this;
	    };
	    /**
		 *  Cancel events scheduled after the given time
		 *  @param  {Time=}  after  Time after which scheduled events will 
		 *                          be removed from the scheduling timeline.
		 *  @return  {Tone.Draw}  this
		 */
	    Tone.Draw.prototype.cancel = function (after) {
	        this._events.cancel(this.toSeconds(after));
	        return this;
	    };
	    /**
		 *  The draw loop
		 *  @private
		 */
	    Tone.Draw.prototype._drawLoop = function () {
	        var now = Tone.now();
	        while (this._events.length && this._events.peek().time - this.anticipation <= now) {
	            var event = this._events.shift();
	            if (now - event.time <= this.expiration) {
	                event.callback();
	            }
	        }
	        if (this._events.length > 0) {
	            requestAnimationFrame(this._boundDrawLoop);
	        }
	    };
	    //make a singleton
	    Tone.Draw = new Tone.Draw();
	    return Tone.Draw;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space 
		 *          using a right-handed cartesian coordinate system. 
		 *          The units used in the coordinate system are not defined; 
		 *          these coordinates are independent/invariant of any particular 
		 *          units such as meters or feet. Tone.Panner3D objects have an forward 
		 *          vector representing the direction the sound is projecting. Additionally, 
		 *          they have a sound cone representing how directional the sound is. 
		 *          For example, the sound could be omnidirectional, in which case it would 
		 *          be heard anywhere regardless of its forward, or it can be more directional 
		 *          and heard only if it is facing the listener. Tone.Listener objects 
		 *          (representing a person's ears) have an forward and up vector 
		 *          representing in which direction the person is facing. Because both the 
		 *          source stream and the listener can be moving, they both have a velocity 
		 *          vector representing both the speed and direction of movement. Taken together, 
		 *          these two velocities can be used to generate a doppler shift effect which changes the pitch.
		 *          <br><br>
		 *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D
		 *  
		 *  @constructor
		 *  @extends {Tone}
		 *  @singleton
		 */
	    Tone.Listener = function () {
	        Tone.call(this);
	        /**
			 *  Holds the current forward orientation
			 *  @type  {Array}
			 *  @private
			 */
	        this._orientation = [
	            0,
	            0,
	            0,
	            0,
	            0,
	            0
	        ];
	        /**
			 *  Holds the current position
			 *  @type  {Array}
			 *  @private
			 */
	        this._position = [
	            0,
	            0,
	            0
	        ];
	        Tone.getContext(function () {
	            // set the default position/forward
	            this.set(ListenerConstructor.defaults);
	        }.bind(this));
	    };
	    Tone.extend(Tone.Listener);
	    /**
		 *  Defaults according to the specification
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Listener.defaults = {
	        'positionX': 0,
	        'positionY': 0,
	        'positionZ': 0,
	        'forwardX': 0,
	        'forwardY': 0,
	        'forwardZ': 1,
	        'upX': 0,
	        'upY': 1,
	        'upZ': 0
	    };
	    /**
		 * The ramp time which is applied to the setTargetAtTime
		 * @type {Number}
		 * @private
		 */
	    Tone.Listener.prototype._rampTimeConstant = 0.01;
	    /**
		 *  Sets the position of the listener in 3d space.	
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setPosition = function (x, y, z) {
	        if (this.context.listener.positionX) {
	            var now = this.now();
	            this.context.listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setPosition(x, y, z);
	        }
	        this._position = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  Sets the orientation of the listener using two vectors, the forward
		 *  vector (which direction the listener is facing) and the up vector 
		 *  (which the up direction of the listener). An up vector
		 *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. 
		 *  @param  {Number}  x
		 *  @param  {Number}  y
		 *  @param  {Number}  z
		 *  @param  {Number}  upX
		 *  @param  {Number}  upY
		 *  @param  {Number}  upZ
		 *  @return {Tone.Listener} this
		 */
	    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {
	        if (this.context.listener.forwardX) {
	            var now = this.now();
	            this.context.listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);
	            this.context.listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);
	            this.context.listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);
	            this.context.listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);
	            this.context.listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);
	            this.context.listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);
	        } else {
	            this.context.listener.setOrientation(x, y, z, upX, upY, upZ);
	        }
	        this._orientation = Array.prototype.slice.call(arguments);
	        return this;
	    };
	    /**
		 *  The x position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionX', {
	        set: function (pos) {
	            this._position[0] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[0];
	        }
	    });
	    /**
		 *  The y position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionY', {
	        set: function (pos) {
	            this._position[1] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[1];
	        }
	    });
	    /**
		 *  The z position of the panner object.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name positionZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {
	        set: function (pos) {
	            this._position[2] = pos;
	            this.setPosition.apply(this, this._position);
	        },
	        get: function () {
	            return this._position[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {
	        set: function (pos) {
	            this._orientation[0] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[0];
	        }
	    });
	    /**
		 *  The y coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {
	        set: function (pos) {
	            this._orientation[1] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[1];
	        }
	    });
	    /**
		 *  The z coordinate of the listeners front direction. i.e. 
		 *  which way they are facing.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name forwardZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {
	        set: function (pos) {
	            this._orientation[2] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[2];
	        }
	    });
	    /**
		 *  The x coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upX
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upX', {
	        set: function (pos) {
	            this._orientation[3] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[3];
	        }
	    });
	    /**
		 *  The y coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upY
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upY', {
	        set: function (pos) {
	            this._orientation[4] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[4];
	        }
	    });
	    /**
		 *  The z coordinate of the listener's up direction. i.e.
		 *  the direction the listener is standing in.
		 *  @type {Number}
		 *  @memberOf Tone.Listener#
		 *  @name upZ
		 */
	    Object.defineProperty(Tone.Listener.prototype, 'upZ', {
	        set: function (pos) {
	            this._orientation[5] = pos;
	            this.setOrientation.apply(this, this._orientation);
	        },
	        get: function () {
	            return this._orientation[5];
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Listener} this
		 */
	    Tone.Listener.prototype.dispose = function () {
	        this._orientation = null;
	        this._position = null;
	        return this;
	    };
	    //SINGLETON SETUP
	    var ListenerConstructor = Tone.Listener;
	    Tone.Listener = new ListenerConstructor();
	    Tone.Context.on('init', function (context) {
	        if (context.Listener instanceof ListenerConstructor) {
	            //a single listener object
	            Tone.Listener = context.Listener;
	        } else {
	            //make new Listener insides
	            Tone.Listener = new ListenerConstructor();
	        }
	        context.Listener = Tone.Listener;
	    });
	    //END SINGLETON SETUP
	    return Tone.Listener;
	});
	Module(function (Tone) {
	    /**
		 *  shim
		 *  @private
		 */
	    if (!window.hasOwnProperty('OfflineAudioContext') && window.hasOwnProperty('webkitOfflineAudioContext')) {
	        window.OfflineAudioContext = window.webkitOfflineAudioContext;
	    }
	    /**
		 *  @class Wrapper around the OfflineAudioContext
		 *  @extends {Tone.Context}
		 *  @param  {Number}  channels  The number of channels to render
		 *  @param  {Number}  duration  The duration to render in samples
		 *  @param {Number} sampleRate the sample rate to render at
		 */
	    Tone.OfflineContext = function (channels, duration, sampleRate) {
	        /**
			 *  The offline context
			 *  @private
			 *  @type  {OfflineAudioContext}
			 */
	        var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate);
	        //wrap the methods/members
	        Tone.Context.call(this, {
	            'context': offlineContext,
	            'clockSource': 'offline',
	            'lookAhead': 0,
	            'updateInterval': 128 / sampleRate
	        });
	        /**
			 *  A private reference to the duration
			 *  @private
			 *  @type  {Number}
			 */
	        this._duration = duration;
	        /**
			 *  An artificial clock source
			 *  @type  {Number}
			 *  @private
			 */
	        this._currentTime = 0;
	    };
	    Tone.extend(Tone.OfflineContext, Tone.Context);
	    /**
		 *  Override the now method to point to the internal clock time
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.now = function () {
	        return this._currentTime;
	    };
	    /**
		 *  Render the output of the OfflineContext
		 *  @return  {Promise}
		 */
	    Tone.OfflineContext.prototype.render = function () {
	        while (this._duration - this._currentTime >= 0) {
	            //invoke all the callbacks on that time
	            this.emit('tick');
	            //increment the clock
	            this._currentTime += this.blockTime;
	        }
	        //promise returned is not yet implemented in all browsers
	        return new Promise(function (done) {
	            this._context.oncomplete = function (e) {
	                done(e.renderedBuffer);
	            };
	            this._context.startRendering();
	        }.bind(this));
	    };
	    /**
		 *  Close the context
		 *  @return  {Number}
		 */
	    Tone.OfflineContext.prototype.close = function () {
	        this._context = null;
	    };
	    return Tone.OfflineContext;
	});
	Module(function (Tone) {
	    /**
		 *  Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext. 
		 *  The OfflineAudioContext is capable of rendering much faster than real time in many cases. 
		 *  The callback function also passes in an offline instance of Tone.Transport which can be used
		 *  to schedule events along the Transport. 
		 *  @param  {Function}  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.
		 *  @param  {Time}  duration     the amount of time to record for.
		 *  @return  {Promise}  The promise which is invoked with the Tone.Buffer of the recorded output.
		 *  @example
		 * //render 2 seconds of the oscillator
		 * Tone.Offline(function(){
		 * 	//only nodes created in this callback will be recorded
		 * 	var oscillator = new Tone.Oscillator().toMaster().start(0)
		 * 	//schedule their events
		 * }, 2).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 * @example
		 * //can also schedule events along the Transport
		 * //using the passed in Offline Transport
		 * Tone.Offline(function(Transport){
		 * 	var osc = new Tone.Oscillator().toMaster()
		 * 	Transport.schedule(function(time){
		 * 		osc.start(time).stop(time + 0.1)
		 * 	}, 1)
		 * 	Transport.start(0.2)
		 * }, 4).then(function(buffer){
		 * 	//do something with the output buffer
		 * })
		 */
	    Tone.Offline = function (callback, duration) {
	        //set the OfflineAudioContext
	        var sampleRate = Tone.context.sampleRate;
	        var originalContext = Tone.context;
	        var context = new Tone.OfflineContext(2, duration, sampleRate);
	        Tone.context = context;
	        //invoke the callback/scheduling
	        callback(Tone.Transport);
	        //process the audio
	        var rendered = context.render();
	        //return the original AudioContext
	        Tone.context = originalContext;
	        //return the audio
	        return rendered.then(function (buffer) {
	            //wrap it in a Tone.Buffer
	            return new Tone.Buffer(buffer);
	        });
	    };
	    return Tone.Offline;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
		 * 	        the effectSend and effectReturn GainNodes, then control the amount of
		 * 	        effect which goes to the output using the wet control.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {NormalRange|Object} [wet] The starting wet value.
		 */
	    Tone.Effect = function () {
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        Tone.AudioNode.call(this);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control is how much of the effected
			 *  will pass through to the output. 1 = 100% effected
			 *  signal, 0 = 100% dry signal.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  connect the effectSend to the input of hte effect
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectSend = new Tone.Gain();
	        /**
			 *  connect the output of the effect to the effectReturn
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this.effectReturn = new Tone.Gain();
	        //connections
	        this.input.connect(this._dryWet.a);
	        this.input.connect(this.effectSend);
	        this.effectReturn.connect(this._dryWet.b);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.Effect, Tone.AudioNode);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Effect.defaults = { 'wet': 1 };
	    /**
		 *  chains the effect in between the effectSend and effectReturn
		 *  @param  {Tone} effect
		 *  @private
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.connectEffect = function (effect) {
	        this.effectSend.chain(effect, this.effectReturn);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Effect} this
		 */
	    Tone.Effect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this.effectSend.dispose();
	        this.effectSend = null;
	        this.effectReturn.dispose();
	        this.effectReturn = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.Effect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
		 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
		 *         and depth.
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Time|Object} [frequency] The rate of the LFO.
		 *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation
	 	 *  @param {Frequency=} octaves The number of octaves above the baseFrequency
		 *  @example
		 * //create an autofilter and start it's LFO
		 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
		 * //route an oscillator through the filter and start it
		 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
		 */
	    Tone.AutoFilter = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'baseFrequency',
	            'octaves'
	        ], Tone.AutoFilter);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the filter cutoff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth
	        });
	        /**
			 * The range of the filter modulating between the min and max frequency. 
			 * 0 = no modulation. 1 = full modulation.
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 * How fast the filter modulates between min and max. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The filter node
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The octaves placeholder
			 *  @type {Positive}
			 *  @private
			 */
	        this._octaves = 0;
	        //connections
	        this.connectEffect(this.filter);
	        this._lfo.connect(this.filter.frequency);
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.octaves = options.octaves;
	        this.baseFrequency = options.baseFrequency;
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoFilter, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoFilter.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1,
	        'baseFrequency': 200,
	        'octaves': 2.6,
	        'filter': {
	            'type': 'lowpass',
	            'rolloff': -12,
	            'Q': 1
	        }
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the filter to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 * The minimum value of the filter's cutoff frequency.
		 * @memberOf Tone.AutoFilter#
		 * @type {Frequency}
		 * @name min
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {
	        get: function () {
	            return this._lfo.min;
	        },
	        set: function (freq) {
	            this._lfo.min = this.toFrequency(freq);
	            //and set the max
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 * The maximum value of the filter's cutoff frequency. 
		 * @memberOf Tone.AutoFilter#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (oct) {
	            this._octaves = oct;
	            this._lfo.max = this.baseFrequency * Math.pow(2, oct);
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.AutoFilter} this
		 */
	    Tone.AutoFilter.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this.filter.dispose();
	        this.filter = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoFilter;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
		 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
		 *  @example
		 * //create an autopanner and start it's LFO
		 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
		 * //route an oscillator through the panner and start it
		 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
		 */
	    Tone.AutoPanner = function () {
	        var options = Tone.defaults(arguments, ['frequency'], Tone.AutoPanner);
	        Tone.Effect.call(this, options);
	        /**
			 *  the lfo which drives the panning
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'frequency': options.frequency,
	            'amplitude': options.depth,
	            'min': -1,
	            'max': 1
	        });
	        /**
			 * The amount of panning between left and right. 
			 * 0 = always center. 1 = full range between left and right. 
			 * @type {NormalRange}
			 * @signal
			 */
	        this.depth = this._lfo.amplitude;
	        /**
			 *  the panner node which does the panning
			 *  @type {Tone.Panner}
			 *  @private
			 */
	        this._panner = new Tone.Panner();
	        /**
			 * How fast the panner modulates between left and right. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfo.frequency;
	        //connections
	        this.connectEffect(this._panner);
	        this._lfo.connect(this._panner.pan);
	        this.type = options.type;
	        this._readOnly([
	            'depth',
	            'frequency'
	        ]);
	    };
	    //extend Effect
	    Tone.extend(Tone.AutoPanner, Tone.Effect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoPanner.defaults = {
	        'frequency': 1,
	        'type': 'sine',
	        'depth': 1
	    };
	    /**
		 * Start the effect.
		 * @param {Time} [time=now] When the LFO will start. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.start = function (time) {
	        this._lfo.start(time);
	        return this;
	    };
	    /**
		 * Stop the effect.
		 * @param {Time} [time=now] When the LFO will stop. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.stop = function (time) {
	        this._lfo.stop(time);
	        return this;
	    };
	    /**
		 * Sync the panner to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                               Transport has started. 
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.sync = function (delay) {
	        this._lfo.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the panner from the transport
		 * @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.unsync = function () {
	        this._lfo.unsync();
	        return this;
	    };
	    /**
		 * Type of oscillator attached to the AutoFilter. 
		 * Possible values: "sine", "square", "triangle", "sawtooth".
		 * @memberOf Tone.AutoFilter#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.AutoPanner} this
		 */
	    Tone.AutoPanner.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._lfo.dispose();
	        this._lfo = null;
	        this._panner.dispose();
	        this._panner = null;
	        this._writable([
	            'depth',
	            'frequency'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.AutoPanner;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
		 *          The frequency of the filter is adjusted proportionally to the 
		 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
		 *                                            to at the low point of the wah
		 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
		 *                                the filter will sweep to when fully open
		 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
		 *                                   the incoming signal. Normal range of -40 to 0. 
		 *  @example
		 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
		 * //initialize the synth and connect to autowah
		 * var synth = new Synth.connect(autoWah);
		 * //Q value influences the effect of the wah - default is 2
		 * autoWah.Q.value = 6;
		 * //more audible on higher notes
		 * synth.triggerAttackRelease("C4", "8n")
		 */
	    Tone.AutoWah = function () {
	        var options = Tone.defaults(arguments, [
	            'baseFrequency',
	            'octaves',
	            'sensitivity'
	        ], Tone.AutoWah);
	        Tone.Effect.call(this, options);
	        /**
			 *  The envelope follower. Set the attack/release
			 *  timing to adjust how the envelope is followed. 
			 *  @type {Tone.Follower}
			 *  @private
			 */
	        this.follower = new Tone.Follower(options.follower);
	        /**
			 *  scales the follower value to the frequency domain
			 *  @type {Tone}
			 *  @private
			 */
	        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  the input gain to adjust the sensitivity
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._inputBoost = new Tone.Gain();
	        /**
			 *  @type {BiquadFilterNode}
			 *  @private
			 */
	        this._bandpass = new Tone.Filter({
	            'rolloff': -48,
	            'frequency': 0,
	            'Q': options.Q
	        });
	        /**
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._peaking = new Tone.Filter(0, 'peaking');
	        this._peaking.gain.value = options.gain;
	        /**
			 * The gain of the filter.
			 * @type {Number}
			 * @signal
			 */
	        this.gain = this._peaking.gain;
	        /**
			 * The quality of the filter.
			 * @type {Positive}
			 * @signal
			 */
	        this.Q = this._bandpass.Q;
	        //the control signal path
	        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
	        this._sweepRange.connect(this._bandpass.frequency);
	        this._sweepRange.connect(this._peaking.frequency);
	        //the filtered path
	        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
	        //set the initial value
	        this._setSweepRange();
	        this.sensitivity = options.sensitivity;
	        this._readOnly([
	            'gain',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.AutoWah, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AutoWah.defaults = {
	        'baseFrequency': 100,
	        'octaves': 6,
	        'sensitivity': 0,
	        'Q': 2,
	        'gain': 2,
	        'follower': {
	            'attack': 0.3,
	            'release': 0.5
	        }
	    };
	    /**
		 * The number of octaves that the filter will sweep above the 
		 * baseFrequency. 
		 * @memberOf Tone.AutoWah#
		 * @type {Number}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The base frequency from which the sweep will start from.
		 * @memberOf Tone.AutoWah#
		 * @type {Frequency}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (baseFreq) {
	            this._baseFrequency = baseFreq;
	            this._setSweepRange();
	        }
	    });
	    /**
		 * The sensitivity to control how responsive to the input signal the filter is. 
		 * @memberOf Tone.AutoWah#
		 * @type {Decibels}
		 * @name sensitivity
		 */
	    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
	        get: function () {
	            return Tone.gainToDb(1 / this._inputBoost.gain.value);
	        },
	        set: function (sensitivy) {
	            this._inputBoost.gain.value = 1 / Tone.dbToGain(sensitivy);
	        }
	    });
	    /**
		 *  sets the sweep range of the scaler
		 *  @private
		 */
	    Tone.AutoWah.prototype._setSweepRange = function () {
	        this._sweepRange.min = this._baseFrequency;
	        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.AutoWah} this
		 */
	    Tone.AutoWah.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this.follower.dispose();
	        this.follower = null;
	        this._sweepRange.dispose();
	        this._sweepRange = null;
	        this._bandpass.dispose();
	        this._bandpass = null;
	        this._peaking.dispose();
	        this._peaking = null;
	        this._inputBoost.dispose();
	        this._inputBoost = null;
	        this._writable([
	            'gain',
	            'Q'
	        ]);
	        this.gain = null;
	        this.Q = null;
	        return this;
	    };
	    return Tone.AutoWah;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
		 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
		 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
		 *                       of 1 to 8. 
		 *  @example
		 * //initialize crusher and route a synth through it
		 * var crusher = new Tone.BitCrusher(4).toMaster();
		 * var synth = new Tone.MonoSynth().connect(crusher);
		 */
	    Tone.BitCrusher = function () {
	        var options = Tone.defaults(arguments, ['bits'], Tone.BitCrusher);
	        Tone.Effect.call(this, options);
	        var invStepSize = 1 / Math.pow(2, options.bits - 1);
	        /**
			 *  Subtract the input signal and the modulus of the input signal
			 *  @type {Tone.Subtract}
			 *  @private
			 */
	        this._subtract = new Tone.Subtract();
	        /**
			 *  The mod function
			 *  @type  {Tone.Modulo}
			 *  @private
			 */
	        this._modulo = new Tone.Modulo(invStepSize);
	        /**
			 *  keeps track of the bits
			 *  @type {number}
			 *  @private
			 */
	        this._bits = options.bits;
	        //connect it up
	        this.effectSend.fan(this._subtract, this._modulo);
	        this._modulo.connect(this._subtract, 0, 1);
	        this._subtract.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.BitCrusher, Tone.Effect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.BitCrusher.defaults = { 'bits': 4 };
	    /**
		 * The bit depth of the effect. Nominal range of 1-8. 
		 * @memberOf Tone.BitCrusher#
		 * @type {number}
		 * @name bits
		 */
	    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
	        get: function () {
	            return this._bits;
	        },
	        set: function (bits) {
	            this._bits = bits;
	            var invStepSize = 1 / Math.pow(2, bits - 1);
	            this._modulo.value = invStepSize;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.BitCrusher} this
		 */
	    Tone.BitCrusher.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._subtract.dispose();
	        this._subtract = null;
	        this._modulo.dispose();
	        this._modulo = null;
	        return this;
	    };
	    return Tone.BitCrusher;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
		 *         for making different types of distortion sounds.
		 *         Note that odd orders sound very different from even ones, 
		 *         and order = 1 is no change. 
		 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
		 *  @example
		 * //create a new cheby
		 * var cheby = new Tone.Chebyshev(50);
		 * //create a monosynth connected to our cheby
		 * synth = new Tone.MonoSynth().connect(cheby);
		 */
	    Tone.Chebyshev = function () {
	        var options = Tone.defaults(arguments, ['order'], Tone.Chebyshev);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds onto the order of the filter
			 * @type {number}
			 * @private
			 */
	        this._order = options.order;
	        this.connectEffect(this._shaper);
	        this.order = options.order;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Chebyshev, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Chebyshev.defaults = {
	        'order': 1,
	        'oversample': 'none'
	    };
	    /**
		 *  get the coefficient for that degree
		 *  @param {number} x the x value
		 *  @param   {number} degree 
		 *  @param {Object} memo memoize the computed value. 
		 *                       this speeds up computation greatly. 
		 *  @return  {number}       the coefficient 
		 *  @private
		 */
	    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
	        if (memo.hasOwnProperty(degree)) {
	            return memo[degree];
	        } else if (degree === 0) {
	            memo[degree] = 0;
	        } else if (degree === 1) {
	            memo[degree] = x;
	        } else {
	            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
	        }
	        return memo[degree];
	    };
	    /**
		 * The order of the Chebyshev polynomial which creates
		 * the equation which is applied to the incoming 
		 * signal through a Tone.WaveShaper. The equations
		 * are in the form:<br>
		 * order 2: 2x^2 + 1<br>
		 * order 3: 4x^3 + 3x <br>
		 * @memberOf Tone.Chebyshev#
		 * @type {Positive}
		 * @name order
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
	        get: function () {
	            return this._order;
	        },
	        set: function (order) {
	            this._order = order;
	            var curve = new Array(4096);
	            var len = curve.length;
	            for (var i = 0; i < len; ++i) {
	                var x = i * 2 / len - 1;
	                if (x === 0) {
	                    //should output 0 when input is 0
	                    curve[i] = 0;
	                } else {
	                    curve[i] = this._getCoefficient(x, order, {});
	                }
	            }
	            this._shaper.curve = curve;
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Chebyshev#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chebyshev} this
		 */
	    Tone.Chebyshev.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Chebyshev;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R.
		 *
		 *	@constructor
		 *	@extends {Tone.Effect}
		 */
	    Tone.StereoEffect = function () {
	        //get the defaults
	        Tone.AudioNode.call(this);
	        var options = Tone.defaults(arguments, ['wet'], Tone.Effect);
	        this.createInsOuts(1, 1);
	        /**
			 *  the drywet knob to control the amount of effect
			 *  @type {Tone.CrossFade}
			 *  @private
			 */
	        this._dryWet = new Tone.CrossFade(options.wet);
	        /**
			 *  The wet control, i.e. how much of the effected
			 *  will pass through to the output.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.wet = this._dryWet.fade;
	        /**
			 *  then split it
			 *  @type {Tone.Split}
			 *  @private
			 */
	        this._split = new Tone.Split();
	        /**
			 *  the effects send LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendL = this._split.left;
	        /**
			 *  the effects send RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectSendR = this._split.right;
	        /**
			 *  the stereo effect merger
			 *  @type {Tone.Merge}
			 *  @private
			 */
	        this._merge = new Tone.Merge();
	        /**
			 *  the effect return LEFT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnL = this._merge.left;
	        /**
			 *  the effect return RIGHT
			 *  @type {GainNode}
			 *  @private
			 */
	        this.effectReturnR = this._merge.right;
	        //connections
	        this.input.connect(this._split);
	        //dry wet connections
	        this.input.connect(this._dryWet, 0, 0);
	        this._merge.connect(this._dryWet, 0, 1);
	        this._dryWet.connect(this.output);
	        this._readOnly(['wet']);
	    };
	    Tone.extend(Tone.StereoEffect, Tone.Effect);
	    /**
		 *  Clean up.
		 *  @returns {Tone.StereoEffect} this
		 */
	    Tone.StereoEffect.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._dryWet.dispose();
	        this._dryWet = null;
	        this._split.dispose();
	        this._split = null;
	        this._merge.dispose();
	        this._merge = null;
	        this.effectSendL = null;
	        this.effectSendR = null;
	        this.effectReturnL = null;
	        this.effectReturnR = null;
	        this._writable(['wet']);
	        this.wet = null;
	        return this;
	    };
	    return Tone.StereoEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 * 	@class  Tone.FeedbackEffect provides a loop between an 
		 * 	        audio source and its own output. This is a base-class
		 * 	        for feedback effects. 
		 *
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {NormalRange|Object} [feedback] The initial feedback value.
		 */
	    Tone.FeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.Effect.call(this, options);
	        /**
			 *  the gain which controls the feedback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  The amount of signal which is fed back into the effect input. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = this._feedbackGain.gain;
	        //the feedback loop
	        this.effectReturn.chain(this._feedbackGain, this.effectSend);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.FeedbackEffect} this
		 */
	    Tone.FeedbackEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this._feedbackGain.dispose();
	        this._feedbackGain = null;
	        this.feedback = null;
	        return this;
	    };
	    return Tone.FeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
		 *         and right to left instead of on the same channel.
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoXFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The amount of feedback from the output
			 *  back into the input of the effect (routed
			 *  across left and right channels).
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackLR = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackRL = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
	        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
	        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoXFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoXFeedbackEffect} this
		 */
	    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackLR.dispose();
	        this._feedbackLR = null;
	        this._feedbackRL.dispose();
	        this._feedbackRL = null;
	        return this;
	    };
	    return Tone.StereoXFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
		 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
		 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
		 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
		 *
		 *	@constructor
		 *	@extends {Tone.StereoXFeedbackEffect}
		 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
		 *	@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. 
		 *	@param {NormalRange} [depth] The depth of the chorus.
		 *	@example
		 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
		 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
		 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
		 */
	    Tone.Chorus = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'delayTime',
	            'depth'
	        ], Tone.Chorus);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the depth of the chorus
			 *  @type {number}
			 *  @private
			 */
	        this._depth = options.depth;
	        /**
			 *  the delayTime
			 *  @type {number}
			 *  @private
			 */
	        this._delayTime = options.delayTime / 1000;
	        /**
			 *  the lfo which controls the delayTime
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1
	        });
	        /**
			 *  another LFO for the right side with a 180 degree phase diff
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'frequency': options.frequency,
	            'min': 0,
	            'max': 1,
	            'phase': 180
	        });
	        /**
			 *  delay for left
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeL = new Tone.Delay();
	        /**
			 *  delay for right
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNodeR = new Tone.Delay();
	        /**
			 * The frequency of the LFO which modulates the delayTime. 
			 * @type {Frequency}
			 * @signal
			 */
	        this.frequency = this._lfoL.frequency;
	        //connections
	        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);
	        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);
	        //and pass through to make the detune apparent
	        this.effectSendL.connect(this.effectReturnL);
	        this.effectSendR.connect(this.effectReturnR);
	        //lfo setup
	        this._lfoL.connect(this._delayNodeL.delayTime);
	        this._lfoR.connect(this._delayNodeR.delayTime);
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        //have one LFO frequency control the other
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the initial values
	        this.depth = this._depth;
	        this.frequency.value = options.frequency;
	        this.type = options.type;
	        this._readOnly(['frequency']);
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Chorus.defaults = {
	        'frequency': 1.5,
	        'delayTime': 3.5,
	        'depth': 0.7,
	        'feedback': 0.1,
	        'type': 'sine',
	        'spread': 180
	    };
	    /**
		 * The depth of the effect. A depth of 1 makes the delayTime
		 * modulate between 0 and 2*delayTime (centered around the delayTime). 
		 * @memberOf Tone.Chorus#
		 * @type {NormalRange}
		 * @name depth
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
	        get: function () {
	            return this._depth;
	        },
	        set: function (depth) {
	            this._depth = depth;
	            var deviation = this._delayTime * depth;
	            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoL.max = this._delayTime + deviation;
	            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
	            this._lfoR.max = this._delayTime + deviation;
	        }
	    });
	    /**
		 * The delayTime in milliseconds of the chorus. A larger delayTime
		 * will give a more pronounced effect. Nominal range a delayTime
		 * is between 2 and 20ms. 
		 * @memberOf Tone.Chorus#
		 * @type {Milliseconds}
		 * @name delayTime
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
	        get: function () {
	            return this._delayTime * 1000;
	        },
	        set: function (delayTime) {
	            this._delayTime = delayTime / 1000;
	            this.depth = this._depth;
	        }
	    });
	    /**
		 * The oscillator type of the LFO. 
		 * @memberOf Tone.Chorus#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Chorus#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Chorus.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Chorus} this
		 */
	    Tone.Chorus.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._delayNodeL.dispose();
	        this._delayNodeL = null;
	        this._delayNodeR.dispose();
	        this._delayNodeR = null;
	        this._writable('frequency');
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Chorus;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
		 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
		 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
		 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
		 *  
		 *  @constructor
		 *  @extends {Tone.Effect}
		 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
		 *                                           contianing the impulse response. 
		 *  @param {Function} onload The callback to invoke when the url is loaded.
		 *  @example
		 * //initializing the convolver with an impulse response
		 * var convolver = new Tone.Convolver("./path/to/ir.wav").toMaster();
		 */
	    Tone.Convolver = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.Convolver);
	        Tone.Effect.call(this, options);
	        /**
			 *  convolver node
			 *  @type {ConvolverNode}
			 *  @private
			 */
	        this._convolver = this.context.createConvolver();
	        /**
			 *  the convolution buffer
			 *  @type {Tone.Buffer}
			 *  @private
			 */
	        this._buffer = new Tone.Buffer();
	        if (Tone.isString(options.url)) {
	            this._buffer.load(options.url, function (buffer) {
	                this.buffer = buffer;
	                options.onload();
	            }.bind(this));
	        } else if (options.url) {
	            this.buffer = options.url;
	            options.onload();
	        }
	        this.connectEffect(this._convolver);
	    };
	    Tone.extend(Tone.Convolver, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Convolver.defaults = { 'onload': Tone.noOp };
	    /**
		 *  The convolver's buffer
		 *  @memberOf Tone.Convolver#
		 *  @type {AudioBuffer}
		 *  @name buffer
		 */
	    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
	        get: function () {
	            return this._buffer.get();
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	            this._convolver.buffer = this._buffer.get();
	        }
	    });
	    /**
		 *  Load an impulse response url as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads.
		 *  @param {string} url The url of the buffer to load.
		 *                      filetype support depends on the
		 *                      browser.
		 *  @param  {function=} callback
		 *  @returns {Promise}
		 */
	    Tone.Convolver.prototype.load = function (url, callback) {
	        return this._buffer.load(url, function (buff) {
	            this.buffer = buff;
	            if (callback) {
	                callback();
	            }
	        }.bind(this));
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Convolver} this
		 */
	    Tone.Convolver.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._convolver.disconnect();
	        this._convolver = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Convolver;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
		 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
		 *  @example
		 * var dist = new Tone.Distortion(0.8).toMaster();
		 * var fm = new Tone.SimpleFM().connect(dist);
		 * //this sounds good on bass notes
		 * fm.triggerAttackRelease("A1", "8n");
		 */
	    Tone.Distortion = function () {
	        var options = Tone.defaults(arguments, ['distortion'], Tone.Distortion);
	        Tone.Effect.call(this, options);
	        /**
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._shaper = new Tone.WaveShaper(4096);
	        /**
			 * holds the distortion amount
			 * @type {number}
			 * @private
			 */
	        this._distortion = options.distortion;
	        this.connectEffect(this._shaper);
	        this.distortion = options.distortion;
	        this.oversample = options.oversample;
	    };
	    Tone.extend(Tone.Distortion, Tone.Effect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Distortion.defaults = {
	        'distortion': 0.4,
	        'oversample': 'none'
	    };
	    /**
		 * The amount of distortion.
		 * @memberOf Tone.Distortion#
		 * @type {NormalRange}
		 * @name distortion
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
	        get: function () {
	            return this._distortion;
	        },
	        set: function (amount) {
	            this._distortion = amount;
	            var k = amount * 100;
	            var deg = Math.PI / 180;
	            this._shaper.setMap(function (x) {
	                if (Math.abs(x) < 0.001) {
	                    //should output 0 when input is 0
	                    return 0;
	                } else {
	                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
	                }
	            });
	        }
	    });
	    /**
		 * The oversampling of the effect. Can either be "none", "2x" or "4x".
		 * @memberOf Tone.Distortion#
		 * @type {string}
		 * @name oversample
		 */
	    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
	        get: function () {
	            return this._shaper.oversample;
	        },
	        set: function (oversampling) {
	            this._shaper.oversample = oversampling;
	        }
	    });
	    /**
		 *  Clean up. 
		 *  @returns {Tone.Distortion} this
		 */
	    Tone.Distortion.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._shaper.dispose();
	        this._shaper = null;
	        return this;
	    };
	    return Tone.Distortion;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
		 *          signal is fed back into the delay. 
		 *
		 *  @constructor
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                            is fed back through the delay.
		 *  @example
		 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
		 * var tom = new Tone.DrumSynth({
		 * 	"octaves" : 4,
		 * 	"pitchDecay" : 0.1
		 * }).connect(feedbackDelay);
		 * tom.triggerAttackRelease("A2","32n");
		 */
	    Tone.FeedbackDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.FeedbackDelay);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  the delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(options.delayTime);
	        /**
			 *  The delayTime of the DelayNode. 
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._delayNode.delayTime;
	        // connect it up
	        this.connectEffect(this._delayNode);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
	    /**
		 *  The default values. 
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
	    /**
		 *  clean up
		 *  @returns {Tone.FeedbackDelay} this
		 */
	    Tone.FeedbackDelay.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._writable(['delayTime']);
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.FeedbackDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of comb filter delay values from Freeverb implementation
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var combFilterTunings = [
	        1557 / 44100,
	        1617 / 44100,
	        1491 / 44100,
	        1422 / 44100,
	        1277 / 44100,
	        1356 / 44100,
	        1188 / 44100,
	        1116 / 44100
	    ];
	    /**
		 *  an array of allpass filter frequency values from Freeverb implementation
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFrequencies = [
	        225,
	        556,
	        441,
	        341
	    ];
	    /**
		 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
		 *         Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time.
		 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part
		 *                                 of the reverb.
		 *  @example
		 * var freeverb = new Tone.Freeverb().toMaster();
		 * freeverb.dampening.value = 1000;
		 * //routing synth through the reverb
		 * var synth = new Tone.AMSynth().connect(freeverb);
		 */
	    Tone.Freeverb = function () {
	        var options = Tone.defaults(arguments, [
	            'roomSize',
	            'dampening'
	        ], Tone.Freeverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The roomSize value between. A larger roomSize
			 *  will result in a longer decay.
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  The amount of dampening of the reverberant signal.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
	        /**
			 *  the comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._combFilters = [];
	        /**
			 *  the allpass filters on the left
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersL = [];
	        /**
			 *  the allpass filters on the right
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFiltersR = [];
	        //make the allpass filters on the right
	        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
	            var allpassL = this.context.createBiquadFilter();
	            allpassL.type = 'allpass';
	            allpassL.frequency.value = allpassFilterFrequencies[l];
	            this._allpassFiltersL.push(allpassL);
	        }
	        //make the allpass filters on the left
	        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
	            var allpassR = this.context.createBiquadFilter();
	            allpassR.type = 'allpass';
	            allpassR.frequency.value = allpassFilterFrequencies[r];
	            this._allpassFiltersR.push(allpassR);
	        }
	        //make the comb filters
	        for (var c = 0; c < combFilterTunings.length; c++) {
	            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
	            if (c < combFilterTunings.length / 2) {
	                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
	            } else {
	                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
	            }
	            this.roomSize.connect(lfpf.resonance);
	            this.dampening.connect(lfpf.dampening);
	            this._combFilters.push(lfpf);
	        }
	        //chain the allpass filters togetehr
	        Tone.connectSeries.apply(Tone, this._allpassFiltersL);
	        Tone.connectSeries.apply(Tone, this._allpassFiltersR);
	        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
	        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
	        this._readOnly([
	            'roomSize',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Freeverb.defaults = {
	        'roomSize': 0.7,
	        'dampening': 3000
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Freeverb} this
		 */
	    Tone.Freeverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var al = 0; al < this._allpassFiltersL.length; al++) {
	            this._allpassFiltersL[al].disconnect();
	            this._allpassFiltersL[al] = null;
	        }
	        this._allpassFiltersL = null;
	        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
	            this._allpassFiltersR[ar].disconnect();
	            this._allpassFiltersR[ar] = null;
	        }
	        this._allpassFiltersR = null;
	        for (var cf = 0; cf < this._combFilters.length; cf++) {
	            this._combFilters[cf].dispose();
	            this._combFilters[cf] = null;
	        }
	        this._combFilters = null;
	        this._writable([
	            'roomSize',
	            'dampening'
	        ]);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this.dampening.dispose();
	        this.dampening = null;
	        return this;
	    };
	    return Tone.Freeverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  an array of the comb filter delay time values
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterDelayTimes = [
	        1687 / 25000,
	        1601 / 25000,
	        2053 / 25000,
	        2251 / 25000
	    ];
	    /**
		 *  the resonances of each of the comb filters
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var combFilterResonances = [
	        0.773,
	        0.802,
	        0.753,
	        0.733
	    ];
	    /**
		 *  the allpass filter frequencies
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var allpassFilterFreqs = [
	        347,
	        113,
	        37
	    ];
	    /**
		 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
		 *         tuned by John Chowning in 1970.
		 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
		 *         
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
		 *  @example
		 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
		 * var delay = new Tone.FeedbackDelay(0.5); 
		 * //connecting the synth to reverb through delay
		 * var synth = new Tone.DuoSynth().chain(delay, reverb);
		 * synth.triggerAttackRelease("A4","8n");
		 */
	    Tone.JCReverb = function () {
	        var options = Tone.defaults(arguments, ['roomSize'], Tone.JCReverb);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  room size control values between [0,1]
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
	        /**
			 *  scale the room size
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
	        /**
			 *  a series of allpass filters
			 *  @type {Array}
			 *  @private
			 */
	        this._allpassFilters = [];
	        /**
			 *  parallel feedback comb filters
			 *  @type {Array}
			 *  @private
			 */
	        this._feedbackCombFilters = [];
	        //make the allpass filters
	        for (var af = 0; af < allpassFilterFreqs.length; af++) {
	            var allpass = this.context.createBiquadFilter();
	            allpass.type = 'allpass';
	            allpass.frequency.value = allpassFilterFreqs[af];
	            this._allpassFilters.push(allpass);
	        }
	        //and the comb filters
	        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
	            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
	            this._scaleRoomSize.connect(fbcf.resonance);
	            fbcf.resonance.value = combFilterResonances[cf];
	            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
	            if (cf < combFilterDelayTimes.length / 2) {
	                fbcf.connect(this.effectReturnL);
	            } else {
	                fbcf.connect(this.effectReturnR);
	            }
	            this._feedbackCombFilters.push(fbcf);
	        }
	        //chain the allpass filters together
	        this.roomSize.connect(this._scaleRoomSize);
	        Tone.connectSeries.apply(Tone, this._allpassFilters);
	        this.effectSendL.connect(this._allpassFilters[0]);
	        this.effectSendR.connect(this._allpassFilters[0]);
	        this._readOnly(['roomSize']);
	    };
	    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.JCReverb} this
		 */
	    Tone.JCReverb.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
	            this._allpassFilters[apf].disconnect();
	            this._allpassFilters[apf] = null;
	        }
	        this._allpassFilters = null;
	        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
	            this._feedbackCombFilters[fbcf].dispose();
	            this._feedbackCombFilters[fbcf] = null;
	        }
	        this._feedbackCombFilters = null;
	        this._writable(['roomSize']);
	        this.roomSize.dispose();
	        this.roomSize = null;
	        this._scaleRoomSize.dispose();
	        this._scaleRoomSize = null;
	        return this;
	    };
	    return Tone.JCReverb;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Mid/Side processing separates the the 'mid' signal 
		 *         (which comes out of both the left and the right channel) 
		 *         and the 'side' (which only comes out of the the side channels) 
		 *         and effects them separately before being recombined.
		 *         Applies a Mid/Side seperation and recombination.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         This is a base-class for Mid/Side Effects. 
		 *
		 *  @extends {Tone.Effect}
		 *  @constructor
		 */
	    Tone.MidSideEffect = function () {
	        Tone.Effect.apply(this, arguments);
	        /**
			 *  The mid/side split
			 *  @type  {Tone.MidSideSplit}
			 *  @private
			 */
	        this._midSideSplit = new Tone.MidSideSplit();
	        /**
			 *  The mid/side merge
			 *  @type  {Tone.MidSideMerge}
			 *  @private
			 */
	        this._midSideMerge = new Tone.MidSideMerge();
	        /**
			 *  The mid send. Connect to mid processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.midSend = this._midSideSplit.mid;
	        /**
			 *  The side send. Connect to side processing
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this.sideSend = this._midSideSplit.side;
	        /**
			 *  The mid return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.midReturn = this._midSideMerge.mid;
	        /**
			 *  The side return connection
			 *  @type {GainNode}
			 *  @private
			 */
	        this.sideReturn = this._midSideMerge.side;
	        //the connections
	        this.effectSend.connect(this._midSideSplit);
	        this._midSideMerge.connect(this.effectReturn);
	    };
	    Tone.extend(Tone.MidSideEffect, Tone.Effect);
	    /**
		 *  Clean up. 
		 *  @returns {Tone.MidSideEffect} this
		 */
	    Tone.MidSideEffect.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._midSideSplit.dispose();
	        this._midSideSplit = null;
	        this._midSideMerge.dispose();
	        this._midSideMerge = null;
	        this.midSend = null;
	        this.sideSend = null;
	        this.midReturn = null;
	        this.sideReturn = null;
	        return this;
	    };
	    return Tone.MidSideEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
		 *         of different frequency components of an incoming signal. Read more on 
		 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
		 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
		 *
		 *	@extends {Tone.StereoEffect}
		 *	@constructor
		 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
		 *	@param {number} [octaves] The octaves of the effect. 
		 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
		 *	@example
		 * var phaser = new Tone.Phaser({
		 * 	"frequency" : 15, 
		 * 	"octaves" : 5, 
		 * 	"baseFrequency" : 1000
		 * }).toMaster();
		 * var synth = new Tone.FMSynth().connect(phaser);
		 * synth.triggerAttackRelease("E3", "2n");
		 */
	    Tone.Phaser = function () {
	        //set the defaults
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'octaves',
	            'baseFrequency'
	        ], Tone.Phaser);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  the lfo which controls the frequency on the left side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
	        /**
			 *  the lfo which controls the frequency on the right side
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
	        this._lfoR.phase = 180;
	        /**
			 *  the base modulation frequency
			 *  @type {number}
			 *  @private
			 */
	        this._baseFrequency = options.baseFrequency;
	        /**
			 *  the octaves of the phasing
			 *  @type {number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  The quality factor of the filters
			 *  @type {Positive}
			 *  @signal
			 */
	        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
	        /**
			 *  the array of filters for the left side
			 *  @type {Array}
			 *  @private
			 */
	        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
	        /**
			 * the frequency of the effect
			 * @type {Tone.Signal}
			 */
	        this.frequency = this._lfoL.frequency;
	        this.frequency.value = options.frequency;
	        //connect them up
	        this.effectSendL.connect(this._filtersL[0]);
	        this.effectSendR.connect(this._filtersR[0]);
	        this._filtersL[options.stages - 1].connect(this.effectReturnL);
	        this._filtersR[options.stages - 1].connect(this.effectReturnR);
	        //control the frequency with one LFO
	        this._lfoL.frequency.connect(this._lfoR.frequency);
	        //set the options
	        this.baseFrequency = options.baseFrequency;
	        this.octaves = options.octaves;
	        //start the lfo
	        this._lfoL.start();
	        this._lfoR.start();
	        this._readOnly([
	            'frequency',
	            'Q'
	        ]);
	    };
	    Tone.extend(Tone.Phaser, Tone.StereoEffect);
	    /**
		 *  defaults
		 *  @static
		 *  @type {object}
		 */
	    Tone.Phaser.defaults = {
	        'frequency': 0.5,
	        'octaves': 3,
	        'stages': 10,
	        'Q': 10,
	        'baseFrequency': 350
	    };
	    /**
		 *  @param {number} stages
		 *  @returns {Array} the number of filters all connected together
		 *  @private
		 */
	    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
	        var filters = new Array(stages);
	        //make all the filters
	        for (var i = 0; i < stages; i++) {
	            var filter = this.context.createBiquadFilter();
	            filter.type = 'allpass';
	            Q.connect(filter.Q);
	            connectToFreq.connect(filter.frequency);
	            filters[i] = filter;
	        }
	        Tone.connectSeries.apply(Tone, filters);
	        return filters;
	    };
	    /**
		 * The number of octaves the phase goes above
		 * the baseFrequency
		 * @memberOf Tone.Phaser#
		 * @type {Positive}
		 * @name octaves
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octaves) {
	            this._octaves = octaves;
	            var max = this._baseFrequency * Math.pow(2, octaves);
	            this._lfoL.max = max;
	            this._lfoR.max = max;
	        }
	    });
	    /**
		 * The the base frequency of the filters. 
		 * @memberOf Tone.Phaser#
		 * @type {number}
		 * @name baseFrequency
		 */
	    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
	        get: function () {
	            return this._baseFrequency;
	        },
	        set: function (freq) {
	            this._baseFrequency = freq;
	            this._lfoL.min = freq;
	            this._lfoR.min = freq;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Phaser} this
		 */
	    Tone.Phaser.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'Q'
	        ]);
	        this.Q.dispose();
	        this.Q = null;
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        for (var i = 0; i < this._filtersL.length; i++) {
	            this._filtersL[i].disconnect();
	            this._filtersL[i] = null;
	        }
	        this._filtersL = null;
	        for (var j = 0; j < this._filtersR.length; j++) {
	            this._filtersR[j].disconnect();
	            this._filtersR[j] = null;
	        }
	        this._filtersR = null;
	        this.frequency = null;
	        return this;
	    };
	    return Tone.Phaser;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
		 *          first in one channel and next in the opposite channel. In a stereo
		 *          system these are the right and left channels.
		 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
		 *          with independent delay values. Each delay is routed to one channel
		 *          (left or right), and the channel triggered second will always 
		 *          trigger at the same interval after the first.
		 *
		 * 	@constructor
		 * 	@extends {Tone.StereoXFeedbackEffect}
		 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
		 *  @param {NormalRange=} feedback The amount of the effected signal which 
		 *                                 is fed back through the delay.
		 *  @example
		 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
		 * var drum = new Tone.DrumSynth().connect(pingPong);
		 * drum.triggerAttackRelease("C4", "32n");
		 */
	    Tone.PingPongDelay = function () {
	        var options = Tone.defaults(arguments, [
	            'delayTime',
	            'feedback'
	        ], Tone.PingPongDelay);
	        Tone.StereoXFeedbackEffect.call(this, options);
	        /**
			 *  the delay node on the left side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay node on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the predelay on the right side
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);
	        /**
			 *  the delay time signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
	        //connect it up
	        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
	        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
	        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
	        //rearranged the feedback to be after the rightPreDelay
	        this._feedbackLR.disconnect();
	        this._feedbackLR.connect(this._rightDelay);
	        this._readOnly(['delayTime']);
	    };
	    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PingPongDelay.defaults = {
	        'delayTime': 0.25,
	        'maxDelayTime': 1
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PingPongDelay} this
		 */
	    Tone.PingPongDelay.prototype.dispose = function () {
	        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
	        this._leftDelay.dispose();
	        this._leftDelay = null;
	        this._rightDelay.dispose();
	        this._rightDelay = null;
	        this._rightPreDelay.dispose();
	        this._rightPreDelay = null;
	        this._writable(['delayTime']);
	        this.delayTime.dispose();
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PingPongDelay;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. 
		 *         The effect is achieved by speeding up or slowing down the delayTime
		 *         of a DelayNode using a sawtooth wave. 
		 *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).
		 *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).
		 *         
		 *  @extends {Tone.FeedbackEffect}
		 *  @param {Interval=} pitch The interval to transpose the incoming signal by. 
		 */
	    Tone.PitchShift = function () {
	        var options = Tone.defaults(arguments, ['pitch'], Tone.PitchShift);
	        Tone.FeedbackEffect.call(this, options);
	        /**
			 *  The pitch signal
			 *  @type  {Tone.Signal}
			 *  @private
			 */
	        this._frequency = new Tone.Signal(0);
	        /**
			 *  Uses two DelayNodes to cover up the jump in
			 *  the sawtooth wave. 
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayA = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoA = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth'
	        }).connect(this._delayA.delayTime);
	        /**
			 *  The second DelayNode
			 *  @type  {DelayNode}
			 *  @private
			 */
	        this._delayB = new Tone.Delay(0, 1);
	        /**
			 *  The first LFO.
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoB = new Tone.LFO({
	            'min': 0,
	            'max': 0.1,
	            'type': 'sawtooth',
	            'phase': 180
	        }).connect(this._delayB.delayTime);
	        /**
			 *  Crossfade quickly between the two delay lines
			 *  to cover up the jump in the sawtooth wave
			 *  @type  {Tone.CrossFade}
			 *  @private
			 */
	        this._crossFade = new Tone.CrossFade();
	        /**
			 *  LFO which alternates between the two
			 *  delay lines to cover up the disparity in the
			 *  sawtooth wave. 
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._crossFadeLFO = new Tone.LFO({
	            'min': 0,
	            'max': 1,
	            'type': 'triangle',
	            'phase': 90
	        }).connect(this._crossFade.fade);
	        /**
			 *  The delay node
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._feedbackDelay = new Tone.Delay(options.delayTime);
	        /**
			 *  The amount of delay on the input signal
			 *  @type {Time}
			 *  @signal
			 */
	        this.delayTime = this._feedbackDelay.delayTime;
	        this._readOnly('delayTime');
	        /**
			 *  Hold the current pitch
			 *  @type {Number}
			 *  @private
			 */
	        this._pitch = options.pitch;
	        /**
			 *  Hold the current windowSize
			 *  @type {Number}
			 *  @private
			 */
	        this._windowSize = options.windowSize;
	        //connect the two delay lines up
	        this._delayA.connect(this._crossFade.a);
	        this._delayB.connect(this._crossFade.b);
	        //connect the frequency
	        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);
	        //route the input
	        this.effectSend.fan(this._delayA, this._delayB);
	        this._crossFade.chain(this._feedbackDelay, this.effectReturn);
	        //start the LFOs at the same time
	        var now = this.now();
	        this._lfoA.start(now);
	        this._lfoB.start(now);
	        this._crossFadeLFO.start(now);
	        //set the initial value
	        this.windowSize = this._windowSize;
	    };
	    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PitchShift.defaults = {
	        'pitch': 0,
	        'windowSize': 0.1,
	        'delayTime': 0,
	        'feedback': 0
	    };
	    /**
		 * Repitch the incoming signal by some interval (measured
		 * in semi-tones). 
		 * @memberOf Tone.PitchShift#
		 * @type {Interval}
		 * @name pitch
		 * @example
		 * pitchShift.pitch = -12; //down one octave
		 * pitchShift.pitch = 7; //up a fifth
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {
	        get: function () {
	            return this._pitch;
	        },
	        set: function (interval) {
	            this._pitch = interval;
	            var factor = 0;
	            if (interval < 0) {
	                this._lfoA.min = 0;
	                this._lfoA.max = this._windowSize;
	                this._lfoB.min = 0;
	                this._lfoB.max = this._windowSize;
	                factor = Tone.intervalToFrequencyRatio(interval - 1) + 1;
	            } else {
	                this._lfoA.min = this._windowSize;
	                this._lfoA.max = 0;
	                this._lfoB.min = this._windowSize;
	                this._lfoB.max = 0;
	                factor = Tone.intervalToFrequencyRatio(interval) - 1;
	            }
	            this._frequency.value = factor * (1.2 / this._windowSize);
	        }
	    });
	    /**
		 * The window size corresponds roughly to the sample length in a looping sampler. 
		 * Smaller values are desirable for a less noticeable delay time of the pitch shifted
		 * signal, but larger values will result in smoother pitch shifting for larger intervals. 
		 * A nominal range of 0.03 to 0.1 is recommended. 
		 * @memberOf Tone.PitchShift#
		 * @type {Time}
		 * @name windowSize
		 * @example
		 * pitchShift.windowSize = 0.1;
		 */
	    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {
	        get: function () {
	            return this._windowSize;
	        },
	        set: function (size) {
	            this._windowSize = this.toSeconds(size);
	            this.pitch = this._pitch;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.PitchShift}  this
		 */
	    Tone.PitchShift.prototype.dispose = function () {
	        Tone.FeedbackEffect.prototype.dispose.call(this);
	        this._frequency.dispose();
	        this._frequency = null;
	        this._delayA.disconnect();
	        this._delayA = null;
	        this._delayB.disconnect();
	        this._delayB = null;
	        this._lfoA.dispose();
	        this._lfoA = null;
	        this._lfoB.dispose();
	        this._lfoB = null;
	        this._crossFade.dispose();
	        this._crossFade = null;
	        this._crossFadeLFO.dispose();
	        this._crossFadeLFO = null;
	        this._writable('delayTime');
	        this._feedbackDelay.dispose();
	        this._feedbackDelay = null;
	        this.delayTime = null;
	        return this;
	    };
	    return Tone.PitchShift;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Base class for stereo feedback effects where the effectReturn
		 *         is fed back into the same channel. 
		 *
		 *	@constructor
		 *	@extends {Tone.StereoEffect}
		 */
	    Tone.StereoFeedbackEffect = function () {
	        var options = Tone.defaults(arguments, ['feedback'], Tone.FeedbackEffect);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  controls the amount of feedback
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
	        /**
			 *  the left side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackL = new Tone.Gain();
	        /**
			 *  the right side feeback
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._feedbackR = new Tone.Gain();
	        //connect it up
	        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
	        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
	        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
	        this._readOnly(['feedback']);
	    };
	    Tone.extend(Tone.StereoFeedbackEffect, Tone.StereoEffect);
	    /**
		 *  clean up
		 *  @returns {Tone.StereoFeedbackEffect} this
		 */
	    Tone.StereoFeedbackEffect.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable(['feedback']);
	        this.feedback.dispose();
	        this.feedback = null;
	        this._feedbackL.dispose();
	        this._feedbackL = null;
	        this._feedbackR.dispose();
	        this._feedbackR = null;
	        return this;
	    };
	    return Tone.StereoFeedbackEffect;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Applies a width factor to the mid/side seperation. 
		 *         0 is all mid and 1 is all side.
		 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
		 *         <br><br>
		 *         <code>
		 *         Mid *= 2*(1-width)<br>
		 *         Side *= 2*width
		 *         </code>
		 *
		 *  @extends {Tone.MidSideEffect}
		 *  @constructor
		 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
		 */
	    Tone.StereoWidener = function () {
	        var options = Tone.defaults(arguments, ['width'], Tone.StereoWidener);
	        Tone.MidSideEffect.call(this, options);
	        /**
			 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  Mid multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
	        /**
			 *  Side multiplier
			 *  @type {Tone.Expr}
			 *  @private
			 */
	        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
	        /**
			 *  constant output of 2
			 *  @type {Tone}
			 *  @private
			 */
	        this._two = new Tone.Signal(2);
	        //the mid chain
	        this._two.connect(this._midMult, 0, 1);
	        this.width.connect(this._midMult, 0, 2);
	        //the side chain
	        this._two.connect(this._sideMult, 0, 1);
	        this.width.connect(this._sideMult, 0, 2);
	        //connect it to the effect send/return
	        this.midSend.chain(this._midMult, this.midReturn);
	        this.sideSend.chain(this._sideMult, this.sideReturn);
	        this._readOnly(['width']);
	    };
	    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
	    /**
		 *  the default values
		 *  @static
		 *  @type {Object}
		 */
	    Tone.StereoWidener.defaults = { 'width': 0.5 };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.StereoWidener} this
		 */
	    Tone.StereoWidener.prototype.dispose = function () {
	        Tone.MidSideEffect.prototype.dispose.call(this);
	        this._writable(['width']);
	        this.width.dispose();
	        this.width = null;
	        this._midMult.dispose();
	        this._midMult = null;
	        this._sideMult.dispose();
	        this._sideMult = null;
	        this._two.dispose();
	        this._two = null;
	        return this;
	    };
	    return Tone.StereoWidener;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.
		 *         The type, frequency, and depth of the LFO is controllable.
		 *
		 *  @extends {Tone.StereoEffect}
		 *  @constructor
		 *  @param {Frequency} [frequency] The rate of the effect.
		 *  @param {NormalRange} [depth] The depth of the effect.
		 *  @example
		 * //create a tremolo and start it's LFO
		 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
		 * //route an oscillator through the tremolo and start it
		 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
		 */
	    Tone.Tremolo = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Tremolo);
	        Tone.StereoEffect.call(this, options);
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoL = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  The tremelo LFO in the left channel
			 *  @type  {Tone.LFO}
			 *  @private
			 */
	        this._lfoR = new Tone.LFO({
	            'phase': options.spread,
	            'min': 1,
	            'max': 0
	        });
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeL = new Tone.Gain();
	        /**
			 *  Where the gain is multiplied
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._amplitudeR = new Tone.Gain();
	        /**
			 *  The frequency of the tremolo.
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The depth of the effect. A depth of 0, has no effect
			 *  on the amplitude, and a depth of 1 makes the amplitude
			 *  modulate fully between 0 and 1.
			 *  @type  {NormalRange}
			 *  @signal
			 */
	        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);
	        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);
	        this._lfoL.connect(this._amplitudeL.gain);
	        this._lfoR.connect(this._amplitudeR.gain);
	        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);
	        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);
	        this.type = options.type;
	        this.spread = options.spread;
	    };
	    Tone.extend(Tone.Tremolo, Tone.StereoEffect);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Tremolo.defaults = {
	        'frequency': 10,
	        'type': 'sine',
	        'depth': 0.5,
	        'spread': 180
	    };
	    /**
		 * Start the tremolo.
		 * @param {Time} [time=now] When the tremolo begins.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.start = function (time) {
	        this._lfoL.start(time);
	        this._lfoR.start(time);
	        return this;
	    };
	    /**
		 * Stop the tremolo.
		 * @param {Time} [time=now] When the tremolo stops.
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.stop = function (time) {
	        this._lfoL.stop(time);
	        this._lfoR.stop(time);
	        return this;
	    };
	    /**
		 * Sync the effect to the transport.
		 * @param {Time} [delay=0] Delay time before starting the effect after the
		 *                              Transport has started.
		 * @returns {Tone.AutoFilter} this
		 */
	    Tone.Tremolo.prototype.sync = function (delay) {
	        this._lfoL.sync(delay);
	        this._lfoR.sync(delay);
	        return this;
	    };
	    /**
		 * Unsync the filter from the transport
		 * @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.unsync = function () {
	        this._lfoL.unsync();
	        this._lfoR.unsync();
	        return this;
	    };
	    /**
		 * The Tremolo's oscillator type.
		 * @memberOf Tone.Tremolo#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
	        get: function () {
	            return this._lfoL.type;
	        },
	        set: function (type) {
	            this._lfoL.type = type;
	            this._lfoR.type = type;
	        }
	    });
	    /** 
		 * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.
		 * When set to 180, LFO's will be panned hard left and right respectively.
		 * @memberOf Tone.Tremolo#
		 * @type {Degrees}
		 * @name spread
		 */
	    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {
	        get: function () {
	            return this._lfoR.phase - this._lfoL.phase;    //180
	        },
	        set: function (spread) {
	            this._lfoL.phase = 90 - spread / 2;
	            this._lfoR.phase = spread / 2 + 90;
	        }
	    });
	    /**
		 *  clean up
		 *  @returns {Tone.Tremolo} this
		 */
	    Tone.Tremolo.prototype.dispose = function () {
	        Tone.StereoEffect.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this._lfoL.dispose();
	        this._lfoL = null;
	        this._lfoR.dispose();
	        this._lfoR = null;
	        this._amplitudeL.dispose();
	        this._amplitudeL = null;
	        this._amplitudeR.dispose();
	        this._amplitudeR = null;
	        this.frequency = null;
	        this.depth = null;
	        return this;
	    };
	    return Tone.Tremolo;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO
		 *         modulates the delayTime of the delay, causing the pitch to rise
		 *         and fall. 
		 *  @extends {Tone.Effect}
		 *  @param {Frequency} frequency The frequency of the vibrato.
		 *  @param {NormalRange} depth The amount the pitch is modulated.
		 */
	    Tone.Vibrato = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'depth'
	        ], Tone.Vibrato);
	        Tone.Effect.call(this, options);
	        /**
			 *  The delay node used for the vibrato effect
			 *  @type {Tone.Delay}
			 *  @private
			 */
	        this._delayNode = new Tone.Delay(0, options.maxDelay);
	        /**
			 *  The LFO used to control the vibrato
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._lfo = new Tone.LFO({
	            'type': options.type,
	            'min': 0,
	            'max': options.maxDelay,
	            'frequency': options.frequency,
	            'phase': -90    //offse the phase so the resting position is in the center
	        }).start().connect(this._delayNode.delayTime);
	        /**
			 *  The frequency of the vibrato
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._lfo.frequency;
	        /**
			 *  The depth of the vibrato. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.depth = this._lfo.amplitude;
	        this.depth.value = options.depth;
	        this._readOnly([
	            'frequency',
	            'depth'
	        ]);
	        this.effectSend.chain(this._delayNode, this.effectReturn);
	    };
	    Tone.extend(Tone.Vibrato, Tone.Effect);
	    /**
		 *  The defaults
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Vibrato.defaults = {
	        'maxDelay': 0.005,
	        'frequency': 5,
	        'depth': 0.1,
	        'type': 'sine'
	    };
	    /**
		 * Type of oscillator attached to the Vibrato.
		 * @memberOf Tone.Vibrato#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.Vibrato.prototype, 'type', {
	        get: function () {
	            return this._lfo.type;
	        },
	        set: function (type) {
	            this._lfo.type = type;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @returns {Tone.Vibrato} this
		 */
	    Tone.Vibrato.prototype.dispose = function () {
	        Tone.Effect.prototype.dispose.call(this);
	        this._delayNode.dispose();
	        this._delayNode = null;
	        this._lfo.dispose();
	        this._lfo = null;
	        this._writable([
	            'frequency',
	            'depth'
	        ]);
	        this.frequency = null;
	        this.depth = null;
	    };
	    return Tone.Vibrato;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable
		 *          callback for a single or repeatable events along the timeline. 
		 *
		 *  @extends {Tone}
		 *  @param {function} callback The callback to invoke at the time. 
		 *  @param {*} value The value or values which should be passed to
		 *                      the callback function on invocation.  
		 *  @example
		 * var chord = new Tone.Event(function(time, chord){
		 * 	//the chord as well as the exact time of the event
		 * 	//are passed in as arguments to the callback function
		 * }, ["D4", "E4", "F4"]);
		 * //start the chord at the beginning of the transport timeline
		 * chord.start();
		 * //loop it every measure for 8 measures
		 * chord.loop = 8;
		 * chord.loopEnd = "1m";
		 */
	    Tone.Event = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'value'
	        ], Tone.Event);
	        Tone.call(this);
	        /**
			 *  Loop value
			 *  @type  {Boolean|Positive}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  The callback to invoke. 
			 *  @type  {Function}
			 */
	        this.callback = options.callback;
	        /**
			 *  The value which is passed to the
			 *  callback function.
			 *  @type  {*}
			 *  @private
			 */
	        this.value = options.value;
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = this.toTicks(options.loopStart);
	        /**
			 *  When the note is scheduled to start.
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = this.toTicks(options.loopEnd);
	        /**
			 *  Tracks the scheduled events
			 *  @type {Tone.TimelineState}
			 *  @private
			 */
	        this._state = new Tone.TimelineState(Tone.State.Stopped);
	        /**
			 *  The playback speed of the note. A speed of 1
			 *  is no change. 
			 *  @private
			 *  @type {Positive}
			 */
	        this._playbackRate = 1;
	        /**
			 *  A delay time from when the event is scheduled to start
			 *  @type {Ticks}
			 *  @private
			 */
	        this._startOffset = 0;
	        /**
			 *  private holder of probability value
			 *  @type {NormalRange}
			 *  @private
			 */
	        this._probability = options.probability;
	        /**
			 *  the amount of variation from the
			 *  given time. 
			 *  @type {Boolean|Time}
			 *  @private
			 */
	        this._humanize = options.humanize;
	        /**
			 *  If mute is true, the callback won't be
			 *  invoked.
			 *  @type {Boolean}
			 */
	        this.mute = options.mute;
	        //set the initial values
	        this.playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Event.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'value': null,
	        'probability': 1,
	        'mute': false,
	        'humanize': false
	    };
	    /**
		 *  Reschedule all of the events along the timeline
		 *  with the updated values.
		 *  @param {Time} after Only reschedules events after the given time.
		 *  @return  {Tone.Event}  this
		 *  @private
		 */
	    Tone.Event.prototype._rescheduleEvents = function (after) {
	        //if no argument is given, schedules all of the events
	        after = Tone.defaultArg(after, -1);
	        this._state.forEachFrom(after, function (event) {
	            var duration;
	            if (event.state === Tone.State.Started) {
	                if (!Tone.isUndef(event.id)) {
	                    Tone.Transport.clear(event.id);
	                }
	                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);
	                if (this._loop) {
	                    duration = Infinity;
	                    if (Tone.isNumber(this._loop)) {
	                        duration = this._loop * this._getLoopDuration();
	                    }
	                    var nextEvent = this._state.getAfter(startTick);
	                    if (nextEvent !== null) {
	                        duration = Math.min(duration, nextEvent.time - startTick);
	                    }
	                    if (duration !== Infinity) {
	                        //schedule a stop since it's finite duration
	                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);
	                        duration = Tone.Time(duration, 'i');
	                    }
	                    var interval = Tone.Time(this._getLoopDuration(), 'i');
	                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);
	                } else {
	                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');
	                }
	            }
	        }.bind(this));
	        return this;
	    };
	    /**
		 *  Returns the playback state of the note, either "started" or "stopped".
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.Event#
		 *  @name state
		 */
	    Object.defineProperty(Tone.Event.prototype, 'state', {
	        get: function () {
	            return this._state.getValueAtTime(Tone.Transport.ticks);
	        }
	    });
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Event#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Event.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	        }
	    });
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Event.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Event.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	        }
	    });
	    /**
		 *  Start the note at the given time. 
		 *  @param  {TimelinePosition}  time  When the note should start.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.start = function (time) {
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': time,
	                'id': undefined
	            });
	            this._rescheduleEvents(time);
	        }
	        return this;
	    };
	    /**
		 *  Stop the Event at the given time.
		 *  @param  {TimelinePosition}  time  When the note should stop.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.stop = function (time) {
	        this.cancel(time);
	        time = this.toTicks(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            this._state.setStateAtTime(Tone.State.Stopped, time);
	            var previousEvent = this._state.getBefore(time);
	            var reschedulTime = time;
	            if (previousEvent !== null) {
	                reschedulTime = previousEvent.time;
	            }
	            this._rescheduleEvents(reschedulTime);
	        }
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.cancel = function (time) {
	        time = Tone.defaultArg(time, -Infinity);
	        time = this.toTicks(time);
	        this._state.forEachFrom(time, function (event) {
	            Tone.Transport.clear(event.id);
	        });
	        this._state.cancel(time);
	        return this;
	    };
	    /**
		 *  The callback function invoker. Also 
		 *  checks if the Event is done playing
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Event.prototype._tick = function (time) {
	        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {
	            if (this.probability < 1 && Math.random() > this.probability) {
	                return;
	            }
	            if (this.humanize) {
	                var variation = 0.02;
	                if (!Tone.isBoolean(this.humanize)) {
	                    variation = this.toSeconds(this.humanize);
	                }
	                time += (Math.random() * 2 - 1) * variation;
	            }
	            this.callback(time, this.value);
	        }
	    };
	    /**
		 *  Get the duration of the loop.
		 *  @return  {Ticks}
		 *  @private
		 */
	    Tone.Event.prototype._getLoopDuration = function () {
	        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);
	    };
	    /**
		 *  If the note should loop or not
		 *  between Tone.Event.loopStart and 
		 *  Tone.Event.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Event does after it starts.
		 *  @memberOf Tone.Event#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 * 	The playback rate of the note. Defaults to 1.
		 *  @memberOf Tone.Event#
		 *  @type {Positive}
		 *  @name playbackRate
		 *  @example
		 * note.loop = true;
		 * //repeat the note twice as fast
		 * note.playbackRate = 2;
		 */
	    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._rescheduleEvents();
	        }
	    });
	    /**
		 *  The loopEnd point is the time the event will loop
		 *  if Tone.Event.loop is true.
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The time when the loop should start. 
		 *  @memberOf Tone.Event#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Event.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._rescheduleEvents();
	            }
	        }
	    });
	    /**
		 *  The current progress of the loop interval.
		 *  Returns 0 if the event is not started yet or
		 *  it is not set to loop.
		 *  @memberOf Tone.Event#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Event.prototype, 'progress', {
	        get: function () {
	            if (this._loop) {
	                var ticks = Tone.Transport.ticks;
	                var lastEvent = this._state.get(ticks);
	                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {
	                    var loopDuration = this._getLoopDuration();
	                    var progress = (ticks - lastEvent.time) % loopDuration;
	                    return progress / loopDuration;
	                } else {
	                    return 0;
	                }
	            } else {
	                return 0;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Event}  this
		 */
	    Tone.Event.prototype.dispose = function () {
	        this.cancel();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this.value = null;
	    };
	    return Tone.Event;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Loop creates a looped callback at the 
		 *         specified interval. The callback can be 
		 *         started, stopped and scheduled along
		 *         the Transport's timeline. 
		 *  @example
		 * var loop = new Tone.Loop(function(time){
		 * 	//triggered every eighth note. 
		 * 	console.log(time);
		 * }, "8n").start(0);
		 * Tone.Transport.start();
		 *  @extends {Tone}
		 *  @param {Function} callback The callback to invoke with the event.
		 *  @param {Time} interval The time between successive callback calls. 
		 */
	    Tone.Loop = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'interval'
	        ], Tone.Loop);
	        Tone.call(this);
	        /**
			 *  The event which produces the callbacks
			 */
	        this._event = new Tone.Event({
	            'callback': this._tick.bind(this),
	            'loop': true,
	            'loopEnd': options.interval,
	            'playbackRate': options.playbackRate,
	            'probability': options.probability
	        });
	        /**
			 *  The callback to invoke with the next event in the pattern
			 *  @type {Function}
			 */
	        this.callback = options.callback;
	        //set the iterations
	        this.iterations = options.iterations;
	    };
	    Tone.extend(Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Loop.defaults = {
	        'interval': '4n',
	        'callback': Tone.noOp,
	        'playbackRate': 1,
	        'iterations': Infinity,
	        'probability': true,
	        'mute': false
	    };
	    /**
		 *  Start the loop at the specified time along the Transport's
		 *  timeline.
		 *  @param  {TimelinePosition=}  time  When to start the Loop.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.start = function (time) {
	        this._event.start(time);
	        return this;
	    };
	    /**
		 *  Stop the loop at the given time.
		 *  @param  {TimelinePosition=}  time  When to stop the Arpeggio
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.stop = function (time) {
	        this._event.stop(time);
	        return this;
	    };
	    /**
		 *  Cancel all scheduled events greater than or equal to the given time
		 *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.cancel = function (time) {
	        this._event.cancel(time);
	        return this;
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Loop.prototype._tick = function (time) {
	        this.callback(time);
	    };
	    /**
		 *  The state of the Loop, either started or stopped.
		 *  @memberOf Tone.Loop#
		 *  @type {String}
		 *  @name state
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'state', {
	        get: function () {
	            return this._event.state;
	        }
	    });
	    /**
		 *  The progress of the loop as a value between 0-1. 0, when
		 *  the loop is stopped or done iterating. 
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name progress
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'progress', {
	        get: function () {
	            return this._event.progress;
	        }
	    });
	    /**
		 *  The time between successive callbacks. 
		 *  @example
		 * loop.interval = "8n"; //loop every 8n
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name interval
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'interval', {
	        get: function () {
	            return this._event.loopEnd;
	        },
	        set: function (interval) {
	            this._event.loopEnd = interval;
	        }
	    });
	    /**
		 *  The playback rate of the loop. The normal playback rate is 1 (no change). 
		 *  A `playbackRate` of 2 would be twice as fast. 
		 *  @memberOf Tone.Loop#
		 *  @type {Time}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {
	        get: function () {
	            return this._event.playbackRate;
	        },
	        set: function (rate) {
	            this._event.playbackRate = rate;
	        }
	    });
	    /**
		 *  Random variation +/-0.01s to the scheduled time. 
		 *  Or give it a time value which it will randomize by.
		 *  @type {Boolean|Time}
		 *  @memberOf Tone.Loop#
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'humanize', {
	        get: function () {
	            return this._event.humanize;
	        },
	        set: function (variation) {
	            this._event.humanize = variation;
	        }
	    });
	    /**
		 *  The probably of the callback being invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'probability', {
	        get: function () {
	            return this._event.probability;
	        },
	        set: function (prob) {
	            this._event.probability = prob;
	        }
	    });
	    /**
		 *  Muting the Loop means that no callbacks are invoked.
		 *  @memberOf Tone.Loop#
		 *  @type {Boolean}
		 *  @name mute
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'mute', {
	        get: function () {
	            return this._event.mute;
	        },
	        set: function (mute) {
	            this._event.mute = mute;
	        }
	    });
	    /**
		 *  The number of iterations of the loop. The default
		 *  value is Infinity (loop forever).
		 *  @memberOf Tone.Loop#
		 *  @type {Positive}
		 *  @name iterations
		 */
	    Object.defineProperty(Tone.Loop.prototype, 'iterations', {
	        get: function () {
	            if (this._event.loop === true) {
	                return Infinity;
	            } else {
	                return this._event.loop;
	            }
	        },
	        set: function (iters) {
	            if (iters === Infinity) {
	                this._event.loop = true;
	            } else {
	                this._event.loop = iters;
	            }
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Loop}  this
		 */
	    Tone.Loop.prototype.dispose = function () {
	        this._event.dispose();
	        this._event = null;
	        this.callback = null;
	    };
	    return Tone.Loop;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.Part is a collection Tone.Events which can be
		 *         started/stopped and looped as a single unit.
		 *
		 *  @extends {Tone.Event}
		 *  @param {Function} callback The callback to invoke on each event
		 *  @param {Array} events the array of events
		 *  @example
		 * var part = new Tone.Part(function(time, note){
		 * 	//the notes given as the second element in the array
		 * 	//will be passed in as the second argument
		 * 	synth.triggerAttackRelease(note, "8n", time);
		 * }, [[0, "C2"], ["0:2", "C3"], ["0:3:2", "G2"]]);
		 *  @example
		 * //use an array of objects as long as the object has a "time" attribute
		 * var part = new Tone.Part(function(time, value){
		 * 	//the value is an object which contains both the note and the velocity
		 * 	synth.triggerAttackRelease(value.note, "8n", time, value.velocity);
		 * }, [{"time" : 0, "note" : "C3", "velocity": 0.9}, 
		 * 	   {"time" : "0:2", "note" : "C4", "velocity": 0.5}
		 * ]).start(0);
		 */
	    Tone.Part = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events'
	        ], Tone.Part);
	        Tone.Event.call(this, options);
	        /**
			 *  An array of Objects. 
			 *  @type  {Array}
			 *  @private
			 */
	        this._events = [];
	        //add the events
	        for (var i = 0; i < options.events.length; i++) {
	            if (Array.isArray(options.events[i])) {
	                this.add(options.events[i][0], options.events[i][1]);
	            } else {
	                this.add(options.events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Part, Tone.Event);
	    /**
		 *  The default values
		 *  @type  {Object}
		 *  @const
		 */
	    Tone.Part.defaults = {
	        'callback': Tone.noOp,
	        'loop': false,
	        'loopEnd': '1m',
	        'loopStart': 0,
	        'playbackRate': 1,
	        'probability': 1,
	        'humanize': false,
	        'mute': false,
	        'events': []
	    };
	    /**
		 *  Start the part at the given time. 
		 *  @param  {TransportTime}  time    When to start the part.
		 *  @param  {Time=}  offset  The offset from the start of the part
		 *                           to begin playing at.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.start = function (time, offset) {
	        var ticks = this.toTicks(time);
	        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {
	            if (this._loop) {
	                offset = Tone.defaultArg(offset, this._loopStart);
	            } else {
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toTicks(offset);
	            this._state.add({
	                'state': Tone.State.Started,
	                'time': ticks,
	                'offset': offset
	            });
	            this._forEach(function (event) {
	                this._startNote(event, ticks, offset);
	            });
	        }
	        return this;
	    };
	    /**
		 *  Start the event in the given event at the correct time given
		 *  the ticks and offset and looping.
		 *  @param  {Tone.Event}  event 
		 *  @param  {Ticks}  ticks
		 *  @param  {Ticks}  offset
		 *  @private
		 */
	    Tone.Part.prototype._startNote = function (event, ticks, offset) {
	        ticks -= offset;
	        if (this._loop) {
	            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {
	                if (event.startOffset < offset) {
	                    //start it on the next loop
	                    ticks += this._getLoopDuration();
	                }
	                event.start(Tone.TransportTime(ticks, 'i'));
	            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {
	                event.loop = false;
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        } else {
	            if (event.startOffset >= offset) {
	                event.start(Tone.TransportTime(ticks, 'i'));
	            }
	        }
	    };
	    /**
		 *  The start from the scheduled start time
		 *  @type {Ticks}
		 *  @memberOf Tone.Part#
		 *  @name startOffset
		 *  @private
		 */
	    Object.defineProperty(Tone.Part.prototype, 'startOffset', {
	        get: function () {
	            return this._startOffset;
	        },
	        set: function (offset) {
	            this._startOffset = offset;
	            this._forEach(function (event) {
	                event.startOffset += this._startOffset;
	            });
	        }
	    });
	    /**
		 *  Stop the part at the given time.
		 *  @param  {TimelinePosition}  time  When to stop the part.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.stop = function (time) {
	        var ticks = this.toTicks(time);
	        this._state.cancel(ticks);
	        this._state.setStateAtTime(Tone.State.Stopped, ticks);
	        this._forEach(function (event) {
	            event.stop(time);
	        });
	        return this;
	    };
	    /**
		 *  Get/Set an Event's value at the given time. 
		 *  If a value is passed in and no event exists at
		 *  the given time, one will be created with that value. 
		 *  If two events are at the same time, the first one will
		 *  be returned.
		 *  @example
		 * part.at("1m"); //returns the part at the first measure
		 *
		 * part.at("2m", "C2"); //set the value at "2m" to C2. 
		 * //if an event didn't exist at that time, it will be created.
		 *  @param {TransportTime} time The time of the event to get or set.
		 *  @param {*=} value If a value is passed in, the value of the
		 *                    event at the given time will be set to it.
		 *  @return {Tone.Event} the event at the time
		 */
	    Tone.Part.prototype.at = function (time, value) {
	        time = Tone.TransportTime(time);
	        var tickTime = Tone.Time(1, 'i').toSeconds();
	        for (var i = 0; i < this._events.length; i++) {
	            var event = this._events[i];
	            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {
	                if (!Tone.isUndef(value)) {
	                    event.value = value;
	                }
	                return event;
	            }
	        }
	        //if there was no event at that time, create one
	        if (!Tone.isUndef(value)) {
	            this.add(time, value);
	            //return the new event
	            return this._events[this._events.length - 1];
	        } else {
	            return null;
	        }
	    };
	    /**
		 *  Add a an event to the part. 
		 *  @param {Time} time The time the note should start.
		 *                            If an object is passed in, it should
		 *                            have a 'time' attribute and the rest
		 *                            of the object will be used as the 'value'.
		 *  @param  {Tone.Event|*}  value 
		 *  @returns {Tone.Part} this
		 *  @example
		 * part.add("1m", "C#+11");
		 */
	    Tone.Part.prototype.add = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        var event;
	        if (value instanceof Tone.Event) {
	            event = value;
	            event.callback = this._tick.bind(this);
	        } else {
	            event = new Tone.Event({
	                'callback': this._tick.bind(this),
	                'value': value
	            });
	        }
	        //the start offset
	        event.startOffset = time;
	        //initialize the values
	        event.set({
	            'loopEnd': this.loopEnd,
	            'loopStart': this.loopStart,
	            'loop': this.loop,
	            'humanize': this.humanize,
	            'playbackRate': this.playbackRate,
	            'probability': this.probability
	        });
	        this._events.push(event);
	        //start the note if it should be played right now
	        this._restartEvent(event);
	        return this;
	    };
	    /**
		 *  Restart the given event
		 *  @param  {Tone.Event}  event 
		 *  @private
		 */
	    Tone.Part.prototype._restartEvent = function (event) {
	        this._state.forEach(function (stateEvent) {
	            if (stateEvent.state === Tone.State.Started) {
	                this._startNote(event, stateEvent.time, stateEvent.offset);
	            } else {
	                //stop the note
	                event.stop(Tone.TransportTime(stateEvent.time, 'i'));
	            }
	        }.bind(this));
	    };
	    /**
		 *  Remove an event from the part. Will recursively iterate
		 *  into nested parts to find the event.
		 *  @param {Time} time The time of the event
		 *  @param {*} value Optionally select only a specific event value
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.remove = function (time, value) {
	        //extract the parameters
	        if (time.hasOwnProperty('time')) {
	            value = time;
	            time = value.time;
	        }
	        time = this.toTicks(time);
	        for (var i = this._events.length - 1; i >= 0; i--) {
	            var event = this._events[i];
	            if (event instanceof Tone.Part) {
	                event.remove(time, value);
	            } else {
	                if (event.startOffset === time) {
	                    if (Tone.isUndef(value) || !Tone.isUndef(value) && event.value === value) {
	                        this._events.splice(i, 1);
	                        event.dispose();
	                    }
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Remove all of the notes from the group. 
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.removeAll = function () {
	        this._forEach(function (event) {
	            event.dispose();
	        });
	        this._events = [];
	        return this;
	    };
	    /**
		 *  Cancel scheduled state change events: i.e. "start" and "stop".
		 *  @param {TimelinePosition} after The time after which to cancel the scheduled events.
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.cancel = function (after) {
	        this._forEach(function (event) {
	            event.cancel(after);
	        });
	        this._state.cancel(this.toTicks(after));
	        return this;
	    };
	    /**
		 *  Iterate over all of the events
		 *  @param {Function} callback
		 *  @param {Object} ctx The context
		 *  @private
		 */
	    Tone.Part.prototype._forEach = function (callback, ctx) {
	        if (this._events) {
	            ctx = Tone.defaultArg(ctx, this);
	            for (var i = this._events.length - 1; i >= 0; i--) {
	                var e = this._events[i];
	                if (e instanceof Tone.Part) {
	                    e._forEach(callback, ctx);
	                } else {
	                    callback.call(ctx, e);
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set the attribute of all of the events
		 *  @param  {String}  attr  the attribute to set
		 *  @param  {*}  value      The value to set it to
		 *  @private
		 */
	    Tone.Part.prototype._setAll = function (attr, value) {
	        this._forEach(function (event) {
	            event[attr] = value;
	        });
	    };
	    /**
		 *  Internal tick method
		 *  @param  {Number}  time  The time of the event in seconds
		 *  @private
		 */
	    Tone.Part.prototype._tick = function (time, value) {
	        if (!this.mute) {
	            this.callback(time, value);
	        }
	    };
	    /**
		 *  Determine if the event should be currently looping
		 *  given the loop boundries of this Part.
		 *  @param  {Tone.Event}  event  The event to test
		 *  @private
		 */
	    Tone.Part.prototype._testLoopBoundries = function (event) {
	        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {
	            event.cancel(0);
	        } else {
	            //reschedule it if it's stopped
	            if (event.state === Tone.State.Stopped) {
	                this._restartEvent(event);
	            }
	        }
	    };
	    /**
		 *  The probability of the notes being triggered.
		 *  @memberOf Tone.Part#
		 *  @type {NormalRange}
		 *  @name probability
		 */
	    Object.defineProperty(Tone.Part.prototype, 'probability', {
	        get: function () {
	            return this._probability;
	        },
	        set: function (prob) {
	            this._probability = prob;
	            this._setAll('probability', prob);
	        }
	    });
	    /**
		 *  If set to true, will apply small random variation
		 *  to the callback time. If the value is given as a time, it will randomize
		 *  by that amount.
		 *  @example
		 * event.humanize = true;
		 *  @type {Boolean|Time}
		 *  @name humanize
		 */
	    Object.defineProperty(Tone.Part.prototype, 'humanize', {
	        get: function () {
	            return this._humanize;
	        },
	        set: function (variation) {
	            this._humanize = variation;
	            this._setAll('humanize', variation);
	        }
	    });
	    /**
		 *  If the part should loop or not
		 *  between Tone.Part.loopStart and 
		 *  Tone.Part.loopEnd. An integer
		 *  value corresponds to the number of
		 *  loops the Part does after it starts.
		 *  @memberOf Tone.Part#
		 *  @type {Boolean|Positive}
		 *  @name loop
		 *  @example
		 * //loop the part 8 times
		 * part.loop = 8;
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            this._forEach(function (event) {
	                event._loopStart = this._loopStart;
	                event._loopEnd = this._loopEnd;
	                event.loop = loop;
	                this._testLoopBoundries(event);
	            });
	        }
	    });
	    /**
		 *  The loopEnd point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopEnd
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {
	        get: function () {
	            return Tone.TransportTime(this._loopEnd, 'i').toNotation();
	        },
	        set: function (loopEnd) {
	            this._loopEnd = this.toTicks(loopEnd);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopEnd = loopEnd;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 *  The loopStart point determines when it will 
		 *  loop if Tone.Part.loop is true.
		 *  @memberOf Tone.Part#
		 *  @type {TransportTime}
		 *  @name loopStart
		 */
	    Object.defineProperty(Tone.Part.prototype, 'loopStart', {
	        get: function () {
	            return Tone.TransportTime(this._loopStart, 'i').toNotation();
	        },
	        set: function (loopStart) {
	            this._loopStart = this.toTicks(loopStart);
	            if (this._loop) {
	                this._forEach(function (event) {
	                    event.loopStart = this.loopStart;
	                    this._testLoopBoundries(event);
	                });
	            }
	        }
	    });
	    /**
		 * 	The playback rate of the part
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name playbackRate
		 */
	    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this._setAll('playbackRate', rate);
	        }
	    });
	    /**
		 * 	The number of scheduled notes in the part. 
		 *  @memberOf Tone.Part#
		 *  @type {Positive}
		 *  @name length
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Part.prototype, 'length', {
	        get: function () {
	            return this._events.length;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Part}  this
		 */
	    Tone.Part.prototype.dispose = function () {
	        this.removeAll();
	        this._state.dispose();
	        this._state = null;
	        this.callback = null;
	        this._events = null;
	        return this;
	    };
	    return Tone.Part;
	});
	Module(function (Tone) {
	    /**
		 *  @class Tone.Pattern arpeggiates between the given notes
		 *         in a number of patterns. See Tone.CtrlPattern for
		 *         a full list of patterns.
		 *  @example
		 * var pattern = new Tone.Pattern(function(time, note){
		 *   //the order of the notes passed in depends on the pattern
		 * }, ["C2", "D4", "E5", "A6"], "upDown");
		 *  @extends {Tone.Loop}
		 *  @param {Function} callback The callback to invoke with the
		 *                             event.
		 *  @param {Array} values The values to arpeggiate over.
		 */
	    Tone.Pattern = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'values',
	            'pattern'
	        ], Tone.Pattern);
	        Tone.Loop.call(this, options);
	        /**
			 *  The pattern manager
			 *  @type {Tone.CtrlPattern}
			 *  @private
			 */
	        this._pattern = new Tone.CtrlPattern({
	            'values': options.values,
	            'type': options.pattern,
	            'index': options.index
	        });
	    };
	    Tone.extend(Tone.Pattern, Tone.Loop);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.Pattern.defaults = {
	        'pattern': Tone.CtrlPattern.Type.Up,
	        'callback': Tone.noOp,
	        'values': []
	    };
	    /**
		 *  Internal function called when the notes should be called
		 *  @param  {Number}  time  The time the event occurs
		 *  @private
		 */
	    Tone.Pattern.prototype._tick = function (time) {
	        this.callback(time, this._pattern.value);
	        this._pattern.next();
	    };
	    /**
		 *  The current index in the values array.
		 *  @memberOf Tone.Pattern#
		 *  @type {Positive}
		 *  @name index
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'index', {
	        get: function () {
	            return this._pattern.index;
	        },
	        set: function (i) {
	            this._pattern.index = i;
	        }
	    });
	    /**
		 *  The array of events.
		 *  @memberOf Tone.Pattern#
		 *  @type {Array}
		 *  @name values
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'values', {
	        get: function () {
	            return this._pattern.values;
	        },
	        set: function (vals) {
	            this._pattern.values = vals;
	        }
	    });
	    /**
		 *  The current value of the pattern.
		 *  @memberOf Tone.Pattern#
		 *  @type {*}
		 *  @name value
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'value', {
	        get: function () {
	            return this._pattern.value;
	        }
	    });
	    /**
		 *  The pattern type. See Tone.CtrlPattern for the full list of patterns.
		 *  @memberOf Tone.Pattern#
		 *  @type {String}
		 *  @name pattern
		 */
	    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {
	        get: function () {
	            return this._pattern.type;
	        },
	        set: function (pattern) {
	            this._pattern.type = pattern;
	        }
	    });
	    /**
		 *  Clean up
		 *  @return  {Tone.Pattern}  this
		 */
	    Tone.Pattern.prototype.dispose = function () {
	        Tone.Loop.prototype.dispose.call(this);
	        this._pattern.dispose();
	        this._pattern = null;
	    };
	    return Tone.Pattern;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class A sequence is an alternate notation of a part. Instead
		 *         of passing in an array of [time, event] pairs, pass
		 *         in an array of events which will be spaced at the
		 *         given subdivision. Sub-arrays will subdivide that beat
		 *         by the number of items are in the array. 
		 *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)
		 *  @param  {Function}  callback  The callback to invoke with every note
		 *  @param  {Array}    events  The sequence
		 *  @param  {Time} subdivision  The subdivision between which events are placed. 
		 *  @extends {Tone.Part}
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //straight quater notes
		 * }, ["C4", "E4", "G4", "A4"], "4n");
		 *  @example
		 * var seq = new Tone.Sequence(function(time, note){
		 * 	console.log(note);
		 * //subdivisions are given as subarrays
		 * }, ["C4", ["E4", "D4", "E4"], "G4", ["A4", "G4"]]);
		 */
	    Tone.Sequence = function () {
	        var options = Tone.defaults(arguments, [
	            'callback',
	            'events',
	            'subdivision'
	        ], Tone.Sequence);
	        //remove the events
	        var events = options.events;
	        delete options.events;
	        Tone.Part.call(this, options);
	        /**
			 *  The subdivison of each note
			 *  @type  {Ticks}
			 *  @private
			 */
	        this._subdivision = this.toTicks(options.subdivision);
	        //if no time was passed in, the loop end is the end of the cycle
	        if (Tone.isUndef(options.loopEnd) && !Tone.isUndef(events)) {
	            this._loopEnd = events.length * this._subdivision;
	        }
	        //defaults to looping
	        this._loop = true;
	        //add all of the events
	        if (!Tone.isUndef(events)) {
	            for (var i = 0; i < events.length; i++) {
	                this.add(i, events[i]);
	            }
	        }
	    };
	    Tone.extend(Tone.Sequence, Tone.Part);
	    /**
		 *  The default values.
		 *  @type  {Object}
		 */
	    Tone.Sequence.defaults = { 'subdivision': '4n' };
	    /**
		 *  The subdivision of the sequence. This can only be 
		 *  set in the constructor. The subdivision is the 
		 *  interval between successive steps. 
		 *  @type {Time}
		 *  @memberOf Tone.Sequence#
		 *  @name subdivision
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {
	        get: function () {
	            return Tone.Time(this._subdivision, 'i').toNotation();
	        }
	    });
	    /**
		 *  Get/Set an index of the sequence. If the index contains a subarray, 
		 *  a Tone.Sequence representing that sub-array will be returned. 
		 *  @example
		 * var sequence = new Tone.Sequence(playNote, ["E4", "C4", "F#4", ["A4", "Bb3"]])
		 * sequence.at(0)// => returns "E4"
		 * //set a value
		 * sequence.at(0, "G3");
		 * //get a nested sequence
		 * sequence.at(3).at(1)// => returns "Bb3"
		 * @param {Positive} index The index to get or set
		 * @param {*} value Optionally pass in the value to set at the given index.
		 */
	    Tone.Sequence.prototype.at = function (index, value) {
	        //if the value is an array, 
	        if (Tone.isArray(value)) {
	            //remove the current event at that index
	            this.remove(index);
	        }
	        //call the parent's method
	        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);
	    };
	    /**
		 *  Add an event at an index, if there's already something
		 *  at that index, overwrite it. If `value` is an array, 
		 *  it will be parsed as a subsequence.
		 *  @param {Number} index The index to add the event to
		 *  @param {*} value The value to add at that index
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.add = function (index, value) {
	        if (value === null) {
	            return this;
	        }
	        if (Tone.isArray(value)) {
	            //make a subsequence and add that to the sequence
	            var subSubdivision = Math.round(this._subdivision / value.length);
	            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));
	        }
	        Tone.Part.prototype.add.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Remove a value from the sequence by index
		 *  @param {Number} index The index of the event to remove
		 *  @returns {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.remove = function (index, value) {
	        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);
	        return this;
	    };
	    /**
		 *  Get the time of the index given the Sequence's subdivision
		 *  @param  {Number}  index 
		 *  @return  {Time}  The time of that index
		 *  @private
		 */
	    Tone.Sequence.prototype._indexTime = function (index) {
	        if (index instanceof Tone.TransportTime) {
	            return index;
	        } else {
	            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');
	        }
	    };
	    /**
		 *  Clean up.
		 *  @return {Tone.Sequence} this
		 */
	    Tone.Sequence.prototype.dispose = function () {
	        Tone.Part.prototype.dispose.call(this);
	        return this;
	    };
	    return Tone.Sequence;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
		 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
		 *         a square and only odd-numbered harmonics are present. At all other widths 
		 *         even-numbered harmonics are present. Read more 
		 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {Frequency} [frequency] The frequency of the oscillator
		 *  @param {NormalRange} [width] The width of the pulse
		 *  @example
		 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
		 */
	    Tone.PulseOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'width'
	        ], Tone.Oscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The width of the pulse. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
	        /**
			 *  gate the width amount
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._widthGate = new Tone.Gain();
	        /**
			 *  the sawtooth oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._sawtooth = new Tone.Oscillator({
	            frequency: options.frequency,
	            detune: options.detune,
	            type: 'sawtooth',
	            phase: options.phase
	        });
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._sawtooth.frequency;
	        /**
			 *  The detune in cents. 
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._sawtooth.detune;
	        /**
			 *  Threshold the signal to turn it into a square
			 *  @type {Tone.WaveShaper}
			 *  @private
			 */
	        this._thresh = new Tone.WaveShaper(function (val) {
	            if (val < 0) {
	                return -1;
	            } else {
	                return 1;
	            }
	        });
	        //connections
	        this._sawtooth.chain(this._thresh, this.output);
	        this.width.chain(this._widthGate, this._thresh);
	        this._readOnly([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PulseOscillator, Tone.Source);
	    /**
		 *  The default parameters.
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PulseOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'width': 0.2
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.start(time);
	        this._widthGate.gain.setValueAtTime(1, time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time 
		 *  @private
		 */
	    Tone.PulseOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._sawtooth.stop(time);
	        //the width is still connected to the output. 
	        //that needs to be stopped also
	        this._widthGate.gain.setValueAtTime(0, time);
	    };
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PulseOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
	        get: function () {
	            return this._sawtooth.phase;
	        },
	        set: function (phase) {
	            this._sawtooth.phase = phase;
	        }
	    });
	    /**
		 * The type of the oscillator. Always returns "pulse".
		 * @readOnly
		 * @memberOf Tone.PulseOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
	        get: function () {
	            return 'pulse';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PulseOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 *  Clean up method.
		 *  @return {Tone.PulseOscillator} this
		 */
	    Tone.PulseOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._sawtooth.dispose();
	        this._sawtooth = null;
	        this._writable([
	            'width',
	            'frequency',
	            'detune'
	        ]);
	        this.width.dispose();
	        this.width = null;
	        this._widthGate.dispose();
	        this._widthGate = null;
	        this._thresh.dispose();
	        this._thresh = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.PulseOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
		 *         at the modulationFrequency. This has the effect of continuously
		 *         changing the timbre of the oscillator by altering the harmonics 
		 *         generated.
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
		 *  @example
		 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
		 */
	    Tone.PWMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'modulationFrequency'
	        ], Tone.PWMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  the pulse oscillator
			 *  @type {Tone.PulseOscillator}
			 *  @private
			 */
	        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
	        //change the pulse oscillator type
	        this._pulse._sawtooth.type = 'sine';
	        /**
			 *  the modulator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator({
	            'frequency': options.frequency,
	            'detune': options.detune,
	            'phase': options.phase
	        });
	        /**
			 *  Scale the oscillator so it doesn't go silent 
			 *  at the extreme values.
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._scale = new Tone.Multiply(2);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._modulator.frequency;
	        /**
			 *  The detune of the oscillator.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._modulator.detune;
	        /**
			 *  The modulation rate of the oscillator. 
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.modulationFrequency = this._pulse.frequency;
	        //connections
	        this._modulator.chain(this._scale, this._pulse.width);
	        this._pulse.connect(this.output);
	        this._readOnly([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.PWMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.PWMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationFrequency': 0.4
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._pulse.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.PWMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._pulse.stop(time);
	    };
	    /**
		 * The type of the oscillator. Always returns "pwm".
		 * @readOnly
		 * @memberOf Tone.PWMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
	        get: function () {
	            return 'pwm';
	        }
	    });
	    /**
		 * The partials of the waveform. Cannot set partials for this waveform type
		 * @memberOf Tone.PWMOscillator#
		 * @type {Array}
		 * @name partials
		 * @private
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {
	        get: function () {
	            return [];
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.PWMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._modulator.phase;
	        },
	        set: function (phase) {
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.PWMOscillator} this
		 */
	    Tone.PWMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._pulse.dispose();
	        this._pulse = null;
	        this._scale.dispose();
	        this._scale = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._writable([
	            'modulationFrequency',
	            'frequency',
	            'detune'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.modulationFrequency = null;
	        return this;
	    };
	    return Tone.PWMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FMOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.FMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
			 *  modulating signal (ma) -- as in ma/mf. 
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this.detune.connect(this._modulator.detune);
	        this.phase = options.phase;
	        this._readOnly([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.FMOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationIndex': 2,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.FMOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FMOscillator} this
		 */
	    Tone.FMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'modulationIndex',
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        return this;
	    };
	    return Tone.FMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.AMOscillator 
		 *
		 *  @extends {Tone.Oscillator}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.AMOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.AMOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'modulationType'
	        ], Tone.AMOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The carrier oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._carrier = new Tone.Oscillator(options.frequency, options.type);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this._carrier.frequency;
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this._carrier.detune;
	        this.detune.value = options.detune;
	        /**
			 *  The modulating oscillator
			 *  @type  {Tone.Oscillator}
			 *  @private
			 */
	        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
			 *  A harmonicity of 1 gives both oscillators the same frequency. 
			 *  Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch the modulator an octave below carrier
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //connections
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.connect(this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this.phase = options.phase;
	        this._readOnly([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	    };
	    Tone.extend(Tone.AMOscillator, Tone.Oscillator);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.AMOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'modulationType': 'square',
	        'harmonicity': 1
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.AMOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.start(time);
	        this._carrier.start(time);
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.AMOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._modulator.stop(time);
	        this._carrier.stop(time);
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {
	        get: function () {
	            return this._carrier.type;
	        },
	        set: function (type) {
	            this._carrier.type = type;
	        }
	    });
	    /**
		 * The type of the modulator oscillator
		 * @memberOf Tone.AMOscillator#
		 * @type {string}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {
	        get: function () {
	            return this._modulator.type;
	        },
	        set: function (type) {
	            this._modulator.type = type;
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.AMOscillator#
		 * @type {number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {
	        get: function () {
	            return this._carrier.phase;
	        },
	        set: function (phase) {
	            this._carrier.phase = phase;
	            this._modulator.phase = phase;
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.AMOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {
	        get: function () {
	            return this._carrier.partials;
	        },
	        set: function (partials) {
	            this._carrier.partials = partials;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.AMOscillator} this
		 */
	    Tone.AMOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune',
	            'harmonicity'
	        ]);
	        this.frequency = null;
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        return this;
	    };
	    return Tone.AMOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.FatOscillator 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The starting frequency of the oscillator. 
		 *  @param {String} type The type of the carrier oscillator.
		 *  @param {String} modulationType The type of the modulator oscillator.
		 *  @example
		 * //a sine oscillator frequency-modulated by a square wave
		 * var fmOsc = new Tone.FatOscillator("Ab3", "sine", "square").toMaster().start();
		 */
	    Tone.FatOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type',
	            'spread'
	        ], Tone.FatOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The oscillator's frequency
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control signal.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  The array of oscillators
			 *  @type {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The total spread of the oscillators
			 *  @type  {Cents}
			 *  @private
			 */
	        this._spread = options.spread;
	        /**
			 *  The type of the oscillator
			 *  @type {String}
			 *  @private
			 */
	        this._type = options.type;
	        /**
			 *  The phase of the oscillators
			 *  @type {Degrees}
			 *  @private
			 */
	        this._phase = options.phase;
	        /**
			 *  The partials array
			 *  @type {Array}
			 *  @private
			 */
	        this._partials = Tone.defaultArg(options.partials, []);
	        //set the count initially
	        this.count = options.count;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FatOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.FatOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'phase': 0,
	        'spread': 20,
	        'count': 3,
	        'type': 'sawtooth'
	    };
	    /**
		 *  start the oscillator
		 *  @param  {Time} [time=now]
		 *  @private
		 */
	    Tone.FatOscillator.prototype._start = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.start(time);
	        });
	    };
	    /**
		 *  stop the oscillator
		 *  @param  {Time} time (optional) timing parameter
		 *  @private
		 */
	    Tone.FatOscillator.prototype._stop = function (time) {
	        time = this.toSeconds(time);
	        this._forEach(function (osc) {
	            osc.stop(time);
	        });
	    };
	    /**
		 *  Iterate over all of the oscillators
		 *  @param  {Function}  iterator  The iterator function
		 *  @private
		 */
	    Tone.FatOscillator.prototype._forEach = function (iterator) {
	        for (var i = 0; i < this._oscillators.length; i++) {
	            iterator.call(this, this._oscillators[i], i);
	        }
	    };
	    /**
		 * The type of the carrier oscillator
		 * @memberOf Tone.FatOscillator#
		 * @type {string}
		 * @name type
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            this._type = type;
	            this._forEach(function (osc) {
	                osc.type = type;
	            });
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents.
		 * @memberOf Tone.FatOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {
	        get: function () {
	            return this._spread;
	        },
	        set: function (spread) {
	            this._spread = spread;
	            if (this._oscillators.length > 1) {
	                var start = -spread / 2;
	                var step = spread / (this._oscillators.length - 1);
	                this._forEach(function (osc, i) {
	                    osc.detune.value = start + step * i;
	                });
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {
	        get: function () {
	            return this._oscillators.length;
	        },
	        set: function (count) {
	            count = Math.max(count, 1);
	            if (this._oscillators.length !== count) {
	                // var partials = this.partials;
	                // var type = this.type;
	                //dispose the previous oscillators
	                this._forEach(function (osc) {
	                    osc.dispose();
	                });
	                this._oscillators = [];
	                for (var i = 0; i < count; i++) {
	                    var osc = new Tone.Oscillator();
	                    if (this.type === Tone.Oscillator.Type.Custom) {
	                        osc.partials = this._partials;
	                    } else {
	                        osc.type = this._type;
	                    }
	                    osc.phase = this._phase;
	                    osc.volume.value = -6 - count;
	                    this.frequency.connect(osc.frequency);
	                    this.detune.connect(osc.detune);
	                    osc.connect(this.output);
	                    this._oscillators[i] = osc;
	                }
	                //set the spread
	                this.spread = this._spread;
	                if (this.state === Tone.State.Started) {
	                    this._forEach(function (osc) {
	                        osc.start();
	                    });
	                }
	            }
	        }
	    });
	    /**
		 * The phase of the oscillator in degrees.
		 * @memberOf Tone.FatOscillator#
		 * @type {Number}
		 * @name phase
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {
	        get: function () {
	            return this._phase;
	        },
	        set: function (phase) {
	            this._phase = phase;
	            this._forEach(function (osc) {
	                osc.phase = phase;
	            });
	        }
	    });
	    /**
		 * The partials of the carrier waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * @memberOf Tone.FatOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {
	        get: function () {
	            return this._partials;
	        },
	        set: function (partials) {
	            this._partials = partials;
	            this._type = Tone.Oscillator.Type.Custom;
	            this._forEach(function (osc) {
	                osc.partials = partials;
	            });
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.FatOscillator} this
		 */
	    Tone.FatOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this._forEach(function (osc) {
	            osc.dispose();
	        });
	        this._oscillators = null;
	        this._partials = null;
	        return this;
	    };
	    return Tone.FatOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
		 *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator
		 *         into one class. The oscillator class can be changed by setting the `type`. 
		 *         `omniOsc.type = "pwm"` will set it to the Tone.PWMOscillator. Prefixing
		 *         any of the basic types ("sine", "square4", etc.) with "fm", "am", or "fat"
		 *         will use the FMOscillator, AMOscillator or FatOscillator respectively. 
		 *         For example: `omniOsc.type = "fatsawtooth"` will create set the oscillator
		 *         to a FatOscillator of type "sawtooth". 
		 *
		 *  @extends {Tone.Source}
		 *  @constructor
		 *  @param {Frequency} frequency The initial frequency of the oscillator.
		 *  @param {String} type The type of the oscillator.
		 *  @example
		 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
		 */
	    Tone.OmniOscillator = function () {
	        var options = Tone.defaults(arguments, [
	            'frequency',
	            'type'
	        ], Tone.OmniOscillator);
	        Tone.Source.call(this, options);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The detune control
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  the type of the oscillator source
			 *  @type {String}
			 *  @private
			 */
	        this._sourceType = undefined;
	        /**
			 *  the oscillator
			 *  @type {Tone.Oscillator}
			 *  @private
			 */
	        this._oscillator = null;
	        //set the oscillator
	        this.type = options.type;
	        this._readOnly([
	            'frequency',
	            'detune'
	        ]);
	        //set the options
	        this.set(options);
	    };
	    Tone.extend(Tone.OmniOscillator, Tone.Source);
	    /**
		 *  default values
		 *  @static
		 *  @type {Object}
		 *  @const
		 */
	    Tone.OmniOscillator.defaults = {
	        'frequency': 440,
	        'detune': 0,
	        'type': 'sine',
	        'phase': 0
	    };
	    /**
		 *  @enum {String}
		 *  @private
		 */
	    var OmniOscType = {
	        Pulse: 'PulseOscillator',
	        PWM: 'PWMOscillator',
	        Osc: 'Oscillator',
	        FM: 'FMOscillator',
	        AM: 'AMOscillator',
	        Fat: 'FatOscillator'
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._start = function (time) {
	        this._oscillator.start(time);
	    };
	    /**
		 *  start the oscillator
		 *  @param {Time} [time=now] the time to start the oscillator
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._stop = function (time) {
	        this._oscillator.stop(time);
	    };
	    /**
		 * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or
		 * prefix the basic types with "fm", "am", or "fat" to use the FMOscillator, AMOscillator or FatOscillator
		 * types. The oscillator could also be set to "pwm" or "pulse". All of the parameters of the
		 * oscillator's class are accessible when the oscillator is set to that type, but throws an error 
		 * when it's not.
		 * 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name type
		 * @example
		 * omniOsc.type = "pwm";
		 * //modulationFrequency is parameter which is available
		 * //only when the type is "pwm". 
		 * omniOsc.modulationFrequency.value = 0.5;
		 * @example
		 * //an square wave frequency modulated by a sawtooth
		 * omniOsc.type = "fmsquare";
		 * omniOsc.modulationType = "sawtooth";
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
	        get: function () {
	            var prefix = '';
	            if (this._sourceType === OmniOscType.FM) {
	                prefix = 'fm';
	            } else if (this._sourceType === OmniOscType.AM) {
	                prefix = 'am';
	            } else if (this._sourceType === OmniOscType.Fat) {
	                prefix = 'fat';
	            }
	            return prefix + this._oscillator.type;
	        },
	        set: function (type) {
	            if (type.substr(0, 2) === 'fm') {
	                this._createNewOscillator(OmniOscType.FM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 2) === 'am') {
	                this._createNewOscillator(OmniOscType.AM);
	                this._oscillator.type = type.substr(2);
	            } else if (type.substr(0, 3) === 'fat') {
	                this._createNewOscillator(OmniOscType.Fat);
	                this._oscillator.type = type.substr(3);
	            } else if (type === 'pwm') {
	                this._createNewOscillator(OmniOscType.PWM);
	            } else if (type === 'pulse') {
	                this._createNewOscillator(OmniOscType.Pulse);
	            } else {
	                this._createNewOscillator(OmniOscType.Osc);
	                this._oscillator.type = type;
	            }
	        }
	    });
	    /**
		 * The partials of the waveform. A partial represents 
		 * the amplitude at a harmonic. The first harmonic is the 
		 * fundamental frequency, the second is the octave and so on
		 * following the harmonic series. 
		 * Setting this value will automatically set the type to "custom". 
		 * The value is an empty array when the type is not "custom". 
		 * This is not available on "pwm" and "pulse" oscillator types.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Array}
		 * @name partials
		 * @example
		 * osc.partials = [1, 0.2, 0.01];
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {
	        get: function () {
	            return this._oscillator.partials;
	        },
	        set: function (partials) {
	            this._oscillator.partials = partials;
	        }
	    });
	    /**
		 *  Set a member/attribute of the oscillator. 
		 *  @param {Object|String} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.set = function (params, value) {
	        //make sure the type is set first
	        if (params === 'type') {
	            this.type = value;
	        } else if (Tone.isObject(params) && params.hasOwnProperty('type')) {
	            this.type = params.type;
	        }
	        //then set the rest
	        Tone.prototype.set.apply(this, arguments);
	        return this;
	    };
	    /**
		 *  connect the oscillator to the frequency and detune signals
		 *  @private
		 */
	    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {
	        if (oscType !== this._sourceType) {
	            this._sourceType = oscType;
	            var OscillatorConstructor = Tone[oscType];
	            //short delay to avoid clicks on the change
	            var now = this.now();
	            if (this._oscillator !== null) {
	                var oldOsc = this._oscillator;
	                oldOsc.stop(now);
	                //dispose the old one
	                this.context.setTimeout(function () {
	                    oldOsc.dispose();
	                    oldOsc = null;
	                }, this.blockTime);
	            }
	            this._oscillator = new OscillatorConstructor();
	            this.frequency.connect(this._oscillator.frequency);
	            this.detune.connect(this._oscillator.detune);
	            this._oscillator.connect(this.output);
	            if (this.state === Tone.State.Started) {
	                this._oscillator.start(now);
	            }
	        }
	    };
	    /**
		 * The phase of the oscillator in degrees. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Degrees}
		 * @name phase
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
	        get: function () {
	            return this._oscillator.phase;
	        },
	        set: function (phase) {
	            this._oscillator.phase = phase;
	        }
	    });
	    /**
		 * The width of the oscillator (only if the oscillator is set to "pulse")
		 * @memberOf Tone.OmniOscillator#
		 * @type {NormalRange}
		 * @signal
		 * @name width
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
		 * //can access the width attribute only if type === "pulse"
		 * omniOsc.width.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Pulse) {
	                return this._oscillator.width;
	            }
	        }
	    });
	    /**
		 * The number of detuned oscillators
		 * @memberOf Tone.OmniOscillator#
		 * @type {Number}
		 * @name count
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.count;
	            }
	        },
	        set: function (count) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.count = count;
	            }
	        }
	    });
	    /**
		 * The detune spread between the oscillators. If "count" is
		 * set to 3 oscillators and the "spread" is set to 40,
		 * the three oscillators would be detuned like this: [-20, 0, 20]
		 * for a total detune spread of 40 cents. See Tone.FatOscillator
		 * for more info.
		 * @memberOf Tone.OmniOscillator#
		 * @type {Cents}
		 * @name spread
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {
	        get: function () {
	            if (this._sourceType === OmniOscType.Fat) {
	                return this._oscillator.spread;
	            }
	        },
	        set: function (spread) {
	            if (this._sourceType === OmniOscType.Fat) {
	                this._oscillator.spread = spread;
	            }
	        }
	    });
	    /**
		 * The type of the modulator oscillator. Only if the oscillator
		 * is set to "am" or "fm" types. see. Tone.AMOscillator or Tone.FMOscillator
		 * for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {String}
		 * @name modulationType
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.modulationType;
	            }
	        },
	        set: function (mType) {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                this._oscillator.modulationType = mType;
	            }
	        }
	    });
	    /**
		 * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
		 * ratio of the frequency of the modulating signal (mf) to the amplitude of the 
		 * modulating signal (ma) -- as in ma/mf. 
		 * See Tone.FMOscillator for more info. 
		 * @type {Positive}
		 * @signal
		 * @name modulationIndex
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM) {
	                return this._oscillator.modulationIndex;
	            }
	        }
	    });
	    /**
		 *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. 
		 *  A harmonicity of 1 gives both oscillators the same frequency. 
		 *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator
		 *  for more info. 
		 *  @memberOf Tone.OmniOscillator#
		 *  @signal
		 *  @type {Positive}
		 *  @name harmonicity
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {
	        get: function () {
	            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {
	                return this._oscillator.harmonicity;
	            }
	        }
	    });
	    /**
		 * The modulationFrequency Signal of the oscillator 
		 * (only if the oscillator type is set to pwm). See 
		 * Tone.PWMOscillator for more info. 
		 * @memberOf Tone.OmniOscillator#
		 * @type {Frequency}
		 * @signal
		 * @name modulationFrequency
		 * @example
		 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
		 * //can access the modulationFrequency attribute only if type === "pwm"
		 * omniOsc.modulationFrequency.value = 0.2; 
		 */
	    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
	        get: function () {
	            if (this._sourceType === OmniOscType.PWM) {
	                return this._oscillator.modulationFrequency;
	            }
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return {Tone.OmniOscillator} this
		 */
	    Tone.OmniOscillator.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'detune'
	        ]);
	        this.detune.dispose();
	        this.detune = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._oscillator.dispose();
	        this._oscillator = null;
	        this._sourceType = null;
	        return this;
	    };
	    return Tone.OmniOscillator;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Base-class for all instruments
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 */
	    Tone.Instrument = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        Tone.AudioNode.call(this);
	        /**
			 *  The output and volume triming node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	    };
	    Tone.extend(Tone.Instrument, Tone.AudioNode);
	    /**
		 *  the default attributes
		 *  @type {object}
		 */
	    Tone.Instrument.defaults = {
	        /** the volume of the output in decibels */
	        'volume': 0
	    };
	    /**
		 *  @abstract
		 *  @param {string|number} note the note to trigger
		 *  @param {Time} [time=now] the time to trigger the ntoe
		 *  @param {number} [velocity=1] the velocity to trigger the note
		 */
	    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
	    /**
		 *  @abstract
		 *  @param {Time} [time=now] when to trigger the release
		 */
	    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
	    /**
		 *  Trigger the attack and then the release after the duration.
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} duration How long the note should be held for before
		 *                          triggering the release. This value must be greater than 0.
		 *  @param {Time} [time=now]  When the note should be triggered.
		 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
		 *  @returns {Tone.Instrument} this
		 *  @example
		 * //trigger "C4" for the duration of an 8th note
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Instrument} this
		 */
	    Tone.Instrument.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable(['volume']);
	        this.volume = null;
	        return this;
	    };
	    return Tone.Instrument;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  This is an abstract base class for other monophonic instruments to 
		 *          extend. IMPORTANT: It does not make any sound on its own and
		 *          shouldn't be directly instantiated.
		 *
		 *  @constructor
		 *  @abstract
		 *  @extends {Tone.Instrument}
		 */
	    Tone.Monophonic = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Monophonic.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The glide time between notes. 
			 *  @type {Time}
			 */
	        this.portamento = options.portamento;
	    };
	    Tone.extend(Tone.Monophonic, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Monophonic.defaults = { 'portamento': 0 };
	    /**
		 *  Trigger the attack of the note optionally with a given velocity. 
		 *  
		 *  
		 *  @param  {Frequency} note     The note to trigger.
		 *  @param  {Time} [time=now]     When the note should start.
		 *  @param  {number} [velocity=1] velocity The velocity scaler 
		 *                                determines how "loud" the note 
		 *                                will be triggered.
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerAttack("C4");
		 *  @example
		 * //trigger the note a half second from now at half velocity
		 * synth.triggerAttack("C4", "+0.5", 0.5);
		 */
	    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeAttack(time, velocity);
	        this.setNote(note, time);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the envelope
		 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
		 *  @returns {Tone.Monophonic} this
		 *  @example
		 * synth.triggerRelease();
		 */
	    Tone.Monophonic.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this._triggerEnvelopeRelease(time);
	        return this;
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
	    };
	    /**
		 *  override this method with the actual method
		 *  @abstract
		 *  @private
		 */
	    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
	    };
	    /**
		 *  Set the note at the given time. If no time is given, the note
		 *  will set immediately. 
		 *  @param {Frequency} note The note to change to.
		 *  @param  {Time} [time=now] The time when the note should be set. 
		 *  @returns {Tone.Monophonic} this
		 * @example
		 * //change to F#6 in one quarter note from now.
		 * synth.setNote("F#6", "+4n");
		 * @example
		 * //change to Bb4 right now
		 * synth.setNote("Bb4");
		 */
	    Tone.Monophonic.prototype.setNote = function (note, time) {
	        time = this.toSeconds(time);
	        if (this.portamento > 0) {
	            var currentNote = this.frequency.value;
	            this.frequency.setValueAtTime(currentNote, time);
	            var portTime = this.toSeconds(this.portamento);
	            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
	        } else {
	            this.frequency.setValueAtTime(note, time);
	        }
	        return this;
	    };
	    return Tone.Monophonic;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator
		 *          routed through a Tone.AmplitudeEnvelope. 
		 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.Synth().toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.Synth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.Synth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.Synth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.Synth.defaults = {
	        'oscillator': { 'type': 'triangle' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.3,
	            'release': 1
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.Synth} this
		 *  @private
		 */
	    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Synth} this
		 */
	    Tone.Synth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.Synth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  AMSynth uses the output of one Tone.Synth to modulate the
		 *          amplitude of another Tone.Synth. The harmonicity (the ratio between
		 *          the two signals) affects the timbre of the output signal greatly.
		 *          Read more about Amplitude Modulation Synthesis on
		 *          [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).
		 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                            see defaults below
		 *  @example
		 * var synth = new Tone.AMSynth().toMaster();
		 * synth.triggerAttackRelease("C4", "4n");
		 */
	    Tone.AMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.AMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth();
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth();
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  convert the -1,1 output to 0,1
			 *  @type {Tone.AudioToGain}
			 *  @private
			 */
	        this._modulationScale = new Tone.AudioToGain();
	        /**
			 *  the node where the modulation happens
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain();
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.chain(this._modulationScale, this._modulationNode.gain);
	        this._carrier.chain(this._modulationNode, this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.AMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.AMSynth.defaults = {
	        'harmonicity': 3,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 *  trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {NormalRange} [velocity=1] the velocity of the note
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the port glide
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @private
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.AMSynth} this
		 */
	    Tone.AMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationScale.dispose();
	        this._modulationScale = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.AMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
		 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
		 *          Tone.Filter are controlled by Tone.Envelopes. 
		 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
		 *          
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MonoSynth({
		 * 	"oscillator" : {
		 * 		"type" : "square"
		 *  },
		 *  "envelope" : {
		 *  	"attack" : 0.1
		 *  }
		 * }).toMaster();
		 * synth.triggerAttackRelease("C4", "8n");
		 */
	    Tone.MonoSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.MonoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = this.oscillator.frequency;
	        /**
			 *  The detune control.
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = this.oscillator.detune;
	        /**
			 *  The filter.
			 *  @type {Tone.Filter}
			 */
	        this.filter = new Tone.Filter(options.filter);
	        /**
			 *  The filter envelope.
			 *  @type {Tone.FrequencyEnvelope}
			 */
	        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the oscillators to the output
	        this.oscillator.chain(this.filter, this.envelope, this.output);
	        //start the oscillators
	        this.oscillator.start();
	        //connect the filter envelope
	        this.filterEnvelope.connect(this.filter.frequency);
	        this._readOnly([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MonoSynth.defaults = {
	        'frequency': 'C4',
	        'detune': 0,
	        'oscillator': { 'type': 'square' },
	        'filter': {
	            'Q': 6,
	            'type': 'lowpass',
	            'rolloff': -24
	        },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0.9,
	            'release': 1
	        },
	        'filterEnvelope': {
	            'attack': 0.06,
	            'decay': 0.2,
	            'sustain': 0.5,
	            'release': 2,
	            'baseFrequency': 200,
	            'octaves': 7,
	            'exponent': 2
	        }
	    };
	    /**
		 *  start the attack portion of the envelope
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelope
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.MonoSynth} this
		 *  @private
		 */
	    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        this.filterEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.MonoSynth} this
		 */
	    Tone.MonoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'frequency',
	            'detune',
	            'filter',
	            'filterEnvelope',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this.filterEnvelope.dispose();
	        this.filterEnvelope = null;
	        this.filter.dispose();
	        this.filter = null;
	        this.frequency = null;
	        this.detune = null;
	        return this;
	    };
	    return Tone.MonoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
		 *          MonoSynths run in parallel with control over the 
		 *          frequency ratio between the two voices and vibrato effect.
		 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var duoSynth = new Tone.DuoSynth().toMaster();
		 * duoSynth.triggerAttackRelease("C4", "2n");
		 */
	    Tone.DuoSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.DuoSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  the first voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice0 = new Tone.MonoSynth(options.voice0);
	        this.voice0.volume.value = -10;
	        /**
			 *  the second voice
			 *  @type {Tone.MonoSynth}
			 */
	        this.voice1 = new Tone.MonoSynth(options.voice1);
	        this.voice1.volume.value = -10;
	        /**
			 *  The vibrato LFO. 
			 *  @type {Tone.LFO}
			 *  @private
			 */
	        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
	        this._vibrato.start();
	        /**
			 * the vibrato frequency
			 * @type {Frequency}
			 * @signal
			 */
	        this.vibratoRate = this._vibrato.frequency;
	        /**
			 *  the vibrato gain
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);
	        /**
			 * The amount of vibrato
			 * @type {Positive}
			 * @signal
			 */
	        this.vibratoAmount = this._vibratoGain.gain;
	        /**
			 *  the frequency control
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave. 
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * duoSynth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        //control the two voices frequency
	        this.frequency.connect(this.voice0.frequency);
	        this.frequency.chain(this.harmonicity, this.voice1.frequency);
	        this._vibrato.connect(this._vibratoGain);
	        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
	        this.voice0.connect(this.output);
	        this.voice1.connect(this.output);
	        this._readOnly([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	    };
	    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.DuoSynth.defaults = {
	        'vibratoAmount': 0.5,
	        'vibratoRate': 5,
	        'harmonicity': 1.5,
	        'voice0': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        },
	        'voice1': {
	            'volume': -10,
	            'portamento': 0,
	            'oscillator': { 'type': 'sine' },
	            'filterEnvelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            },
	            'envelope': {
	                'attack': 0.01,
	                'decay': 0,
	                'sustain': 1,
	                'release': 0.5
	            }
	        }
	    };
	    /**
		 *  start the attack portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        this.voice0.envelope.triggerAttack(time, velocity);
	        this.voice1.envelope.triggerAttack(time, velocity);
	        this.voice0.filterEnvelope.triggerAttack(time);
	        this.voice1.filterEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  start the release portion of the envelopes
		 *  
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.DuoSynth} this
		 *  @private
		 */
	    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
	        this.voice0.triggerRelease(time);
	        this.voice1.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.DuoSynth} this
		 */
	    Tone.DuoSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'voice0',
	            'voice1',
	            'frequency',
	            'vibratoAmount',
	            'vibratoRate'
	        ]);
	        this.voice0.dispose();
	        this.voice0 = null;
	        this.voice1.dispose();
	        this.voice1 = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._vibratoGain.dispose();
	        this._vibratoGain = null;
	        this._vibrato = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this.vibratoAmount.dispose();
	        this.vibratoAmount = null;
	        this.vibratoRate = null;
	        return this;
	    };
	    return Tone.DuoSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates
		 *          the frequency of a second Tone.Synth. A lot of spectral content 
		 *          can be explored using the modulationIndex parameter. Read more about
		 *          frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).
		 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
		 *
		 *  @constructor
		 *  @extends {Tone.Monophonic}
		 *  @param {Object} [options] the options available for the synth
		 *                          see defaults below
		 *  @example
		 * var fmSynth = new Tone.FMSynth().toMaster();
		 * fmSynth.triggerAttackRelease("C5", "4n");
		 */
	    Tone.FMSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.FMSynth.defaults);
	        Tone.Monophonic.call(this, options);
	        /**
			 *  The carrier voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._carrier = new Tone.Synth(options.carrier);
	        this._carrier.volume.value = -10;
	        /**
			 *  The carrier's oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.oscillator = this._carrier.oscillator;
	        /**
			 *  The carrier's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.envelope = this._carrier.envelope.set(options.envelope);
	        /**
			 *  The modulator voice.
			 *  @type {Tone.Synth}
			 *  @private
			 */
	        this._modulator = new Tone.Synth(options.modulator);
	        this._modulator.volume.value = -10;
	        /**
			 *  The modulator's oscillator which is applied
			 *  to the amplitude of the oscillator
			 *  @type {Tone.Oscillator}
			 */
	        this.modulation = this._modulator.oscillator.set(options.modulation);
	        /**
			 *  The modulator's envelope
			 *  @type {Tone.Oscillator}
			 */
	        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);
	        /**
			 *  The frequency control.
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        /**
			 *  Harmonicity is the ratio between the two voices. A harmonicity of
			 *  1 is no change. Harmonicity = 2 means a change of an octave.
			 *  @type {Positive}
			 *  @signal
			 *  @example
			 * //pitch voice1 an octave below voice0
			 * synth.harmonicity.value = 0.5;
			 */
	        this.harmonicity = new Tone.Multiply(options.harmonicity);
	        this.harmonicity.units = Tone.Type.Positive;
	        /**
			 *  The modulation index which essentially the depth or amount of the modulation. It is the
			 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the
			 *  modulating signal (ma) -- as in ma/mf.
			 *	@type {Positive}
			 *	@signal
			 */
	        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
	        this.modulationIndex.units = Tone.Type.Positive;
	        /**
			 *  the node where the modulation happens
			 *  @type {GainNode}
			 *  @private
			 */
	        this._modulationNode = new Tone.Gain(0);
	        //control the two voices frequency
	        this.frequency.connect(this._carrier.frequency);
	        this.frequency.chain(this.harmonicity, this._modulator.frequency);
	        this.frequency.chain(this.modulationIndex, this._modulationNode);
	        this.detune.fan(this._carrier.detune, this._modulator.detune);
	        this._modulator.connect(this._modulationNode.gain);
	        this._modulationNode.connect(this._carrier.frequency);
	        this._carrier.connect(this.output);
	        this._readOnly([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	    };
	    Tone.extend(Tone.FMSynth, Tone.Monophonic);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.FMSynth.defaults = {
	        'harmonicity': 3,
	        'modulationIndex': 10,
	        'detune': 0,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.01,
	            'decay': 0.01,
	            'sustain': 1,
	            'release': 0.5
	        },
	        'modulation': { 'type': 'square' },
	        'modulationEnvelope': {
	            'attack': 0.5,
	            'decay': 0,
	            'sustain': 1,
	            'release': 0.5
	        }
	    };
	    /**
		 * 	trigger the attack portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will occur
		 *  @param {number} [velocity=1] the velocity of the note
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
	        time = this.toSeconds(time);
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        this.modulationEnvelope.triggerAttack(time);
	        return this;
	    };
	    /**
		 *  trigger the release portion of the note
		 *
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.FMSynth} this
		 *  @private
		 */
	    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        this.modulationEnvelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.FMSynth} this
		 */
	    Tone.FMSynth.prototype.dispose = function () {
	        Tone.Monophonic.prototype.dispose.call(this);
	        this._writable([
	            'frequency',
	            'harmonicity',
	            'modulationIndex',
	            'oscillator',
	            'envelope',
	            'modulation',
	            'modulationEnvelope',
	            'detune'
	        ]);
	        this._carrier.dispose();
	        this._carrier = null;
	        this._modulator.dispose();
	        this._modulator = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this.detune.dispose();
	        this.detune = null;
	        this.modulationIndex.dispose();
	        this.modulationIndex = null;
	        this.harmonicity.dispose();
	        this.harmonicity = null;
	        this._modulationNode.dispose();
	        this._modulationNode = null;
	        this.oscillator = null;
	        this.envelope = null;
	        this.modulationEnvelope = null;
	        this.modulation = null;
	        return this;
	    };
	    return Tone.FMSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator
		 *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator
		 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
		 *          quality of the sound comes from the frequency envelope applied
		 *          during Tone.MembraneSynth.triggerAttack(note). The frequency envelope
		 *          starts at <code>note * .octaves</code> and ramps to <code>note</code>
		 *          over the duration of <code>.pitchDecay</code>. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 *  @example
		 * var synth = new Tone.MembraneSynth().toMaster();
		 * synth.triggerAttackRelease("C2", "8n");
		 */
	    Tone.MembraneSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MembraneSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The oscillator.
			 *  @type {Tone.OmniOscillator}
			 */
	        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();
	        /**
			 *  The amplitude envelope.
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        /**
			 *  The number of octaves the pitch envelope ramps.
			 *  @type {Positive}
			 */
	        this.octaves = options.octaves;
	        /**
			 *  The amount of time the frequency envelope takes. 
			 *  @type {Time}
			 */
	        this.pitchDecay = options.pitchDecay;
	        this.oscillator.chain(this.envelope, this.output);
	        this._readOnly([
	            'oscillator',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.MembraneSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @type {Object}
		 */
	    Tone.MembraneSynth.defaults = {
	        'pitchDecay': 0.05,
	        'octaves': 10,
	        'oscillator': { 'type': 'sine' },
	        'envelope': {
	            'attack': 0.001,
	            'decay': 0.4,
	            'sustain': 0.01,
	            'release': 1.4,
	            'attackCurve': 'exponential'
	        }
	    };
	    /**
		 *  Trigger the note at the given time with the given velocity. 
		 *  
		 *  @param  {Frequency} note     the note
		 *  @param  {Time} [time=now]     the time, if not given is now
		 *  @param  {number} [velocity=1] velocity defaults to 1
		 *  @returns {Tone.MembraneSynth} this
		 *  @example
		 *  kick.triggerAttack(60);
		 */
	    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {
	        time = this.toSeconds(time);
	        note = this.toFrequency(note);
	        var maxNote = note * this.octaves;
	        this.oscillator.frequency.setValueAtTime(maxNote, time);
	        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Trigger the release portion of the note.
		 *  
		 *  @param  {Time} [time=now] the time the note will release
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.MembraneSynth} this
		 */
	    Tone.MembraneSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'oscillator',
	            'envelope'
	        ]);
	        this.oscillator.dispose();
	        this.oscillator = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.MembraneSynth;
	});
	Module(function (Tone) {
	    /**
		 *  Inharmonic ratio of frequencies based on the Roland TR-808
		 *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model
		 *  @private
		 *  @static
		 *  @type {Array}
		 */
	    var inharmRatios = [
	        1,
	        1.483,
	        1.932,
	        2.546,
	        2.63,
	        3.897
	    ];
	    /**
		 *  @class  A highly inharmonic and spectrally complex source with a highpass filter
		 *          and amplitude envelope which is good for making metalophone sounds. Based
		 *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).
		 *          Inspiration from [Sound on Sound](https://web.archive.org/web/20160610143924/https://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] The options availble for the synth
		 *                             see defaults below
		 */
	    Tone.MetalSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.MetalSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The frequency of the cymbal
			 *  @type  {Frequency}
			 *  @signal
			 */
	        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
	        /**
			 *  The array of FMOscillators
			 *  @type  {Array}
			 *  @private
			 */
	        this._oscillators = [];
	        /**
			 *  The frequency multipliers
			 *  @type {Array}
			 *  @private
			 */
	        this._freqMultipliers = [];
	        /**
			 *  The amplitude for the body
			 *  @type {Tone.Gain}
			 *  @private
			 */
	        this._amplitue = new Tone.Gain(0).connect(this.output);
	        /**
			 *  highpass the output
			 *  @type {Tone.Filter}
			 *  @private
			 */
	        this._highpass = new Tone.Filter({
	            'type': 'highpass',
	            'Q': -3.0102999566398125
	        }).connect(this._amplitue);
	        /**
			 *  The number of octaves the highpass
			 *  filter frequency ramps
			 *  @type {Number}
			 *  @private
			 */
	        this._octaves = options.octaves;
	        /**
			 *  Scale the body envelope
			 *  for the bandpass
			 *  @type {Tone.Scale}
			 *  @private
			 */
	        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);
	        /**
			 *  The envelope which is connected both to the
			 *  amplitude and highpass filter's cutoff frequency
			 *  @type  {Tone.Envelope}
			 */
	        this.envelope = new Tone.Envelope({
	            'attack': options.envelope.attack,
	            'attackCurve': 'linear',
	            'decay': options.envelope.decay,
	            'sustain': 0,
	            'release': options.envelope.release
	        }).chain(this._filterFreqScaler, this._highpass.frequency);
	        this.envelope.connect(this._amplitue.gain);
	        for (var i = 0; i < inharmRatios.length; i++) {
	            var osc = new Tone.FMOscillator({
	                'type': 'square',
	                'modulationType': 'square',
	                'harmonicity': options.harmonicity,
	                'modulationIndex': options.modulationIndex
	            });
	            osc.connect(this._highpass).start();
	            this._oscillators[i] = osc;
	            var mult = new Tone.Multiply(inharmRatios[i]);
	            this._freqMultipliers[i] = mult;
	            this.frequency.chain(mult, osc.frequency);
	        }
	        //set the octaves
	        this.octaves = options.octaves;
	    };
	    Tone.extend(Tone.MetalSynth, Tone.Instrument);
	    /**
		 *  default values
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.MetalSynth.defaults = {
	        'frequency': 200,
	        'envelope': {
	            'attack': 0.001,
	            'decay': 1.4,
	            'release': 0.2
	        },
	        'harmonicity': 5.1,
	        'modulationIndex': 32,
	        'resonance': 4000,
	        'octaves': 1.5
	    };
	    /**
		 *  Trigger the attack.
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {
	        time = this.toSeconds(time);
	        vel = Tone.defaultArg(vel, 1);
	        this.envelope.triggerAttack(time, vel);
	        return this;
	    };
	    /**
		 *  Trigger the release of the envelope.
		 *  @param  {Time}  time      When the release should be triggered.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerRelease = function (time) {
	        time = this.toSeconds(time);
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and release of the envelope after the given
		 *  duration.
		 *  @param  {Time}  duration  The duration before triggering the release
		 *  @param  {Time}  time      When the attack should be triggered.
		 *  @param  {NormalRange}  [velocity=1]  The velocity that the envelope should be triggered at.
		 *  @return  {Tone.MetalSynth}  this
		 */
	    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  The modulationIndex of the oscillators which make up the source.
		 *  see Tone.FMOscillator.modulationIndex
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  modulationIndex
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {
	        get: function () {
	            return this._oscillators[0].modulationIndex.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].modulationIndex.value = val;
	            }
	        }
	    });
	    /**
		 *  The harmonicity of the oscillators which make up the source.
		 *  see Tone.FMOscillator.harmonicity
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Positive}
		 *  @name  harmonicity
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {
	        get: function () {
	            return this._oscillators[0].harmonicity.value;
	        },
	        set: function (val) {
	            for (var i = 0; i < this._oscillators.length; i++) {
	                this._oscillators[i].harmonicity.value = val;
	            }
	        }
	    });
	    /**
		 *  The frequency of the highpass filter attached to the envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Frequency}
		 *  @name  resonance
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {
	        get: function () {
	            return this._filterFreqScaler.min;
	        },
	        set: function (val) {
	            this._filterFreqScaler.min = val;
	            this.octaves = this._octaves;
	        }
	    });
	    /**
		 *  The number of octaves above the "resonance" frequency
		 *  that the filter ramps during the attack/decay envelope
		 *  @memberOf Tone.MetalSynth#
		 *  @type {Number}
		 *  @name  octaves
		 */
	    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {
	        get: function () {
	            return this._octaves;
	        },
	        set: function (octs) {
	            this._octaves = octs;
	            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);
	        }
	    });
	    /**
		 *  Clean up
		 *  @returns {Tone.MetalSynth} this
		 */
	    Tone.MetalSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this._oscillators.length; i++) {
	            this._oscillators[i].dispose();
	            this._freqMultipliers[i].dispose();
	        }
	        this._oscillators = null;
	        this._freqMultipliers = null;
	        this.frequency.dispose();
	        this.frequency = null;
	        this._filterFreqScaler.dispose();
	        this._filterFreqScaler = null;
	        this._amplitue.dispose();
	        this._amplitue = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        this._highpass.dispose();
	        this._highpass = null;
	    };
	    return Tone.MetalSynth;
	});
	Module(function (Tone) {
	    /**
		 *  BufferSource polyfill
		 */
	    if (window.AudioBufferSourceNode && !AudioBufferSourceNode.prototype.start) {
	        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
	        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
	    }
	    /**
		 *  @class Wrapper around the native BufferSourceNode.
		 *  @extends {Tone.AudioNode}
		 *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play
		 *  @param  {Function}  onload  The callback to invoke when the
		 *                               buffer is done playing.
		 */
	    Tone.BufferSource = function () {
	        var options = Tone.defaults(arguments, [
	            'buffer',
	            'onload'
	        ], Tone.BufferSource);
	        Tone.AudioNode.call(this);
	        /**
			 *  The callback to invoke after the
			 *  buffer source is done playing.
			 *  @type  {Function}
			 */
	        this.onended = options.onended;
	        /**
			 *  The time that the buffer was started.
			 *  @type  {Number}
			 *  @private
			 */
	        this._startTime = -1;
	        /**
			 *  The time that the buffer is scheduled to stop.
			 *  @type  {Number}
			 *  @private
			 */
	        this._stopTime = -1;
	        /**
			 *  The gain node which envelopes the BufferSource
			 *  @type  {Tone.Gain}
			 *  @private
			 */
	        this._gainNode = this.output = new Tone.Gain();
	        /**
			 *  The buffer source
			 *  @type  {AudioBufferSourceNode}
			 *  @private
			 */
	        this._source = this.context.createBufferSource();
	        this._source.connect(this._gainNode);
	        /**
			 * The private buffer instance
			 * @type {Tone.Buffer}
			 * @private
			 */
	        this._buffer = new Tone.Buffer(options.buffer, options.onload);
	        /**
			 *  The playbackRate of the buffer
			 *  @type {Positive}
			 *  @signal
			 */
	        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	        /**
			 * The curve applied to the fades, either "linear" or "exponential"
			 * @type {String}
			 */
	        this.curve = options.curve;
	        /**
			 *  The value that the buffer ramps to
			 *  @type {Gain}
			 *  @private
			 */
	        this._gain = 1;
	        /**
			 * The onended timeout
			 * @type {Number}
			 * @private
			 */
	        this._onendedTimeout = -1;
	        //set some values initially
	        this.loop = options.loop;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.playbackRate.value = options.playbackRate;
	    };
	    Tone.extend(Tone.BufferSource, Tone.AudioNode);
	    /**
		 *  The defaults
		 *  @const
		 *  @type  {Object}
		 */
	    Tone.BufferSource.defaults = {
	        'onended': Tone.noOp,
	        'onload': Tone.noOp,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'fadeIn': 0,
	        'fadeOut': 0,
	        'curve': 'linear',
	        'playbackRate': 1
	    };
	    /**
		 *  Returns the playback state of the source, either "started" or "stopped".
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.BufferSource#
		 *  @name state
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'state', {
	        get: function () {
	            var now = this.now();
	            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {
	                return Tone.State.Started;
	            } else {
	                return Tone.State.Stopped;
	            }
	        }
	    });
	    /**
		 *  Start the buffer
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.
		 *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {
	        if (this._startTime !== -1) {
	            throw new Error('Tone.BufferSource can only be started once.');
	        }
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //if it's a loop the default offset is the loopstart point
	            if (this.loop) {
	                offset = Tone.defaultArg(offset, this.loopStart);
	            } else {
	                //otherwise the default offset is 0
	                offset = Tone.defaultArg(offset, 0);
	            }
	            offset = this.toSeconds(offset);
	            gain = Tone.defaultArg(gain, 1);
	            this._gain = gain;
	            fadeInTime = this.toSeconds(Tone.defaultArg(fadeInTime, this.fadeIn));
	            this.fadeIn = fadeInTime;
	            if (fadeInTime > 0) {
	                this._gainNode.gain.setValueAtTime(0, time);
	                if (this.curve === 'linear') {
	                    this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);
	                } else {
	                    this._gainNode.gain.exponentialAppraochValueAtTime(this._gain, time, fadeInTime);
	                }
	            } else {
	                this._gainNode.gain.setValueAtTime(gain, time);
	            }
	            this._startTime = time;
	            var computedDur = this.toSeconds(Tone.defaultArg(duration, this.buffer.duration - offset));
	            computedDur = Math.max(computedDur, 0);
	            if (!this.loop || this.loop && !Tone.isUndef(duration)) {
	                //clip the duration when not looping
	                if (!this.loop) {
	                    computedDur = Math.min(computedDur, this.buffer.duration - offset);
	                }
	                this.stop(time + computedDur, this.fadeOut);
	            }
	            //start the buffer source
	            if (this.loop) {
	                //modify the offset if it's greater than the loop time
	                var loopEnd = this.loopEnd || this.buffer.duration;
	                var loopStart = this.loopStart;
	                var loopDuration = loopEnd - loopStart;
	                //move the offset back
	                if (offset > loopEnd) {
	                    offset = (offset - loopStart) % loopDuration + loopStart;
	                }
	            }
	            this._source.buffer = this.buffer.get();
	            this._source.loopEnd = this.loopEnd || this.buffer.duration;
	            Tone.isPast(time);
	            this._source.start(time, offset);
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Stop the buffer. Optionally add a ramp time to fade the
		 *  buffer out.
		 *  @param  {Time=}  time         The time the buffer should stop.
		 *  @param  {Time=}  fadeOutTime  How long the gain should fade out for
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {
	        if (this.buffer.loaded) {
	            time = this.toSeconds(time);
	            //if this is before the previous stop
	            if (this._stopTime === -1 || this._stopTime > time) {
	                //stop if it's schedule before the start time
	                if (time <= this._startTime) {
	                    this._gainNode.gain.cancelScheduledValues(time);
	                    this._gainNode.gain.value = 0;
	                    return this;
	                }
	                time = Math.max(this._startTime + this.fadeIn + this.sampleTime, time);
	                //cancel the previous curve
	                this._gainNode.gain.cancelScheduledValues(time);
	                this._stopTime = time;
	                //the fadeOut time
	                fadeOutTime = this.toSeconds(Tone.defaultArg(fadeOutTime, this.fadeOut));
	                var heldDuration = time - this._startTime - this.fadeIn - this.sampleTime;
	                if (!this.loop) {
	                    //make sure the fade does not go beyond the length of the buffer
	                    heldDuration = Math.min(heldDuration, this.buffer.duration);
	                }
	                fadeOutTime = Math.min(heldDuration, fadeOutTime);
	                var startFade = time - fadeOutTime;
	                if (fadeOutTime > this.sampleTime) {
	                    this._gainNode.gain.setValueAtTime(this._gain, startFade);
	                    if (this.curve === 'linear') {
	                        this._gainNode.gain.linearRampToValueAtTime(0, time);
	                    } else {
	                        this._gainNode.gain.exponentialAppraochValueAtTime(0, startFade, fadeOutTime);
	                    }
	                } else {
	                    this._gainNode.gain.setValueAtTime(0, time);
	                }
	                Tone.context.clearTimeout(this._onendedTimeout);
	                this._onendedTimeout = Tone.context.setTimeout(this._onended.bind(this), this._stopTime - this.now());
	            }
	        } else {
	            throw new Error('Tone.BufferSource: buffer is either not set or not loaded.');
	        }
	        return this;
	    };
	    /**
		 *  Internal callback when the buffer is ended.
		 *  Invokes `onended` and disposes the node.
		 *  @private
		 */
	    Tone.BufferSource.prototype._onended = function () {
	        this.onended(this);
	        //allow additional time for the exponential curve to fully decay
	        var additionalTail = this.curve === 'exponential' ? this.fadeOut * 2 : 0;
	        this._source.stop(this._stopTime + additionalTail);
	    };
	    /**
		 * If loop is true, the loop will start at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {
	        get: function () {
	            return this._source.loopStart;
	        },
	        set: function (loopStart) {
	            this._source.loopStart = this.toSeconds(loopStart);
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.BufferSource#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {
	        get: function () {
	            return this._source.loopEnd;
	        },
	        set: function (loopEnd) {
	            this._source.loopEnd = this.toSeconds(loopEnd);
	        }
	    });
	    /**
		 * The audio buffer belonging to the player.
		 * @memberOf Tone.BufferSource#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over.
		 * @memberOf Tone.BufferSource#
		 * @type {Boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {
	        get: function () {
	            return this._source.loop;
	        },
	        set: function (loop) {
	            this._source.loop = loop;
	        }
	    });
	    /**
		 *  Clean up.
		 *  @return  {Tone.BufferSource}  this
		 */
	    Tone.BufferSource.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.onended = null;
	        this._source.disconnect();
	        this._source = null;
	        this._gainNode.dispose();
	        this._gainNode = null;
	        this._buffer.dispose();
	        this._buffer = null;
	        this._startTime = -1;
	        this.playbackRate = null;
	        Tone.context.clearTimeout(this._onendedTimeout);
	        return this;
	    };
	    return Tone.BufferSource;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
		 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
		 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
		 *
		 *  @constructor
		 *  @extends {Tone.Source}
		 *  @param {string} type the noise type (white|pink|brown)
		 *  @example
		 * //initialize the noise and start
		 * var noise = new Tone.Noise("pink").start();
		 * 
		 * //make an autofilter to shape the noise
		 * var autoFilter = new Tone.AutoFilter({
		 * 	"frequency" : "8m", 
		 * 	"min" : 800, 
		 * 	"max" : 15000
		 * }).connect(Tone.Master);
		 * 
		 * //connect the noise
		 * noise.connect(autoFilter);
		 * //start the autofilter LFO
		 * autoFilter.start()
		 */
	    Tone.Noise = function () {
	        var options = Tone.defaults(arguments, ['type'], Tone.Noise);
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {AudioBuffer}
			 */
	        this._type = options.type;
	        /**
			 *  The playback rate of the noise. Affects
			 *  the "frequency" of the noise.
			 *  @type {Positive}
			 *  @signal
			 */
	        this._playbackRate = options.playbackRate;
	    };
	    Tone.extend(Tone.Noise, Tone.Source);
	    /**
		 *  the default parameters
		 *
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Noise.defaults = {
	        'type': 'white',
	        'playbackRate': 1
	    };
	    /**
		 * The type of the noise. Can be "white", "brown", or "pink". 
		 * @memberOf Tone.Noise#
		 * @type {string}
		 * @name type
		 * @example
		 * noise.type = "white";
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'type', {
	        get: function () {
	            return this._type;
	        },
	        set: function (type) {
	            if (this._type !== type) {
	                if (type in _noiseBuffers) {
	                    this._type = type;
	                    //if it's playing, stop and restart it
	                    if (this.state === Tone.State.Started) {
	                        var now = this.now();
	                        this._stop(now);
	                        this._start(now);
	                    }
	                } else {
	                    throw new TypeError('Tone.Noise: invalid type: ' + type);
	                }
	            }
	        }
	    });
	    /**
		 *  The playback rate of the noise. Affects
		 *  the "frequency" of the noise.
		 *  @type {Positive}
		 *  @signal
		 */
	    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 *  internal start method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._start = function (time) {
	        var buffer = _noiseBuffers[this._type];
	        this._source = new Tone.BufferSource(buffer).connect(this.output);
	        this._source.loop = true;
	        this._source.playbackRate.value = this._playbackRate;
	        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));
	    };
	    /**
		 *  internal stop method
		 *
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.Noise.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	            this._source = null;
	        }
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.Noise} this
		 */
	    Tone.Noise.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer = null;
	        return this;
	    };
	    ///////////////////////////////////////////////////////////////////////////
	    // THE BUFFERS
	    ///////////////////////////////////////////////////////////////////////////
	    //Noise buffer stats
	    var bufferLength = 44100 * 5;
	    var channels = 2;
	    /**
		 *	The noise arrays. Generated on initialization.
		 *  borrowed heavily from https://github.com/zacharydenton/noise.js 
		 *  (c) 2013 Zach Denton (MIT)
		 *  @static
		 *  @private
		 *  @type {Array}
		 */
	    var _noiseArrays = {
	        'pink': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var b0, b1, b2, b3, b4, b5, b6;
	                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    b0 = 0.99886 * b0 + white * 0.0555179;
	                    b1 = 0.99332 * b1 + white * 0.0750759;
	                    b2 = 0.969 * b2 + white * 0.153852;
	                    b3 = 0.8665 * b3 + white * 0.3104856;
	                    b4 = 0.55 * b4 + white * 0.5329522;
	                    b5 = -0.7616 * b5 - white * 0.016898;
	                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
	                    channel[i] *= 0.11;
	                    // (roughly) compensate for gain
	                    b6 = white * 0.115926;
	                }
	            }
	            return buffer;
	        }(),
	        'brown': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                var lastOut = 0;
	                for (var i = 0; i < bufferLength; i++) {
	                    var white = Math.random() * 2 - 1;
	                    channel[i] = (lastOut + 0.02 * white) / 1.02;
	                    lastOut = channel[i];
	                    channel[i] *= 3.5;    // (roughly) compensate for gain
	                }
	            }
	            return buffer;
	        }(),
	        'white': function () {
	            var buffer = [];
	            for (var channelNum = 0; channelNum < channels; channelNum++) {
	                var channel = new Float32Array(bufferLength);
	                buffer[channelNum] = channel;
	                for (var i = 0; i < bufferLength; i++) {
	                    channel[i] = Math.random() * 2 - 1;
	                }
	            }
	            return buffer;
	        }()
	    };
	    /**
		 *	static noise buffers
		 *  @static
		 *  @private
		 *  @type {Tone.Buffer}
		 */
	    var _noiseBuffers = {};
	    //create the Tone.Buffers
	    function createBuffers() {
	        for (var type in _noiseArrays) {
	            _noiseBuffers[type] = new Tone.Buffer().fromArray(_noiseArrays[type]);
	        }
	    }
	    //create the noise buffers
	    Tone.getContext(createBuffers);
	    Tone.Context.on('init', createBuffers);
	    return Tone.Noise;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
		 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
		 *          of the noise and the other is controls the cutoff frequency of the filter. 
		 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] the options available for the synth 
		 *                          see defaults below
		 * @example
		 * var noiseSynth = new Tone.NoiseSynth().toMaster();
		 * noiseSynth.triggerAttackRelease("8n");
		 */
	    Tone.NoiseSynth = function (options) {
	        //get the defaults
	        options = Tone.defaultArg(options, Tone.NoiseSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  The noise source.
			 *  @type {Tone.Noise}
			 *  @example
			 * noiseSynth.set("noise.type", "brown");
			 */
	        this.noise = new Tone.Noise();
	        /**
			 *  The amplitude envelope. 
			 *  @type {Tone.AmplitudeEnvelope}
			 */
	        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
	        //connect the noise to the output
	        this.noise.chain(this.envelope, this.output);
	        //start the noise
	        this.noise.start();
	        this._readOnly([
	            'noise',
	            'envelope'
	        ]);
	    };
	    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
	    /**
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.NoiseSynth.defaults = {
	        'noise': { 'type': 'white' },
	        'envelope': {
	            'attack': 0.005,
	            'decay': 0.1,
	            'sustain': 0
	        }
	    };
	    /**
		 *  Start the attack portion of the envelopes. Unlike other 
		 *  instruments, Tone.NoiseSynth doesn't have a note. 
		 *  @param {Time} [time=now] the time the attack should start
		 *  @param {number} [velocity=1] the velocity of the note (0-1)
		 *  @returns {Tone.NoiseSynth} this
		 *  @example
		 * noiseSynth.triggerAttack();
		 */
	    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
	        //the envelopes
	        this.envelope.triggerAttack(time, velocity);
	        return this;
	    };
	    /**
		 *  Start the release portion of the envelopes.
		 *  @param {Time} [time=now] the time the release should start
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
	        this.envelope.triggerRelease(time);
	        return this;
	    };
	    /**
		 *  Trigger the attack and then the release. 
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     the time of the attack
		 *  @param  {number} [velocity=1] the velocity
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(time, velocity);
	        this.triggerRelease(time + duration);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.NoiseSynth} this
		 */
	    Tone.NoiseSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._writable([
	            'noise',
	            'envelope'
	        ]);
	        this.noise.dispose();
	        this.noise = null;
	        this.envelope.dispose();
	        this.envelope = null;
	        return this;
	    };
	    return Tone.NoiseSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Karplus-String string synthesis. Often out of tune. 
		 *         Will change when the AudioWorkerNode is available across
		 *         browsers. 
		 *  
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {Object} [options] see the defaults
		 *  @example
		 * var plucky = new Tone.PluckSynth().toMaster();
		 * plucky.triggerAttack("C4");
		 */
	    Tone.PluckSynth = function (options) {
	        options = Tone.defaultArg(options, Tone.PluckSynth.defaults);
	        Tone.Instrument.call(this, options);
	        /**
			 *  @type {Tone.Noise}
			 *  @private
			 */
	        this._noise = new Tone.Noise('pink');
	        /**
			 *  The amount of noise at the attack. 
			 *  Nominal range of [0.1, 20]
			 *  @type {number}
			 */
	        this.attackNoise = options.attackNoise;
	        /**
			 *  the LFCF
			 *  @type {Tone.LowpassCombFilter}
			 *  @private
			 */
	        this._lfcf = new Tone.LowpassCombFilter({
	            'resonance': options.resonance,
	            'dampening': options.dampening
	        });
	        /**
			 *  The resonance control. 
			 *  @type {NormalRange}
			 *  @signal
			 */
	        this.resonance = this._lfcf.resonance;
	        /**
			 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
			 *  @type {Frequency}
			 *  @signal
			 */
	        this.dampening = this._lfcf.dampening;
	        //connections
	        this._noise.connect(this._lfcf);
	        this._lfcf.connect(this.output);
	        this._readOnly([
	            'resonance',
	            'dampening'
	        ]);
	    };
	    Tone.extend(Tone.PluckSynth, Tone.Instrument);
	    /**
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.PluckSynth.defaults = {
	        'attackNoise': 1,
	        'dampening': 4000,
	        'resonance': 0.9
	    };
	    /**
		 *  Trigger the note. 
		 *  @param {Frequency} note The note to trigger.
		 *  @param {Time} [time=now] When the note should be triggered.
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
	        note = this.toFrequency(note);
	        time = this.toSeconds(time);
	        var delayAmount = 1 / note;
	        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
	        this._noise.start(time);
	        this._noise.stop(time + delayAmount * this.attackNoise);
	        return this;
	    };
	    /**
		 *  Clean up. 
		 *  @returns {Tone.PluckSynth} this
		 */
	    Tone.PluckSynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._noise.dispose();
	        this._lfcf.dispose();
	        this._noise = null;
	        this._lfcf = null;
	        this._writable([
	            'resonance',
	            'dampening'
	        ]);
	        this.dampening = null;
	        this.resonance = null;
	        return this;
	    };
	    return Tone.PluckSynth;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.PolySynth handles voice creation and allocation for any
		 *          instruments passed in as the second paramter. PolySynth is 
		 *          not a synthesizer by itself, it merely manages voices of 
		 *          one of the other types of synths, allowing any of the 
		 *          monophonic synthesizers to be polyphonic. 
		 *
		 *  @constructor
		 *  @extends {Tone.Instrument}
		 *  @param {number|Object} [polyphony=4] The number of voices to create
		 *  @param {function} [voice=Tone.Synth] The constructor of the voices
		 *                                            uses Tone.Synth by default. 
		 *  @example
		 * //a polysynth composed of 6 Voices of Synth
		 * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();
		 * //set the attributes using the set interface
		 * synth.set("detune", -1200);
		 * //play a chord
		 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
		 */
	    Tone.PolySynth = function () {
	        var options = Tone.defaults(arguments, [
	            'polyphony',
	            'voice'
	        ], Tone.PolySynth);
	        Tone.Instrument.call(this, options);
	        options = Tone.defaultArg(options, Tone.Instrument.defaults);
	        //max polyphony
	        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);
	        /**
			 *  the array of voices
			 *  @type {Array}
			 */
	        this.voices = new Array(options.polyphony);
	        /**
			 *  The queue of voices with data about last trigger
			 *  and the triggered note
			 *  @private
			 *  @type {Array}
			 */
	        this._triggers = new Array(options.polyphony);
	        /**
			 *  The detune in cents
			 *  @type {Cents}
			 *  @signal
			 */
	        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
	        this._readOnly('detune');
	        //create the voices
	        for (var i = 0; i < options.polyphony; i++) {
	            var v = new options.voice(arguments[2], arguments[3]);
	            this.voices[i] = v;
	            v.connect(this.output);
	            if (v.hasOwnProperty('detune')) {
	                this.detune.connect(v.detune);
	            }
	            this._triggers[i] = {
	                release: -1,
	                note: null,
	                voice: v
	            };
	        }
	    };
	    Tone.extend(Tone.PolySynth, Tone.Instrument);
	    /**
		 *  the defaults
		 *  @const
		 *  @static
		 *  @type {Object}
		 */
	    Tone.PolySynth.defaults = {
	        'polyphony': 4,
	        'volume': 0,
	        'detune': 0,
	        'voice': Tone.Synth
	    };
	    /**
		 *  Trigger the attack portion of the note
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  The start time of the note.
		 *  @param {number} [velocity=1] The velocity of the note.
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord immediately with a velocity of 0.2
		 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
		 */
	    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            var val = notes[i];
	            //trigger the oldest voice
	            var oldest = this._triggers[0];
	            var oldestIndex = 0;
	            for (var j = 1; j < this._triggers.length; j++) {
	                if (this._triggers[j].release < oldest.release) {
	                    oldest = this._triggers[j];
	                    oldestIndex = j;
	                }
	            }
	            oldest.release = Infinity;
	            oldest.note = JSON.stringify(val);
	            oldest.voice.triggerAttack(val, time, velocity);
	        }
	        return this;
	    };
	    /**
		 *  Trigger the attack and release after the specified duration
		 *  
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} duration the duration of the note
		 *  @param  {Time} [time=now]     if no time is given, defaults to now
		 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * //trigger a chord for a duration of a half note 
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
		 *  @example
		 * //can pass in an array of durations as well
		 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
		 */
	    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
	        time = this.toSeconds(time);
	        this.triggerAttack(notes, time, velocity);
	        if (Tone.isArray(duration) && Tone.isArray(notes)) {
	            for (var i = 0; i < notes.length; i++) {
	                var d = duration[Math.min(i, duration.length - 1)];
	                this.triggerRelease(notes[i], time + this.toSeconds(d));
	            }
	        } else {
	            this.triggerRelease(notes, time + this.toSeconds(duration));
	        }
	        return this;
	    };
	    /**
		 *  Trigger the release of the note. Unlike monophonic instruments, 
		 *  a note (or array of notes) needs to be passed in as the first argument.
		 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
		 *                                  Frequency or an array of frequencies.
		 *  @param  {Time} [time=now]  When the release will be triggered. 
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
		 */
	    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
	        if (!Array.isArray(notes)) {
	            notes = [notes];
	        }
	        time = this.toSeconds(time);
	        for (var i = 0; i < notes.length; i++) {
	            //get the voice
	            var stringified = JSON.stringify(notes[i]);
	            for (var v = 0; v < this._triggers.length; v++) {
	                var desc = this._triggers[v];
	                if (desc.note === stringified && desc.release > time) {
	                    desc.voice.triggerRelease(time);
	                    desc.release = time;
	                }
	            }
	        }
	        return this;
	    };
	    /**
		 *  Set a member/attribute of the voices. 
		 *  @param {Object|string} params
		 *  @param {number=} value
		 *  @param {Time=} rampTime
		 *  @returns {Tone.PolySynth} this
		 *  @example
		 * poly.set({
		 * 	"filter" : {
		 * 		"type" : "highpass"
		 * 	},
		 * 	"envelope" : {
		 * 		"attack" : 0.25
		 * 	}
		 * });
		 */
	    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].set(params, value, rampTime);
	        }
	        return this;
	    };
	    /**
		 *  Get the synth's attributes. Given no arguments get
		 *  will return all available object properties and their corresponding
		 *  values. Pass in a single attribute to retrieve or an array
		 *  of attributes. The attribute strings can also include a "."
		 *  to access deeper properties.
		 *  @param {Array=} params the parameters to get, otherwise will return 
		 *  					   all available.
		 */
	    Tone.PolySynth.prototype.get = function (params) {
	        return this.voices[0].get(params);
	    };
	    /**
		 *  Trigger the release portion of all the currently active voices.
		 *  @param {Time} [time=now] When the notes should be released.
		 *  @return {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.releaseAll = function (time) {
	        time = this.toSeconds(time);
	        for (var i = 0; i < this._triggers.length; i++) {
	            var desc = this._triggers[i];
	            if (desc.release > time) {
	                desc.release = time;
	                desc.voice.triggerRelease(time);
	            }
	        }
	        return this;
	    };
	    /**
		 *  Clean up.
		 *  @returns {Tone.PolySynth} this
		 */
	    Tone.PolySynth.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        for (var i = 0; i < this.voices.length; i++) {
	            this.voices[i].dispose();
	            this.voices[i] = null;
	        }
	        this._writable('detune');
	        this.detune.dispose();
	        this.detune = null;
	        this.voices = null;
	        this._triggers = null;
	        return this;
	    };
	    /**
		 *  The maximum number of notes that can be allocated 
		 *  to a polysynth. 
		 *  @type  {Number}
		 *  @static
		 */
	    Tone.PolySynth.MAX_POLYPHONY = 20;
	    return Tone.PolySynth;
	});
	Module(function (Tone) {
	    /**
		 * @class Automatically interpolates between a set of pitched samples. Pass in an object which maps the note's pitch or midi value to the url, then you can trigger the attack and release of that note like other instruments. By automatically repitching the samples, it is possible to play pitches which were not explicitly included which can save loading time.
		 *        For sample or buffer playback where repitching is not necessary, use [Tone.Player](https://tonejs.github.io/docs/Player).
		 * @param {Object} samples An object of samples mapping either Midi
		 *                         Note Numbers or Scientific Pitch Notation
		 *                         to the url of that sample.
		 * @param {Function=} onload The callback to invoke when all of the samples are loaded.
		 * @param {String=} baseUrl The root URL of all of the samples, which is prepended to all the URLs.
		 * @example
		 * var sampler = new Tone.Sampler({
		 * 	"C3" : "path/to/C3.mp3",
		 * 	"D#3" : "path/to/Dsharp3.mp3",
		 * 	"F#3" : "path/to/Fsharp3.mp3",
		 * 	"A3" : "path/to/A3.mp3",
		 * }, function(){
		 * 	//sampler will repitch the closest sample
		 * 	sampler.triggerAttack("D3")
		 * })
		 * @extends {Tone.Instrument}
		 */
	    Tone.Sampler = function (urls) {
	        // shift arguments over one. Those are the remainder of the options
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, [
	            'onload',
	            'baseUrl'
	        ], Tone.Sampler);
	        Tone.Instrument.call(this, options);
	        var urlMap = {};
	        for (var note in urls) {
	            if (Tone.isNote(note)) {
	                //convert the note name to MIDI
	                var mid = Tone.Frequency(note).toMidi();
	                urlMap[mid] = urls[note];
	            } else if (!isNaN(parseFloat(note))) {
	                //otherwise if it's numbers assume it's midi
	                urlMap[note] = urls[note];
	            } else {
	                throw new Error('Tone.Sampler: url keys must be the note\'s pitch');
	            }
	        }
	        /**
			 * The stored and loaded buffers
			 * @type {Tone.Buffers}
			 * @private
			 */
	        this._buffers = new Tone.Buffers(urlMap, options.onload, options.baseUrl);
	        /**
			 * The object of all currently playing BufferSources
			 * @type {Object}
			 * @private
			 */
	        this._activeSources = {};
	        /**
			 * The envelope applied to the beginning of the sample.
			 * @type {Time}
			 */
	        this.attack = options.attack;
	        /**
			 * The envelope applied to the end of the envelope.
			 * @type {Time}
			 */
	        this.release = options.release;
	    };
	    Tone.extend(Tone.Sampler, Tone.Instrument);
	    /**
		 * The defaults
		 * @const
		 * @type {Object}
		 */
	    Tone.Sampler.defaults = {
	        attack: 0,
	        release: 0.1,
	        onload: Tone.noOp,
	        baseUrl: ''
	    };
	    /**
		 * Returns the difference in steps between the given midi note at the closets sample.
		 * @param  {Midi} midi
		 * @return {Interval}
		 * @private
		 */
	    Tone.Sampler.prototype._findClosest = function (midi) {
	        var MAX_INTERVAL = 24;
	        var interval = 0;
	        while (interval < MAX_INTERVAL) {
	            // check above and below
	            if (this._buffers.has(midi + interval)) {
	                return -interval;
	            } else if (this._buffers.has(midi - interval)) {
	                return interval;
	            }
	            interval++;
	        }
	        return null;
	    };
	    /**
		 * @param  {Frequency} note     The note to play
		 * @param  {Time=} time     When to play the note
		 * @param  {NormalRange=} velocity The velocity to play the sample back.
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttack = function (note, time, velocity) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the closest note pitch
	        var difference = this._findClosest(midi);
	        if (difference !== null) {
	            var closestNote = midi - difference;
	            var buffer = this._buffers.get(closestNote);
	            // play that note
	            var source = new Tone.BufferSource({
	                'buffer': buffer,
	                'playbackRate': Tone.intervalToFrequencyRatio(difference),
	                'fadeIn': this.attack,
	                'fadeOut': this.release,
	                'curve': 'exponential'
	            }).connect(this.output);
	            source.start(time, 0, buffer.duration, velocity);
	            // add it to the active sources
	            if (!Tone.isArray(this._activeSources[midi])) {
	                this._activeSources[midi] = [];
	            }
	            this._activeSources[midi].push({
	                note: midi,
	                source: source
	            });
	        }
	        return this;
	    };
	    /**
		 * @param  {Frequency} note     The note to release.
		 * @param  {Time=} time     	When to release the note.
		 * @return {Tone.Sampler}	this
		 */
	    Tone.Sampler.prototype.triggerRelease = function (note, time) {
	        var midi = Tone.Frequency(note).toMidi();
	        // find the note
	        if (this._activeSources[midi] && this._activeSources[midi].length) {
	            var source = this._activeSources[midi].shift().source;
	            time = this.toSeconds(time);
	            source.stop(time + this.release, this.release);
	        }
	    };
	    /**
		 * Invoke the attack phase, then after the duration, invoke the release.
		 * @param  {Frequency} note     The note to play
		 * @param  {Time} duration The time the note should be held
		 * @param  {Time=} time     When to start the attack
		 * @param  {NormalRange} [velocity=1] The velocity of the attack
		 * @return {Tone.Sampler}          this
		 */
	    Tone.Sampler.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
	        time = this.toSeconds(time);
	        duration = this.toSeconds(duration);
	        this.triggerAttack(note, time, velocity);
	        this.triggerRelease(note, time + duration);
	        return this;
	    };
	    /**
		 *  Add a note to the sampler.
		 *  @param  {Note|Midi}   note      The buffer's pitch.
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Sampler.prototype.add = function (note, url, callback) {
	        if (Tone.isNote(note)) {
	            //convert the note name to MIDI
	            var mid = Tone.Frequency(note).toMidi();
	            this._buffers.add(mid, url, callback);
	        } else if (!isNaN(parseFloat(note))) {
	            //otherwise if it's numbers assume it's midi
	            this._buffers.add(note, url, callback);
	        } else {
	            throw new Error('Tone.Sampler: note must be the note\'s pitch. Instead got ' + note);
	        }
	    };
	    /**
		 * If the buffers are loaded or not
		 * @memberOf Tone.Sampler#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Sampler.prototype, 'loaded', {
	        get: function () {
	            return this._buffers.loaded;
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.Sampler} this
		 */
	    Tone.Sampler.prototype.dispose = function () {
	        Tone.Instrument.prototype.dispose.call(this);
	        this._buffers.dispose();
	        this._buffers = null;
	        for (var midi in this._activeSources) {
	            this._activeSources[midi].forEach(function (event) {
	                event.source.dispose();
	            });
	        }
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.Sampler;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
		 *         See also Tone.AudioToGain. 
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @example
		 * var g2a = new Tone.GainToAudio();
		 */
	    Tone.GainToAudio = function () {
	        Tone.SignalBase.call(this);
	        /**
			 *  @type {WaveShaperNode}
			 *  @private
			 */
	        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
	            return Math.abs(x) * 2 - 1;
	        });
	    };
	    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
	    /**
		 *  clean up
		 *  @returns {Tone.GainToAudio} this
		 */
	    Tone.GainToAudio.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._norm.dispose();
	        this._norm = null;
	        return this;
	    };
	    return Tone.GainToAudio;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
		 *
		 *  @extends {Tone.SignalBase}
		 *  @constructor
		 *  @param {number} inputMin the min input value
		 *  @param {number} inputMax the max input value
		 *  @example
		 * var norm = new Tone.Normalize(2, 4);
		 * var sig = new Tone.Signal(3).connect(norm);
		 * //output of norm is 0.5. 
		 */
	    Tone.Normalize = function (inputMin, inputMax) {
	        Tone.SignalBase.call(this);
	        /**
			 *  the min input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMin = Tone.defaultArg(inputMin, 0);
	        /**
			 *  the max input value
			 *  @type {number}
			 *  @private
			 */
	        this._inputMax = Tone.defaultArg(inputMax, 1);
	        /**
			 *  subtract the min from the input
			 *  @type {Tone.Add}
			 *  @private
			 */
	        this._sub = this.input = new Tone.Add(0);
	        /**
			 *  divide by the difference between the input and output
			 *  @type {Tone.Multiply}
			 *  @private
			 */
	        this._div = this.output = new Tone.Multiply(1);
	        this._sub.connect(this._div);
	        this._setRange();
	    };
	    Tone.extend(Tone.Normalize, Tone.SignalBase);
	    /**
		 * The minimum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name min
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'min', {
	        get: function () {
	            return this._inputMin;
	        },
	        set: function (min) {
	            this._inputMin = min;
	            this._setRange();
	        }
	    });
	    /**
		 * The maximum value the input signal will reach.
		 * @memberOf Tone.Normalize#
		 * @type {number}
		 * @name max
		 */
	    Object.defineProperty(Tone.Normalize.prototype, 'max', {
	        get: function () {
	            return this._inputMax;
	        },
	        set: function (max) {
	            this._inputMax = max;
	            this._setRange();
	        }
	    });
	    /**
		 *  set the values
		 *  @private
		 */
	    Tone.Normalize.prototype._setRange = function () {
	        this._sub.value = -this._inputMin;
	        this._div.value = 1 / (this._inputMax - this._inputMin);
	    };
	    /**
		 *  clean up
		 *  @returns {Tone.Normalize} this
		 */
	    Tone.Normalize.prototype.dispose = function () {
	        Tone.SignalBase.prototype.dispose.call(this);
	        this._sub.dispose();
	        this._sub = null;
	        this._div.dispose();
	        this._div = null;
	        return this;
	    };
	    return Tone.Normalize;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.TransportTimelineSignal extends Tone.TimelineSignal, but adds the ability to synchronize the signal to the signal to the Tone.Transport
		 * @extends {Tone.TimelineSignal}
		 */
	    Tone.TransportTimelineSignal = function () {
	        Tone.TimelineSignal.apply(this, arguments);
	        /**
			 * The real signal output
			 * @type {Tone.Signal}
			 * @private
			 */
	        this.output = this._outputSig = new Tone.Signal(this._initial);
	        /**
			 * Keep track of the last value. (small optimization)
			 * @private
			 * @type {Number}
			 */
	        this._lastVal = this.value;
	        /**
			 * The event id of the tick update loop
			 * @private
			 * @type {Number}
			 */
	        this._synced = Tone.Transport.scheduleRepeat(this._onTick.bind(this), '1i');
	        /**
			 * A bound version of the anchor value methods
			 * @type {Function}
			 * @private
			 */
	        this._bindAnchorValue = this._anchorValue.bind(this);
	        Tone.Transport.on('start stop pause', this._bindAnchorValue);
	        this._events.memory = Infinity;
	    };
	    Tone.extend(Tone.TransportTimelineSignal, Tone.TimelineSignal);
	    /**
		 * Callback which is invoked every tick.
		 * @private
		 * @param  {Number} time
		 * @return {Tone.TransportTimelineSignal}      this
		 */
	    Tone.TransportTimelineSignal.prototype._onTick = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.seconds);
	        if (this._lastVal !== val) {
	            this._lastVal = val;
	            //approximate ramp curves with linear ramps
	            this._outputSig.linearRampToValueAtTime(val, time);
	        }
	    };
	    /**
		 * Anchor the value at the start and stop of the Transport
		 * @param  {Number} time The time of the event
		 * @return {Tone.TransportTimelineSignal}      this
		 * @private
		 */
	    Tone.TransportTimelineSignal.prototype._anchorValue = function (time) {
	        var val = this.getValueAtTime(Tone.Transport.ticks);
	        this._lastVal = val;
	        this._outputSig.cancelScheduledValues(time);
	        this._outputSig.setValueAtTime(val, time);
	        return this;
	    };
	    /**
		 *  Get the scheduled value at the given time. This will
		 *  return the unconverted (raw) value.
		 *  @param  {TransportTime}  time  The time in seconds.
		 *  @return  {Number}  The scheduled value at the given time.
		 */
	    Tone.TransportTimelineSignal.prototype.getValueAtTime = function (time) {
	        time = this.toTicks(time);
	        return Tone.TimelineSignal.prototype.getValueAtTime.call(this, time);
	    };
	    /**
		 * Set the output of the signal at the given time
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.setValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Linear ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.linearRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.linearRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 * Exponential ramp to the given value from the previous scheduled point to the given value
		 * @param  {Number} value The value to change to at the given time
		 * @param  {TransportTime} time  The time to change the signal
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.exponentialRampToValueAtTime = function (value, time) {
	        time = this.toTicks(time);
	        Tone.TimelineSignal.prototype.exponentialRampToValueAtTime.call(this, value, time);
	        return this;
	    };
	    /**
		 *  Start exponentially approaching the target value at the given time with
		 *  a rate having the given time constant.
		 *  @param {number} value
		 *  @param {TransportTime} startTime
		 *  @param {number} timeConstant
		 * @return {Tone.TransportTimelineSignal}       this
		 */
	    Tone.TransportTimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.setTargetAtTime.call(this, value, startTime, timeConstant);
	        return this;
	    };
	    /**
		 *  Cancels all scheduled parameter changes with times greater than or
		 *  equal to startTime.
		 *  @param  {TransportTime} startTime
		 *  @returns {Tone.Param} this
		 */
	    Tone.TransportTimelineSignal.prototype.cancelScheduledValues = function (startTime) {
	        startTime = this.toTicks(startTime);
	        Tone.TimelineSignal.prototype.cancelScheduledValues.call(this, startTime);
	        return this;
	    };
	    /**
		 *  Set an array of arbitrary values starting at the given time for the given duration.
		 *  @param {Float32Array} values
		 *  @param {Time} startTime
		 *  @param {Time} duration
		 *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value
		 *  @returns {Tone.TimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {
	        startTime = this.toTicks(startTime);
	        duration = this.toTicks(duration);
	        Tone.TimelineSignal.prototype.setValueCurveAtTime.call(this, values, startTime, duration, scaling);
	        return this;
	    };
	    /**
		 * Dispose and disconnect
		 * @return {Tone.TransportTimelineSignal} this
		 */
	    Tone.TransportTimelineSignal.prototype.dispose = function () {
	        Tone.Transport.clear(this._synced);
	        Tone.Transport.off('start stop pause', this._syncedCallback);
	        this._events.cancel(0);
	        Tone.TimelineSignal.prototype.dispose.call(this);
	        this._outputSig.dispose();
	        this._outputSig = null;
	    };
	    return Tone.TransportTimelineSignal;
	});
	Module(function (Tone) {
	    /**
		 * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).
		 *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the
		 *        amount of time each small chunk of audio is played for and the overlap is the
		 *        amount of crossfading transition time between successive grains.
		 * @extends {Tone.Source}
		 * @param {String|Tone.Buffer} url	The url to load, or the Tone.Buffer to play.
		 * @param {Function=} callback The callback to invoke after the url is loaded.
		 */
	    Tone.GrainPlayer = function () {
	        var options = Tone.defaults(arguments, [
	            'url',
	            'onload'
	        ], Tone.GrainPlayer);
	        Tone.Source.call(this, options);
	        /**
			 *  The audio buffer belonging to the player.
			 *  @type  {Tone.Buffer}
			 */
	        this.buffer = new Tone.Buffer(options.url, options.onload);
	        /**
			 *  Create a repeating tick to schedule
			 *  the grains.
			 *  @type  {Tone.Clock}
			 *  @private
			 */
	        this._clock = new Tone.Clock(this._tick.bind(this), options.grainSize);
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopStart = 0;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._loopEnd = 0;
	        /**
			 * All of the currently playing BufferSources
			 * @type {Array}
			 * @private
			 */
	        this._activeSources = [];
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  @type  {Number}
			 *  @private
			 */
	        this._grainSize = options.grainSize;
	        /**
			 *  @private
			 *  @type {Number}
			 */
	        this._overlap = options.overlap;
	        /**
			 *  Adjust the pitch independently of the playbackRate.
			 *  @type  {Cents}
			 */
	        this.detune = options.detune;
	        //setup
	        this.overlap = options.overlap;
	        this.loop = options.loop;
	        this.playbackRate = options.playbackRate;
	        this.grainSize = options.grainSize;
	        this.loopStart = options.loopStart;
	        this.loopEnd = options.loopEnd;
	        this.reverse = options.reverse;
	        this._clock.on('stop', this._onstop.bind(this));
	    };
	    Tone.extend(Tone.GrainPlayer, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.GrainPlayer.defaults = {
	        'onload': Tone.noOp,
	        'overlap': 0.1,
	        'grainSize': 0.2,
	        'playbackRate': 1,
	        'detune': 0,
	        'loop': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'reverse': false
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration.
		 *
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at.
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.GrainPlayer} this
		 *  @memberOf Tone.GrainPlayer#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @param {Time} offset
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._start = function (time, offset, duration) {
	        offset = Tone.defaultArg(offset, 0);
	        offset = this.toSeconds(offset);
	        time = this.toSeconds(time);
	        this._offset = offset;
	        this._clock.start(time);
	        if (duration) {
	            this.stop(time + this.toSeconds(duration));
	        }
	    };
	    /**
		 *  Internal start method
		 *  @param {Time} time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._stop = function (time) {
	        this._clock.stop(time);
	    };
	    /**
		 * Invoked when the clock is stopped
		 * @param  {Number} time
		 * @private
		 */
	    Tone.GrainPlayer.prototype._onstop = function (time) {
	        //stop the players
	        this._activeSources.forEach(function (source) {
	            source.stop(time, 0);
	        });
	    };
	    /**
		 *  Invoked on each clock tick. scheduled a new
		 *  grain at this time.
		 *  @param  {Time}  time
		 *  @private
		 */
	    Tone.GrainPlayer.prototype._tick = function (time) {
	        var fadeIn = this._offset < this._overlap ? 0 : this._overlap;
	        var source = new Tone.BufferSource({
	            'buffer': this.buffer,
	            'fadeIn': fadeIn,
	            'fadeOut': this._overlap,
	            'loop': this.loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': Tone.intervalToFrequencyRatio(this.detune / 100)
	        }).connect(this.output);
	        source.start(time, this._offset);
	        this._offset += this.grainSize;
	        source.stop(time + this.grainSize);
	        //add it to the active sources
	        this._activeSources.push(source);
	        //remove it when it's done
	        source.onended = function () {
	            var index = this._activeSources.indexOf(source);
	            if (index !== -1) {
	                this._activeSources.splice(index, 1);
	            }
	        }.bind(this);
	    };
	    /**
		 *  Jump to a specific time and play it.
		 *  @param  {Time}  offset  The offset to jump to.
		 *  @param {Time=} time When to make the jump.
		 *  @return  {Tone.GrainPlayer}  this
		 */
	    Tone.GrainPlayer.prototype.seek = function (offset, time) {
	        this._offset = this.toSeconds(offset);
	        this._tick(this.toSeconds(time));
	        return this;
	    };
	    /**
		 * The playback rate of the sample
		 * @memberOf Tone.GrainPlayer#
		 * @type {Positive}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            this.grainSize = this._grainSize;
	        }
	    });
	    /**
		 * The loop start time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (time) {
	            this._loopStart = this.toSeconds(time);
	        }
	    });
	    /**
		 * The loop end time.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (time) {
	            this._loopEnd = this.toSeconds(time);
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.GrainPlayer#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {
	        get: function () {
	            return this.buffer.reverse;
	        },
	        set: function (rev) {
	            this.buffer.reverse = rev;
	        }
	    });
	    /**
		 * The size of each chunk of audio that the
		 * buffer is chopped into and played back at.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name grainSize
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {
	        get: function () {
	            return this._grainSize;
	        },
	        set: function (size) {
	            this._grainSize = this.toSeconds(size);
	            this._clock.frequency.value = this._playbackRate / this._grainSize;
	        }
	    });
	    /**
		 * This is the duration of the cross-fade between
		 * sucessive grains.
		 * @memberOf Tone.GrainPlayer#
		 * @type {Time}
		 * @name overlap
		 */
	    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {
	        get: function () {
	            return this._overlap;
	        },
	        set: function (time) {
	            this._overlap = this.toSeconds(time);
	        }
	    });
	    /**
		 * Clean up
		 * @return {Tone.GrainPlayer} this
		 */
	    Tone.GrainPlayer.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        this.buffer.dispose();
	        this.buffer = null;
	        this._clock.dispose();
	        this._clock = null;
	        this._activeSources.forEach(function (source) {
	            source.dispose();
	        });
	        this._activeSources = null;
	        return this;
	    };
	    return Tone.GrainPlayer;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
		 *  
		 *  @constructor
		 *  @extends {Tone.Source} 
		 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
		 *                                  which to load the AudioBuffer
		 *  @param {function=} onload The function to invoke when the buffer is loaded. 
		 *                            Recommended to use Tone.Buffer.on('load') instead.
		 *  @example
		 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
		 * //play as soon as the buffer is loaded
		 * player.autostart = true;
		 */
	    Tone.Player = function (url) {
	        var options;
	        if (url instanceof Tone.Buffer) {
	            url = url.get();
	            options = Tone.Player.defaults;
	        } else {
	            options = Tone.defaults(arguments, [
	                'url',
	                'onload'
	            ], Tone.Player);
	        }
	        Tone.Source.call(this, options);
	        /**
			 *  @private
			 *  @type {AudioBufferSourceNode}
			 */
	        this._source = null;
	        /**
			 *  If the file should play as soon
			 *  as the buffer is loaded. 
			 *  @type {boolean}
			 *  @example
			 * //will play as soon as it's loaded
			 * var player = new Tone.Player({
			 * 	"url" : "./path/to/sample.mp3",
			 * 	"autostart" : true,
			 * }).toMaster();
			 */
	        this.autostart = options.autostart;
	        /**
			 *  the buffer
			 *  @private
			 *  @type {Tone.Buffer}
			 */
	        this._buffer = new Tone.Buffer({
	            'url': options.url,
	            'onload': this._onload.bind(this, options.onload),
	            'reverse': options.reverse
	        });
	        if (url instanceof AudioBuffer) {
	            this._buffer.set(url);
	        }
	        /**
			 *  if the buffer should loop once it's over
			 *  @type {boolean}
			 *  @private
			 */
	        this._loop = options.loop;
	        /**
			 *  if 'loop' is true, the loop will start at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopStart = options.loopStart;
	        /**
			 *  if 'loop' is true, the loop will end at this position
			 *  @type {Time}
			 *  @private
			 */
	        this._loopEnd = options.loopEnd;
	        /**
			 *  the playback rate
			 *  @private
			 *  @type {number}
			 */
	        this._playbackRate = options.playbackRate;
	        /**
			 *  Enabling retrigger will allow a player to be restarted
			 *  before the the previous 'start' is done playing. Otherwise, 
			 *  successive calls to Tone.Player.start will only start
			 *  the sample if it had played all the way through. 
			 *  @type {boolean}
			 */
	        this.retrigger = options.retrigger;
	        /**
			 *  The fadeIn time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeIn = options.fadeIn;
	        /**
			 *  The fadeOut time of the amplitude envelope.
			 *  @type {Time}
			 */
	        this.fadeOut = options.fadeOut;
	    };
	    Tone.extend(Tone.Player, Tone.Source);
	    /**
		 *  the default parameters
		 *  @static
		 *  @const
		 *  @type {Object}
		 */
	    Tone.Player.defaults = {
	        'onload': Tone.noOp,
	        'playbackRate': 1,
	        'loop': false,
	        'autostart': false,
	        'loopStart': 0,
	        'loopEnd': 0,
	        'retrigger': false,
	        'reverse': false,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  Load the audio file as an audio buffer.
		 *  Decodes the audio asynchronously and invokes
		 *  the callback once the audio buffer loads. 
		 *  Note: this does not need to be called if a url
		 *  was passed in to the constructor. Only use this
		 *  if you want to manually load a new url. 
		 * @param {string} url The url of the buffer to load.
		 *                     Filetype support depends on the
		 *                     browser.
		 *  @param  {function=} callback The function to invoke once
		 *                               the sample is loaded.
		 *  @returns {Promise}
		 */
	    Tone.Player.prototype.load = function (url, callback) {
	        return this._buffer.load(url, this._onload.bind(this, callback));
	    };
	    /**
		 * Internal callback when the buffer is loaded.
		 * @private
		 */
	    Tone.Player.prototype._onload = function (callback) {
	        callback = Tone.defaultArg(callback, Tone.noOp);
	        callback(this);
	        if (this.autostart) {
	            this.start();
	        }
	    };
	    /**
		 *  Play the buffer at the given startTime. Optionally add an offset
		 *  and/or duration which will play the buffer from a position
		 *  within the buffer for the given duration. 
		 *  
		 *  @param  {Time} [startTime=now] When the player should start.
		 *  @param  {Time} [offset=0] The offset from the beginning of the sample
		 *                                 to start at. 
		 *  @param  {Time=} duration How long the sample should play. If no duration
		 *                                is given, it will default to the full length 
		 *                                of the sample (minus any offset)
		 *  @returns {Tone.Player} this
		 *  @memberOf Tone.Player#
		 *  @method start
		 *  @name start
		 */
	    /**
		 *  Internal start method
		 *  @private
		 */
	    Tone.Player.prototype._start = function (startTime, offset, duration) {
	        //if it's a loop the default offset is the loopstart point
	        if (this._loop) {
	            offset = Tone.defaultArg(offset, this._loopStart);
	        } else {
	            //otherwise the default offset is 0
	            offset = Tone.defaultArg(offset, 0);
	        }
	        //compute the values in seconds
	        offset = this.toSeconds(offset);
	        duration = Tone.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));
	        duration = this.toSeconds(duration);
	        startTime = this.toSeconds(startTime);
	        // //make the source
	        this._source = new Tone.BufferSource({
	            'buffer': this._buffer,
	            'loop': this._loop,
	            'loopStart': this._loopStart,
	            'loopEnd': this._loopEnd,
	            'playbackRate': this._playbackRate,
	            'fadeIn': this.fadeIn,
	            'fadeOut': this.fadeOut
	        }).connect(this.output);
	        //set the looping properties
	        if (!this._loop && !this._synced) {
	            //if it's not looping, set the state change at the end of the sample
	            this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);
	        }
	        //start it
	        if (this._loop) {
	            this._source.start(startTime, offset);
	        } else {
	            this._source.start(startTime, offset, duration);
	        }
	        return this;
	    };
	    /**
		 *  Stop playback.
		 *  @private
		 *  @param  {Time} [time=now]
		 *  @returns {Tone.Player} this
		 */
	    Tone.Player.prototype._stop = function (time) {
	        if (this._source) {
	            this._source.stop(this.toSeconds(time));
	        }
	        return this;
	    };
	    /**
		 *  Seek to a specific time in the player's buffer. If the 
		 *  source is no longer playing at that time, it will stop.
		 *  If you seek to a time that 
		 *  @param {Time} offset The time to seek to.
		 *  @param {Time=} time The time for the seek event to occur.
		 *  @return {Tone.Player} this
		 *  @example
		 * source.start(0.2);
		 * source.stop(0.4);
		 */
	    Tone.Player.prototype.seek = function (offset, time) {
	        time = this.toSeconds(time);
	        if (this._state.getValueAtTime(time) === Tone.State.Started) {
	            offset = this.toSeconds(offset);
	            // if it's currently playing, stop it
	            this._stop(time);
	            //restart it at the given time
	            this._start(time, offset);
	        }
	        return this;
	    };
	    /**
		 *  Set the loop start and end. Will only loop if loop is 
		 *  set to true. 
		 *  @param {Time} loopStart The loop end time
		 *  @param {Time} loopEnd The loop end time
		 *  @returns {Tone.Player} this
		 *  @example
		 * //loop 0.1 seconds of the file. 
		 * player.setLoopPoints(0.2, 0.3);
		 * player.loop = true;
		 */
	    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
	        this.loopStart = loopStart;
	        this.loopEnd = loopEnd;
	        return this;
	    };
	    /**
		 * If loop is true, the loop will start at this position. 
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopStart
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
	        get: function () {
	            return this._loopStart;
	        },
	        set: function (loopStart) {
	            this._loopStart = loopStart;
	            if (this._source) {
	                this._source.loopStart = this.toSeconds(loopStart);
	            }
	        }
	    });
	    /**
		 * If loop is true, the loop will end at this position.
		 * @memberOf Tone.Player#
		 * @type {Time}
		 * @name loopEnd
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
	        get: function () {
	            return this._loopEnd;
	        },
	        set: function (loopEnd) {
	            this._loopEnd = loopEnd;
	            if (this._source) {
	                this._source.loopEnd = this.toSeconds(loopEnd);
	            }
	        }
	    });
	    /**
		 * The audio buffer belonging to the player. 
		 * @memberOf Tone.Player#
		 * @type {Tone.Buffer}
		 * @name buffer
		 */
	    Object.defineProperty(Tone.Player.prototype, 'buffer', {
	        get: function () {
	            return this._buffer;
	        },
	        set: function (buffer) {
	            this._buffer.set(buffer);
	        }
	    });
	    /**
		 * If the buffer should loop once it's over. 
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name loop
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loop', {
	        get: function () {
	            return this._loop;
	        },
	        set: function (loop) {
	            this._loop = loop;
	            if (this._source) {
	                this._source.loop = loop;
	            }
	        }
	    });
	    /**
		 * The playback speed. 1 is normal speed. This is not a signal because
		 * Safari and iOS currently don't support playbackRate as a signal.
		 * @memberOf Tone.Player#
		 * @type {number}
		 * @name playbackRate
		 */
	    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
	        get: function () {
	            return this._playbackRate;
	        },
	        set: function (rate) {
	            this._playbackRate = rate;
	            if (this._source) {
	                this._source.playbackRate.value = rate;
	            }
	        }
	    });
	    /**
		 * The direction the buffer should play in
		 * @memberOf Tone.Player#
		 * @type {boolean}
		 * @name reverse
		 */
	    Object.defineProperty(Tone.Player.prototype, 'reverse', {
	        get: function () {
	            return this._buffer.reverse;
	        },
	        set: function (rev) {
	            this._buffer.reverse = rev;
	        }
	    });
	    /**
		 * If all the buffer is loaded
		 * @memberOf Tone.Player#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Player.prototype, 'loaded', {
	        get: function () {
	            return this._buffer.loaded;
	        }
	    });
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Player} this
		 */
	    Tone.Player.prototype.dispose = function () {
	        Tone.Source.prototype.dispose.call(this);
	        if (this._source !== null) {
	            this._source.disconnect();
	            this._source = null;
	        }
	        this._buffer.dispose();
	        this._buffer = null;
	        return this;
	    };
	    return Tone.Player;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.Players combines multiple [Tone.Player](Player) objects.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Object} urls An object mapping a name to a url.
		 *  @param {function=} onload The function to invoke when all buffers are loaded.
		 */
	    Tone.Players = function (urls) {
	        var args = Array.prototype.slice.call(arguments);
	        args.shift();
	        var options = Tone.defaults(args, ['onload'], Tone.Players);
	        Tone.call(this);
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * source.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        //make the output explicitly stereo
	        this._volume.output.output.channelCount = 2;
	        this._volume.output.output.channelCountMode = 'explicit';
	        //mute initially
	        this.mute = options.mute;
	        /**
			 * The container of all of the players
			 * @type {Object}
			 * @private
			 */
	        this._players = {};
	        /**
			 * The loading count
			 * @type {Number}
			 * @private
			 */
	        this._loadingCount = 0;
	        /**
			 * private holder of the fadeIn time
			 * @type {Time}
			 * @private
			 */
	        this._fadeIn = options.fadeIn;
	        /**
			 * private holder of the fadeOut time
			 * @type {Time}
			 * @private
			 */
	        this._fadeOut = options.fadeOut;
	        //add all of the players
	        for (var name in urls) {
	            this._loadingCount++;
	            this.add(name, urls[name], this._bufferLoaded.bind(this, options.onload));
	        }
	    };
	    Tone.extend(Tone.Players, Tone.AudioNode);
	    /**
		 * The default values
		 * @type {Object}
		 */
	    Tone.Players.defaults = {
	        'volume': 0,
	        'mute': false,
	        'onload': Tone.noOp,
	        'fadeIn': 0,
	        'fadeOut': 0
	    };
	    /**
		 *  A buffer was loaded. decrement the counter.
		 *  @param  {Function}  callback
		 *  @private
		 */
	    Tone.Players.prototype._bufferLoaded = function (callback) {
	        this._loadingCount--;
	        if (this._loadingCount === 0 && callback) {
	            callback(this);
	        }
	    };
	    /**
		 * Mute the output.
		 * @memberOf Tone.Source#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * source.mute = true;
		 */
	    Object.defineProperty(Tone.Players.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * The fadeIn time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeIn
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeIn', {
	        get: function () {
	            return this._fadeIn;
	        },
	        set: function (fadeIn) {
	            this._fadeIn = fadeIn;
	            this._forEach(function (player) {
	                player.fadeIn = fadeIn;
	            });
	        }
	    });
	    /**
		 * The fadeOut time of the amplitude envelope.
		 * @memberOf Tone.Source#
		 * @type {Time}
		 * @name fadeOut
		 */
	    Object.defineProperty(Tone.Players.prototype, 'fadeOut', {
	        get: function () {
	            return this._fadeOut;
	        },
	        set: function (fadeOut) {
	            this._fadeOut = fadeOut;
	            this._forEach(function (player) {
	                player.fadeOut = fadeOut;
	            });
	        }
	    });
	    /**
		 * The state of the players object. Returns "started" if any of the players are playing.
		 * @memberOf Tone.Players#
		 * @type {String}
		 * @name state
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'state', {
	        get: function () {
	            var playing = false;
	            this._forEach(function (player) {
	                playing = playing || player.state === Tone.State.Started;
	            });
	            return playing ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 *  True if the buffers object has a buffer by that name.
		 *  @param  {String|Number}  name  The key or index of the
		 *                                 buffer.
		 *  @return  {Boolean}
		 */
	    Tone.Players.prototype.has = function (name) {
	        return this._players.hasOwnProperty(name);
	    };
	    /**
		 *  Get a player by name.
		 *  @param  {String}  name  The players name as defined in
		 *                          the constructor object or `add` method.
		 *  @return  {Tone.Player}
		 */
	    Tone.Players.prototype.get = function (name) {
	        if (this.has(name)) {
	            return this._players[name];
	        } else {
	            throw new Error('Tone.Players: no player named ' + name);
	        }
	    };
	    /**
		 * Iterate over all of the players
		 * @param  {Function} callback
		 * @return {Tone.Players}            this
		 * @private
		 */
	    Tone.Players.prototype._forEach = function (callback) {
	        for (var playerName in this._players) {
	            callback(this._players[playerName], playerName);
	        }
	        return this;
	    };
	    /**
		 * If all the buffers are loaded or not
		 * @memberOf Tone.Players#
		 * @type {Boolean}
		 * @name loaded
		 * @readOnly
		 */
	    Object.defineProperty(Tone.Players.prototype, 'loaded', {
	        get: function () {
	            var isLoaded = true;
	            this._forEach(function (player) {
	                isLoaded = isLoaded && player.loaded;
	            });
	            return isLoaded;
	        }
	    });
	    /**
		 *  Add a player by name and url to the Players
		 *  @param  {String}    name      A unique name to give the player
		 *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer,
		 *                                                 or a buffer which will be added
		 *                                                 with the given name.
		 *  @param  {Function=}  callback  The callback to invoke
		 *                                 when the url is loaded.
		 */
	    Tone.Players.prototype.add = function (name, url, callback) {
	        this._players[name] = new Tone.Player(url, callback).connect(this.output);
	        this._players[name].fadeIn = this._fadeIn;
	        this._players[name].fadeOut = this._fadeOut;
	        return this;
	    };
	    /**
		 * Stop all of the players at the given time
		 * @param {Time} time The time to stop all of the players.
		 * @return {Tone.Players} this
		 */
	    Tone.Players.prototype.stopAll = function (time) {
	        this._forEach(function (player) {
	            player.stop(time);
	        });
	    };
	    /**
		 *  Dispose and disconnect.
		 *  @return {Tone.Players} this
		 */
	    Tone.Players.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this._volume.dispose();
	        this._volume = null;
	        this._writable('volume');
	        this.volume = null;
	        this.output = null;
	        this._forEach(function (player) {
	            player.dispose();
	        });
	        this._players = null;
	        return this;
	    };
	    return Tone.Players;
	});
	Module(function (Tone) {
	    
	    /**
		 *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up
		 *          and external microphone or audio input. Check
		 *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)
		 *          to see which browsers are supported. Access to an external input
		 *          is limited to secure (HTTPS) connections.
		 *
		 *  @constructor
		 *  @extends {Tone.AudioNode}
		 *  @param {Decibels=} volume The level of the input
		 *  @example
		 * //list the inputs and open the third one
		 * var motu = new Tone.UserMedia();
		 *
		 * //opening the input asks the user to activate their mic
		 * motu.open().then(function(){
		 * 	//opening is activates the microphone
		 * 	//starting lets audio through
		 * 	motu.start(10);
		 * });
		 */
	    Tone.UserMedia = function () {
	        var options = Tone.defaults(arguments, ['volume'], Tone.UserMedia);
	        Tone.AudioNode.call(this);
	        /**
			 *  The MediaStreamNode
			 *  @type {MediaStreamAudioSourceNode}
			 *  @private
			 */
	        this._mediaStream = null;
	        /**
			 *  The media stream created by getUserMedia.
			 *  @type {LocalMediaStream}
			 *  @private
			 */
	        this._stream = null;
	        /**
			 *  The open device
			 *  @type  {MediaDeviceInfo}
			 *  @private
			 */
	        this._device = null;
	        /**
			 *  The output volume node
			 *  @type  {Tone.Volume}
			 *  @private
			 */
	        this._volume = this.output = new Tone.Volume(options.volume);
	        /**
			 * The volume of the output in decibels.
			 * @type {Decibels}
			 * @signal
			 * @example
			 * input.volume.value = -6;
			 */
	        this.volume = this._volume.volume;
	        this._readOnly('volume');
	        this.mute = options.mute;
	    };
	    Tone.extend(Tone.UserMedia, Tone.AudioNode);
	    /**
		 * the default parameters
		 * @type {Object}
		 */
	    Tone.UserMedia.defaults = {
	        'volume': 0,
	        'mute': false
	    };
	    /**
		 *  Open the media stream. If a string is passed in, it is assumed
		 *  to be the label or id of the stream, if a number is passed in,
		 *  it is the input number of the stream.
		 *  @param  {String|Number} [labelOrId="default"] The label or id of the audio input media device.
		 *                                                With no argument, the default stream is opened.
		 *  @return {Promise} The promise is resolved when the stream is open.
		 */
	    Tone.UserMedia.prototype.open = function (labelOrId) {
	        labelOrId = Tone.defaultArg(labelOrId, 'default');
	        return Tone.UserMedia.enumerateDevices().then(function (devices) {
	            var device;
	            if (Tone.isNumber(labelOrId)) {
	                device = devices[labelOrId];
	            } else {
	                device = devices.find(function (device) {
	                    return device.label === labelOrId || device.deviceId === labelOrId;
	                });
	                //didn't find a matching device
	                if (!device) {
	                    throw new Error('Tone.UserMedia: no matching device: ' + labelOrId);
	                }
	            }
	            this._device = device;
	            //do getUserMedia
	            var constraints = {
	                audio: {
	                    'deviceId': device.deviceId,
	                    'echoCancellation': false,
	                    'sampleRate': this.context.sampleRate
	                }
	            };
	            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
	                //start a new source only if the previous one is closed
	                if (!this._stream) {
	                    this._stream = stream;
	                    //Wrap a MediaStreamSourceNode around the live input stream.
	                    this._mediaStream = this.context.createMediaStreamSource(stream);
	                    //Connect the MediaStreamSourceNode to a gate gain node
	                    this._mediaStream.connect(this.output);
	                }
	                return this;
	            }.bind(this));
	        }.bind(this));
	    };
	    /**
		 *  Close the media stream
		 *  @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.close = function () {
	        if (this._stream) {
	            this._stream.getAudioTracks().forEach(function (track) {
	                track.stop();
	            });
	            this._stream = null;
	            //remove the old media stream
	            this._mediaStream.disconnect();
	            this._mediaStream = null;
	        }
	        this._device = null;
	        return this;
	    };
	    /**
		 *  Returns a promise which resolves with the list of audio input devices available.
		 *  @return {Promise} The promise that is resolved with the devices
		 *  @static
		 *  @example
		 * Tone.UserMedia.enumerateDevices().then(function(devices){
		 * 	console.log(devices)
		 * })
		 */
	    Tone.UserMedia.enumerateDevices = function () {
	        return navigator.mediaDevices.enumerateDevices().then(function (devices) {
	            return devices.filter(function (device) {
	                return device.kind === 'audioinput';
	            });
	        });
	    };
	    /**
		 *  Returns the playback state of the source, "started" when the microphone is open
		 *  and "stopped" when the mic is closed.
		 *  @type {Tone.State}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name state
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'state', {
	        get: function () {
	            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;
	        }
	    });
	    /**
		 * 	Returns an identifier for the represented device that is
		 * 	persisted across sessions. It is un-guessable by other applications and
		 * 	unique to the origin of the calling application. It is reset when the
		 * 	user clears cookies (for Private Browsing, a different identifier is
		 * 	used that is not persisted across sessions). Returns undefined when the
		 * 	device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name deviceId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {
	        get: function () {
	            if (this._device) {
	                return this._device.deviceId;
	            }
	        }
	    });
	    /**
		 * 	Returns a group identifier. Two devices have the
		 * 	same group identifier if they belong to the same physical device.
		 * 	Returns undefined when the device is not open.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {
	        get: function () {
	            if (this._device) {
	                return this._device.groupId;
	            }
	        }
	    });
	    /**
		 * 	Returns a label describing this device (for example "Built-in Microphone").
		 * 	Returns undefined when the device is not open or label is not available
		 * 	because of permissions.
		 *  @type {String}
		 *  @readOnly
		 *  @memberOf Tone.UserMedia#
		 *  @name groupId
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'label', {
	        get: function () {
	            if (this._device) {
	                return this._device.label;
	            }
	        }
	    });
	    /**
		 * Mute the output.
		 * @memberOf Tone.UserMedia#
		 * @type {boolean}
		 * @name mute
		 * @example
		 * //mute the output
		 * userMedia.mute = true;
		 */
	    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {
	        get: function () {
	            return this._volume.mute;
	        },
	        set: function (mute) {
	            this._volume.mute = mute;
	        }
	    });
	    /**
		 * Clean up.
		 * @return {Tone.UserMedia} this
		 */
	    Tone.UserMedia.prototype.dispose = function () {
	        Tone.AudioNode.prototype.dispose.call(this);
	        this.close();
	        this._writable('volume');
	        this._volume.dispose();
	        this._volume = null;
	        this.volume = null;
	        return this;
	    };
	    /**
		 *  If getUserMedia is supported by the browser.
		 *  @type  {Boolean}
		 *  @memberOf Tone.UserMedia#
		 *  @name supported
		 *  @static
		 *  @readOnly
		 */
	    Object.defineProperty(Tone.UserMedia, 'supported', {
	        get: function () {
	            return !Tone.isUndef(navigator.mediaDevices) && Tone.isFunction(navigator.mediaDevices.getUserMedia);
	        }
	    });
	    return Tone.UserMedia;
	});
	
	return Tone;
}));
},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                var values = new Float32Array(xhr.response);
                var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(ndarray);
            };
            xhr.onerror = function (error) {
                throw new Error('Could not fetch variable ' + varName + ': ' + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"./math/ndarray":22}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].getValues();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.getValues();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(ndarray_1.NDArray.make(example.shape, { values: normalizedValues }));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.getValues();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"./math/ndarray":22,"./util":79}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_layers_1 = require("./graph_layers");
var concat3d_util = require("./math/concat3d_util");
var conv_util = require("./math/conv_util");
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new graph_layers_1.GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = ndarray_1.Scalar.new(value);
        }
        else if (value instanceof ndarray_1.NDArray) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var vals = new Float32Array(util.flatten(value));
            finalValue = ndarray_1.NDArray.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var Tensor = (function () {
    function Tensor(shape) {
        this.shape = shape;
        this.id = Tensor.nextID++;
    }
    Tensor.nextID = 0;
    return Tensor;
}());
exports.Tensor = Tensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new Tensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, 'Error making reshape operation: input Tensor to reshape \'' +
            this.name + '\' of shape (' + this.x.shape +
            ') does not match size of requested shape ' + this.shape + '.');
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new Tensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                'shape: ' + this.c1.shape);
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                'shape: ' + this.c2.shape);
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding add operation op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            'shapes ' + this.t1.shape + ' and ' + this.t2.shape +
            ' must match.');
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new Tensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new Tensor(concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat3d_util.assertConcat3DShapesMatch(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                this.x1.shape + ' and ' + this.x2.shape + ' must match.');
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape + ' must match size of vector with shape ' +
                this.x2.shape + '.');
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], 'Error adding matmul op: size of vector with shape ' + this.x1.shape +
                ' must match first dimension of matrix with ' +
                'shape ' + this.x2.shape + '.');
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            this.x.shape + '.');
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            this.w.shape + '.');
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            this.b.shape + '.');
        util.assert(this.x.shape[2] === this.w.shape[2], 'Error adding conv2d op: depth of input (' + this.x.shape[2] +
            ') must match input depth for weights (' + this.w.shape[2] + ').');
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            this.x.shape + '.');
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new Tensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new Tensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new Tensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new Tensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new Tensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new Tensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new Tensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), 'Error adding softmaxCrossEntropyCost op: x shape (' + this.x.shape +
            ') must match target shape (' + this.target.shape + ').');
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new Tensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new Tensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), 'Error adding meanSquaredCost op: label shape (' + this.label.shape +
            ') must match prediction shape (' + this.prediction.shape + ').');
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new Tensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new Tensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), 'Error adding ArgMaxEquals op: x1 shape (' + this.x1.shape +
            ') must match x2 shape (' + this.x2.shape + ').');
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;
var SplitNode = (function (_super) {
    __extends(SplitNode, _super);
    function SplitNode(graph, x) {
        var _this = _super.call(this, graph, 'SplitNode', { x: x }, new Tensor(x.shape)) || this;
        _this.outputs = [];
        return _this;
    }
    SplitNode.prototype.getNewOutputTensor = function () {
        var output = new Tensor(this.inputs[SplitNode.X].shape);
        output.node = this;
        this.outputs.push(output);
        return output;
    };
    SplitNode.prototype.validate = function () { };
    SplitNode.X = 'x';
    return SplitNode;
}(Node));
exports.SplitNode = SplitNode;

},{"./graph_layers":8,"./math/concat3d_util":15,"./math/conv_util":16,"./math/ndarray":22,"./util":79}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var initializers_1 = require("./initializers");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;

},{"./initializers":12}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var session_1 = require("./session");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.totalIdleTimeMs = 0;
        this.resetStatistics();
        this.zeroScalar = ndarray_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
        this.totalIdleTimeMs = 0;
        this.lastStopTimestamp = null;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
        this.lastStopTimestamp = performance.now();
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        if (this.lastStopTimestamp != null) {
            this.totalIdleTimeMs += performance.now() - this.lastStopTimestamp;
        }
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        this.math.scope(function (keep) {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        setTimeout(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof ndarray_1.NDArray) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            setTimeout(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        this.math.scope(function (keep, track) {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    ndarrayFeedEntries.push({
                        tensor: feedEntry.tensor,
                        data: track(feedEntry.data.getNextCopy(_this.math))
                    });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].getValues();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return this.math.scope(function (keep) {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue);
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"./math/ndarray":22,"./session":75}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":7,"./priority_queue":74}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("./math/conv_util");
exports.conv_util = conv_util;
var gpgpu_util = require("./math/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var render_ndarray_gpu_util = require("./math/webgl/render_ndarray_gpu_util");
exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
var webgl_util = require("./math/webgl/webgl_util");
exports.webgl_util = webgl_util;
var util = require("./util");
exports.util = util;
var checkpoint_loader_1 = require("./checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var graph_1 = require("./graph");
exports.Graph = graph_1.Graph;
exports.Tensor = graph_1.Tensor;
var graph_runner_1 = require("./graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = require("./initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var input_provider_1 = require("./input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var math_1 = require("./math/math");
exports.MatrixOrientation = math_1.MatrixOrientation;
exports.NDArrayMath = math_1.NDArrayMath;
var math_cpu_1 = require("./math/math_cpu");
exports.NDArrayMathCPU = math_cpu_1.NDArrayMathCPU;
var math_gpu_1 = require("./math/math_gpu");
exports.NDArrayMathGPU = math_gpu_1.NDArrayMathGPU;
var ndarray_1 = require("./math/ndarray");
exports.Array1D = ndarray_1.Array1D;
exports.Array2D = ndarray_1.Array2D;
exports.Array3D = ndarray_1.Array3D;
exports.Array4D = ndarray_1.Array4D;
exports.NDArray = ndarray_1.NDArray;
exports.Scalar = ndarray_1.Scalar;
var gpgpu_context_1 = require("./math/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
var optimizer_1 = require("./optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var session_1 = require("./session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var sgd_optimizer_1 = require("./sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;

},{"./checkpoint_loader":5,"./dataset":6,"./graph":7,"./graph_runner":9,"./initializers":12,"./input_provider":13,"./math/conv_util":16,"./math/math":19,"./math/math_cpu":20,"./math/math_gpu":21,"./math/ndarray":22,"./math/webgl/gpgpu_context":33,"./math/webgl/gpgpu_util":35,"./math/webgl/render_ndarray_gpu_util":44,"./math/webgl/webgl_util":51,"./optimizer":73,"./session":75,"./sgd_optimizer":77,"./util":79}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error('Unexpected mode for variance scaling initializer: ' + this.mode);
        }
        if (this.distribution === 'normal') {
            return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error('Unexpected distribution for variance scaling initializer: ' +
                this.distribution);
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(1);
        return values;
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var values = ndarray_1.NDArray.zeros(weightsShape);
        values.fill(this.value);
        return values;
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var NDArrayInitializer = (function () {
    function NDArrayInitializer(ndarray) {
        this.ndarray = ndarray;
    }
    NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.ndarray;
    };
    return NDArrayInitializer;
}());
exports.NDArrayInitializer = NDArrayInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"./math/ndarray":22}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function (math) {
                return math.clone(shuffledInputProvider.getNextInput(inputId));
            },
            disposeCopy: function (math, copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"./math/ndarray":22,"./util":79}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var TanHFunc = (function () {
    function TanHFunc() {
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.tanh(x);
        });
    };
    TanHFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.scalarMinusArray(ndarray_1.Scalar.ONE, ySquared);
        });
    };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.relu(x);
        });
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.step(x);
        });
    };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.sigmoid(x);
        });
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            var ySquared = math.elementWiseMul(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.scope(function () {
            return math.elementWiseMul(x, x);
        });
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.scope(function () {
            return math.scalarTimesArray(ndarray_1.Scalar.TWO, x);
        });
    };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;

},{"./ndarray":22}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertConcat3DShapesMatch(x1Shape, x2Shape, axis, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    util.assert(x1Shape.length === 3, errorMessagePrefix + 'Concat3D x1 shape should be of rank 3.');
    util.assert(x2Shape.length === 3, errorMessagePrefix + 'Concat3D x2 shape should be of rank 3.');
    util.assert(axis >= 0 && axis < 3, 'Axis for concat3D must be between 0 and 2.');
    for (var i = 0; i < 3; i++) {
        util.assert((i === axis) || (x1Shape[i] === x2Shape[i]), errorMessagePrefix +
            ("Shape (" + x1Shape + ") does not match (" + x2Shape + ") along ") +
            "non-concatenated axis.");
    }
}
exports.assertConcat3DShapesMatch = assertConcat3DShapesMatch;
function computeConcat3DOutputShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === 3, 'Concat3D x1 shape should be of rank 3.');
    util.assert(x2Shape.length === 3, 'Concat3D x2shape should be of rank 3.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeConcat3DOutputShape = computeConcat3DOutputShape;

},{"../util":79}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computeOutputShape3D(inputShapeRowColDepth, fieldSize, depth, stride, zeroPad) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inputShapeRowColDepth, fieldSize, stride);
    }
    var inputRows = inputShapeRowColDepth[0];
    var inputCols = inputShapeRowColDepth[1];
    var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, depth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeTexShapeFrom3D(shapeRowColDepth) {
    return [shapeRowColDepth[0], shapeRowColDepth[1] * shapeRowColDepth[2]];
}
exports.computeTexShapeFrom3D = computeTexShapeFrom3D;
function computeWeightsShape4D(inputDepth, outputDepth, fSize) {
    return [fSize, fSize, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeWeightsTexShape(inputDepth, outputDepth, fieldSize) {
    return [fieldSize * fieldSize * inputDepth, outputDepth];
}
exports.computeWeightsTexShape = computeWeightsTexShape;
function computeBiasesTexShape(outputDepth) {
    return [1, outputDepth];
}
exports.computeBiasesTexShape = computeBiasesTexShape;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;

},{"../util":79}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function validateShapes(sourceSize, destSize) {
    var srcArea = sourceSize[0] * sourceSize[1];
    var dstArea = destSize[0] * destSize[1];
    if (srcArea !== dstArea) {
        var srcStr = '[' + sourceSize[0] + ', ' + sourceSize[1] + ']';
        var dstStr = '[' + destSize[0] + ', ' + destSize[1] + ']';
        throw new Error('copy2D shapes have different areas:\n  sourceSize ' + srcStr +
            ', area ' + srcArea + '\n  destSize ' + dstStr + ', area ' + dstArea);
    }
}
exports.validateShapes = validateShapes;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./ndarray");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = ndarray_1.Scalar.new(0.5);
    }
    SquareCostFunc.prototype.cost = function (math, x1, x2) {
        var diff = math.subStrict(x1, x2);
        var diffSquared = math.elementWiseMul(diff, diff);
        var result = math.scalarTimesArray(this.halfOne, diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (math, x1, x2) {
        return math.subStrict(x1, x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"./ndarray":22}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var copy2d_util = require("./copy2d_util");
var ndarray_1 = require("./ndarray");
var NDArrayMath = (function () {
    function NDArrayMath(safeMode) {
        this.safeMode = safeMode;
        this.ndarrayScopes = [];
        this.ndarraysToKeep = [];
        this.activeScopeNDArraysToKeep = [];
        this.debugMode = false;
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var _this = this;
        this.startScope();
        var keepFn = function (ndarray) { return _this.keep(ndarray); };
        var trackFn = function (ndarray) { return _this.track(ndarray); };
        var result = scopeFn(keepFn, trackFn);
        this.endScope(result);
        return result;
    };
    NDArrayMath.prototype.enableDebugMode = function () {
        this.debugMode = true;
        console.warn('Debugging mode is ON. The output of every math call will ' +
            'be downloaded to CPU and checked for NaNs. ' +
            'This significantly impacts performance.');
    };
    NDArrayMath.prototype.startScope = function () {
        var newScope = [];
        this.ndarrayScopes.push(newScope);
        this.activeScope = newScope;
        var newNDArraysToKeep = [];
        this.ndarraysToKeep.push(newNDArraysToKeep);
        this.activeScopeNDArraysToKeep = newNDArraysToKeep;
    };
    NDArrayMath.prototype.endScope = function (result) {
        var _this = this;
        var arraysToKeep = this.activeScopeNDArraysToKeep;
        if (result != null) {
            arraysToKeep = arraysToKeep.concat(result);
        }
        for (var i = 0; i < this.activeScope.length; i++) {
            var ndarray = this.activeScope[i];
            if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                continue;
            }
            ndarray.dispose();
        }
        this.ndarrayScopes.pop();
        this.activeScope = this.ndarrayScopes.length === 0 ?
            null :
            this.ndarrayScopes[this.ndarrayScopes.length - 1];
        if (result instanceof ndarray_1.NDArray &&
            !this.isNDArrayDataInList(result, this.activeScopeNDArraysToKeep)) {
            this.track(result);
        }
        else if (Array.isArray(result)) {
            result.forEach(function (r) {
                if (r instanceof ndarray_1.NDArray &&
                    !_this.isNDArrayDataInList(r, _this.activeScopeNDArraysToKeep)) {
                    _this.track(r);
                }
            });
        }
        this.ndarraysToKeep.pop();
        this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
            null :
            this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
    };
    NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
        for (var i = 0; i < ndarrayList.length; i++) {
            if (ndarrayList[i].getData() === ndarray.getData()) {
                return true;
            }
        }
        return false;
    };
    NDArrayMath.prototype.keep = function (result) {
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScopeNDArraysToKeep.push(result);
        return result;
    };
    NDArrayMath.prototype.checkForNaN = function (arr) {
        var vals = arr.getValues();
        for (var i = 0; i < vals.length; i++) {
            if (isNaN(vals[i])) {
                throw Error('The result NDArray of the last math call has NaNs.');
            }
        }
    };
    NDArrayMath.prototype.track = function (result) {
        if (this.debugMode) {
            this.checkForNaN(result);
        }
        if (this.activeScope == null) {
            if (this.safeMode) {
                throw new Error('You are using math in safe mode. Enclose all ' +
                    'math.method() calls inside a scope: ' +
                    'math.scope(() => {math.method();...}) to avoid memory ' +
                    'leaks.');
            }
            return result;
        }
        this.activeScope.push(result);
        return result;
    };
    NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = MatrixOrientation.REGULAR; }
        var innerShapeA = (aOrientation === MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var innerShapeB = (bOrientation === MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            ("and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
            (b.shape + " and orientations " + MatrixOrientation[aOrientation]) +
            (" and " + MatrixOrientation[bOrientation] + " must match."));
        return this.track(this.matMulInternal(a, b, aOrientation, bOrientation));
    };
    NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of first rank 1 input (" + v.size + ") " +
            "must match inner dimension of second rank 2 input, but got " +
            ("rank " + matrix.rank + "."));
        return this.matMul(v.as2D(1, v.size), matrix).as1D();
    };
    NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in vectorTimesMatrix: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return this.matMul(matrix, v.as2D(v.size, 1)).as1D();
    };
    NDArrayMath.prototype.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return this.matMul(v1.as2D(1, v1.size), v2.as2D(v2.size, 1)).asScalar();
    };
    NDArrayMath.prototype.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return this.matMul(v1.as2D(v1.size, 1), v2.as2D(1, v2.size));
    };
    NDArrayMath.prototype.clone = function (ndarray) {
        return this.track(this.cloneInternal(ndarray));
    };
    NDArrayMath.prototype.reshape = function (ndarray, newShape) {
        util.assert(ndarray.size === util.sizeFromShape(newShape), "Error in reshape: old size " + ndarray.size + " must match new size " +
            (util.sizeFromShape(newShape) + "."));
        return this.track(this.reshapeInternal(ndarray, newShape));
    };
    NDArrayMath.prototype.slice2D = function (input, begin, size) {
        util.assert(begin[0] + size[0] <= input.shape[0] &&
            begin[1] + size[1] <= input.shape[1], "Error in slice2D: requested start position " + begin + " and size " +
            (size + " would overflow input of shape " + input.shape + "."));
        return this.track(this.slice2DInternal(input, begin, size));
    };
    NDArrayMath.prototype.copy2D = function (source, sourceBegin, sourceSize, dest, destBegin, destSize) {
        util.assert(sourceBegin[0] + sourceSize[0] <= source.shape[0] &&
            sourceBegin[1] + sourceSize[1] <= source.shape[1], "Error in copy2D: requested source start position " + sourceBegin + " " +
            ("and source size " + sourceSize + " would overflow source NDArray") +
            ("of shape " + source.shape + "."));
        util.assert(destBegin[0] + destSize[0] <= dest.shape[0] &&
            destBegin[1] + destSize[1] <= dest.shape[1], "Error in copy2D: requested dest start position " + destBegin + " " +
            ("and source size " + destSize + " would overflow dest NDArray of") +
            ("shape " + dest.shape + "."));
        copy2d_util.validateShapes(sourceSize, destSize);
        return this.copy2DInternal(source, sourceBegin, sourceSize, dest, destBegin, destSize);
    };
    NDArrayMath.prototype.concat3D = function (ndarray1, ndarray2, axis) {
        concat3d_util.assertConcat3DShapesMatch(ndarray1.shape, ndarray2.shape, axis, 'Error in concat3d: ');
        return this.track(this.concat3DInternal(ndarray1, ndarray2, axis));
    };
    NDArrayMath.prototype.logSumExp = function (ndarray) {
        return this.track(this.logSumExpInternal(ndarray));
    };
    NDArrayMath.prototype.sum = function (ndarray) {
        return this.track(this.sumInternal(ndarray));
    };
    NDArrayMath.prototype.argMin = function (ndarray) {
        return this.track(this.argMinInternal(ndarray));
    };
    NDArrayMath.prototype.argMax = function (ndarray) {
        return this.track(this.argMaxInternal(ndarray));
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return this.track(this.argMaxEqualsInternal(x1, x2));
    };
    NDArrayMath.prototype.topK = function (ndarray, k) {
        util.assert(k <= ndarray.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("ndarray, got shape " + ndarray.shape + "."));
        var result = this.topKInternal(ndarray, k);
        this.track(result.values);
        this.track(result.indices);
        return result;
    };
    NDArrayMath.prototype.min = function (ndarray) {
        return this.track(this.minInternal(ndarray));
    };
    NDArrayMath.prototype.max = function (ndarray) {
        return this.track(this.maxInternal(ndarray));
    };
    NDArrayMath.prototype.softmax = function (x) {
        var _this = this;
        return this.scope(function () {
            var lse = _this.logSumExp(x);
            var logResult = _this.arrayMinusScalar(x, lse);
            return _this.exp(logResult);
        });
    };
    NDArrayMath.prototype.switchDim = function (a, newDim) {
        util.assert(a.rank === newDim.length, "Error in switchDim: length of input shape " + a.shape + " " +
            ("must match size of newDim array " + newDim + "."));
        return this.track(this.switchDimInternal(a, newDim));
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.sub(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.sub(a, c);
    };
    NDArrayMath.prototype.neg = function (a) {
        return this.track(this.negInternal(a));
    };
    NDArrayMath.prototype.add = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.addInternal(a, b));
    };
    NDArrayMath.prototype.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return this.add(a, b);
    };
    NDArrayMath.prototype.sub = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.subInternal(a, b));
    };
    NDArrayMath.prototype.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return this.sub(a, b);
    };
    NDArrayMath.prototype.multiply = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.multiplyInternal(a, b));
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return this.multiplyStrict(a, b);
    };
    NDArrayMath.prototype.multiplyStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.divide = function (a, b) {
        util.assertAndGetBroadcastedShape(a.shape, b.shape);
        return this.track(this.divideInternal(a, b));
    };
    NDArrayMath.prototype.divideStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return this.divide(a, b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got NDArray of rank " + c.rank + "."));
        return this.divide(c, a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got NDArray of rank " + c.rank + "."));
        return this.divide(a, c);
    };
    NDArrayMath.prototype.exp = function (ndarray) {
        return this.track(this.expInternal(ndarray));
    };
    NDArrayMath.prototype.log = function (ndarray) {
        return this.track(this.logInternal(ndarray));
    };
    NDArrayMath.prototype.relu = function (ndarray) {
        return this.track(this.reluInternal(ndarray));
    };
    NDArrayMath.prototype.sigmoid = function (ndarray) {
        return this.track(this.sigmoidInternal(ndarray));
    };
    NDArrayMath.prototype.tanh = function (ndarray) {
        return this.track(this.tanhInternal(ndarray));
    };
    NDArrayMath.prototype.sin = function (ndarray) {
        return this.track(this.sinInternal(ndarray));
    };
    NDArrayMath.prototype.step = function (ndarray) {
        return this.track(this.stepInternal(ndarray));
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("NDArray of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return this.track(this.scaledArrayAddInternal(c1, a, c2, b));
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
        util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
            ("rank 2, but got rank " + a.rank + "."));
        util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
            ("rank 2, but got rank " + b.rank + "."));
        return this.multiply(a, b);
    };
    NDArrayMath.prototype.conv2d = function (x, weights, biases, stride, zeroPad) {
        util.assert(x.rank === 3, "Error in conv2d: x must be rank 3, but got rank " + x.rank + ".");
        util.assert(weights.rank === 4, "Error in conv2d: weights must be rank 4, but got rank " +
            (weights.rank + "."));
        if (biases != null) {
            util.assert(biases.rank === 1, "Error in conv2d: biases must be rank 1, but got rank " +
                (biases.rank + "."));
        }
        util.assert(x.shape[2] === weights.shape[2], "Error in conv2d: depth of input (" + x.shape[2] + ") must match  " +
            ("input depth for weights " + weights.shape[2] + "."));
        return this.track(this.conv2dInternal(x, weights, biases, stride, zeroPad));
    };
    NDArrayMath.prototype.conv2dBackProp = function (x, dy, weights, stride, pad) {
        util.assert(x.rank === 3, "Error in conv2dBackProp: x must be rank 3, but got shape " +
            (x.shape + "."));
        util.assert(dy.rank === 3, "Error in conv2dBackProp: dy must be rank 3, but got shape " +
            (dy.shape + "."));
        util.assert(weights.rank === 4, "Error in conv2dBackProp: weights must be rank 4, but got shape " +
            (weights.shape + "."));
        util.assert(x.shape[2] === weights.shape[2], "Error in conv2dBackProp: depth of x " + x.shape[2] + ") must " +
            ("match input depth for weights (" + weights.shape[2] + "."));
        util.assert(dy.shape[2] === weights.shape[3], "Error in conv2dBackProp: depth of dy (" + dy.shape[2] + ") must " +
            ("match output depth for weights (" + weights.shape[3] + ")."));
        var backpropResult = this.conv2dBackPropInternal(x, dy, weights, stride, pad);
        this.track(backpropResult.db);
        this.track(backpropResult.dw);
        this.track(backpropResult.dx);
        return backpropResult;
    };
    NDArrayMath.prototype.conv2dTranspose = function (x, weights, biases, stride, pad) {
        util.assert(x.rank === 3, "Error in conv2dTranspose: x must be rank 3, but got rank " +
            (x.rank + "."));
        util.assert(weights.rank === 4, "Error in conv2dTranspose: weights must be rank 4, but got " +
            ("rank " + weights.rank));
        if (biases != null) {
            util.assert(biases.rank === 1, "Error in conv2dTranspose: biases must be rank 1, but got ' +\n              'rank " + biases.rank + ".");
        }
        util.assert(x.shape[2] === weights.shape[3], "Error in conv2dTranspose: depth of input (" + x.shape[2] + ") must " +
            ("match input depth for weights " + weights.shape[3] + "."));
        return this.track(this.conv2dTransposeInternal(x, weights, biases, stride, pad));
    };
    NDArrayMath.prototype.maxPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, 'Error in maxPool: x must be rank 3 but got rank ' + x.rank + '.');
        return this.track(this.maxPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.maxPoolBackprop = function (dy, x, fSize, stride, pad) {
        util.assert(dy.rank === 3, "Error in maxPoolBackprop: dy must be rank 3 but got rank " +
            (dy.rank + "."));
        util.assert(x.rank === 3, "Error in maxPoolBackprop: x must be rank 3 but got rank " +
            (x.rank + "."));
        return this.track(this.maxPoolBackpropInternal(dy, x, fSize, stride, pad));
    };
    NDArrayMath.prototype.minPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, "Error in minPool: x must be rank 3 but got rank " + x.rank + ".");
        return this.track(this.minPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.avgPool = function (x, fSize, stride, pad) {
        util.assert(x.rank === 3, "Error in avgPool: x must be rank 3 but got rank " + x.rank + ".");
        return this.track(this.avgPoolInternal(x, fSize, stride, pad));
    };
    NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
        util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
            (newShape2D + "."));
        return this.track(this.resizeBilinear3DInternal(x, newShape2D, alignCorners));
    };
    NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return this.track(this.batchNormalization3DInternal(x, mean, variance, varianceEpsilon, scale, offset));
    };
    NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
        util.assert(data.shape[0] === 1, "Error in multiRNNCell: first dimension of data is " + data.shape[0] + ", " +
            "but batch sizes > 1 are not yet supported.");
        var res = this.scope(function () {
            var input = data;
            var newStates = [];
            for (var i = 0; i < lstmCells.length; i++) {
                var output = lstmCells[i](input, c[i], h[i]);
                newStates.push(output[0]);
                newStates.push(output[1]);
                input = output[1];
            }
            return newStates;
        });
        var newC = [];
        var newH = [];
        for (var i = 0; i < res.length; i += 2) {
            newC.push(res[i]);
            newH.push(res[i + 1]);
        }
        return [newC, newH];
    };
    NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var _this = this;
        var res = this.scope(function () {
            util.assert(data.shape[0] === 1, "Error in multiRNNCell: first dimension of data is " +
                (data.shape[0] + ", but batch sizes > 1 are not yet supported."));
            var data3D = data.as3D(1, 1, data.shape[1]);
            var h3D = h.as3D(1, 1, h.shape[1]);
            var combined3D = _this.concat3D(data3D, h3D, 2);
            var combined2D = combined3D.as2D(1, data.shape[1] + h.shape[1]);
            var weighted = _this.matMul(combined2D, lstmKernel);
            var res = _this.add(weighted, lstmBias);
            var i = _this.slice2D(res, [0, 0], [res.shape[0], res.shape[1] / 4]);
            var j = _this.slice2D(res, [0, res.shape[1] / 4 * 1], [res.shape[0], res.shape[1] / 4]);
            var f = _this.slice2D(res, [0, res.shape[1] / 4 * 2], [res.shape[0], res.shape[1] / 4]);
            var o = _this.slice2D(res, [0, res.shape[1] / 4 * 3], [res.shape[0], res.shape[1] / 4]);
            var newC = _this.add(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
            var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
            return [newC, newH];
        });
        return [res[0], res[1]];
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));

},{"../util":79,"./concat3d_util":15,"./copy2d_util":17,"./ndarray":22}],20:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var copy2D_util = require("./copy2d_util");
var math_1 = require("./math");
var ndarray_1 = require("./ndarray");
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        return _super.call(this, safeMode) || this;
    }
    NDArrayMathCPU.prototype.cloneInternal = function (ndarray) {
        return ndarray_1.NDArray.make(ndarray.shape, { values: new Float32Array(ndarray.getValues()) });
    };
    NDArrayMathCPU.prototype.reshapeInternal = function (ndarray, newShape) {
        return this.cloneInternal(ndarray).reshape(newShape);
    };
    NDArrayMathCPU.prototype.slice2DInternal = function (input, beginRowCol, sizeRowCol) {
        var result = ndarray_1.Array2D.zeros(sizeRowCol);
        this.copy2DInternal(input, beginRowCol, sizeRowCol, result, [0, 0], sizeRowCol);
        return result;
    };
    NDArrayMathCPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        copy2D_util.validateShapes(sourceSizeRowCol, destSizeRowCol);
        var srcValues = source.getValues();
        var dstValues = dest.getValues();
        var n = sourceSizeRowCol[0] * sourceSizeRowCol[1];
        for (var i = 0; i < n; ++i) {
            var srcRow = sourceBeginRowCol[0] + Math.floor(i / sourceSizeRowCol[1]);
            var srcCol = sourceBeginRowCol[1] + (i % sourceSizeRowCol[1]);
            var srcOff = srcRow * source.shape[1] + srcCol;
            var dstRow = destBeginRowCol[0] + Math.floor(i / destSizeRowCol[1]);
            var dstCol = destBeginRowCol[1] + (i % destSizeRowCol[1]);
            var dstOff = dstRow * dest.shape[1] + dstCol;
            dstValues[dstOff] = srcValues[srcOff];
        }
    };
    NDArrayMathCPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var outputShape = concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis);
        var values = ndarray_1.Array3D.zeros(outputShape);
        for (var i = 0; i < outputShape[0]; i++) {
            for (var j = 0; j < outputShape[1]; j++) {
                for (var k = 0; k < outputShape[2]; k++) {
                    var index = [i, j, k];
                    var value = void 0;
                    if (index[axis] < x1.shape[axis]) {
                        value = x1.get(i, j, k);
                    }
                    else {
                        index[axis] -= x1.shape[axis];
                        var i2 = index[0], j2 = index[1], k2 = index[2];
                        value = x2.get(i2, j2, k2);
                    }
                    values.set(value, i, j, k);
                }
            }
        }
        return values;
    };
    NDArrayMathCPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        var c1Val = c1.get();
        var c2Val = c2.get();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = c1Val * aValues[i % a.size] + c2Val * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.negInternal = function (a) {
        return this.scalarTimesArray(ndarray_1.Scalar.NEG_ONE, a);
    };
    NDArrayMathCPU.prototype.addInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.ONE, b);
    };
    NDArrayMathCPU.prototype.subInternal = function (a, b) {
        return this.scaledArrayAddInternal(ndarray_1.Scalar.ONE, a, ndarray_1.Scalar.NEG_ONE, b);
    };
    NDArrayMathCPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        if (aOrientation === void 0) { aOrientation = math_1.MatrixOrientation.REGULAR; }
        if (bOrientation === void 0) { bOrientation = math_1.MatrixOrientation.REGULAR; }
        var sharedDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
        var leftDim = (aOrientation === math_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
        var rightDim = (bOrientation === math_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = (aOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var bGetter = (bOrientation === math_1.MatrixOrientation.REGULAR) ?
            normalGetter :
            transposedGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ndarray_1.Array2D.new([leftDim, rightDim], values);
    };
    NDArrayMathCPU.prototype.multiplyInternal = function (a, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] * bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.divideInternal = function (a, b) {
        var newShape = util.assertAndGetBroadcastedShape(a.shape, b.shape);
        var newValues = new Float32Array(util.sizeFromShape(newShape));
        var aValues = a.getValues();
        var bValues = b.getValues();
        for (var i = 0; i < newValues.length; ++i) {
            newValues[i] = aValues[i % a.size] / bValues[i % b.size];
        }
        return ndarray_1.NDArray.make(newShape, { values: newValues });
    };
    NDArrayMathCPU.prototype.sumInternal = function (ndarray) {
        var sum = 0;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            sum += values[i];
        }
        return ndarray_1.Scalar.new(sum);
    };
    NDArrayMathCPU.prototype.argMinInternal = function (ndarray) {
        var min = Number.MAX_VALUE;
        var minIndex = -1;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value < min) {
                min = value;
                minIndex = i;
            }
        }
        return ndarray_1.Scalar.new(minIndex);
    };
    NDArrayMathCPU.prototype.argMaxInternal = function (ndarray) {
        var max = Number.NEGATIVE_INFINITY;
        var maxIndex = -1;
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value > max) {
                max = value;
                maxIndex = i;
            }
        }
        return ndarray_1.Scalar.new(maxIndex);
    };
    NDArrayMathCPU.prototype.argMaxEqualsInternal = function (x1, x2) {
        var argMax1 = this.argMaxInternal(x1).get();
        var argMax2 = this.argMaxInternal(x2).get();
        if (isNaN(argMax1) || isNaN(argMax2)) {
            return ndarray_1.Scalar.new(NaN);
        }
        return ndarray_1.Scalar.new(+(argMax1 === argMax2));
    };
    NDArrayMathCPU.prototype.topKInternal = function (ndarray, k) {
        var values = ndarray.getValues();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = new Float32Array(k);
        var topkIndices = new Float32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return { values: ndarray_1.Array1D.new(topkValues), indices: ndarray_1.Array1D.new(topkIndices) };
    };
    NDArrayMathCPU.prototype.minInternal = function (ndarray) {
        var values = ndarray.getValues();
        var min = values[0];
        for (var i = 1; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value < min) {
                min = value;
            }
        }
        return ndarray_1.Scalar.new(min);
    };
    NDArrayMathCPU.prototype.maxInternal = function (ndarray) {
        var values = ndarray.getValues();
        var max = values[0];
        for (var i = 1; i < values.length; ++i) {
            var value = values[i];
            if (isNaN(value)) {
                return ndarray_1.Scalar.new(NaN);
            }
            if (value > max) {
                max = value;
            }
        }
        return ndarray_1.Scalar.new(max);
    };
    NDArrayMathCPU.prototype.expInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logInternal = function (ndarray) {
        var values = ndarray.getValues();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: newValues });
    };
    NDArrayMathCPU.prototype.logSumExpInternal = function (ndarray) {
        var xMax = this.max(ndarray);
        var a = this.arrayMinusScalar(ndarray, xMax);
        var b = this.exp(a);
        var c = this.sum(b);
        var d = this.log(c);
        var result = this.add(xMax, d);
        xMax.dispose();
        a.dispose();
        b.dispose();
        c.dispose();
        d.dispose();
        return result;
    };
    NDArrayMathCPU.prototype.reluInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.max(0, values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sigmoidInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.tanhInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.sinInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.stepInternal = function (ndarray) {
        var resultValues = new Float32Array(ndarray.size);
        var values = ndarray.getValues();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            resultValues[i] = value > 0 ? 1 : (value < 0 ? 0 : value);
        }
        return ndarray_1.NDArray.make(ndarray.shape, { values: resultValues });
    };
    NDArrayMathCPU.prototype.conv2dInternal = function (x, weights, biases, stride, pad) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], inputDepth = _a[2];
        var fieldSize = weights.shape[0];
        var outputDepth = weights.shape[3];
        var outputShape = conv_util.computeOutputShape3D([xRows, xCols, inputDepth], fieldSize, outputDepth, stride, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fieldSize + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fieldSize + xCCorner);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            for (var d1 = 0; d1 < inputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = weights.get(wR, wC, d1, d2);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var bias = (biases != null) ? biases.get(d2) : 0;
                    y.set(dotProd + bias, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dBackPropInternal = function (x, dy, weights, stride, pad) {
        var fSize = weights.shape[0];
        var dw = this.conv2dDerWeights(x, dy, fSize, stride, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dTransposeInternal(dy, weights, null, stride, pad);
        return { dx: dx, db: db, dw: dw };
    };
    NDArrayMathCPU.prototype.conv2dTransposeInternal = function (x, weights, biases, origStride, origPad) {
        var fSize = weights.shape[0];
        var pad = fSize - 1 - origPad;
        var origInputDepth = weights.shape[2];
        var origOutputDepth = weights.shape[3];
        var xRows = x.shape[0];
        var xCols = x.shape[1];
        var xRowsDilated = (xRows - 1) * origStride + 1;
        var xColsDilated = (xCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([xRowsDilated, xColsDilated, origOutputDepth], fSize, origInputDepth, 1, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < origInputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR - pad;
                var xRMin = Math.max(0, Math.ceil(xRCorner / origStride));
                var xRMax = Math.min(xRows, (fSize + xRCorner) / origStride);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC - pad;
                    var xCMin = Math.max(0, Math.ceil(xCCorner / origStride));
                    var xCMax = Math.min(xCols, (fSize + xCCorner) / origStride);
                    var dotProd = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR * origStride - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC * origStride - xCCorner;
                            for (var d1 = 0; d1 < origOutputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = weights.get(fSize - 1 - wR, fSize - 1 - wC, d2, d1);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    var bias = biases != null ? biases.get(d2) : 0;
                    y.set(dotProd + bias, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dTransposeShaderLike = function (x, origWeights, origStride, origPad) {
        var fSize = origWeights.shape[0];
        var pad = fSize - 1 - origPad;
        var origInputDepth = origWeights.shape[2];
        var origOutputDepth = origWeights.shape[3];
        var xRows = x.shape[0];
        var xCols = x.shape[1];
        var xRowsDilated = (xRows - 1) * origStride + 1;
        var xColsDilated = (xCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([xRowsDilated, xColsDilated, origOutputDepth], fSize, origInputDepth, 1, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d2 = 0; d2 < origInputDepth; ++d2) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xRCorner = yR - pad;
                    var xCCorner = yC - pad;
                    var dotProd = 0;
                    for (var wR = 0; wR < fSize; ++wR) {
                        var xR = (xRCorner + wR) / origStride;
                        if (xR < 0 || xR >= xRows || Math.floor(xR) !== xR) {
                            continue;
                        }
                        for (var wC = 0; wC < fSize; ++wC) {
                            var xC = (xCCorner + wC) / origStride;
                            if (xC < 0 || xC >= xCols || Math.floor(xC) !== xC) {
                                continue;
                            }
                            for (var d1 = 0; d1 < origOutputDepth; ++d1) {
                                var pixel = x.get(xR, xC, d1);
                                var weight = origWeights.get(fSize - 1 - wR, fSize - 1 - wC, d2, d1);
                                dotProd += pixel * weight;
                            }
                        }
                    }
                    y.set(dotProd, yR, yC, d2);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.conv2dDerWeights = function (x, dY, fSize, stride, zeroPad) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, fSize);
        var dW = ndarray_1.Array4D.zeros(weightsShape);
        var yNumRows = dY.shape[0];
        var yNumCols = dY.shape[1];
        var xNumRows = x.shape[0];
        var xNumCols = x.shape[1];
        for (var wR = 0; wR < fSize; ++wR) {
            var yRMin = Math.max(0, Math.ceil((zeroPad - wR) / stride));
            var yRMax = Math.min(yNumRows, (xNumRows + zeroPad - wR) / stride);
            for (var wC = 0; wC < fSize; ++wC) {
                var yCMin = Math.max(0, Math.ceil((zeroPad - wC) / stride));
                var yCMax = Math.min(yNumCols, (xNumCols + zeroPad - wC) / stride);
                for (var d1 = 0; d1 < inputDepth; ++d1) {
                    for (var d2 = 0; d2 < outputDepth; ++d2) {
                        var dotProd = 0;
                        for (var yR = yRMin; yR < yRMax; ++yR) {
                            var xR = wR + yR * stride - zeroPad;
                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                var xC = wC + yC * stride - zeroPad;
                                dotProd += x.get(xR, xC, d1) * dY.get(yR, yC, d2);
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW;
    };
    NDArrayMathCPU.prototype.conv2dDerBias = function (dY) {
        var outputDepth = dY.shape[2];
        var numRows = dY.shape[0];
        var numCols = dY.shape[1];
        var values = new Float32Array(outputDepth);
        for (var d2 = 0; d2 < outputDepth; ++d2) {
            var sum = 0;
            for (var r = 0; r < numRows; ++r) {
                for (var c = 0; c < numCols; ++c) {
                    sum += dY.get(r, c, d2);
                }
            }
            values[d2] = sum;
        }
        return ndarray_1.Array1D.new(values);
    };
    NDArrayMathCPU.prototype.switchDimInternal = function (t, newDim) {
        var newShape = new Array(t.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = t.shape[newDim[i]];
        }
        var resultValues = new Float32Array(t.size);
        var values = t.getValues();
        var result = ndarray_1.NDArray.make(newShape, { values: resultValues });
        for (var i = 0; i < t.size; ++i) {
            var loc = t.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_1 = 0; i_1 < newLoc.length; i_1++) {
                newLoc[i_1] = loc[newDim[i_1]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    NDArrayMathCPU.prototype.pool = function (x, fSize, stride, pad, poolType) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = conv_util.computeOutputShape3D([xRows, xCols, depth], fSize, depth, stride, pad);
        var y = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < y.shape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fSize + xRCorner);
                for (var yC = 0; yC < y.shape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fSize + xCCorner);
                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                        Number.POSITIVE_INFINITY);
                    var avgValue = 0;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var pixel = x.get(xR, xC, d);
                            if (isNaN(pixel)) {
                                minMaxValue = NaN;
                                avgValue = NaN;
                                break;
                            }
                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                (poolType === 'min' && pixel < minMaxValue)) {
                                minMaxValue = pixel;
                            }
                            else if (poolType === 'avg') {
                                avgValue += pixel / (fSize * fSize);
                            }
                        }
                        if (isNaN(minMaxValue)) {
                            break;
                        }
                    }
                    y.set(poolType === 'avg' ? avgValue : minMaxValue, yR, yC, d);
                }
            }
        }
        return y;
    };
    NDArrayMathCPU.prototype.maxPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'max');
    };
    NDArrayMathCPU.prototype.maxPoolPositions = function (x, fSize, stride, pad) {
        var _a = x.shape, xRows = _a[0], xCols = _a[1], depth = _a[2];
        var outputShape = conv_util.computeOutputShape3D(x.shape, fSize, depth, stride, pad);
        var maxPositions = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var yR = 0; yR < outputShape[0]; ++yR) {
                var xRCorner = yR * stride - pad;
                var xRMin = Math.max(0, xRCorner);
                var xRMax = Math.min(xRows, fSize + xRCorner);
                for (var yC = 0; yC < outputShape[1]; ++yC) {
                    var xCCorner = yC * stride - pad;
                    var xCMin = Math.max(0, xCCorner);
                    var xCMax = Math.min(xCols, fSize + xCCorner);
                    var maxValue = Number.NEGATIVE_INFINITY;
                    var maxPosition = -1;
                    for (var xR = xRMin; xR < xRMax; ++xR) {
                        var wR = xR - xRCorner;
                        for (var xC = xCMin; xC < xCMax; ++xC) {
                            var wC = xC - xCCorner;
                            var pixel = x.get(xR, xC, d);
                            if (pixel > maxValue) {
                                maxValue = pixel;
                                maxPosition = wR * fSize + wC;
                            }
                        }
                    }
                    maxPositions.set(maxPosition, yR, yC, d);
                }
            }
        }
        return maxPositions;
    };
    NDArrayMathCPU.prototype.maxPoolBackpropInternal = function (dy, x, fSize, origStride, origPad) {
        var maxPositions = this.maxPoolPositions(x, fSize, origStride, origPad);
        var pad = fSize - 1 - origPad;
        var _a = dy.shape, dyRows = _a[0], dyCols = _a[1], depth = _a[2];
        var dyRowsDilated = (dyRows - 1) * origStride + 1;
        var dxColsDilated = (dyCols - 1) * origStride + 1;
        var outputShape = conv_util.computeOutputShape3D([dyRowsDilated, dxColsDilated, depth], fSize, depth, 1, pad);
        var dx = ndarray_1.Array3D.zeros(outputShape);
        for (var d = 0; d < depth; ++d) {
            for (var dxR = 0; dxR < dx.shape[0]; ++dxR) {
                for (var dxC = 0; dxC < dx.shape[1]; ++dxC) {
                    var dyRCorner = dxR - pad;
                    var dyCCorner = dxC - pad;
                    var dotProd = 0;
                    for (var wR = 0; wR < fSize; ++wR) {
                        var dyR = (dyRCorner + wR) / origStride;
                        if (dyR < 0 || dyR >= dyRows || Math.floor(dyR) !== dyR) {
                            continue;
                        }
                        for (var wC = 0; wC < fSize; ++wC) {
                            var dyC = (dyCCorner + wC) / origStride;
                            if (dyC < 0 || dyC >= dyCols || Math.floor(dyC) !== dyC) {
                                continue;
                            }
                            var maxPos = fSize * fSize - 1 - maxPositions.get(dyR, dyC, d);
                            var curPos = wR * fSize + wC;
                            var mask = maxPos === curPos ? 1 : 0;
                            if (mask === 0) {
                                continue;
                            }
                            var pixel = dy.get(dyR, dyC, d);
                            dotProd += pixel * mask;
                        }
                    }
                    dx.set(dotProd, dxR, dxC, d);
                }
            }
        }
        return dx;
    };
    NDArrayMathCPU.prototype.minPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'min');
    };
    NDArrayMathCPU.prototype.avgPoolInternal = function (x, fSize, stride, pad) {
        return this.pool(x, fSize, stride, pad, 'avg');
    };
    NDArrayMathCPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
        var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
        var effectiveOutputSize = alignCorners ?
            [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
            output.shape;
        for (var r = 0; r < output.shape[0]; r++) {
            for (var c = 0; c < output.shape[1]; c++) {
                for (var d = 0; d < output.shape[2]; d++) {
                    var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                    var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                    var sourceRowFloor = Math.floor(sourceFracRow);
                    var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                    var sourceColFloor = Math.floor(sourceFracCol);
                    var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                    var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                    var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                    var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                    var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                    var rowFrac = sourceFracRow - sourceRowFloor;
                    var colFrac = sourceFracCol - sourceColFloor;
                    var top_1 = topLeft + (topRight - topLeft) * colFrac;
                    var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                    var newValue = top_1 + (bottom - top_1) * rowFrac;
                    output.set(newValue, r, c, d);
                }
            }
        }
        return output;
    };
    NDArrayMathCPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        var xValues = x.getValues();
        var meanValues = mean.getValues();
        var varianceValues = variance.getValues();
        var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
        var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ndarray_1.NDArray.make(x.shape, { values: outValues });
    };
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../math/conv_util":16,"../util":79,"./concat3d_util":15,"./copy2d_util":17,"./math":19,"./ndarray":22}],21:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var concat3d_util = require("./concat3d_util");
var conv_util = require("./conv_util");
var math_1 = require("./math");
var ndarray = require("./ndarray");
var ndarray_1 = require("./ndarray");
var addscaledmat_gpu = require("./webgl/addscaledmat_gpu");
var argmaxequals_gpu_1 = require("./webgl/argmaxequals_gpu");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_gpu = require("./webgl/avg_pool_gpu");
var batchnorm_gpu = require("./webgl/batchnorm_gpu");
var concat3d_gpu = require("./webgl/concat3d_gpu");
var conv_backprop_gpu = require("./webgl/conv_backprop_gpu");
var conv_gpu = require("./webgl/conv_gpu");
var copy_gpu = require("./webgl/copy_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var gpgpu_math = require("./webgl/gpgpu_math");
var gpgpu_util = require("./webgl/gpgpu_util");
var logsumexp_gpu_1 = require("./webgl/logsumexp_gpu");
var max_pool_backprop_gpu = require("./webgl/max_pool_backprop_gpu");
var max_pool_gpu = require("./webgl/max_pool_gpu");
var min_pool_gpu = require("./webgl/min_pool_gpu");
var minmax_gpu_1 = require("./webgl/minmax_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var pool_gpu = require("./webgl/pool_gpu");
var reducesum_gpu_1 = require("./webgl/reducesum_gpu");
var reshape_gpu = require("./webgl/reshape_gpu");
var resize_bilinear_gpu = require("./webgl/resize_bilinear_gpu");
var texture_manager_1 = require("./webgl/texture_manager");
var webgl_util = require("./webgl/webgl_util");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var BATCHNORM_PROG = 'batchnorm';
var COPY_PROG = 'copy';
var CONCAT_PROG = 'concat';
var ADD_SCALED_MAT_PROG = 'addscaledmat';
var RESHAPE_PROG = 'reshape';
var CONV2D_PROG = 'conv';
var CONV2D_TRANSPOSE_PROG = 'conv_transpose';
var CONV2D_DERW_PROG = 'conv_derw';
var CONV2D_DERB_PROG = 'conv_derb';
var MAX_POOL_PROG = 'maxpool';
var MAX_POOL_POSITIONS_PROG = 'maxpool_posn';
var MAX_POOL_BACKPROP_PROG = 'maxpool_backprop';
var MIN_POOL_PROG = 'minpool';
var AVG_POOL_PROG = 'avgpool';
var RESIZE_BILINEAR_PROG = 'resizebilin';
function makeCopyProgramName(sourceShapeRowCol, sourceSizeRowCol, destSizeRowCol) {
    var shapeName = sourceShapeRowCol[0] + "_" + sourceShapeRowCol[1];
    var srcSizeName = sourceSizeRowCol[0] + "_" + sourceSizeRowCol[1];
    var dstSizeName = destSizeRowCol[0] + "_" + destSizeRowCol[1];
    return COPY_PROG + "_" + shapeName + "_" + srcSizeName + "_" + dstSizeName;
}
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = true; }
        var _this = _super.call(this, safeMode) || this;
        _this.programCache = {};
        _this.binaryCache = {};
        if (gpgpu == null) {
            var gl = gpgpu_util.createWebGLContext();
            _this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
            _this.gpgpuCreatedLocally = true;
        }
        else {
            _this.gpgpu = gpgpu;
            _this.gpgpuCreatedLocally = false;
        }
        _this.textureManager = new texture_manager_1.TextureManager(_this.gpgpu);
        ndarray.initializeGPU(_this.gpgpu, _this.textureManager);
        return _this;
    }
    NDArrayMathGPU.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    NDArrayMathGPU.prototype.cloneInternal = function (ndarray) {
        var textureShapeRC = ndarray.getTextureShapeRC();
        var program = this.getAndSaveProgram(makeCopyProgramName(textureShapeRC, textureShapeRC, textureShapeRC), function () { return copy_gpu.getFragmentShaderSource(textureShapeRC, textureShapeRC, textureShapeRC); });
        var resultTexture = this.textureManager.acquireTexture(textureShapeRC);
        copy_gpu.copy(this.gpgpu, program, ndarray.getTexture(), textureShapeRC, [0, 0], textureShapeRC, resultTexture, textureShapeRC, [0, 0], textureShapeRC);
        return ndarray_1.NDArray.make(ndarray.shape, { texture: resultTexture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.reshapeInternal = function (ndarray, newShape) {
        var newTexShape;
        switch (newShape.length) {
            case 0:
                newTexShape = [1, 1];
                break;
            case 1:
                newTexShape = [newShape[0], 1];
                break;
            case 2:
                newTexShape = [newShape[0], newShape[1]];
                break;
            case 3:
                newTexShape = [newShape[0], newShape[1] * newShape[2]];
                break;
            default:
                throw Error("Reshapes into " + newShape.length + "-dim ndarray is not yet " +
                    "supported on GPU");
        }
        var actualTexShape = ndarray.getTextureShapeRC(newTexShape);
        var clonedArray;
        if (!util.arraysEqual(actualTexShape, newTexShape)) {
            clonedArray = this.reshapeTexture(ndarray, newTexShape);
        }
        else {
            clonedArray = this.cloneInternal(ndarray);
        }
        return clonedArray.reshape(newShape);
    };
    NDArrayMathGPU.prototype.slice2DInternal = function (input, beginRowCol, sizeRowCol) {
        var result = ndarray_1.NDArray.make(sizeRowCol, {
            texture: this.textureManager.acquireTexture(sizeRowCol),
            textureShapeRC: sizeRowCol
        });
        this.copy2DInternal(input, beginRowCol, sizeRowCol, result, [0, 0], sizeRowCol);
        return result;
    };
    NDArrayMathGPU.prototype.copy2DInternal = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
        var sourceShapeRC = source.getTextureShapeRC();
        var destShapeRC = dest.getTextureShapeRC();
        var program = this.getAndSaveProgram(makeCopyProgramName(sourceShapeRC, sourceSizeRowCol, destSizeRowCol), function () { return copy_gpu.getFragmentShaderSource(sourceShapeRC, sourceSizeRowCol, destSizeRowCol); });
        copy_gpu.copy(this.gpgpu, program, source.getTexture(), sourceShapeRC, sourceBeginRowCol, sourceSizeRowCol, dest.getTexture(), destShapeRC, destBeginRowCol, destSizeRowCol);
    };
    NDArrayMathGPU.prototype.concat3DInternal = function (x1, x2, axis) {
        var x1TexShapeRC = conv_util.computeTexShapeFrom3D(x1.shape);
        var x2TexShapeRC = conv_util.computeTexShapeFrom3D(x2.shape);
        var actualX1TexShape = x1.getTextureShapeRC(x1TexShapeRC);
        var cleanupX1 = false;
        if (!util.arraysEqual(actualX1TexShape, x1TexShapeRC)) {
            x1 = this.reshapeTexture(x1, x1TexShapeRC);
            cleanupX1 = true;
        }
        var actualX2TexShape = x2.getTextureShapeRC(x2TexShapeRC);
        var cleanupX2 = false;
        if (!util.arraysEqual(actualX2TexShape, x2TexShapeRC)) {
            x2 = this.reshapeTexture(x2, x2TexShapeRC);
            cleanupX2 = true;
        }
        var resultShapeRCD = concat3d_util.computeConcat3DOutputShape(x1.shape, x2.shape, axis);
        var program = this.getAndSaveProgram(CONCAT_PROG + "_" + x1.shape + "_" + x2.shape + "_" + axis, function () { return concat3d_gpu.getFragmentShaderSource(x1.shape, x2.shape, resultShapeRCD, axis); });
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShapeRCD);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        concat3d_gpu.concat3D(this.gpgpu, program, x1.getTexture(), x2.getTexture(), resultTex, resultTexShape);
        if (cleanupX1) {
            x1.dispose();
        }
        if (cleanupX2) {
            x2.dispose();
        }
        return ndarray_1.NDArray.make(resultShapeRCD, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.scaledArrayAddInternal = function (c1, a, c2, b) {
        var cleanupB = false;
        if (!this.doGPUShapesMatch(a, b)) {
            b = this.reshapeTexture(b, a.getTextureShapeRC());
            cleanupB = true;
        }
        var program = this.getAndSaveProgram(ADD_SCALED_MAT_PROG, function () { return addscaledmat_gpu.getFragmentShaderSource(); });
        var textureShapeRC = a.getTextureShapeRC();
        var resultTexture = this.textureManager.acquireTexture(textureShapeRC);
        addscaledmat_gpu.addScaledMatrices(this.gpgpu, program, a.getTexture(), b.getTexture(), textureShapeRC[0], textureShapeRC[1], c1.getTexture(), c2.getTexture(), resultTexture);
        if (cleanupB) {
            b.dispose();
        }
        return ndarray_1.NDArray.make(a.shape, { texture: resultTexture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.negInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.NEG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.makeOutputArray = function (shape) {
        var textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        var texture = this.textureManager.acquireTexture(textureShapeRC);
        return ndarray_1.NDArray.make(shape, { texture: texture, textureShapeRC: textureShapeRC });
    };
    NDArrayMathGPU.prototype.compileAndRun = function (program, inputs) {
        var _this = this;
        var output = this.makeOutputArray(program.outputShape);
        var key = gpgpu_math.makeShaderKey(program, inputs, output);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputs, output);
        });
        gpgpu_math.runProgram(binary, inputs, output);
        return output;
    };
    NDArrayMathGPU.prototype.reshapeTexture = function (a, newTextureShape) {
        var aTexShape = a.getTextureShapeRC();
        var program = this.getAndSaveProgram(RESHAPE_PROG, function () { return reshape_gpu.getFragmentShaderSource(); });
        var resultTexture = this.textureManager.acquireTexture(newTextureShape);
        reshape_gpu.reshape(this.gpgpu, program, a.getTexture(), aTexShape[0], aTexShape[1], resultTexture, newTextureShape[0], newTextureShape[1]);
        return ndarray_1.NDArray.make(a.shape, { texture: resultTexture, textureShapeRC: newTextureShape });
    };
    NDArrayMathGPU.prototype.matMulInternal = function (a, b, aOrientation, bOrientation) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.multiplyInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('*', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.batchNormalization3DInternal = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xTexShape = x.getTextureShapeRC();
        var cleanupMean = false;
        var preferredMeanTexShape = mean.rank === 1 ? [1, mean.size] : xTexShape;
        var meanTexShape = mean.getTextureShapeRC(preferredMeanTexShape);
        if (!util.arraysEqual(meanTexShape, preferredMeanTexShape)) {
            mean = this.reshapeTexture(mean, preferredMeanTexShape);
            meanTexShape = preferredMeanTexShape;
            cleanupMean = true;
        }
        var cleanupVariance = false;
        var preferredVarianceTexShape = variance.rank === 1 ? [1, variance.size] : xTexShape;
        var varianceTexShape = variance.getTextureShapeRC(preferredMeanTexShape);
        if (!util.arraysEqual(varianceTexShape, preferredVarianceTexShape)) {
            variance = this.reshapeTexture(variance, preferredVarianceTexShape);
            varianceTexShape = preferredVarianceTexShape;
            cleanupVariance = true;
        }
        var scaleTexShape = null;
        var cleanupScale = false;
        if (scale != null) {
            var preferredScaleTexShape = scale.rank === 1 ? [1, scale.size] : xTexShape;
            scaleTexShape = scale.getTextureShapeRC(preferredScaleTexShape);
            if (!util.arraysEqual(scaleTexShape, preferredScaleTexShape)) {
                scale = this.reshapeTexture(scale, preferredScaleTexShape);
                scaleTexShape = preferredScaleTexShape;
                cleanupScale = true;
            }
        }
        var offsetTexShape = null;
        var cleanupOffset = false;
        if (offset != null) {
            var preferredOffsetTexShape = offset.rank === 1 ? [1, offset.size] : xTexShape;
            offsetTexShape = offset.getTextureShapeRC(preferredOffsetTexShape);
            if (!util.arraysEqual(offsetTexShape, preferredOffsetTexShape)) {
                offset = this.reshapeTexture(offset, preferredOffsetTexShape);
                offsetTexShape = preferredOffsetTexShape;
                cleanupOffset = true;
            }
        }
        var resultTexShape = x.getTextureShapeRC();
        var program = this.getAndSaveProgram(BATCHNORM_PROG + "_" + xTexShape + "_" + meanTexShape + "_" + varianceTexShape + "_" +
            (scaleTexShape + "_" + offsetTexShape + "_" + varianceEpsilon), function () { return batchnorm_gpu.getFragmentShaderSource(xTexShape, meanTexShape, varianceTexShape, offsetTexShape, scaleTexShape, varianceEpsilon); });
        var resultTexture = this.textureManager.acquireTexture(resultTexShape);
        batchnorm_gpu.batchNormalization(this.gpgpu, program, x.getTexture(), xTexShape, mean.getTexture(), meanTexShape, variance.getTexture(), varianceTexShape, offset != null ? offset.getTexture() : null, offset != null ? offsetTexShape : null, scale != null ? scale.getTexture() : null, scale != null ? scaleTexShape : null, resultTexture, resultTexShape);
        if (cleanupMean) {
            mean.dispose();
        }
        if (cleanupVariance) {
            variance.dispose();
        }
        if (cleanupScale) {
            scale.dispose();
        }
        if (cleanupOffset) {
            offset.dispose();
        }
        return ndarray_1.NDArray.make(x.shape, { texture: resultTexture, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.switchDimInternal = function (a, newDim) {
        throw new Error('Not yet implemented!');
    };
    NDArrayMathGPU.prototype.sumInternal = function (a) {
        var program = new reducesum_gpu_1.ReduceSumProgram(a.size);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMinInternal = function (a) {
        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'min');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMaxInternal = function (a) {
        var program = new argminmax_gpu_1.ArgMinMaxProgram(a.size, 'max');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.argMaxEqualsInternal = function (x1, x2) {
        var program = new argmaxequals_gpu_1.ArgMaxEqualsProgram(x1.size, x2.size);
        return this.compileAndRun(program, [x1, x2]);
    };
    NDArrayMathGPU.prototype.topKInternal = function (ndarray, k) {
        throw new Error('topK GPU not yet implemented!');
    };
    NDArrayMathGPU.prototype.minInternal = function (a) {
        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'min');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.maxInternal = function (a) {
        var program = new minmax_gpu_1.MinMaxProgram(a.size, 'max');
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.divideInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('/', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.addInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('+', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.subInternal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram('-', a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    NDArrayMathGPU.prototype.logSumExpInternal = function (a) {
        var program = new logsumexp_gpu_1.LogSumExpProgram(a.size);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.expInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.EXP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.logInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.LOG);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.reluInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.RELU);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sigmoidInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.SIGMOID);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.tanhInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.TANH);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.sinInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.SIN);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.stepInternal = function (a) {
        var program = new unaryop_gpu_1.UnaryOpProgram(a.shape, unaryop_gpu_1.UnaryOp.STEP);
        return this.compileAndRun(program, [a]);
    };
    NDArrayMathGPU.prototype.conv2dInternal = function (x, weights, biases, stride, zeroPad) {
        var fieldSize = weights.shape[0];
        var inputDepth = weights.shape[2];
        var outputDepth = weights.shape[3];
        var progKey = [
            CONV2D_PROG, x.shape, outputDepth, fieldSize, stride, biases != null
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_gpu.getFragmentShaderSource(x.shape, outputDepth, fieldSize, stride, zeroPad, biases != null);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fieldSize);
        var biasTexShape = conv_util.computeBiasesTexShape(outputDepth);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupB = false;
        if (biases != null) {
            var actualBTexShape = biases.getTextureShapeRC(biasTexShape);
            if (!util.arraysEqual(actualBTexShape, biasTexShape)) {
                biases = this.reshapeTexture(biases, biasTexShape);
                cleanupB = true;
            }
        }
        var resultShape = conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_gpu.convolve(this.gpgpu, program, x.getTexture(), weights.getTexture(), biases != null ? biases.getTexture() : null, resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupB && biases != null) {
            biases.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dBackPropInternal = function (x, dy, weights, stride, pad) {
        var fSize = weights.shape[0];
        var inputDepth = weights.shape[2];
        var outputDepth = weights.shape[3];
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
        var yTexShape = conv_util.computeTexShapeFrom3D(dy.shape);
        var cleanupX = false;
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupY = false;
        var actualYTexShape = dy.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dy = this.reshapeTexture(dy, yTexShape);
            cleanupY = true;
        }
        var dw = this.conv2dDerWeights(x, dy, fSize, stride, pad);
        var db = this.conv2dDerBias(dy);
        var dx = this.conv2dTransposeInternal(dy, weights, null, stride, pad);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupY) {
            dy.dispose();
        }
        return { dx: dx, db: db, dw: dw };
    };
    NDArrayMathGPU.prototype.conv2dTransposeInternal = function (x, weights, biases, origStride, origPad) {
        var origInputDepth = weights.shape[2];
        var origOutputDepth = weights.shape[3];
        var fieldSize = weights.shape[0];
        var progKey = [
            CONV2D_TRANSPOSE_PROG, x.shape, fieldSize, origInputDepth, origStride,
            origPad, biases != null
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderConvTransposeSource(x.shape, fieldSize, origInputDepth, origStride, origPad, biases != null);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var wTexShape = conv_util.computeWeightsTexShape(origInputDepth, origOutputDepth, fieldSize);
        var biasTexShape = conv_util.computeBiasesTexShape(origInputDepth);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupW = false;
        var actualWTexShape = weights.getTextureShapeRC(wTexShape);
        if (!util.arraysEqual(actualWTexShape, wTexShape)) {
            weights = this.reshapeTexture(weights, wTexShape);
            cleanupW = true;
        }
        var cleanupB = false;
        if (biases != null) {
            var actualBiasTexShape = biases.getTextureShapeRC(biasTexShape);
            if (!util.arraysEqual(actualBiasTexShape, biasTexShape)) {
                biases = this.reshapeTexture(biases, biasTexShape);
                cleanupB = true;
            }
        }
        var dilatedRC = conv_util.computeDilatedRC([x.shape[0], x.shape[1]], origStride);
        var pad = fieldSize - 1 - origPad;
        var resultShape = conv_util.computeOutputShape3D([dilatedRC[0], dilatedRC[1], origOutputDepth], fieldSize, origInputDepth, 1, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.convTranspose(this.gpgpu, program, x.getTexture(), weights.getTexture(), biases != null ? biases.getTexture() : null, resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupW) {
            weights.dispose();
        }
        if (cleanupB) {
            biases.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dDerWeights = function (x, dY, fSize, stride, zeroPad) {
        var inputDepth = x.shape[2];
        var outputDepth = dY.shape[2];
        var progKey = [
            CONV2D_DERW_PROG, x.shape, fSize, outputDepth, stride, zeroPad
        ].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderDerWeightsSource(x.shape, fSize, outputDepth, stride, zeroPad);
        });
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var yShape = conv_util.computeOutputShape3D(x.shape, fSize, outputDepth, stride, zeroPad);
        var yTexShape = conv_util.computeTexShapeFrom3D(yShape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var cleanupY = false;
        var actualYTexShape = dY.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dY = this.reshapeTexture(dY, yTexShape);
            cleanupY = true;
        }
        var resultTexShape = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.derWeights(this.gpgpu, program, x.getTexture(), dY.getTexture(), resultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        if (cleanupY) {
            dY.dispose();
        }
        var weightsShape = conv_util.computeWeightsShape4D(inputDepth, outputDepth, fSize);
        return ndarray_1.NDArray.make(weightsShape, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.conv2dDerBias = function (dY) {
        var outputDepth = dY.shape[2];
        var progKey = [CONV2D_DERB_PROG, dY.shape].join('_');
        var program = this.getAndSaveProgram(progKey, function () {
            return conv_backprop_gpu.getFragmentShaderDerBiasSource(dY.shape);
        });
        var yTexShape = conv_util.computeTexShapeFrom3D(dY.shape);
        var cleanupY = false;
        var actualYTexShape = dY.getTextureShapeRC(yTexShape);
        if (!util.arraysEqual(actualYTexShape, yTexShape)) {
            dY = this.reshapeTexture(dY, yTexShape);
            cleanupY = true;
        }
        var resultTexShape = conv_util.computeBiasesTexShape(outputDepth);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        conv_backprop_gpu.derBias(this.gpgpu, program, dY.getTexture(), resultTex, resultTexShape);
        if (cleanupY) {
            dY.dispose();
        }
        return ndarray_1.NDArray.make([outputDepth], { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.pool = function (program, x, fSize, stride, pad) {
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        var resultShape = conv_util.computeOutputShape3D(x.shape, fSize, x.shape[2], stride, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShape);
        var poolResultTex = this.textureManager.acquireTexture(resultTexShape);
        pool_gpu.poolCommon(this.gpgpu, program, x.getTexture(), poolResultTex, resultTexShape);
        if (cleanupX) {
            x.dispose();
        }
        return ndarray_1.NDArray.make(resultShape, { texture: poolResultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.maxPoolInternal = function (x, fSize, stride, pad) {
        var maxPoolProgKey = [MAX_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var maxPoolProgram = this.getAndSaveProgram(maxPoolProgKey, function () {
            return max_pool_gpu.getFragmentShaderMaxPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(maxPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.minPoolInternal = function (x, fSize, stride, pad) {
        var minPoolProgKey = [MIN_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var minPoolProgram = this.getAndSaveProgram(minPoolProgKey, function () {
            return min_pool_gpu.getFragmentShaderMinPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(minPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.avgPoolInternal = function (x, fSize, stride, pad) {
        var avgPoolProgKey = [AVG_POOL_PROG, x.shape, fSize, stride, pad].join('_');
        var avgPoolProgram = this.getAndSaveProgram(avgPoolProgKey, function () {
            return avg_pool_gpu.getFragmentShaderAvgPoolSource(x.shape, fSize, stride, pad);
        });
        return this.pool(avgPoolProgram, x, fSize, stride, pad);
    };
    NDArrayMathGPU.prototype.maxPoolBackpropInternal = function (dy, x, fSize, origStride, origPad) {
        var maxPoolPositionsProgKey = [
            MAX_POOL_POSITIONS_PROG, x.shape, fSize, origStride, origPad
        ].join('_');
        var maxPoolPositionsProgram = this.getAndSaveProgram(maxPoolPositionsProgKey, function () {
            return max_pool_gpu.getFragmentShaderMaxPoolPositionsSource(x.shape, fSize, origStride, origPad);
        });
        var maxPoolResultShape = conv_util.computeOutputShape3D(x.shape, fSize, x.shape[2], origStride, origPad);
        var maxPoolResultTexShape = conv_util.computeTexShapeFrom3D(maxPoolResultShape);
        var maxPoolPositionsResultTex = this.textureManager.acquireTexture(maxPoolResultTexShape);
        var xTexShape = conv_util.computeTexShapeFrom3D(x.shape);
        var actualXTexShape = x.getTextureShapeRC(xTexShape);
        var cleanupX = false;
        if (!util.arraysEqual(actualXTexShape, xTexShape)) {
            x = this.reshapeTexture(x, xTexShape);
            cleanupX = true;
        }
        max_pool_gpu.maxPoolCommon(this.gpgpu, maxPoolPositionsProgram, x.getTexture(), maxPoolPositionsResultTex, maxPoolResultTexShape);
        var maxPoolBackpropProgKey = [
            MAX_POOL_BACKPROP_PROG, dy.shape, fSize, origStride, origPad
        ].join('_');
        var program = this.getAndSaveProgram(maxPoolBackpropProgKey, function () {
            return max_pool_backprop_gpu.getFragmentShaderMaxPoolBackprop(dy.shape, fSize, origStride, origPad);
        });
        var dyTexShape = conv_util.computeTexShapeFrom3D(dy.shape);
        var actualDyTexShape = dy.getTextureShapeRC(dyTexShape);
        var cleanupDy = false;
        if (!util.arraysEqual(actualDyTexShape, dyTexShape)) {
            dy = this.reshapeTexture(dy, dyTexShape);
            cleanupDy = true;
        }
        var dilatedDyRC = conv_util.computeDilatedRC([dy.shape[0], dy.shape[1]], origStride);
        var pad = fSize - 1 - origPad;
        var resultShapeRCD = conv_util.computeOutputShape3D([dilatedDyRC[0], dilatedDyRC[1], dy.shape[2]], fSize, dy.shape[2], 1, pad);
        var resultTexShape = conv_util.computeTexShapeFrom3D(resultShapeRCD);
        var resultTex = this.textureManager.acquireTexture(resultTexShape);
        max_pool_backprop_gpu.maxPoolBackprop(this.gpgpu, program, dy.getTexture(), maxPoolPositionsResultTex, resultTex, resultTexShape);
        if (cleanupDy) {
            dy.dispose();
        }
        if (cleanupX) {
            x.dispose();
        }
        this.textureManager.releaseTexture(maxPoolPositionsResultTex, maxPoolResultTexShape);
        return ndarray_1.NDArray.make(resultShapeRCD, { texture: resultTex, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.resizeBilinear3DInternal = function (x, newShape2D, alignCorners) {
        var programKey = [RESIZE_BILINEAR_PROG, x.shape, newShape2D, alignCorners].join('_');
        var newShapeRCD = [newShape2D[0], newShape2D[1], x.shape[2]];
        var resultTexShape = conv_util.computeTexShapeFrom3D(newShapeRCD);
        var program = this.getAndSaveProgram(programKey, function () { return resize_bilinear_gpu.getFragmentShaderSource(x.shape, newShape2D, alignCorners); });
        var resultTexture = this.textureManager.acquireTexture(resultTexShape);
        resize_bilinear_gpu.resizeBilinear(this.gpgpu, program, x.getTexture(), resultTexture, resultTexShape);
        return ndarray_1.NDArray.make(newShapeRCD, { texture: resultTexture, textureShapeRC: resultTexShape });
    };
    NDArrayMathGPU.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    NDArrayMathGPU.prototype.getAndSaveProgram = function (programKey, getShaderSource) {
        if (!(programKey in this.programCache)) {
            this.programCache[programKey] =
                this.gpgpu.createProgram(getShaderSource());
        }
        return this.programCache[programKey];
    };
    NDArrayMathGPU.prototype.doGPUShapesMatch = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape);
        if (a.inGPU()) {
            b.getTextureShapeRC(a.getTextureShapeRC());
        }
        else if (b.inGPU()) {
            a.getTextureShapeRC(b.getTextureShapeRC());
        }
        return util.arraysEqual(a.getTextureShapeRC(), b.getTextureShapeRC());
    };
    NDArrayMathGPU.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    NDArrayMathGPU.prototype.dispose = function () {
        for (var programKey in this.programCache) {
            if (this.programCache.hasOwnProperty(programKey)) {
                this.gpgpu.deleteProgram(this.programCache[programKey]);
            }
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
    };
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;

},{"../util":79,"./concat3d_util":15,"./conv_util":16,"./math":19,"./ndarray":22,"./webgl/addscaledmat_gpu":23,"./webgl/argmaxequals_gpu":24,"./webgl/argminmax_gpu":25,"./webgl/avg_pool_gpu":26,"./webgl/batchnorm_gpu":27,"./webgl/binaryop_gpu":28,"./webgl/concat3d_gpu":29,"./webgl/conv_backprop_gpu":30,"./webgl/conv_gpu":31,"./webgl/copy_gpu":32,"./webgl/gpgpu_context":33,"./webgl/gpgpu_math":34,"./webgl/gpgpu_util":35,"./webgl/logsumexp_gpu":36,"./webgl/max_pool_backprop_gpu":37,"./webgl/max_pool_gpu":38,"./webgl/min_pool_gpu":39,"./webgl/minmax_gpu":40,"./webgl/mulmat_gpu":41,"./webgl/pool_gpu":42,"./webgl/reducesum_gpu":43,"./webgl/reshape_gpu":45,"./webgl/resize_bilinear_gpu":46,"./webgl/texture_manager":49,"./webgl/unaryop_gpu":50,"./webgl/webgl_util":51}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var webgl_util = require("./webgl/webgl_util");
exports.GPGPU = null;
exports.TEXTURE_MANAGER = null;
function initializeGPU(gpgpu, textureManager) {
    exports.GPGPU = gpgpu;
    exports.TEXTURE_MANAGER = textureManager;
}
exports.initializeGPU = initializeGPU;
function throwIfGPUNotInitialized() {
    if (exports.GPGPU == null || exports.TEXTURE_MANAGER == null) {
        throw new Error('GPU not intialized.');
    }
}
var NDArray = (function () {
    function NDArray(shape, data) {
        util.assert(data.values != null || data.texture != null, 'Either `values` or `texture` must be defined');
        util.assert(data.texture == null || (data.textureShapeRC != null), '`textureShape` must be defined when `texture` is defined');
        this.size = util.sizeFromShape(shape);
        if (data.values != null) {
            util.assert(this.size === data.values.length, 'Constructing ndarray of shape (' + this.size + ') should match the' +
                ' length of values (' + data.values.length + ')');
        }
        this.shape = shape;
        this.data = data;
        var dim = this.shape.length;
        if (dim < 2) {
            this.strides = [];
        }
        else {
            this.strides = new Array(dim - 1);
            this.strides[dim - 2] = this.shape[dim - 1];
            for (var i = dim - 3; i >= 0; --i) {
                this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
            }
        }
    }
    NDArray.zeros = function (shape) {
        var values = new Float32Array(util.sizeFromShape(shape));
        return NDArray.make(shape, { values: values });
    };
    NDArray.zerosLike = function (another) {
        return NDArray.zeros(another.shape);
    };
    NDArray.like = function (another) {
        var values = another.getValues();
        return NDArray.make(another.shape, { values: new Float32Array(values) });
    };
    NDArray.make = function (shape, data) {
        switch (shape.length) {
            case 0:
                return new Scalar(data);
            case 1:
                return new Array1D(data);
            case 2:
                return new Array2D(shape, data);
            case 3:
                return new Array3D(shape, data);
            case 4:
                return new Array4D(shape, data);
            default:
                return new NDArray(shape, data);
        }
    };
    NDArray.prototype.reshape = function (newShape) {
        if (util.arraysEqual(this.shape, newShape)) {
            return this;
        }
        util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
        return NDArray.make(newShape, this.data);
    };
    NDArray.prototype.asScalar = function () {
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    NDArray.prototype.as1D = function () {
        return this.reshape([this.size]);
    };
    NDArray.prototype.as2D = function (rows, columns) {
        return this.reshape([rows, columns]);
    };
    NDArray.prototype.as3D = function (rows, columns, depth) {
        return this.reshape([rows, columns, depth]);
    };
    NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
        return this.reshape([rows, columns, depth, depth2]);
    };
    Object.defineProperty(NDArray.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    NDArray.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.getValues()[index];
    };
    NDArray.prototype.add = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
    };
    NDArray.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        this.getValues()[index] = value;
    };
    NDArray.prototype.locToIndex = function (locs) {
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    NDArray.prototype.indexToLoc = function (index) {
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    NDArray.prototype.fill = function (value) {
        this.getValues().fill(value);
    };
    NDArray.prototype.getData = function () {
        return this.data;
    };
    NDArray.prototype.getValues = function () {
        if (this.data.values == null) {
            throwIfGPUNotInitialized();
            this.data.values = exports.GPGPU.downloadMatrixFromTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1]);
            this.disposeTexture();
        }
        return this.data.values;
    };
    NDArray.prototype.uploadToGPU = function (preferredTexShape) {
        throwIfGPUNotInitialized();
        this.data.textureShapeRC = webgl_util.getTextureShapeFromLogicalShape(exports.GPGPU.gl, this.shape, preferredTexShape);
        this.data.texture =
            exports.TEXTURE_MANAGER.acquireTexture(this.data.textureShapeRC);
        exports.GPGPU.uploadMatrixToTexture(this.data.texture, this.data.textureShapeRC[0], this.data.textureShapeRC[1], this.data.values);
        this.data.values = null;
    };
    NDArray.prototype.getTexture = function (preferredShapeRC) {
        if (this.data.texture == null) {
            this.uploadToGPU(preferredShapeRC);
        }
        return this.data.texture;
    };
    NDArray.prototype.getTextureShapeRC = function (preferredShapeRC) {
        if (this.data.textureShapeRC == null) {
            this.uploadToGPU(preferredShapeRC);
        }
        return this.data.textureShapeRC;
    };
    NDArray.prototype.dispose = function () {
        this.data.values = null;
        this.shape = null;
        if (this.data.texture != null) {
            this.disposeTexture();
        }
    };
    NDArray.prototype.disposeTexture = function () {
        throwIfGPUNotInitialized();
        exports.TEXTURE_MANAGER.releaseTexture(this.data.texture, this.data.textureShapeRC);
        this.data.texture = null;
        this.data.textureShapeRC = null;
    };
    NDArray.prototype.inGPU = function () {
        return this.data.texture != null;
    };
    NDArray.prototype.equals = function (t) {
        return util.arraysEqual(this.shape, t.shape) &&
            util.arraysEqual(this.getValues(), t.getValues());
    };
    NDArray.rand = function (shape, randFunction) {
        var size = util.sizeFromShape(shape);
        var values = new Float32Array(size);
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return NDArray.make(shape, { values: values });
    };
    NDArray.randNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev); });
    };
    NDArray.randTruncatedNormal = function (shape, mean, stdDev) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return NDArray.rand(shape, function () { return util.randGauss(mean, stdDev, true); });
    };
    NDArray.randUniform = function (shape, a, b) {
        return NDArray.rand(shape, function () { return util.randUniform(a, b); });
    };
    return NDArray;
}());
exports.NDArray = NDArray;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar(data) {
        var _this = this;
        if (data.texture != null) {
            data.textureShapeRC = [1, 1];
        }
        _this = _super.call(this, [], data) || this;
        return _this;
    }
    Scalar.new = function (value) {
        return new Scalar({ values: new Float32Array([value]) });
    };
    Scalar.prototype.get = function () {
        return this.getValues()[0];
    };
    Scalar.prototype.set = function (value) {
        this.getValues()[0] = value;
    };
    Scalar.prototype.add = function (value) {
        this.getValues()[0] += value;
    };
    Scalar.ZERO = Scalar.new(0);
    Scalar.ONE = Scalar.new(1);
    Scalar.TWO = Scalar.new(2);
    Scalar.NEG_ONE = Scalar.new(-1);
    return Scalar;
}(NDArray));
exports.Scalar = Scalar;
var Array1D = (function (_super) {
    __extends(Array1D, _super);
    function Array1D(data) {
        var _this = this;
        var shape = (data.values != null) ?
            [data.values.length] :
            [util.sizeFromShape(data.textureShapeRC)];
        _this = _super.call(this, shape, data) || this;
        return _this;
    }
    Array1D.new = function (values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                "not 1 dimensional.");
        }
        return new Array1D({ values: toTypedArray(values) });
    };
    Array1D.prototype.get = function (i) {
        return this.getValues()[i];
    };
    Array1D.prototype.set = function (value, i) {
        this.getValues()[i] = value;
    };
    Array1D.prototype.add = function (value, i) {
        this.getValues()[i] += value;
    };
    Array1D.prototype.locToIndex = function (loc) {
        return loc[0];
    };
    Array1D.prototype.indexToLoc = function (index) {
        return [index];
    };
    Array1D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array1D;
}(NDArray));
exports.Array1D = Array1D;
var Array2D = (function (_super) {
    __extends(Array2D, _super);
    function Array2D(shape, data) {
        var _this = this;
        util.assert(shape.length === 2, 'Shape should be of length 2');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        return _this;
    }
    Array2D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array2D(shape, { values: toTypedArray(values) });
    };
    Array2D.prototype.get = function (i, j) {
        return this.getValues()[this.stride0 * i + j];
    };
    Array2D.prototype.set = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] = value;
    };
    Array2D.prototype.add = function (value, i, j) {
        this.getValues()[this.stride0 * i + j] += value;
    };
    Array2D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + locs[1];
    };
    Array2D.prototype.indexToLoc = function (index) {
        return [Math.floor(index / this.stride0), index % this.stride0];
    };
    Array2D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array2D;
}(NDArray));
exports.Array2D = Array2D;
var Array3D = (function (_super) {
    __extends(Array3D, _super);
    function Array3D(shape, data) {
        var _this = this;
        util.assert(shape.length === 3, 'Shape should be of length 3');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        return _this;
    }
    Array3D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array3D(shape, { values: toTypedArray(values) });
    };
    Array3D.prototype.get = function (i, j, k) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + k];
    };
    Array3D.prototype.set = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] = value;
    };
    Array3D.prototype.add = function (value, i, j, k) {
        this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
    };
    Array3D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
    };
    Array3D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        return [i, Math.floor(index / this.stride1), index % this.stride1];
    };
    Array3D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array3D;
}(NDArray));
exports.Array3D = Array3D;
var Array4D = (function (_super) {
    __extends(Array4D, _super);
    function Array4D(shape, data) {
        var _this = this;
        util.assert(shape.length === 4, 'Shape should be of length 4');
        _this = _super.call(this, shape, data) || this;
        _this.stride0 = _this.strides[0];
        _this.stride1 = _this.strides[1];
        _this.stride2 = _this.strides[2];
        return _this;
    }
    Array4D.new = function (shape, values) {
        if (!(values instanceof Float32Array)) {
            var inferredShape = util.inferShape(values);
            if (inferredShape.length > 1) {
                util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                    (inferredShape + " does not match the provided shape ") +
                    (shape + ". "));
            }
        }
        return new Array4D(shape, { values: toTypedArray(values) });
    };
    Array4D.prototype.get = function (i, j, k, l) {
        return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
    };
    Array4D.prototype.set = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] = value;
    };
    Array4D.prototype.add = function (value, i, j, k, l) {
        this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
    };
    Array4D.prototype.locToIndex = function (locs) {
        return this.stride0 * locs[0] + this.stride1 * locs[1] +
            this.stride2 * locs[2] + locs[3];
    };
    Array4D.prototype.indexToLoc = function (index) {
        var i = Math.floor(index / this.stride0);
        index -= i * this.stride0;
        var j = Math.floor(index / this.stride1);
        index -= j * this.stride1;
        return [i, j, Math.floor(index / this.stride2), index % this.stride2];
    };
    Array4D.zeros = function (shape) {
        return NDArray.zeros(shape);
    };
    return Array4D;
}(NDArray));
exports.Array4D = Array4D;
function toTypedArray(a) {
    return (a instanceof Float32Array) ? a : new Float32Array(util.flatten(a));
}

},{"../util":79,"./webgl/webgl_util":51}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_context_1 = require("./gpgpu_context");
function getFragmentShaderSource() {
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    uniform sampler2D matrixB;\n    uniform sampler2D matrixAScalar;\n    uniform sampler2D matrixBScalar;\n    varying vec2 resultUV;\n\n    const vec2 halfTexel = vec2(0.5, 0.5);\n\n    void main() {\n      float a = texture2D(matrixA, resultUV).r;\n      float b = texture2D(matrixB, resultUV).r;\n      float aScalar = texture2D(matrixAScalar, halfTexel).r;\n      float bScalar = texture2D(matrixBScalar, halfTexel).r;\n      vec2 abScaled = vec2(a, b) * vec2(aScalar, bScalar);\n      gl_FragColor = vec4(abScaled.x + abScaled.y, 0, 0, 0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function addScaledMatrices(gpgpu, addScaledMatricesProgram, a, b, rows, columns, aScalar, bScalar, result) {
    gpgpu.setOutputMatrixTexture(result, rows, columns);
    gpgpu.setProgram(addScaledMatricesProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    gpgpu.setInputMatrixTexture(b, 'matrixB', 1);
    gpgpu.setInputMatrixTexture(aScalar, 'matrixAScalar', 2);
    gpgpu.setInputMatrixTexture(bScalar, 'matrixBScalar', 3);
    gpgpu.executeProgram();
}
exports.addScaledMatrices = addScaledMatrices;
function uploadAddScaledMatricesDownload(a, b, rows, columns, aScalar, bScalar) {
    var gpgpu = new gpgpu_context_1.GPGPUContext();
    var program = gpgpu.createProgram(getFragmentShaderSource());
    var aTex = gpgpu.createMatrixTexture(rows, columns);
    var bTex = gpgpu.createMatrixTexture(rows, columns);
    var aScalarTex = gpgpu.createMatrixTexture(1, 1);
    var bScalarTex = gpgpu.createMatrixTexture(1, 1);
    var resultTex = gpgpu.createMatrixTexture(rows, columns);
    gpgpu.uploadMatrixToTexture(aTex, rows, columns, a);
    gpgpu.uploadMatrixToTexture(bTex, rows, columns, b);
    gpgpu.uploadMatrixToTexture(aScalarTex, 1, 1, new Float32Array([aScalar]));
    gpgpu.uploadMatrixToTexture(bScalarTex, 1, 1, new Float32Array([bScalar]));
    addScaledMatrices(gpgpu, program, aTex, bTex, rows, columns, aScalarTex, bScalarTex, resultTex);
    var result = gpgpu.downloadMatrixFromTexture(resultTex, rows, columns);
    gpgpu.deleteMatrixTexture(aTex);
    gpgpu.deleteMatrixTexture(bTex);
    gpgpu.deleteMatrixTexture(resultTex);
    gpgpu.deleteMatrixTexture(aScalarTex);
    gpgpu.deleteMatrixTexture(bScalarTex);
    gpgpu.deleteProgram(program);
    gpgpu.dispose();
    return result;
}
exports.uploadAddScaledMatricesDownload = uploadAddScaledMatricesDownload;

},{"./gpgpu_context":33}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var argminmax_gpu = require("./argminmax_gpu");
var ArgMaxEqualsProgram = (function () {
    function ArgMaxEqualsProgram(aSize, bSize) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.params = [];
        var aSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'A', aSize);
        var bSnippet = argminmax_gpu.getArgMinMaxSnippet('max', 'B', bSize);
        this.userCode = "\n      " + aSnippet + "\n      " + bSnippet + "\n\n      void main() {\n        float argMaxA = getArgMinMaxA();\n        float argMaxB = getArgMinMaxB();\n\n        float value;\n        if (isNaN(argMaxA)) {\n          value = argMaxA;\n        } else if (isNaN(argMaxB)) {\n          value = argMaxB;\n        } else {\n          value = float(argMaxA == argMaxB);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ArgMaxEqualsProgram;
}());
exports.ArgMaxEqualsProgram = ArgMaxEqualsProgram;

},{"./argminmax_gpu":25}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getArgMinMaxSnippet(op, texName, size) {
    var compOp = (op === 'min') ? '<' : '>';
    return "\n    float getArgMinMax" + texName + "() {\n      float bestIndex = 0.0;\n      float bestValue = get" + texName + "Flat(0.0);\n\n      for (int i = 0; i < " + size + "; i++) {\n        float i_float = float(i);\n        float candidate = get" + texName + "Flat(i_float);\n        if (isNaN(candidate)) {\n          return candidate;\n        }\n        if (candidate " + compOp + " bestValue) {\n          bestValue = candidate;\n          bestIndex = i_float;\n        }\n      }\n      return bestIndex;\n    }\n  ";
}
exports.getArgMinMaxSnippet = getArgMinMaxSnippet;
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(aSize, opType) {
        this.variableNames = ['A'];
        this.outputShape = [];
        this.params = [opType];
        var aSnippet = getArgMinMaxSnippet(opType, 'A', aSize);
        this.userCode = "\n      " + aSnippet + "\n\n      void main() {\n        setOutput(getArgMinMaxA());\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderAvgPoolSource(xShapeRCD, fSize, stride, pad) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'avg', false);
}
exports.getFragmentShaderAvgPoolSource = getFragmentShaderAvgPoolSource;
function avgPool(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.avgPool = avgPool;

},{"./pool_gpu":42}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getFragmentShaderSource(xTexShapeRC, meanTexShapeRC, varianceTexShapeRC, offsetTexShapeRC, scaleTexShapeRC, varianceEpsilon) {
    if (varianceEpsilon === void 0) { varianceEpsilon = 0.001; }
    var offsetSamplerSnippet = '';
    var offsetShapeInitializationSnippet = '';
    var offsetCoordsSnippet = '';
    var offsetUVSnippet = '';
    var offsetValueSnippet = '';
    var offsetOperationSnippet = '0.0';
    var scaleSamplerSnippet = '';
    var scaleShapeInitializationSnippet = '';
    var scaleCoordsSnippet = '';
    var scaleUVSnippet = '';
    var scaleValueSnippet = '';
    var scaleOperationSnippet = '';
    if (offsetTexShapeRC != null) {
        offsetSamplerSnippet = 'uniform sampler2D offset;';
        offsetShapeInitializationSnippet = "const vec2 offsetShapeCR = vec2(\n            " + offsetTexShapeRC[1] + ", " + offsetTexShapeRC[0] + ");";
        offsetCoordsSnippet = 'vec2 offsetCoordsCR = mod(yTexCR, offsetShapeCR);';
        offsetUVSnippet =
            'vec2 offsetUV = (offsetCoordsCR + halfCR) / offsetShapeCR;';
        offsetValueSnippet = 'float offsetValue = texture2D(offset, offsetUV).r;';
        offsetOperationSnippet = 'offsetValue';
    }
    if (scaleTexShapeRC != null) {
        scaleSamplerSnippet = 'uniform sampler2D scale;';
        scaleShapeInitializationSnippet = "const vec2 scaleShapeCR = vec2(\n            " + scaleTexShapeRC[1] + ", " + scaleTexShapeRC[0] + ");";
        scaleCoordsSnippet = 'vec2 scaleCoordsCR = mod(yTexCR, scaleShapeCR);';
        scaleUVSnippet = 'vec2 scaleUV = (scaleCoordsCR + halfCR) / scaleShapeCR;';
        scaleValueSnippet = 'float scaleValue = texture2D(scale, scaleUV).r;';
        scaleOperationSnippet = 'inv *= scaleValue;';
    }
    return "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D mean;\n    uniform sampler2D variance;\n    " + offsetSamplerSnippet + "\n    " + scaleSamplerSnippet + "\n\n    varying vec2 resultUV;\n\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 meanShapeCR = vec2(" + meanTexShapeRC[1] + ", " + meanTexShapeRC[0] + ");\n    const vec2 varianceShapeCR = vec2(\n        " + varianceTexShapeRC[1] + ", " + varianceTexShapeRC[0] + ");\n\n    " + offsetShapeInitializationSnippet + "\n    " + scaleShapeInitializationSnippet + "\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const float varianceEpsilon = " + varianceEpsilon + ";\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      vec2 meanCoordsCR = mod(yTexCR, meanShapeCR);\n      vec2 varianceCoordsCR = mod(yTexCR, varianceShapeCR);\n      " + offsetCoordsSnippet + "\n      " + scaleCoordsSnippet + "\n\n      vec2 meanUV = (meanCoordsCR + halfCR) / meanShapeCR;\n      vec2 varianceUV = (varianceCoordsCR + halfCR) / varianceShapeCR;\n      " + offsetUVSnippet + "\n      " + scaleUVSnippet + "\n\n      float xValue = texture2D(x, resultUV).r;\n      float meanValue = texture2D(mean, meanUV).r;\n      float varianceValue = texture2D(variance, varianceUV).r;\n      " + offsetValueSnippet + "\n      " + scaleValueSnippet + "\n\n      float inv = 1.0 / sqrt(varianceValue + varianceEpsilon);\n      " + scaleOperationSnippet + "\n      float xTimesInv = xValue * inv;\n      float meanTimesInvWithOffset = " + offsetOperationSnippet + "\n          - meanValue * inv;\n\n      gl_FragColor = vec4(xTimesInv + meanTimesInvWithOffset, 0, 0, 0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function batchNormalization(gpgpu, program, x, xShapeRowCol, mean, meanShapeRowCol, variance, varianceShapeRowCol, offset, offsetShapeRowCol, scale, scaleShapeRowCol, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x, 'x', 0);
    gpgpu.setInputMatrixTexture(mean, 'mean', 1);
    gpgpu.setInputMatrixTexture(variance, 'variance', 2);
    var nextIndex = 3;
    if (offset != null) {
        gpgpu.setInputMatrixTexture(offset, 'offset', nextIndex);
        nextIndex++;
    }
    if (scale != null) {
        gpgpu.setInputMatrixTexture(scale, 'scale', nextIndex);
    }
    gpgpu.executeProgram();
}
exports.batchNormalization = batchNormalization;

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.params = [op];
        this.outputShape = util.assertAndGetBroadcastedShape(aShape, bShape);
        this.userCode = "\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(a " + op + " b);\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../util":79}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderSource(x1ShapeRCD, x2ShapeRCD, resultShapeRCD, axis) {
    var x1TexShapeRC = conv_util.computeTexShapeFrom3D(x1ShapeRCD);
    var x2TexShapeRC = conv_util.computeTexShapeFrom3D(x2ShapeRCD);
    var yAxes = ['yR', 'yC', 'yD'];
    var concatAxis = yAxes[axis];
    return "\n    precision highp float;\n    uniform sampler2D x1;\n    uniform sampler2D x2;\n\n    const vec2 x1ShapeCR = vec2(" + x1TexShapeRC[1] + ", " + x1TexShapeRC[0] + ");\n    const vec2 x2ShapeCR = vec2(" + x2TexShapeRC[1] + ".0, " + x2TexShapeRC[0] + ".0);\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, yD).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + resultShapeRCD[2] + ".0);\n      float yD = mod(yTexCR.x, " + resultShapeRCD[2] + ".0);\n\n      float value = 0.0;\n\n      if (" + concatAxis + " < " + x1ShapeRCD[axis] + ".0) {\n        // Map yR, yC, yD back to x1 coordinates.\n        vec2 x1CR = vec2(yC * " + x1ShapeRCD[2] + ".0 + yD, yR);\n        vec2 x1UV = (x1CR + halfCR) / x1ShapeCR;\n        value = texture2D(x1, x1UV).r;\n      } else {\n        " + concatAxis + " = " + concatAxis + " - " + x1ShapeRCD[axis] + ".0;\n\n        // Map yR, yC, yD back to x2 coordinates.\n        vec2 x2CR = vec2(yC * " + x2ShapeRCD[2] + ".0 + yD, yR);\n        vec2 x2UV = (x2CR + halfCR) / x2ShapeCR;\n        value = texture2D(x2, x2UV).r;\n      }\n\n      gl_FragColor = vec4(value, 0.0, 0.0, 0.0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function concat3D(gpgpu, program, x1, x2, result, resultShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRC[0], resultShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x1, 'x1', 0);
    gpgpu.setInputMatrixTexture(x2, 'x2', 1);
    gpgpu.executeProgram();
}
exports.concat3D = concat3D;

},{"../conv_util":16}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
var conv_gpu = require("./conv_gpu");
function getFragmentShaderDerWeightsSource(xShapeRowColDepth, fSize, outputDepth, stride, zeroPad) {
    var getMatrixValueOrZeroPad = conv_gpu.getFragmentShaderGetMatrixValueOrZeroPadSource();
    var inputDepth = xShapeRowColDepth[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRowColDepth);
    var yShape = conv_util.computeOutputShape3D(xShapeRowColDepth, fSize, outputDepth, stride, zeroPad);
    var yNumRows = yShape[0];
    var yNumCols = yShape[1];
    var yTexShapeRC = conv_util.computeTexShapeFrom3D(yShape);
    var fSizeTimesInputDepth = fSize * inputDepth;
    var prologue = "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D dy;\n  ";
    return prologue + '\n' + getMatrixValueOrZeroPad + '\n' +
        ("\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 dyShapeCR = vec2(" + yTexShapeRC[1] + ", " + yTexShapeRC[0] + ");\n\n    void main() {\n      vec2 wTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (wTexR, wTexC) to 4D (wR, wC, d1, d2).\n      float wR = floor(wTexCR.y / " + fSizeTimesInputDepth + ".0);\n      float wTexRLeftover = wTexCR.y - wR * " + fSizeTimesInputDepth + ".0;\n      float wC = floor(wTexRLeftover / " + inputDepth + ".0);\n      float d1 = mod(wTexRLeftover, " + inputDepth + ".0);\n      float d2 = wTexCR.x;\n\n      // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int yR = 0; yR < " + yNumRows + "; yR++) {\n        float yTexR = float(yR);\n        float xR = wR + yTexR * " + stride + ".0 - " + zeroPad + ".0;\n        float xTexR = xR;\n\n        for (int yC = 0; yC < " + yNumCols + "; yC++) {\n          float yC_float = float(yC);\n          float xC = wC + yC_float * " + stride + ".0 - " + zeroPad + ".0;\n\n          // Map from 3D (xR, xC, d1) to 2D (xTexR, xTexC).\n          // Map from 3D (yR, yC, d2) to 2D (yTexR, yTexC).\n          vec2 xyTexC =\n              vec2(xC, yC_float) * vec2(" + inputDepth + ".0, " + outputDepth + ".0) +\n              vec2(d1, d2);\n          float xTexC = xyTexC.x;\n          float yTexC = xyTexC.y;\n\n          // Read dy(yR, yC, d2).\n          vec2 dyUV = (vec2(yTexC, yTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          // Read x(xR, xC, d1) (potentially zero-padded).\n          float xValue =\n            getMatrixValueOrZeroPad(x, xShapeCR, vec2(xTexC, xTexR));\n\n          dotProd += (xValue * dyValue);\n        }\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }");
}
exports.getFragmentShaderDerWeightsSource = getFragmentShaderDerWeightsSource;
function getFragmentShaderConvTransposeSource(xShapeRCD, fSize, origInputDepth, origStride, origPad, hasBias) {
    var pad = fSize - 1 - origPad;
    var xRows = xShapeRCD[0], xCols = xShapeRCD[1], origOutputDepth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var wTexShapeRC = conv_util.computeWeightsTexShape(origInputDepth, origOutputDepth, fSize);
    var getBiasValue = hasBias ?
        conv_gpu.getFragmentShaderGetBiasValueSource(origInputDepth) :
        '';
    var biasPrologue = hasBias ? 'uniform sampler2D biases;' : '';
    var biasOperation = hasBias ? 'dotProd += getBiasValue(biases, d2);' : '';
    var prologue = "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D weights;\n    " + biasPrologue + "\n    ";
    return prologue + '\n' + getBiasValue + '\n' +
        ("\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 wShapeCR = vec2(" + wTexShapeRC[1] + ", " + wTexShapeRC[0] + ");\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + origInputDepth + ".0);\n      float d2 = mod(yTexCR.x, " + origInputDepth + ".0);\n\n      vec2 xRCCorner = vec2(yR, yC) - vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // Convolve x(?, ?, d1) with w(:, :, d2, d1) to get y(yR, yC, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = (xRCorner + wR_float) / " + origStride + ".0;\n        // TODO(smilkov): Splice this with another version where you call\n        // getMatrixValueOrZeroPad(). Here and below.\n        if (xR < 0.0 || xR >= " + xRows + ".0 || fract(xR) > 0.0) {\n          continue;\n        }\n\n        float wRPerm = " + fSize + ".0 - 1.0 - wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = (xCCorner + wC_float) / " + origStride + ".0;\n          if (xC < 0.0 || xC >= " + xCols + ".0 || fract(xC) > 0.0) {\n            continue;\n          }\n\n          float wCPerm = " + fSize + ".0 - 1.0 - wC_float;\n          float wTexR = wRPerm * " + fSize + ".0 * " + origInputDepth + ".0 +\n                        wCPerm * " + origInputDepth + ".0 + d2;\n\n          for (int d1 = 0; d1 < " + origOutputDepth + "; d1++) {\n            float d1_float = float(d1);\n            float xTexC = xC * " + origOutputDepth + ".0 + d1_float;\n            float wTexC = d1_float;\n\n            // Read x(xR, xC, d1).\n            vec2 xUV = (vec2(xTexC, xTexR) + halfCR) / xShapeCR;\n            float xValue = texture2D(x, xUV).r;\n\n            // Read w(wRPerm, wCPerm, d2, d1).\n            vec2 wUV = (vec2(wTexC, wTexR) + halfCR) / wShapeCR;\n            float wValue = texture2D(weights, wUV).r;\n\n            dotProd += xValue * wValue;\n          }\n        }\n      }\n      " + biasOperation + "\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }");
}
exports.getFragmentShaderConvTransposeSource = getFragmentShaderConvTransposeSource;
function getFragmentShaderDerBiasSource(dyShapeRCD) {
    var dyTexShapeRC = conv_util.computeTexShapeFrom3D(dyShapeRCD);
    var yNumRows = dyShapeRCD[0], yNumCols = dyShapeRCD[1], outputDepth = dyShapeRCD[2];
    return "\n    precision highp float;\n    uniform sampler2D dy;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 dyShapeCR = vec2(" + dyTexShapeRC[1] + ", " + dyTexShapeRC[0] + ");\n\n    void main() {\n      vec2 biasTexCR = floor(gl_FragCoord.xy);\n\n      // The bias texture RC shape is [1, d2].\n      float d2 = biasTexCR.x;\n\n      float derBias = 0.0;\n      for (int yR = 0; yR < " + yNumRows + "; yR++) {\n        float yTexR = float(yR);\n\n        for (int yC = 0; yC < " + yNumCols + "; yC++) {\n          float yC_float = float(yC);\n          // Map from 3D (yR, yC, d2) to 2D (yTexR, yTexC).\n          float yTexC = yC_float * " + outputDepth + ".0 + d2;\n\n          // Read dy(yR, yC, d2).\n          vec2 dyUV = (vec2(yTexC, yTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          derBias += dyValue;\n        }\n      }\n      gl_FragColor = vec4(derBias, 0, 0, 0);\n    }";
}
exports.getFragmentShaderDerBiasSource = getFragmentShaderDerBiasSource;
function derBias(gpgpu, program, dyTex, result, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 0);
    gpgpu.executeProgram();
}
exports.derBias = derBias;
function derWeights(gpgpu, program, xTex, dyTex, result, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(result, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(xTex, 'x', 0);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 1);
    gpgpu.executeProgram();
}
exports.derWeights = derWeights;
function convTranspose(gpgpu, program, xTex, weightsTex, biasesTex, resultTex, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(resultTex, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(xTex, 'x', 0);
    gpgpu.setInputMatrixTexture(weightsTex, 'weights', 1);
    if (biasesTex != null) {
        gpgpu.setInputMatrixTexture(biasesTex, 'biases', 2);
    }
    gpgpu.executeProgram();
}
exports.convTranspose = convTranspose;

},{"../conv_util":16,"./conv_gpu":31}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderPrologueSource() {
    return "\n    precision highp float;\n    uniform sampler2D x;\n    uniform sampler2D weights;\n    uniform sampler2D biases;\n    varying vec2 resultUV;";
}
exports.getFragmentShaderPrologueSource = getFragmentShaderPrologueSource;
function getFragmentShaderGetMatrixValueOrZeroPadSource() {
    return "\n    float getMatrixValueOrZeroPad(in sampler2D matrix, vec2 matrixShapeCR,\n        vec2 requestedCR) {\n      vec2 uv = (requestedCR + vec2(0.5, 0.5)) / matrixShapeCR;\n      float value = texture2D(matrix, uv).r;\n      bool lessThanZero = any(lessThan(uv, vec2(0, 0)));\n      bool greaterThanOne = any(greaterThan(uv, vec2(1, 1)));\n      bool outside = lessThanZero || greaterThanOne;\n      return mix(value, 0.0, float(outside));\n    }";
}
exports.getFragmentShaderGetMatrixValueOrZeroPadSource = getFragmentShaderGetMatrixValueOrZeroPadSource;
function getFragmentShaderConvolveSource(xShapeRCD, fSize, outputDepth, stride, pad, hasBias) {
    var inputDepth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var wTexShapeRC = conv_util.computeWeightsTexShape(inputDepth, outputDepth, fSize);
    return "\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n    const vec2 wShapeCR = vec2(" + wTexShapeRC[1] + ", " + wTexShapeRC[0] + ");\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + outputDepth + ".0);\n      float d2 = mod(yTexCR.x, " + outputDepth + ".0);\n      float wTexC = d2;\n\n      vec2 xRCCorner = vec2(yR, yC) * vec2(" + stride + ", " + stride + ") -\n          vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = xRCorner + wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = xCCorner + wC_float;\n\n          for (int d1 = 0; d1 < " + inputDepth + "; d1++) {\n            float d1_float = float(d1);\n            float xTexC = xC * " + inputDepth + ".0 + d1_float;\n            float wTexR = wR_float * " + fSize * inputDepth + ".0 +\n                wC_float * " + inputDepth + ".0 + d1_float;\n\n            float xValue =\n                getMatrixValueOrZeroPad(x, xShapeCR, vec2(xTexC, xTexR));\n\n            // Read w(wR, wC, d1, d2).\n            vec2 wUV = (vec2(wTexC, wTexR) + halfCR) / wShapeCR;\n            float wValue = texture2D(weights, wUV).r;\n\n            dotProd += xValue * wValue;\n          }\n        }\n      }\n      if (" + hasBias + ") {\n        dotProd += getBiasValue(biases, d2);\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }";
}
exports.getFragmentShaderConvolveSource = getFragmentShaderConvolveSource;
function getFragmentShaderGetBiasValueSource(outputDepth) {
    return "\n    float getBiasValue(in sampler2D bias, float biasC) {\n      const vec2 biasShapeCR = vec2(" + outputDepth + ", 1);\n      vec2 biasCR = vec2(mod(biasC, " + outputDepth + ".0), 0);\n      vec2 biasUV = (biasCR + vec2(0.5, 0.5)) / biasShapeCR;\n      return texture2D(bias, biasUV).r;\n    }";
}
exports.getFragmentShaderGetBiasValueSource = getFragmentShaderGetBiasValueSource;
function getFragmentShaderSource(aShapeRowColDepth, resultDepth, fieldSize, stride, zeroPad, hasBias) {
    var prologue = getFragmentShaderPrologueSource();
    var getMatrixValueOrZeroPad = getFragmentShaderGetMatrixValueOrZeroPadSource();
    var convolve = getFragmentShaderConvolveSource(aShapeRowColDepth, fieldSize, resultDepth, stride, zeroPad, hasBias);
    var getBiasValue = getFragmentShaderGetBiasValueSource(resultDepth);
    return [
        prologue,
        getMatrixValueOrZeroPad,
        getBiasValue,
        convolve,
    ].join('\n');
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function convolve(gpgpu, program, a, weights, biases, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(a, 'x', 0);
    gpgpu.setInputMatrixTexture(weights, 'weights', 1);
    if (biases != null) {
        gpgpu.setInputMatrixTexture(biases, 'biases', 2);
    }
    gpgpu.executeProgram();
}
exports.convolve = convolve;

},{"../conv_util":16}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getFragmentShaderSource(sourceShapeRowCol, sourceSizeRowCol, destSizeRowCol) {
    return "\n    precision highp float;\n    uniform sampler2D source;\n    uniform vec2 sourceStartCR;\n    uniform vec2 destStartCR;\n\n    const vec2 sourceShapeCR =\n      vec2(" + sourceShapeRowCol[1] + ", " + sourceShapeRowCol[0] + ");\n    const vec2 sourceSizeCR =\n      vec2(" + sourceSizeRowCol[1] + ", " + sourceSizeRowCol[0] + ");\n    const vec2 destSizeCR =\n      vec2(" + destSizeRowCol[1] + ", " + destSizeRowCol[0] + ");\n\n    void main() {\n      vec2 destOffsetCR = floor(gl_FragCoord.xy) - destStartCR;\n      float destOffsetFlat = (destOffsetCR.y * destSizeCR.x) + destOffsetCR.x;\n      vec2 sourceOffsetCR = vec2(mod(destOffsetFlat, sourceSizeCR.x),\n        floor(destOffsetFlat / sourceSizeCR.x));\n      vec2 sourceCR = sourceStartCR + sourceOffsetCR;\n      vec2 sourceUV = (sourceCR + vec2(0.5, 0.5)) / sourceShapeCR;\n      gl_FragColor = texture2D(source, sourceUV);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function copy(gpgpu, program, source, sourceShapeRowCol, sourceStartRowCol, sourceSizeRowCol, dest, destShapeRowCol, destStartRowCol, destSizeRowCol) {
    gpgpu.setOutputMatrixTexture(dest, destShapeRowCol[0], destShapeRowCol[1]);
    gpgpu.setOutputMatrixWriteRegion(destStartRowCol[0], destSizeRowCol[0], destStartRowCol[1], destSizeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(source, 'source', 0);
    var sourceStartCRLoc = gpgpu.getUniformLocation('sourceStartCR');
    gpgpu.gl.uniform2f(sourceStartCRLoc, sourceStartRowCol[1], sourceStartRowCol[0]);
    var destStartCRLoc = gpgpu.getUniformLocation('destStartCR');
    gpgpu.gl.uniform2f(destStartCRLoc, destStartRowCol[1], destStartRowCol[0]);
    gpgpu.executeProgram();
}
exports.copy = copy;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (!webgl_util.isWebGL2Enabled()) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        this.throwIfDisposed();
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (uniformName) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        return webgl_util.getProgramUniformLocationOrThrow(this.gl, this.program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformName, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformName, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        var result = downloadAndDecode();
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
        return result;
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"./gpgpu_util":35,"./tex_util":48,"./webgl_util":51}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler = require("./shader_compiler");
var util = require("../../util");
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = program.variableNames.map(function (x, i) {
        var shapeInfo = {
            logicalShape: inputs[i].shape,
            texShape: inputs[i].getTextureShapeRC()
        };
        return { name: x, shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.shape,
        texShape: output.getTextureShapeRC()
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    return {
        program: program,
        source: source,
        webGLProgram: gpgpu.createProgram(source),
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, bArrays) {
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = bArrays[i].shape;
        var texShapeB = bArrays[i].getTextureShapeRC();
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.getTexture();
    var outTexShape = output.getTextureShapeRC();
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.getTexture();
        gpgpu.setInputMatrixTexture(tex, binary.program.variableNames[i], i);
    });
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var params = program.params;
    var keyStart = inputs.concat(output).map(function (x) { return x.shape + '_' + x.getTextureShapeRC(); });
    var keyEnd = params.map(function (p) { return p.toString(); });
    var key = [program.constructor.name];
    key.push((program.supportsBroadcasting === true).toString());
    key = key.concat(keyStart, keyEnd);
    return key.join('_');
}
exports.makeShaderKey = makeShaderKey;

},{"../../util":79,"./shader_compiler":47}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (webgl_util.isWebGL2Enabled()) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (webgl_util.isWebGL2Enabled() && numChannels === 1) {
        return gl.RED;
    }
    return gl.RGBA;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, gl.FLOAT, null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    try {
        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
    }
    catch (e) {
        if (!e.hasOwnProperty('namedVertexAttributeNotFound')) {
            throw e;
        }
    }
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    var numChannels = 4;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, gl.RGBA, gl.FLOAT, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, gl.FLOAT, data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
    var unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
    tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerTexture = 4;
    var unpackedArray = new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, unpackedArray); });
    var matrix = new Float32Array(rows * columns);
    tex_util.decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture);
    return matrix;
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"./tex_util":48,"./webgl_util":51}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LogSumExpProgram = (function () {
    function LogSumExpProgram(aSize) {
        this.variableNames = ['A'];
        this.params = [];
        this.outputShape = [];
        this.userCode = "\n      void main() {\n        float aMax = getAFlat(0.0);\n        for (int i = 0; i < " + aSize + "; i++) {\n          aMax = max(aMax, getAFlat(float(i)));\n        }\n\n        float expSum = 0.0;\n        for (int i = 0; i < " + aSize + "; i++) {\n          expSum += exp(getAFlat(float(i)) - aMax);\n        }\n\n        setOutput(aMax + log(expSum));\n      }\n    ";
    }
    return LogSumExpProgram;
}());
exports.LogSumExpProgram = LogSumExpProgram;

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderMaxPoolBackprop(dyShapeRCD, fSize, origStride, origPad) {
    var origInputDepth = dyShapeRCD[2];
    var pad = fSize - 1 - origPad;
    var dyRows = dyShapeRCD[0], dyCols = dyShapeRCD[1], depth = dyShapeRCD[2];
    var dyTexShapeRC = conv_util.computeTexShapeFrom3D(dyShapeRCD);
    return "\n    precision highp float;\n    uniform sampler2D dy;\n    uniform sampler2D maxPos;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 dyShapeCR = vec2(" + dyTexShapeRC[1] + ", " + dyTexShapeRC[0] + ");\n\n    void main() {\n      vec2 dxTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (dxTexR, dxTexC) to 3D (dxR, dxC, d).\n      float dxR = dxTexCR.y;\n      float dxC = floor(dxTexCR.x / " + origInputDepth + ".0);\n      float d = mod(dxTexCR.x, " + origInputDepth + ".0);\n\n      vec2 dyRCCorner = vec2(dxR, dxC) - vec2(" + pad + ".0, " + pad + ".0);\n      float dyRCorner = dyRCCorner.x;\n      float dyCCorner = dyRCCorner.y;\n\n      // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(yR, dxC, d).\n      // ? = to be determined. : = across all values in that axis.\n      float dotProd = 0.0;\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float dyR = (dyRCorner + wR_float) / " + origStride + ".0;\n        // TODO(nsthorat): Splice this with another version where you call\n        // getMatrixValueOrZeroPad(). Here and below.\n        if (dyR < 0.0 || dyR >= " + dyRows + ".0 || fract(dyR) > 0.0) {\n          continue;\n        }\n\n        float dyTexR = dyR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float dyC = (dyCCorner + wC_float) / " + origStride + ".0;\n          if (dyC < 0.0 || dyC >= " + dyCols + ".0 || fract(dyC) > 0.0) {\n            continue;\n          }\n\n          float dyTexC = dyC * " + depth + ".0 + d;\n\n          // Read dy(dyR, dyC, d).\n          vec2 dyUV = (vec2(dyTexC, dyTexR) + halfCR) / dyShapeCR;\n          float dyValue = texture2D(dy, dyUV).r;\n\n          // Read maxPos(dyR, dyC, d).\n          float maxPosValue =\n              " + (fSize * fSize - 1) + ".0 - texture2D(maxPos, dyUV).r;\n\n          // Get the current value, check it against the value from the\n          // position matrix.\n          float curPosValue = wR_float * " + fSize + ".0 + wC_float;\n          float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n          dotProd += dyValue * mask;\n        }\n      }\n      gl_FragColor = vec4(dotProd, 0, 0, 0);\n    }";
}
exports.getFragmentShaderMaxPoolBackprop = getFragmentShaderMaxPoolBackprop;
function maxPoolBackprop(gpgpu, program, dyTex, maxPositionsTex, resultTex, resultTexShapeRC) {
    gpgpu.setOutputMatrixTexture(resultTex, resultTexShapeRC[0], resultTexShapeRC[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(dyTex, 'dy', 0);
    gpgpu.setInputMatrixTexture(maxPositionsTex, 'maxPos', 1);
    gpgpu.executeProgram();
}
exports.maxPoolBackprop = maxPoolBackprop;

},{"../conv_util":16}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderMaxPoolPositionsSource(xShapeRCD, fSize, stride, pad) {
    return getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, true);
}
exports.getFragmentShaderMaxPoolPositionsSource = getFragmentShaderMaxPoolPositionsSource;
function getFragmentShaderMaxPoolSource(xShapeRCD, fSize, stride, pad) {
    return getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, false);
}
exports.getFragmentShaderMaxPoolSource = getFragmentShaderMaxPoolSource;
function getFragmentShaderMaxPoolCommonSource(xShapeRCD, fSize, stride, pad, computeMaxPositions) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'max', computeMaxPositions);
}
function maxPoolCommon(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.maxPoolCommon = maxPoolCommon;

},{"./pool_gpu":42}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pool_gpu = require("./pool_gpu");
function getFragmentShaderMinPoolSource(xShapeRCD, fSize, stride, pad) {
    return pool_gpu.getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, 'min', false);
}
exports.getFragmentShaderMinPoolSource = getFragmentShaderMinPoolSource;
function minPool(gpgpu, program, x, result, resultShapeRowCol) {
    pool_gpu.poolCommon(gpgpu, program, x, result, resultShapeRowCol);
}
exports.minPool = minPool;

},{"./pool_gpu":42}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MinMaxProgram = (function () {
    function MinMaxProgram(aSize, opType) {
        this.variableNames = ['A'];
        this.outputShape = [];
        this.params = [opType];
        this.userCode = "\n      void main() {\n        float value = getAFlat(0.0);\n        for (int i = 0; i < " + aSize + "; i++) {\n          float candidate = getAFlat(float(i));\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          value = " + opType + "(value, candidate);\n        }\n        setOutput(value);\n      }\n    ";
    }
    return MinMaxProgram;
}());
exports.MinMaxProgram = MinMaxProgram;

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var math_1 = require("../math");
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, aOrient, bOrient) {
        if (aOrient === void 0) { aOrient = math_1.MatrixOrientation.REGULAR; }
        if (bOrient === void 0) { bOrient = math_1.MatrixOrientation.REGULAR; }
        this.variableNames = ['matrixA', 'matrixB'];
        this.params = [aOrient, bOrient];
        var outerShapeA = (aOrient === math_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
        var outerShapeB = (bOrient === math_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
        this.outputShape = [outerShapeA, outerShapeB];
        var sharedDim = (aOrient === math_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
        var aSnippet = (aOrient === math_1.MatrixOrientation.REGULAR) ?
            'aRow, i_float' : 'i_float, aRow';
        var bSnippet = (bOrient === math_1.MatrixOrientation.REGULAR) ?
            'i_float, bCol' : 'bCol, i_float';
        this.userCode = "\n      const int sharedDim = " + sharedDim + ";\n\n      float dotARowBCol(float aRow, float bCol) {\n        float result = 0.0;\n        for (int i = 0; i < sharedDim; i++) {\n          float i_float = float(i);\n          float a = getMatrixA(" + aSnippet + ");\n          float b = getMatrixB(" + bSnippet + ");\n          result += (a * b);\n        }\n        return result;\n      }\n\n      void main() {\n        vec2 resRC = getOutputCoords();\n        setOutput(dotARowBCol(resRC.x, resRC.y));\n      }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{"../math":19}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderPoolCommonSource(xShapeRCD, fSize, stride, pad, poolType, computePositions) {
    if (poolType === 'avg' && computePositions) {
        throw new Error('Cannot compute positions for average pool.');
    }
    var depth = xShapeRCD[2];
    var xTexShapeRC = conv_util.computeTexShapeFrom3D(xShapeRCD);
    var returnValue = 'minMaxValue';
    if (computePositions) {
        returnValue = 'minMaxPosition';
    }
    else if (poolType === 'avg') {
        returnValue = 'avgValue';
    }
    return "\n    precision highp float;\n    uniform sampler2D x;\n    varying vec2 resultUV;\n\n    const vec2 halfCR = vec2(0.5, 0.5);\n    const vec2 xShapeCR = vec2(" + xTexShapeRC[1] + ", " + xTexShapeRC[0] + ");\n\n    bool isNaN(float val) {\n      return val == val ? false : true;\n    }\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d2).\n      float yR = yTexCR.y;\n      float yC = floor(yTexCR.x / " + depth + ".0);\n      float d = mod(yTexCR.x, " + depth + ".0);\n\n      vec2 xRCCorner = vec2(yR, yC) * vec2(" + stride + ", " + stride + ") -\n          vec2(" + pad + ".0, " + pad + ".0);\n      float xRCorner = xRCCorner.x;\n      float xCCorner = xRCCorner.y;\n\n      // max/min x(?, ?, d) to get y(yR, yC, d).\n      // ? = to be determined\n      float minMaxValue = 0.0;\n      float minMaxValueFound = 0.0;\n      float minMaxPosition = 0.0;\n      float avgValue = 0.0;\n\n      for (int wR = 0; wR < " + fSize + "; wR++) {\n        float wR_float = float(wR);\n        float xR = xRCorner + wR_float;\n        float xTexR = xR;\n\n        for (int wC = 0; wC < " + fSize + "; wC++) {\n          float wC_float = float(wC);\n          float xC = xCCorner + wC_float;\n          float xTexC = xC * " + depth + ".0 + d;\n\n          vec2 texCR = vec2(xTexC, xTexR);\n\n          // Check if the requested UV is invalid.\n          vec2 uv = (texCR + halfCR) / xShapeCR;\n          bool lessThanZero = any(lessThan(uv, vec2(0, 0)));\n          bool greaterThanOne = any(greaterThan(uv, vec2(1, 1)));\n          bool outside = lessThanZero || greaterThanOne;\n          if (outside) {\n            continue;\n          }\n\n          float value = texture2D(x, uv).r;\n          if (isNaN(value)) {\n            gl_FragColor = vec4(value, 0, 0, 0);\n            return;\n          }\n          if (" + (poolType === 'avg') + ") {\n            avgValue += value / " + fSize * fSize + ".0;\n          } else {\n            // If a min / max value has already been found, use it. If not, use\n            // the current value.\n            float currentMinMaxValue = mix(\n                value, minMaxValue, minMaxValueFound);\n            if (value " + (poolType === 'min' ? '<=' : '>=') + " currentMinMaxValue) {\n              minMaxValue = value;\n              minMaxValueFound = 1.0;\n              if (" + computePositions + ") {\n                minMaxPosition = wR_float * " + fSize + ".0 + wC_float;\n              }\n            }\n          }\n        }\n      }\n      gl_FragColor = vec4(" + returnValue + ", 0, 0, 0);\n    }";
}
exports.getFragmentShaderPoolCommonSource = getFragmentShaderPoolCommonSource;
function poolCommon(gpgpu, program, x, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(program);
    gpgpu.setInputMatrixTexture(x, 'x', 0);
    gpgpu.executeProgram();
}
exports.poolCommon = poolCommon;

},{"../conv_util":16}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceSumProgram = (function () {
    function ReduceSumProgram(aSize) {
        this.aSize = aSize;
        this.variableNames = ['A'];
        this.params = [];
        this.outputShape = [];
        this.userCode = "\n      void main() {\n        float sum = 0.0;\n        for (int i = 0; i < " + aSize + "; i++) {\n          sum += getAFlat(float(i));\n        }\n        setOutput(sum);\n      }\n    ";
    }
    return ReduceSumProgram;
}());
exports.ReduceSumProgram = ReduceSumProgram;

},{}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var webgl_util = require("./webgl_util");
function getRenderRGBShader(gpgpu, destinationWidth) {
    var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
    return gpgpu.createProgram(fragmentShaderSource);
}
exports.getRenderRGBShader = getRenderRGBShader;
function renderToCanvas(gpgpu, renderShader, sourceTex) {
    webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
    renderToFramebuffer(gpgpu, renderShader, sourceTex);
}
exports.renderToCanvas = renderToCanvas;
function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
    gpgpu.setProgram(renderShader);
    gpgpu.setInputMatrixTexture(sourceTex, 'source', 0);
    gpgpu.executeProgram();
}
exports.renderToFramebuffer = renderToFramebuffer;

},{"./webgl_util":51}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
function getFragmentShaderSource() {
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    uniform vec2 inputDimCR;\n    uniform vec2 resultDimCR;\n    varying vec2 resultUV;\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    void main() {\n      vec2 resultCR = floor(resultUV * resultDimCR);\n      // indexInFlat = row * stride + column, where stride == numOutputColumns\n      float indexInFlat = resultCR.y * resultDimCR.x + resultCR.x;\n\n      vec2 inputCR = vec2(\n        mod(indexInFlat, inputDimCR.x), // col = indexInFlat % numInputColumns\n        floor(indexInFlat / inputDimCR.x) // row = indexInFlat / numInputColumns\n      ) + halfCR;\n\n      vec2 inputUV = inputCR / inputDimCR;\n      gl_FragColor = texture2D(matrixA, inputUV);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function reshape(gpgpu, reshapeProgram, a, aNumRows, aNumCols, result, resultNumRows, resultNumCols) {
    var inputSize = aNumRows * aNumCols;
    var outputSize = resultNumCols * resultNumRows;
    util.assert(inputSize === outputSize, "The input size (" + inputSize + ") and output size (" + outputSize + ") " +
        "must match");
    gpgpu.setOutputMatrixTexture(result, resultNumRows, resultNumCols);
    gpgpu.setProgram(reshapeProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    var inputDimCRLocation = gpgpu.getUniformLocation('inputDimCR');
    gpgpu.gl.uniform2f(inputDimCRLocation, aNumCols, aNumRows);
    var resultDimCRLocation = gpgpu.getUniformLocation('resultDimCR');
    gpgpu.gl.uniform2f(resultDimCRLocation, resultNumCols, resultNumRows);
    gpgpu.executeProgram();
}
exports.reshape = reshape;

},{"../../util":79}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../conv_util");
function getFragmentShaderSource(inputShapeRCD, outputDimensionsRowCol, alignCorners) {
    var depth = inputShapeRCD[2];
    var inputTexShapeRC = conv_util.computeTexShapeFrom3D(inputShapeRCD);
    var effectiveInputShapeRCD = alignCorners ?
        [inputShapeRCD[0] - 1, inputShapeRCD[1] - 1, depth] :
        inputShapeRCD;
    var effectiveOutputShapeRCD = alignCorners ?
        [outputDimensionsRowCol[0] - 1, outputDimensionsRowCol[1] - 1, depth] :
        [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
    return "\n    precision highp float;\n    uniform sampler2D matrixA;\n    varying vec2 resultUV;\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    const vec2 inputShapeCR = vec2(" + inputShapeRCD[1] + ", " + inputShapeRCD[0] + ");\n    const vec2 inputShapeTexCR = vec2(\n        " + inputTexShapeRC[1] + ", " + inputTexShapeRC[0] + ");\n\n    const vec2 effectiveInputOverOutputRatioCR = vec2(\n        " + effectiveInputShapeRCD[1] / effectiveOutputShapeRCD[1] + ",\n        " + effectiveInputShapeRCD[0] / effectiveOutputShapeRCD[0] + ");\n\n    float sampleInput(float col, float row, float d) {\n      vec2 uv = (vec2(col * " + depth + ".0 + d, row) + halfCR) / inputShapeTexCR;\n      return texture2D(matrixA, uv).r;\n    }\n\n    void main() {\n      vec2 yTexCR = floor(gl_FragCoord.xy);\n\n      // Map from 2D (yTexR, yTexC) to 3D (yR, yC, d).\n      vec2 yCR = vec2(floor(yTexCR.x / " + depth + ".0), yTexCR.y);\n      float d = mod(yTexCR.x, " + depth + ".0);\n\n      // Fractional source index.\n      vec2 sourceFracIndexCR = yCR * effectiveInputOverOutputRatioCR;\n\n      // Compute the four integer indices.\n      vec2 sourceFloorCR = floor(sourceFracIndexCR);\n      vec2 sourceCeilCR = min(inputShapeCR - 1.0, ceil(sourceFracIndexCR));\n\n      float topLeft = sampleInput(sourceFloorCR[0], sourceFloorCR[1], d);\n      float bottomLeft = sampleInput(sourceFloorCR[0], sourceCeilCR[1], d);\n      float topRight = sampleInput(sourceCeilCR[0], sourceFloorCR[1], d);\n      float bottomRight = sampleInput(sourceCeilCR[0], sourceCeilCR[1], d);\n\n      vec2 fracCR = sourceFracIndexCR - sourceFloorCR;\n\n      float top = topLeft + (topRight - topLeft) * fracCR[0];\n      float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR[0];\n      float newValue = top + (bottom - top) * fracCR[1];\n\n      gl_FragColor = vec4(newValue, 0.0, 0.0, 0.0);\n    }";
}
exports.getFragmentShaderSource = getFragmentShaderSource;
function resizeBilinear(gpgpu, resizeBilinearProgram, a, result, resultShapeRowCol) {
    gpgpu.setOutputMatrixTexture(result, resultShapeRowCol[0], resultShapeRowCol[1]);
    gpgpu.setProgram(resizeBilinearProgram);
    gpgpu.setInputMatrixTexture(a, 'matrixA', 0);
    gpgpu.executeProgram();
}
exports.resizeBilinear = resizeBilinear;

},{"../conv_util":16}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../../util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, inputPrefixSnippet, SAMPLE_1D_SNIPPET, SAMPLE_2D_SNIPPET,
        SAMPLE_3D_SNIPPET, SAMPLE_4D_SNIPPET, inputSamplingSnippet,
        outputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var shape = inInfo.shapeInfo.logicalShape;
    var texShape = inInfo.shapeInfo.texShape;
    var outTexShape = outShapeInfo.texShape;
    var res = '';
    switch (shape.length) {
        case 0:
            res += getSamplerScalar(inInfo.name);
            break;
        case 1:
            res += getSampler1D(inInfo.name, texShape);
            break;
        case 2:
            res += getSampler2D(inInfo.name, shape, texShape);
            break;
        case 3:
            res += getSampler3D(inInfo.name, shape, texShape);
            break;
        case 4:
            res += getSampler4D(inInfo.name, shape, texShape);
            break;
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
    if (broadcast || util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res +=
            getSamplerAtOutputCoords(inInfo.name, texShape, outTexShape, broadcast);
    }
    res += getSamplerFlat(inInfo.name, texShape);
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return '';
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SHADER_PREFIX = "\n  precision highp float;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n\n  bool isNaN(float val) {\n    return val == val ? false : true;\n  }\n";
var SAMPLE_1D_SNIPPET = "\n  float sample1D(sampler2D texture, float texNumR, float texNumC, float index) {\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_2D_SNIPPET = "\n  float sample2D(sampler2D texture, float texNumR, float texNumC, float numC,\n      float row, float col) {\n    float index = dot(vec2(row, col), vec2(numC, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_3D_SNIPPET = "\n  float sample3D(sampler2D texture, float texNumR, float texNumC, float stride0,\n      float stride1, float row, float col, float depth) {\n    float index = dot(vec3(row, col, depth), vec3(stride0, stride1, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
var SAMPLE_4D_SNIPPET = "\n  float sample4D(sampler2D texture, float texNumR, float texNumC, float stride0,\n      float stride1, float stride2, float row, float col, float depth,\n      float depth2) {\n    float index = dot(vec4(row, col, depth, depth2),\n                      vec4(stride0, stride1, stride2, 1.0));\n    float texR = floor(index / texNumC);\n    float texC = mod(index, texNumC);\n    vec2 uv = (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n    return texture2D(texture, uv).r;\n  }\n";
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      float getOutputCoords() {\n        return floor(gl_FragCoord.x);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      float getOutputCoords() {\n        return floor(gl_FragCoord.y);\n      }\n    ";
    }
    return "\n    float getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      return dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    vec3 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n      float r = floor(index / " + stride0 + ".0);\n      index -= r * " + stride0 + ".0;\n      float c = floor(index / " + stride1 + ".0);\n      float d = mod(index, " + stride1 + ".0);\n      return vec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    vec4 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n\n      float r = floor(index / " + stride0 + ".0);\n      index -= r * " + stride0 + ".0;\n\n      float c = floor(index / " + stride1 + ".0);\n      index -= c * " + stride1 + ".0;\n\n      float d = floor(index / " + stride2 + ".0);\n      float d2 = mod(index, " + stride2 + ".0);\n\n      return vec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      vec2 getOutputCoords() {\n        return floor(gl_FragCoord.yx);\n      }\n    ";
    }
    return "\n    vec2 getOutputCoords() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + texShape[1] + ".0, 1.0));\n      float r = floor(index / " + shape[1] + ".0);\n      float c = mod(index, " + shape[1] + ".0);\n      return vec2(r, c);\n    }\n  ";
}
function getSamplerScalar(texName) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return texture2D(" + texName + ", halfCR).r;\n    }\n  ";
}
function getSampler1D(texName, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    if (texShape[0] === 1 && texShape[1] === 1) {
        return "\n      float " + funcName + "(float index) {\n        return texture2D(" + texName + ", halfCR).r;\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2(0.5, (index + 0.5) / " + tR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    if (texShape[0] === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2((index + 0.5) / " + tC + ".0, 0.5);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float index) {\n      return sample1D(" + texName + ", " + tR + ".0, " + tC + ".0, index);\n    }\n  ";
}
function getSampler3D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    float " + funcName + "(float row, float col, float depth) {\n      return sample3D(" + texName + ", " + tR + ".0, " + tC + ".0, " + stride0 + ".0, " + stride1 + ".0,\n          row, col, depth);\n    }\n  ";
}
function getSampler4D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n  float " + funcName + "(float row, float col, float depth, float depth2) {\n    return sample4D(" + texName + ", " + tR + ".0, " + tC + ".0, " + stride0 + ".0, " + stride1 + ".0,\n        " + stride2 + ".0, row, col, depth, depth2);\n  }\n";
}
function getSampler2D(texName, shape, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var tR = texShape[0];
    var tC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n      float " + funcName + "(float row, float col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + tC + ".0, " + tR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float row, float col) {\n      return sample2D(" + texName + ", " + tR + ".0, " + tC + ".0, " + shape[1] + ".0, row, col);\n    }\n  ";
}
function getSamplerFlat(texName, texShape) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) +
        'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(float index) {\n        return texture2D(" + texName + ", halfCR).r;\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2(0.5, (index + 0.5) / " + tNumR + ".0);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(float index) {\n        vec2 uv = vec2((index + 0.5) / " + tNumC + ".0, 0.5);\n        return texture2D(" + texName + ", uv).r;\n      }\n    ";
    }
    return "\n    float " + funcName + "(float index) {\n      float texR = floor(index / " + tNumC + ".0);\n      float texC = mod(index, " + tNumC + ".0);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + tNumC + ".0, " + tNumR + ".0);\n      return texture2D(" + texName + ", uv).r;\n    }\n  ";
}
function getSamplerAtOutputCoords(texName, inTexShape, outTexShape, broadcast) {
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) +
        'AtOutCoords';
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return texture2D(" + texName + ", resultUV).r;\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = broadcast ? "index = mod(index, " + inSize + ".0);" : '';
    return "\n    float " + funcName + "() {\n      vec2 resTexRC = floor(gl_FragCoord.yx);\n      float index = dot(resTexRC, vec2(" + outTexShape[1] + ".0, 1.0));\n      " + broadcastSnippet + "\n      float texR = floor(index / " + inTexShape[1] + ".0);\n      float texC = mod(index, " + inTexShape[1] + ".0);\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n      return texture2D(" + texName + ", uv).r;\n    }\n  ";
}

},{"../../util":79}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error('unpackedSize (' + unpackedSize + ') must be a multiple of ' +
            channelsPerTexture);
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error('unpackedArray length (' + unpackedArray.length +
            ') must be >= ' + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error('packedRGBA length (' + packedRGBA.length +
            ') must be >= ' + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error('matrix length (' + matrix.length + ') must be >= ' + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC) {
        var shapeKey = getKeyFromTextureShape(shapeRC);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
    };
    TextureManager.prototype.releaseTexture = function (texture, shape) {
        var shapeKey = getKeyFromTextureShape(shape);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + ' / ' + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        for (var shape in this.freeTextures) {
            if (this.freeTextures.hasOwnProperty(shape)) {
                for (var i = 0; i < this.freeTextures[shape].length; i++) {
                    this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                }
            }
        }
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol) {
    return shapeRowsCol[0] + '_' + shapeRowsCol[1];
}

},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnaryOp;
(function (UnaryOp) {
    UnaryOp[UnaryOp["EXP"] = 0] = "EXP";
    UnaryOp[UnaryOp["LOG"] = 1] = "LOG";
    UnaryOp[UnaryOp["NEG"] = 2] = "NEG";
    UnaryOp[UnaryOp["RELU"] = 3] = "RELU";
    UnaryOp[UnaryOp["SIGMOID"] = 4] = "SIGMOID";
    UnaryOp[UnaryOp["STEP"] = 5] = "STEP";
    UnaryOp[UnaryOp["SIN"] = 6] = "SIN";
    UnaryOp[UnaryOp["TANH"] = 7] = "TANH";
})(UnaryOp = exports.UnaryOp || (exports.UnaryOp = {}));
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, op) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.params = [op];
        this.userCode = "\n      void main() {\n        float v = getAAtOutCoords();\n        " + getOpSnippet(op) + "\n        setOutput(r);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
function getOpSnippet(op) {
    switch (op) {
        case UnaryOp.EXP:
            return 'float r = exp(v);';
        case UnaryOp.LOG:
            return 'float r = log(v);';
        case UnaryOp.NEG:
            return 'float r = -v;';
        case UnaryOp.RELU:
            return 'float r = (v < 0.0) ? 0.0 : v;';
        case UnaryOp.SIGMOID:
            return 'float r = 1.0 / (1.0 + exp(-1.0 * v));';
        case UnaryOp.STEP:
            return 'float r = (v == v) ? (v > 0.0 ? 1.0 : 0.0) : v;';
        case UnaryOp.SIN:
            return 'float r = sin(v);';
        case UnaryOp.TANH:
            return "float e2x = exp(-2.0 * abs(v));\n              float r = sign(v) * (1.0 - e2x) / (1.0 + e2x);";
        default:
            throw Error('Unrecognized unary op type ' + op);
    }
}

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var USE_WEBGL2_WHEN_AVAILABLE = true;
var WEBGL2_ENABLED = null;
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function preferWebGL1() {
    USE_WEBGL2_WHEN_AVAILABLE = false;
    WEBGL2_ENABLED = null;
}
exports.preferWebGL1 = preferWebGL1;
function preferWebGL2() {
    USE_WEBGL2_WHEN_AVAILABLE = true;
    WEBGL2_ENABLED = null;
}
exports.preferWebGL2 = preferWebGL2;
function isWebGL2Enabled() {
    if (!USE_WEBGL2_WHEN_AVAILABLE) {
        return false;
    }
    if (WEBGL2_ENABLED == null) {
        var tempCanvas = document.createElement('canvas');
        var gl = tempCanvas.getContext('webgl2');
        if (gl != null) {
            WEBGL2_ENABLED = true;
            var loseContextExtension = getExtensionOrThrow(gl, 'WEBGL_lose_context');
            loseContextExtension.loseContext();
        }
        else {
            WEBGL2_ENABLED = false;
        }
    }
    return WEBGL2_ENABLED;
}
exports.isWebGL2Enabled = isWebGL2Enabled;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    if (isWebGL2Enabled()) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return 'Unknown error code ' + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (isWebGL2Enabled()) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = '[' + width + 'x' + height + ']';
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = '[' + width + 'x' + height + ']';
        var max = '[' + maxTextureSize + 'x' + maxTextureSize + ']';
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        var error = new Error('Unable to get attribute "' + attribute + '" on WebGLProgram.');
        error.namedVertexAttributeNotFound = attribute;
        throw error;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerName, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    var samplerLocation = getProgramUniformLocationOrThrow(gl, program, uniformSamplerName);
    callAndCheck(gl, function () { return gl.uniform1i(samplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return 'unknown error ' + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = '[gl.TEXTURE0, gl.TEXTURE' + maxTextureUnit + ']';
        throw new Error('textureUnit must be in ' + textureUnitRange + '.');
    }
}
function getTextureShapeFromLogicalShape(gl, logicalShape, preferredTexShape) {
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logicalShape);
    if (preferredTexShape != null) {
        var sizePreferred = util.sizeFromShape(preferredTexShape);
        util.assert(size === sizePreferred, "Size of shape (" + size + ") must match size of " +
            ("preferredShape (" + sizePreferred + ")"));
        if (preferredTexShape[0] <= maxTexSize &&
            preferredTexShape[1] <= maxTexSize) {
            return preferredTexShape;
        }
    }
    if (logicalShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logicalShape.length === 2 && logicalShape[0] <= maxTexSize &&
        logicalShape[1] <= maxTexSize) {
        return logicalShape;
    }
    else if (logicalShape.length === 3 && logicalShape[0] <= maxTexSize &&
        logicalShape[1] * logicalShape[2] <= maxTexSize) {
        return [logicalShape[0], logicalShape[1] * logicalShape[2]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../util":79}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat3d_1 = require("./ops/concat3d");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var split_1 = require("./ops/split");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SplitNode) {
        return [new split_1.Split(node.inputs[graph_1.SplitNode.X], node.outputs)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error('Unsupported node type: ' + node.constructor.name);
    }
}

},{"./graph":7,"./graph_util":10,"./ops/add":53,"./ops/argmax":54,"./ops/argmaxequals":55,"./ops/concat3d":56,"./ops/convolution":57,"./ops/divide":58,"./ops/element_wise_activation":59,"./ops/element_wise_cost":60,"./ops/exp":61,"./ops/linear_combination":62,"./ops/log":63,"./ops/matmul":64,"./ops/max_pool":65,"./ops/multiply":66,"./ops/reduce_sum":68,"./ops/reshape":69,"./ops/softmax":70,"./ops/split":71,"./ops/subtract":72}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.x1Tensor, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, dy);
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.x2Tensor, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, dy);
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../graph_util":10,"../math/ndarray":22,"../util":79,"./op":67}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"./op":67}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"./op":67}],56:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat3d_util = require("../math/concat3d_util");
var op_1 = require("./op");
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat3d_util.assertConcat3DShapesMatch(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Concat3D backprop not implemented.');
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;

},{"../math/concat3d_util":15,"./op":67}],57:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            var _a = math.conv2dBackProp(x, dy, weights, _this.stride, _this.zeroPad), dw = _a.dw, db = _a.db, dx = _a.dx;
            gradientArrays.set(_this.wTensor, keep(dw));
            gradientArrays.set(_this.bTensor, keep(db));
            gradientArrays.set(_this.xTensor, keep(dx));
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../math/conv_util":16,"../util":79,"./op":67}],58:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.set(_this.x1Tensor, keep(math.sum(div)));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.set(_this.x1Tensor, keep(math.arrayDividedByScalar(dy, x2)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, keep(math.divide(dy, x2)));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.set(_this.x2Tensor, keep(math.sum(dyTimesDerivative)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, keep(dyTimesDerivative));
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../graph_util":10,"../util":79,"./op":67}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var activation_functions_1 = require("../math/activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.set(_this.xTensor, keep(math.elementWiseMul(dy, dydx)));
            dydx.dispose();
        });
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;

},{"../math/activation_functions":14,"./op":67}],60:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var cost_functions_1 = require("../math/cost_functions");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar = ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var elementWiseCost = _this.func.cost(math, x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.set(_this.x1Tensor, keep(_this.func.der(math, x1, x2)));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.set(_this.x2Tensor, keep(_this.func.der(math, x2, x1)));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../graph_util":10,"../math/cost_functions":18,"../math/ndarray":22,"../util":79,"./op":67}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.set(_this.xTensor, keep(math.elementWiseMul(y, dy)));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../graph_util":10,"./op":67}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.set(_this.x1Tensor, keep(math.scalarTimesArray(c1, dy)));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.set(_this.x2Tensor, keep(math.scalarTimesArray(c2, dy)));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.set(_this.c1Tensor, keep(math.sum(dotProduct1)));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.set(_this.c2Tensor, keep(math.sum(dotProduct2)));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../graph_util":10,"./op":67}],63:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.set(_this.xTensor, keep(math.divide(dy, x)));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../graph_util":10,"./op":67}],64:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var math_1 = require("../math/math");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, math_1.MatrixOrientation.REGULAR, math_1.MatrixOrientation.TRANSPOSED);
                gradientArrays.set(_this.x1Tensor, keep(_this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, math_1.MatrixOrientation.TRANSPOSED, math_1.MatrixOrientation.REGULAR);
                gradientArrays.set(_this.x2Tensor, keep(_this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2));
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../graph_util":10,"../math/math":19,"./op":67}],65:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var conv_util = require("../math/conv_util");
var util = require("../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.xTensor, keep(math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../math/conv_util":16,"../util":79,"./op":67}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.set(_this.x1Tensor, keep(math.sum(mul)));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.set(_this.x1Tensor, keep(math.scalarTimesArray(x2, dy)));
                }
                else {
                    gradientArrays.set(_this.x1Tensor, keep(math.elementWiseMul(x2, dy)));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.set(_this.x2Tensor, keep(math.sum(mul)));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.set(_this.x2Tensor, keep(math.scalarTimesArray(x1, dy)));
                }
                else {
                    gradientArrays.set(_this.x2Tensor, keep(math.elementWiseMul(x1, dy)));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../graph_util":10,"../util":79,"./op":67}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],68:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        math.scope(function (keep) {
            inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        math.scope(function (keep) {
            var dy = gradientArrays.get(_this.outTensor);
            if (_this.ones == null) {
                var xArray = inferenceArrays.get(_this.x);
                _this.ones = ndarray_1.NDArray.zerosLike(xArray);
                _this.ones.fill(1);
            }
            gradientArrays.set(_this.x, keep(math.scalarTimesArray(dy, _this.ones)));
        });
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../graph_util":10,"../math/ndarray":22,"../util":79,"./op":67}],69:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        math.scope(function (keep) {
            inferenceArrays.set(_this.yTensor, keep(math.reshape(x, _this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.xTensor, keep(math.reshape(dy, _this.xTensor.shape)));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../util":79,"./op":67}],70:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("../graph");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return math.scope(function (keep) {
            inferenceArrays.set(_this.output, keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function () {
        throw Error('Softmax backprop is not yet implemented');
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.epsilon = ndarray_1.Scalar.new(1e-5);
        _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        math.scope(function (keep) {
            gradientArrays.set(_this.logitsTensor, keep(math.sub(softmax, label)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return math.scope(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../graph":7,"../math/ndarray":22,"../util":79,"./op":67}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var util = require("../util");
var op_1 = require("./op");
var Split = (function (_super) {
    __extends(Split, _super);
    function Split(input, outputs) {
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.outputs = outputs;
        outputs.forEach(function (output) {
            util.assertShapesMatch(input.shape, output.shape);
        });
        return _this;
    }
    Split.prototype.feedForward = function (math, inferenceArrays) {
        var inputArray = inferenceArrays.get(this.input);
        this.outputs.forEach(function (output) {
            inferenceArrays.set(output, inputArray);
        });
    };
    Split.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.input)) {
            return;
        }
        math.scope(function (keep) {
            var dx = math.add(gradientArrays.get(_this.outputs[0]), gradientArrays.get(_this.outputs[1]));
            _this.outputs.slice(2).forEach(function (output) {
                dx = math.add(dx, gradientArrays.get(output));
            });
            gradientArrays.set(_this.input, keep(dx));
        });
    };
    return Split;
}(op_1.Operation));
exports.Split = Split;

},{"../graph_util":10,"../util":79,"./op":67}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var graph_util = require("../graph_util");
var ndarray_1 = require("../math/ndarray");
var util = require("../util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        math.scope(function (keep) {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.sub(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        math.scope(function (keep) {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.t1, keep(math.divide(sum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.t1, keep(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    if (_this.dySizeScalar == null) {
                        _this.dySizeScalar = ndarray_1.Scalar.new(dy.size);
                    }
                    gradientArrays.set(_this.t2, keep(math.divide(negSum, _this.dySizeScalar)));
                }
                else {
                    gradientArrays.set(_this.t2, keep(math.neg(dy)));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../graph_util":10,"../math/ndarray":22,"../util":79,"./op":67}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Optimizer = (function () {
    function Optimizer(specifiedVariableList) {
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var util = require("./util");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.gradientArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = ndarray_1.Scalar.new(1);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return this.math.scope(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            this.batchSizeScalar = ndarray_1.Scalar.new(batchSize);
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.set(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return this.math.scope(function (keep, track) {
            var cost = track(ndarray_1.Scalar.new(0));
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            nodes = session_util.addSplitNodes(nodes);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"./math/ndarray":22,"./operation_emitter":52,"./session_util":76,"./tensor_array_map":78,"./util":79}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var ndarray_1 = require("./math/ndarray");
var util = require("./util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof ndarray_1.NDArray) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy(math);
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(math, feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.set(input, null);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;
function addSplitNodes(nodes) {
    var nodeIdToNumConsumers = [];
    var nodeIdToSplitNode = {};
    nodes.forEach(function (node) {
        var keys = Object.keys(node.inputs);
        keys.forEach(function (key) {
            var inputTensor = node.inputs[key];
            var input = inputTensor.node;
            if (nodeIdToNumConsumers[input.id] == null) {
                nodeIdToNumConsumers[input.id] = 0;
            }
            nodeIdToNumConsumers[input.id]++;
            if (nodeIdToNumConsumers[input.id] > 1 &&
                nodeIdToSplitNode[input.id] == null) {
                nodeIdToSplitNode[input.id] = new graph_1.SplitNode(input.graph, inputTensor);
            }
        });
    });
    var newNodes = [];
    nodes.forEach(function (node) {
        newNodes.push(node);
        if (node.id in nodeIdToSplitNode) {
            var splitNode = nodeIdToSplitNode[node.id];
            newNodes.push(splitNode);
        }
        var keys = Object.keys(node.inputs);
        keys.forEach(function (key) {
            var inputTensor = node.inputs[key];
            var inputId = inputTensor.node.id;
            if (inputId in nodeIdToSplitNode) {
                node.inputs[key] = nodeIdToSplitNode[inputId].getNewOutputTensor();
            }
        });
    });
    return newNodes;
}
exports.addSplitNodes = addSplitNodes;

},{"./graph":7,"./graph_util":10,"./math/ndarray":22,"./util":79}],77:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ndarray_1 = require("./math/ndarray");
var optimizer_1 = require("./optimizer");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        _this.one = ndarray_1.Scalar.new(1);
        return _this;
    }
    SGDOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            this.prevBatchSize = batchSize;
            this.c = ndarray_1.Scalar.new(-this.learningRate / batchSize);
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape)); });
    };
    SGDOptimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        math.scope(function (keep) {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    SGDOptimizer.prototype.dispose = function () {
        if (this.c != null) {
            this.c.dispose();
        }
        this.one.dispose();
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"./math/ndarray":22,"./optimizer":73,"./session_util":76,"./tensor_array_map":78}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMap = (function () {
    function TensorArrayMap() {
        this.dict = {};
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    TensorArrayMap.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error('tensor ' + tensor.id + ' not in array map.');
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error('tensor ' + tensor.id + ' has null array.');
        }
        return nda;
    };
    TensorArrayMap.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMap.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMap.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMap.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMap.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error('tensor ' + tensor.id + ' not in array map.');
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMap;
}());
exports.TensorArrayMap = TensorArrayMap;

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function randGauss(mean, stdDev, truncated) {
    if (mean === void 0) { mean = 0; }
    if (stdDev === void 0) { stdDev = 1; }
    if (truncated === void 0) { truncated = false; }
    var v1, v2, s;
    do {
        v1 = 2 * Math.random() - 1;
        v2 = 2 * Math.random() - 1;
        s = v1 * v1 + v2 * v2;
    } while (s > 1);
    var result = Math.sqrt(-2 * Math.log(s) / s) * v1;
    if (truncated && result > 2) {
        return randGauss(mean, stdDev, true);
    }
    return mean + stdDev * result;
}
exports.randGauss = randGauss;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = a[i] - b[i];
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function flatten(arr, ret) {
    ret = (ret === undefined ? [] : ret);
    for (var i = 0; i < arr.length; ++i) {
        if (Array.isArray(arr[i])) {
            flatten(arr[i], ret);
        }
        else {
            ret.push(arr[i]);
        }
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(arr) {
    var shape = [];
    while (arr instanceof Array) {
        shape.push(arr.length);
        arr = arr[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function assertAndGetBroadcastedShape(shapeA, shapeB) {
    var result = [];
    var nextADimMustBeOne = false;
    var nextBDimMustBeOne = false;
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ". Currently, we only support a ") +
        "stricter version of broadcasting than numpy.";
    var l = Math.max(shapeA.length, shapeB.length);
    shapeA = shapeA.slice().reverse();
    shapeB = shapeB.slice().reverse();
    for (var i = 0; i < l; i++) {
        var a = shapeA[i] || 1;
        var b = shapeB[i] || 1;
        if ((b > 1 && nextBDimMustBeOne) || (a > 1 && nextADimMustBeOne)) {
            throw Error(errMsg);
        }
        if (a > 1 && b === 1) {
            nextBDimMustBeOne = true;
        }
        if (b > 1 && a === 1) {
            nextADimMustBeOne = true;
        }
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.push(Math.max(a, b));
    }
    return result.reverse();
}
exports.assertAndGetBroadcastedShape = assertAndGetBroadcastedShape;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkZW1vcy9kZWVwbGVhcm5qcy50cyIsImRlbW9zL3BlcmZvcm1hbmNlX3Jubi9wZXJmb3JtYW5jZV9ybm4udHMiLCJub2RlX21vZHVsZXMvdG9uZS1waWFuby9idWlsZC9QaWFuby5qcyIsIm5vZGVfbW9kdWxlcy90b25lL2J1aWxkL1RvbmUuanMiLCJzcmMvY2hlY2twb2ludF9sb2FkZXIudHMiLCJzcmMvZGF0YXNldC50cyIsInNyYy9ncmFwaC50cyIsInNyYy9ncmFwaF9sYXllcnMudHMiLCJzcmMvZ3JhcGhfcnVubmVyLnRzIiwic3JjL2dyYXBoX3V0aWwudHMiLCJzcmMvaW5kZXgudHMiLCJzcmMvaW5pdGlhbGl6ZXJzLnRzIiwic3JjL2lucHV0X3Byb3ZpZGVyLnRzIiwic3JjL21hdGgvYWN0aXZhdGlvbl9mdW5jdGlvbnMudHMiLCJzcmMvbWF0aC9jb25jYXQzZF91dGlsLnRzIiwic3JjL21hdGgvY29udl91dGlsLnRzIiwic3JjL21hdGgvY29weTJkX3V0aWwudHMiLCJzcmMvbWF0aC9jb3N0X2Z1bmN0aW9ucy50cyIsInNyYy9tYXRoL21hdGgudHMiLCJzcmMvbWF0aC9tYXRoX2NwdS50cyIsInNyYy9tYXRoL21hdGhfZ3B1LnRzIiwic3JjL21hdGgvbmRhcnJheS50cyIsInNyYy9tYXRoL3dlYmdsL2FkZHNjYWxlZG1hdF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9hcmdtYXhlcXVhbHNfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvYXJnbWlubWF4X2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL2F2Z19wb29sX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL2JhdGNobm9ybV9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9iaW5hcnlvcF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9jb25jYXQzZF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9jb252X2JhY2twcm9wX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL2NvbnZfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvY29weV9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9ncGdwdV9jb250ZXh0LnRzIiwic3JjL21hdGgvd2ViZ2wvZ3BncHVfbWF0aC50cyIsInNyYy9tYXRoL3dlYmdsL2dwZ3B1X3V0aWwudHMiLCJzcmMvbWF0aC93ZWJnbC9sb2dzdW1leHBfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvbWF4X3Bvb2xfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvbWluX3Bvb2xfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvbWlubWF4X2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL211bG1hdF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9wb29sX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL3JlZHVjZXN1bV9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC9yZW5kZXJfbmRhcnJheV9ncHVfdXRpbC50cyIsInNyYy9tYXRoL3dlYmdsL3Jlc2hhcGVfZ3B1LnRzIiwic3JjL21hdGgvd2ViZ2wvcmVzaXplX2JpbGluZWFyX2dwdS50cyIsInNyYy9tYXRoL3dlYmdsL3NoYWRlcl9jb21waWxlci50cyIsInNyYy9tYXRoL3dlYmdsL3RleF91dGlsLnRzIiwic3JjL21hdGgvd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyLnRzIiwic3JjL21hdGgvd2ViZ2wvdW5hcnlvcF9ncHUudHMiLCJzcmMvbWF0aC93ZWJnbC93ZWJnbF91dGlsLnRzIiwic3JjL29wZXJhdGlvbl9lbWl0dGVyLnRzIiwic3JjL29wcy9hZGQudHMiLCJzcmMvb3BzL2FyZ21heC50cyIsInNyYy9vcHMvYXJnbWF4ZXF1YWxzLnRzIiwic3JjL29wcy9jb25jYXQzZC50cyIsInNyYy9vcHMvY29udm9sdXRpb24udHMiLCJzcmMvb3BzL2RpdmlkZS50cyIsInNyYy9vcHMvZWxlbWVudF93aXNlX2FjdGl2YXRpb24udHMiLCJzcmMvb3BzL2VsZW1lbnRfd2lzZV9jb3N0LnRzIiwic3JjL29wcy9leHAudHMiLCJzcmMvb3BzL2xpbmVhcl9jb21iaW5hdGlvbi50cyIsInNyYy9vcHMvbG9nLnRzIiwic3JjL29wcy9tYXRtdWwudHMiLCJzcmMvb3BzL21heF9wb29sLnRzIiwic3JjL29wcy9tdWx0aXBseS50cyIsInNyYy9vcHMvb3AudHMiLCJzcmMvb3BzL3JlZHVjZV9zdW0udHMiLCJzcmMvb3BzL3Jlc2hhcGUudHMiLCJzcmMvb3BzL3NvZnRtYXgudHMiLCJzcmMvb3BzL3NwbGl0LnRzIiwic3JjL29wcy9zdWJ0cmFjdC50cyIsInNyYy9vcHRpbWl6ZXIudHMiLCJzcmMvcHJpb3JpdHlfcXVldWUudHMiLCJzcmMvc2Vzc2lvbi50cyIsInNyYy9zZXNzaW9uX3V0aWwudHMiLCJzcmMvc2dkX29wdGltaXplci50cyIsInNyYy90ZW5zb3JfYXJyYXlfbWFwLnRzIiwic3JjL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQ2lCQSxrQ0FBNkI7Ozs7O0FDRjdCLDhDQUNrQztBQUVsQyxJQUFNLEtBQUssR0FBTyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFBO0FBRTdDLElBQU0sS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLEVBQUMsVUFBVSxFQUFHLENBQUMsRUFBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUE7QUFHcEQsS0FBSyxDQUFDLElBQUksQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUM5RCxJQUFNLE1BQU0sR0FBRyxJQUFJLDhCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUE7QUFDaEMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsSUFBUztJQUNqQixRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUE7SUFFekQsV0FBVyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUN6QixZQUFZLENBQUMsSUFBSSxDQUFDLENBQUE7QUFDbkIsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDcEIsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDO0FBQ3hCLElBQU0sSUFBSSxHQUFHLElBQUksNEJBQWMsRUFBRSxDQUFDO0FBRWxDLElBQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUN2QixJQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDdkIsSUFBSSxVQUFVLEdBQUcsVUFBVSxDQUFBO0FBRTNCLHNCQUFzQixJQUFTO0lBRTlCLElBQU0sV0FBVyxHQUFHLElBQUksQ0FDdkIsa0RBQWtELENBQVksQ0FBQztJQUNoRSxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQ3JCLGdEQUFnRCxDQUFZLENBQUM7SUFFOUQsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUN2QixrREFBa0QsQ0FBWSxDQUFDO0lBQ2hFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FDckIsZ0RBQWdELENBQVksQ0FBQztJQUU5RCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQ3ZCLGtEQUFrRCxDQUFZLENBQUM7SUFDaEUsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUNyQixnREFBZ0QsQ0FBWSxDQUFDO0lBRTlELElBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHdCQUF3QixDQUFZLENBQUM7SUFDdkUsSUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQVksQ0FBQztJQUl6RSxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUs7UUFDdEIsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLG9CQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQ2pFLFNBQVMsQ0FBQyxDQUFDO1FBQ2IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQ2pFLFNBQVMsQ0FBQyxDQUFDO1FBQ2IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQ2pFLFNBQVMsQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLEdBQUc7WUFDTixLQUFLLENBQUMscUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELEtBQUssQ0FBQyxxQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsS0FBSyxDQUFDLHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoRCxDQUFDO1FBQ0osSUFBSSxDQUFDLEdBQUc7WUFDTixLQUFLLENBQUMscUJBQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pELEtBQUssQ0FBQyxxQkFBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsS0FBSyxDQUFDLHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoRCxDQUFDO1FBRUosSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFHOUIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUMsQ0FBQztZQUM3QixJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXJFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDZCxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWQsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLHFCQUFxQixDQUFDLENBQUM7WUFDbkUsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztZQUU5RCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQzVDLElBQU0sYUFBYSxHQUFHLGlCQUFpQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUV2RCxVQUFVLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDMUIsVUFBVSxHQUFHLGFBQWEsQ0FBQTtZQUcxQixLQUFLLEdBQUcsS0FBSyxDQUFDLHFCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDL0IsQ0FBQztJQUNGLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBTSxLQUFLLEdBQUcsV0FBVyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUN2QyxVQUFVLENBQUMsY0FBTSxPQUFBLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBbEIsQ0FBa0IsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLENBQUE7QUFDbkQsQ0FBQztBQUdELElBQU0sY0FBYyxHQUFHLENBQUMsQ0FBQztBQUN6QixJQUFNLGNBQWMsR0FBRyxHQUFHLENBQUM7QUFDM0IsSUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLElBQU0sZUFBZSxHQUFHLEdBQUcsQ0FBQztBQUM1QixJQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQztBQUU3QixJQUFNLFlBQVksR0FBRztJQUNqQixDQUFDLFNBQVMsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDO0lBQzNDLENBQUMsVUFBVSxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUM7SUFDNUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxFQUFFLGVBQWUsQ0FBQztJQUNsQyxDQUFDLGlCQUFpQixFQUFFLENBQUMsRUFBRSxhQUFhLENBQUM7Q0FDeEMsQ0FBQztBQUVGLG9CQUFvQixLQUFhO0lBQ2hDLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNmLEdBQUcsQ0FBQSxDQUFxQixVQUFZLEVBQVosNkJBQVksRUFBWiwwQkFBWSxFQUFaLElBQVk7UUFBaEMsSUFBTSxVQUFVLHFCQUFBO1FBQ25CLElBQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQVcsQ0FBQztRQUMxQyxJQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFXLENBQUM7UUFDekMsSUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBVyxDQUFDO1FBQ3pDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sR0FBRyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUM5RCxFQUFFLENBQUMsQ0FBQyxTQUFTLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDN0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLE1BQU0sRUFBRSxXQUFXLEVBQUUsZUFBZSxDQUFDLENBQUE7WUFDbkUsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQztnQkFDckMsTUFBTSxDQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQTtZQUNqRCxDQUFDO1lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsS0FBSyxZQUFZLENBQUMsQ0FBQyxDQUFDO2dCQUN2QyxXQUFXLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLGdCQUFnQixDQUFBO2dCQUN0RCxNQUFNLENBQUMsV0FBVyxDQUFBO1lBQ25CLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsU0FBUyxLQUFLLGlCQUFpQixDQUFDLENBQUMsQ0FBQztnQkFDNUMsZUFBZSxHQUFHLENBQUMsS0FBSyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxhQUFhLENBQUMsQ0FBQTtnQkFDdkUsZUFBZSxHQUFHLGVBQWUsR0FBQyxHQUFHLENBQUE7Z0JBQ3JDLE1BQU0sQ0FBQyxlQUFlLENBQUE7WUFDdkIsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLEdBQUcsU0FBUyxDQUFDLENBQUM7WUFDN0QsQ0FBQztRQUNGLENBQUM7UUFDRCxNQUFNLElBQUksUUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7S0FDbEM7SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixHQUFHLEtBQUssQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUFNRCwyQkFBMkIsSUFBaUIsRUFBRSxPQUFnQjtJQUM3RCxJQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDMUMsSUFBTSxJQUFJLEdBQUcsb0JBQU0sQ0FBQyxXQUFXLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNoRCxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDWixHQUFHLENBQUEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUM5QyxHQUFHLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDVixDQUFDO0lBQ0YsQ0FBQztJQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztBQUNuRCxDQUFDOzs7QUN6S0Q7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3g1dEJBLDBDQUF1QztBQWlCdkMsSUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFD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QUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBTSxVQUFVLEdBQUcsS0FBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2pELElBQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWxFLElBQU0sUUFBUSxHQUFHLEtBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3JELElBQU0sR0FBRyxHQUFHLEtBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBWSxDQUFDO1lBR3BELElBQU0sQ0FBQyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEUsSUFBTSxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQ2pELENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBTSxDQUFDLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFD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LFFBQVEsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO2dCQUMxQixJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUM1RCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQztnQkFFL0QsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7b0JBQ3ZDLElBQU0sUUFBUSxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUM7b0JBQzFCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQzVELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDO29CQUUvRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7b0JBQ2hCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7d0JBQ3RDLElBQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxVQUFVLEdBQUcsUUFBUSxDQUFDO3dCQUV0QyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDOzRCQUN0QyxJQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsVUFBVSxHQUFHLFFBQVEsQ0FBQzs0QkFFdEMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxlQUFlLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztnQ0FDNUMsSUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dDQUNoQyxJQUFNLE1BQU0sR0FDUixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztnQ0FDeEQsT0FBTyxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUM7NEJBQzVCLENBQUM7d0JBQ0gsQ0FBQztvQkFDSCxDQUFDO29CQUNELElBQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2pELENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNwQyxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFDRCxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQU1TLGtEQUF5QixHQUFuQyxVQUNJLENBQVUsRUFBRSxXQUFvQixFQUFFLFVBQWtCLEVBQ3BELE9BQWU7UUFDakIsSUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxJQUFNLEdBQUcsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUNoQyxJQUFNLGNBQWMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLElBQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsSUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixJQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBR3pCLElBQU0sWUFBWSxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFDbEQsSUFBTSxZQUFZLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsQ0FBQztRQUVsRCxJQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQzlDLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxlQUFlLENBQUMsRUFBRSxLQUFLLEVBQUUsY0FBYyxFQUFFLENBQUMsRUFDdkUsR0FBRyxDQUFDLENBQUM7UUFDVCxJQUFNLENBQUMsR0FBRyxpQkFBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUVyQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO1lBQzNDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUN2QyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztvQkFFdkMsSUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztvQkFDMUIsSUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQztvQkFDMUIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO29CQUNoQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO3dCQUNsQyxJQUFNLEVBQUUsR0FBRyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7d0JBQ3hDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7NEJBQ25ELFFBQVEsQ0FBQzt3QkFDWCxDQUFDO3dCQUNELEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7NEJBQ2xDLElBQU0sRUFBRSxHQUFHLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQzs0QkFDeEMsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztnQ0FDbkQsUUFBUSxDQUFDOzRCQUNYLENBQUM7NEJBQ0QsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxlQUFlLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztnQ0FDNUMsSUFBTSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dDQUNoQyxJQUFNLE1BQU0sR0FDUixXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLEtBQUssR0FBRyxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztnQ0FDNUQsT0FBTyxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUM7NEJBQzVCLENBQUM7d0JBQ0gsQ0FBQztvQkFDSCxDQUFDO29CQUNELENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQzdCLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztRQUNELE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQseUNBQWdCLEdBQWhCLFVBQ0ksQ0FBVSxFQUFFLEVBQVcsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUN0RCxPQUFlO1FBQ2pCLElBQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUIsSUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxJQUFNLFlBQVksR0FDZCxTQUFTLENBQUMscUJBQXFCLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNwRSxJQUFNLEVBQUUsR0FBRyxpQkFBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV2QyxJQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdCLElBQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTVCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDbEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzlELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztZQUVyRSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0JBQzlELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztnQkFFckUsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztvQkFDdkMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQzt3QkFFeEMsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO3dCQUNoQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDOzRCQUN0QyxJQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLE1BQU0sR0FBRyxPQUFPLENBQUM7NEJBQ3RDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0NBQ3RDLElBQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztnQ0FDdEMsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7NEJBQ3BELENBQUM7d0JBQ0gsQ0FBQzt3QkFDRCxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFDbEMsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELHNDQUFhLEdBQWIsVUFBYyxFQUFXO1FBQ3ZCLElBQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEMsSUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFNLE9BQU8sR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLElBQU0sTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsV0FBVyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7WUFDeEMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQ1osR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDakMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztvQkFDakMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDMUIsQ0FBQztZQUNILENBQUM7WUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ25CLENBQUM7UUFDRCxNQUFNLENBQUMsaUJBQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVTLDBDQUFpQixHQUEzQixVQUErQyxDQUFJLEVBQUUsTUFBZ0I7UUFDbkUsSUFBTSxRQUFRLEdBQWEsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3pDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFDRCxJQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzdCLElBQU0sTUFBTSxHQUFHLGlCQUFPLENBQUMsSUFBSSxDQUFJLFFBQVEsRUFBRSxFQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUMsQ0FBQyxDQUFDO1FBQ2pFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ2hDLElBQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFHNUIsSUFBTSxNQUFNLEdBQWEsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQy9DLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBQyxHQUFHLENBQUMsRUFBRSxHQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxHQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUN2QyxNQUFNLENBQUMsR0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdCLENBQUM7WUFFRCxJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVPLDZCQUFJLEdBQVosVUFDSSxDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFBRSxHQUFXLEVBQ3RELFFBQTJCO1FBQ3ZCLElBQUEsWUFBK0IsRUFBOUIsYUFBSyxFQUFFLGFBQUssRUFBRSxhQUFLLENBQVk7UUFDdEMsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUM5QyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdEQsSUFBTSxDQUFDLEdBQUcsaUJBQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDckMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUMvQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztnQkFDdkMsSUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7Z0JBQ25DLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUNwQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUM7Z0JBQ2hELEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO29CQUN2QyxJQUFNLFFBQVEsR0FBRyxFQUFFLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQztvQkFDbkMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQ3BDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQztvQkFHaEQsSUFBSSxXQUFXLEdBQ1gsQ0FBQyxRQUFRLEtBQUssS0FBSyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUI7d0JBQ3hCLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUNwRCxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7b0JBRWpCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7d0JBQ3RDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7NEJBQ3RDLElBQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDL0IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FDakIsV0FBVyxHQUFHLEdBQUcsQ0FBQztnQ0FDbEIsUUFBUSxHQUFHLEdBQUcsQ0FBQztnQ0FDZixLQUFLLENBQUM7NEJBQ1IsQ0FBQzs0QkFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsS0FBSyxLQUFLLElBQUksS0FBSyxHQUFHLFdBQVcsQ0FBQztnQ0FDM0MsQ0FBQyxRQUFRLEtBQUssS0FBSyxJQUFJLEtBQUssR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQ2hELFdBQVcsR0FBRyxLQUFLLENBQUM7NEJBQ3RCLENBQUM7NEJBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dDQUM5QixRQUFRLElBQUksS0FBSyxHQUFHLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDOzRCQUN0QyxDQUFDO3dCQUNILENBQUM7d0JBQ0QsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFDdkIsS0FBSyxDQUFDO3dCQUNSLENBQUM7b0JBQ0gsQ0FBQztvQkFDRCxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsS0FBSyxLQUFLLEdBQUcsUUFBUSxHQUFHLFdBQVcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNoRSxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFDRCxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUVTLHdDQUFlLEdBQXpCLFVBQ0ksQ0FBVSxFQUFFLEtBQWEsRUFBRSxNQUFjLEVBQUUsR0FBVztRQUN4RCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVELHlDQUFnQixHQUFoQixVQUFpQixDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFBRSxHQUFXO1FBQy9ELElBQUEsWUFBK0IsRUFBOUIsYUFBSyxFQUFFLGFBQUssRUFBRSxhQUFLLENBQVk7UUFDdEMsSUFBTSxXQUFXLEdBQ2IsU0FBUyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDdkUsSUFBTSxZQUFZLEdBQUcsaUJBQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDaEQsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUMvQixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2dCQUMzQyxJQUFNLFFBQVEsR0FBRyxFQUFFLEdBQUcsTUFBTSxHQUFHLEdBQUcsQ0FBQztnQkFDbkMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3BDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxRQUFRLENBQUMsQ0FBQztnQkFDaEQsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztvQkFDM0MsSUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7b0JBQ25DLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO29CQUNwQyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUM7b0JBQ2hELElBQUksUUFBUSxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztvQkFDeEMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3JCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7d0JBQ3RDLElBQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUM7d0JBQ3pCLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7NEJBQ3RDLElBQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUM7NEJBQ3pCLElBQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDL0IsRUFBRSxDQUFDLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0NBQ3JCLFFBQVEsR0FBRyxLQUFLLENBQUM7Z0NBQ2pCLFdBQVcsR0FBRyxFQUFFLEdBQUcsS0FBSyxHQUFHLEVBQUUsQ0FBQzs0QkFDaEMsQ0FBQzt3QkFDSCxDQUFDO29CQUNILENBQUM7b0JBQ0QsWUFBWSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDM0MsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBQ0QsTUFBTSxDQUFDLFlBQVksQ0FBQztJQUN0QixDQUFDO0lBRVMsZ0RBQXVCLEdBQWpDLFVBQ0ksRUFBVyxFQUFFLENBQVUsRUFBRSxLQUFhLEVBQUUsVUFBa0IsRUFDMUQsT0FBZTtRQUNqQixJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDMUUsSUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDMUIsSUFBQSxhQUFrQyxFQUFqQyxjQUFNLEVBQUUsY0FBTSxFQUFFLGFBQUssQ0FBYTtRQUd6QyxJQUFNLGFBQWEsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3BELElBQU0sYUFBYSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUM7UUFFcEQsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUM5QyxDQUFDLGFBQWEsRUFBRSxhQUFhLEVBQUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDakUsSUFBTSxFQUFFLEdBQUcsaUJBQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdEMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUMvQixHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQztnQkFDM0MsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUM7b0JBRTNDLElBQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7b0JBQzVCLElBQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7b0JBQzVCLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQztvQkFDaEIsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQzt3QkFDbEMsSUFBTSxHQUFHLEdBQUcsQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDO3dCQUMxQyxFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUN4RCxRQUFRLENBQUM7d0JBQ1gsQ0FBQzt3QkFDRCxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDOzRCQUNsQyxJQUFNLEdBQUcsR0FBRyxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUM7NEJBQzFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxJQUFJLE1BQU0sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0NBQ3hELFFBQVEsQ0FBQzs0QkFDWCxDQUFDOzRCQUNELElBQU0sTUFBTSxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQzs0QkFDakUsSUFBTSxNQUFNLEdBQUcsRUFBRSxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUM7NEJBRS9CLElBQU0sSUFBSSxHQUFHLE1BQU0sS0FBSyxNQUFNLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzs0QkFDdkMsRUFBRSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQ2YsUUFBUSxDQUFDOzRCQUNYLENBQUM7NEJBRUQsSUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUNsQyxPQUFPLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQzt3QkFDMUIsQ0FBQztvQkFDSCxDQUFDO29CQUNELEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztRQUNELE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRVMsd0NBQWUsR0FBekIsVUFDSSxDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFBRSxHQUFXO1FBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRVMsd0NBQWUsR0FBekIsVUFDSSxDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFBRSxHQUFXO1FBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRVMsaURBQXdCLEdBQWxDLFVBQ0ksQ0FBVSxFQUFFLFVBQTRCLEVBQ3hDLFlBQXFCO1FBQ3ZCLElBQU0sTUFBTSxHQUFHLGlCQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV6RSxJQUFNLGtCQUFrQixHQUNwQixZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUMxRSxJQUFNLG1CQUFtQixHQUFHLFlBQVk7WUFDcEMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDakIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDekMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQ3pDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO29CQUl6QyxJQUFNLGFBQWEsR0FDZixDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDM0QsSUFBTSxhQUFhLEdBQ2YsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRTNELElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQ2pELElBQU0sYUFBYSxHQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO29CQUN2RCxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNqRCxJQUFNLGFBQWEsR0FDZixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztvQkFFdkQsSUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUN6RCxJQUFNLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQzNELElBQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDekQsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUUzRCxJQUFNLE9BQU8sR0FBRyxhQUFhLEdBQUcsY0FBYyxDQUFDO29CQUMvQyxJQUFNLE9BQU8sR0FBRyxhQUFhLEdBQUcsY0FBYyxDQUFDO29CQUUvQyxJQUFNLEtBQUcsR0FBRyxPQUFPLEdBQUcsQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO29CQUNyRCxJQUFNLE1BQU0sR0FBRyxVQUFVLEdBQUcsQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDLEdBQUcsT0FBTyxDQUFDO29CQUNqRSxJQUFNLFFBQVEsR0FBRyxLQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsS0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDO29CQUVoRCxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNoQyxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFFRCxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFUyxxREFBNEIsR0FBdEMsVUFDSSxDQUFVLEVBQUUsSUFBcUIsRUFBRSxRQUF5QixFQUM1RCxlQUFzQixFQUFFLEtBQXVCLEVBQy9DLE1BQXdCO1FBRHhCLGdDQUFBLEVBQUEsc0JBQXNCO1FBRXhCLElBQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUM5QixJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDcEMsSUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzVDLElBQU0sV0FBVyxHQUFHLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RFLElBQU0sWUFBWSxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pFLElBQU0sU0FBUyxHQUFHLElBQUksWUFBWSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVuRCxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUN4QyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDO2dCQUNoRCxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDNUMsV0FBVyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDO29CQUNuQyxJQUFJLENBQUMsSUFBSSxDQUNMLGNBQWMsQ0FBQyxDQUFDLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxNQUFNLENBQUMsaUJBQU8sQ0FBQyxJQUFJLENBQVUsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFDSCxxQkFBQztBQUFELENBdHlCQSxBQXN5QkMsQ0F0eUJtQyxrQkFBVyxHQXN5QjlDO0FBdHlCWSx3Q0FBYzs7Ozs7Ozs7Ozs7Ozs7O0FDUjNCLDhCQUFnQztBQUVoQywrQ0FBaUQ7QUFDakQsdUNBQXlDO0FBQ3pDLCtCQUFzRDtBQUN0RCxtQ0FBcUM7QUFDckMscUNBQThFO0FBQzlFLDJEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0QsdURBQXVEO0FBQ3ZELG1EQUFxRDtBQUNyRCxxREFBdUQ7QUFDdkQsbURBQXFEO0FBQ3JELDZEQUErRDtBQUMvRCwyQ0FBNkM7QUFDN0MsMkNBQTZDO0FBQzdDLHVEQUFtRDtBQUNuRCxxREFBcUQ7QUFFckQsK0NBQWlEO0FBQ2pELCtDQUFpRDtBQUNqRCx1REFBdUQ7QUFDdkQscUVBQXVFO0FBQ3ZFLG1EQUFxRDtBQUNyRCxtREFBcUQ7QUFDckQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCwyQ0FBNkM7QUFDN0MsdURBQXVEO0FBQ3ZELGlEQUFtRDtBQUNuRCxpRUFBbUU7QUFDbkUsMkRBQXVEO0FBQ3ZELCtDQUFpRDtBQUNqRCxtREFBNEQ7QUFFNUQsSUFBTSxjQUFjLEdBQUcsV0FBVyxDQUFDO0FBRW5DLElBQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQztBQUN6QixJQUFNLFdBQVcsR0FBRyxRQUFRLENBQUM7QUFHN0IsSUFBTSxtQkFBbUIsR0FBRyxjQUFjLENBQUM7QUFHM0MsSUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDO0FBRy9CLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUMzQixJQUFNLHFCQUFxQixHQUFHLGdCQUFnQixDQUFDO0FBQy9DLElBQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDO0FBQ3JDLElBQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDO0FBQ3JDLElBQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQztBQUNoQyxJQUFNLHVCQUF1QixHQUFHLGNBQWMsQ0FBQztBQUMvQyxJQUFNLHNCQUFzQixHQUFHLGtCQUFrQixDQUFDO0FBQ2xELElBQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQztBQUNoQyxJQUFNLGFBQWEsR0FBRyxTQUFTLENBQUM7QUFFaEMsSUFBTSxvQkFBb0IsR0FBRyxhQUFhLENBQUM7QUFFM0MsNkJBQ0ksaUJBQW1DLEVBQUUsZ0JBQWtDLEVBQ3ZFLGNBQWdDO0lBQ2xDLElBQU0sU0FBUyxHQUFNLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxTQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBRyxDQUFDO0lBQ3BFLElBQU0sV0FBVyxHQUFNLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxTQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBRyxDQUFDO0lBQ3BFLElBQU0sV0FBVyxHQUFNLGNBQWMsQ0FBQyxDQUFDLENBQUMsU0FBSSxjQUFjLENBQUMsQ0FBQyxDQUFHLENBQUM7SUFDaEUsTUFBTSxDQUFJLFNBQVMsU0FBSSxTQUFTLFNBQUksV0FBVyxTQUFJLFdBQWEsQ0FBQztBQUNuRSxDQUFDO0FBRUQ7SUFBb0Msa0NBQVc7SUFPN0Msd0JBQVksS0FBb0IsRUFBRSxRQUFlO1FBQWYseUJBQUEsRUFBQSxlQUFlO1FBQWpELFlBQ0Usa0JBQU0sUUFBUSxDQUFDLFNBYWhCO1FBbEJPLGtCQUFZLEdBQWtDLEVBQUUsQ0FBQztRQUNqRCxpQkFBVyxHQUFpQyxFQUFFLENBQUM7UUFLckQsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDbEIsSUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixFQUFFLENBQUM7WUFDM0MsS0FBSSxDQUFDLEtBQUssR0FBRyxJQUFJLDRCQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDbEMsS0FBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztRQUNsQyxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixLQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztZQUNuQixLQUFJLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDO1FBQ25DLENBQUM7UUFFRCxLQUFJLENBQUMsY0FBYyxHQUFHLElBQUksZ0NBQWMsQ0FBQyxLQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFckQsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFJLENBQUMsS0FBSyxFQUFFLEtBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQzs7SUFDekQsQ0FBQztJQUVELHdDQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRVMsc0NBQWEsR0FBdkIsVUFBMkMsT0FBVTtRQUNuRCxJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUNuRCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQ2xDLG1CQUFtQixDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLEVBQ25FLGNBQU0sT0FBQSxRQUFRLENBQUMsdUJBQXVCLENBQ2xDLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLEVBRDdDLENBQzZDLENBQUMsQ0FBQztRQUV6RCxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV6RSxRQUFRLENBQUMsSUFBSSxDQUNULElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ2pFLGNBQWMsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRTNFLE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxjQUFjLGdCQUFBLEVBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFUyx3Q0FBZSxHQUF6QixVQUNJLE9BQVcsRUFBRSxRQUFrQjtRQUNqQyxJQUFJLFdBQTZCLENBQUM7UUFFbEMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDeEIsS0FBSyxDQUFDO2dCQUNKLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDckIsS0FBSyxDQUFDO1lBQ1IsS0FBSyxDQUFDO2dCQUNKLFdBQVcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDL0IsS0FBSyxDQUFDO1lBQ1IsS0FBSyxDQUFDO2dCQUNKLFdBQVcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDekMsS0FBSyxDQUFDO1lBQ1IsS0FBSyxDQUFDO2dCQUNKLFdBQVcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZELEtBQUssQ0FBQztZQUNSO2dCQUNFLE1BQU0sS0FBSyxDQUNQLG1CQUFpQixRQUFRLENBQUMsTUFBTSw2QkFBMEI7b0JBQzFELGtCQUFrQixDQUFDLENBQUM7UUFDNUIsQ0FBQztRQUVELElBQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM5RCxJQUFJLFdBQWUsQ0FBQztRQUNwQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuRCxXQUFXLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDMUQsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsQ0FBQztRQUNELE1BQU0sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFLLFFBQVEsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFUyx3Q0FBZSxHQUF6QixVQUNJLEtBQWMsRUFBRSxXQUE2QixFQUM3QyxVQUE0QjtRQUM5QixJQUFNLE1BQU0sR0FBRyxpQkFBTyxDQUFDLElBQUksQ0FBVSxVQUFVLEVBQUU7WUFDL0MsT0FBTyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQztZQUN2RCxjQUFjLEVBQUUsVUFBVTtTQUMzQixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsY0FBYyxDQUNmLEtBQUssRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNoRSxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFUyx1Q0FBYyxHQUF4QixVQUNJLE1BQWUsRUFBRSxpQkFBbUMsRUFDcEQsZ0JBQWtDLEVBQUUsSUFBYSxFQUNqRCxlQUFpQyxFQUNqQyxjQUFnQztRQUNsQyxJQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUNqRCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM3QyxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQ2xDLG1CQUFtQixDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsRUFDcEUsY0FBTSxPQUFBLFFBQVEsQ0FBQyx1QkFBdUIsQ0FDbEMsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGNBQWMsQ0FBQyxFQUQ5QyxDQUM4QyxDQUFDLENBQUM7UUFFMUQsUUFBUSxDQUFDLElBQUksQ0FDVCxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsVUFBVSxFQUFFLEVBQUUsYUFBYSxFQUN2RCxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUUsV0FBVyxFQUNuRSxlQUFlLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVTLHlDQUFnQixHQUExQixVQUEyQixFQUFXLEVBQUUsRUFBVyxFQUFFLElBQVk7UUFDL0QsSUFBTSxZQUFZLEdBQ2QsU0FBUyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QyxJQUFNLFlBQVksR0FDZCxTQUFTLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBSTlDLElBQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzVELElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RELEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUMzQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ25CLENBQUM7UUFDRCxJQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM1RCxJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdEIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0RCxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsWUFBWSxDQUFDLENBQUM7WUFDM0MsU0FBUyxHQUFHLElBQUksQ0FBQztRQUNuQixDQUFDO1FBRUQsSUFBTSxjQUFjLEdBQ2hCLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdkUsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUMvQixXQUFXLFNBQUksRUFBRSxDQUFDLEtBQUssU0FBSSxFQUFFLENBQUMsS0FBSyxTQUFJLElBQU0sRUFDaEQsY0FBTSxPQUFBLFlBQVksQ0FBQyx1QkFBdUIsQ0FDdEMsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFEdkMsQ0FDdUMsQ0FBQyxDQUFDO1FBRW5ELElBQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUN2RSxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVyRSxZQUFZLENBQUMsUUFBUSxDQUNqQixJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLFNBQVMsRUFDaEUsY0FBYyxDQUFDLENBQUM7UUFFcEIsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNkLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ2QsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsQ0FBQztRQUVELE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixjQUFjLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFUywrQ0FBc0IsR0FBaEMsVUFDSSxFQUFVLEVBQUUsQ0FBSSxFQUFFLEVBQVUsRUFBRSxDQUFJO1FBQ3BDLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO1lBQ2xELFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FDbEMsbUJBQW1CLEVBQUUsY0FBTSxPQUFBLGdCQUFnQixDQUFDLHVCQUF1QixFQUFFLEVBQTFDLENBQTBDLENBQUMsQ0FBQztRQUUzRSxJQUFNLGNBQWMsR0FBRyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM3QyxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV6RSxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FDOUIsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQ3RFLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBRXhFLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZCxDQUFDO1FBRUQsTUFBTSxDQUFDLGlCQUFPLENBQUMsSUFBSSxDQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLGNBQWMsZ0JBQUEsRUFBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUVTLG9DQUFXLEdBQXJCLFVBQXlDLENBQUk7UUFDM0MsSUFBTSxPQUFPLEdBQUcsSUFBSSw0QkFBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUscUJBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6RCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBTyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFTyx3Q0FBZSxHQUF2QixVQUEyQyxLQUFlO1FBQ3hELElBQU0sY0FBYyxHQUNoQixVQUFVLENBQUMsK0JBQStCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckUsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbkUsTUFBTSxDQUFDLGlCQUFPLENBQUMsSUFBSSxDQUFJLEtBQUssRUFBRSxFQUFDLE9BQU8sU0FBQSxFQUFFLGNBQWMsZ0JBQUEsRUFBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVPLHNDQUFhLEdBQXJCLFVBQ0ksT0FBcUIsRUFBRSxNQUFXO1FBRHRDLGlCQVNDO1FBUEMsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBSSxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDNUQsSUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUU7WUFDeEMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVPLHVDQUFjLEdBQXRCLFVBQTBDLENBQUksRUFBRSxlQUUvQztRQUNDLElBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXhDLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FDbEMsWUFBWSxFQUFFLGNBQU0sT0FBQSxXQUFXLENBQUMsdUJBQXVCLEVBQUUsRUFBckMsQ0FBcUMsQ0FBQyxDQUFDO1FBRS9ELElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzFFLFdBQVcsQ0FBQyxPQUFPLENBQ2YsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQy9ELGFBQWEsRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFM0QsTUFBTSxDQUFDLGlCQUFPLENBQUMsSUFBSSxDQUNmLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFUyx1Q0FBYyxHQUF4QixVQUNJLENBQVUsRUFBRSxDQUFVLEVBQUUsWUFBK0IsRUFDdkQsWUFBK0I7UUFDakMsSUFBTSxPQUFPLEdBQUcsSUFBSSwwQkFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxZQUFZLEVBQzVELFlBQVksQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFtQixPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRVMseUNBQWdCLEdBQTFCLFVBQThDLENBQUksRUFBRSxDQUFJO1FBQ3RELElBQU0sT0FBTyxHQUFHLElBQUksOEJBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0QsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQU8sT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVTLHFEQUE0QixHQUF0QyxVQUNJLENBQVUsRUFBRSxJQUFxQixFQUFFLFFBQXlCLEVBQzVELGVBQXVCLEVBQUUsS0FBdUIsRUFDaEQsTUFBd0I7UUFDMUIsSUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFeEMsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQU0scUJBQXFCLEdBQ3ZCLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7UUFDakQsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDakUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUscUJBQXFCLENBQUMsQ0FBQztZQUN4RCxZQUFZLEdBQUcscUJBQXFCLENBQUM7WUFDckMsV0FBVyxHQUFHLElBQUksQ0FBQztRQUNyQixDQUFDO1FBRUQsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBQzVCLElBQU0seUJBQXlCLEdBQzNCLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7UUFDekQsSUFBSSxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsaUJBQWlCLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUN6RSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUseUJBQXlCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkUsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLHlCQUF5QixDQUFDLENBQUM7WUFDcEUsZ0JBQWdCLEdBQUcseUJBQXlCLENBQUM7WUFDN0MsZUFBZSxHQUFHLElBQUksQ0FBQztRQUN6QixDQUFDO1FBRUQsSUFBSSxhQUFhLEdBQTBCLElBQUksQ0FBQztRQUNoRCxJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDekIsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDbEIsSUFBTSxzQkFBc0IsR0FDeEIsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQztZQUVuRCxhQUFhLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixDQUFDLHNCQUFzQixDQUFDLENBQUM7WUFDaEUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0QsS0FBSyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLHNCQUFzQixDQUFDLENBQUM7Z0JBQzNELGFBQWEsR0FBRyxzQkFBc0IsQ0FBQztnQkFDdkMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUN0QixDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksY0FBYyxHQUEwQixJQUFJLENBQUM7UUFDakQsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBQzFCLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ25CLElBQU0sdUJBQXVCLEdBQ3pCLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUM7WUFFckQsY0FBYyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ25FLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUUsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9ELE1BQU0sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO2dCQUM5RCxjQUFjLEdBQUcsdUJBQXVCLENBQUM7Z0JBQ3pDLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDdkIsQ0FBQztRQUNILENBQUM7UUFFRCxJQUFNLGNBQWMsR0FBcUIsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFL0QsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUMvQixjQUFjLFNBQUksU0FBUyxTQUFJLFlBQVksU0FBSSxnQkFBZ0IsTUFBRzthQUM5RCxhQUFjLFNBQUksY0FBZSxTQUFJLGVBQWlCLENBQUEsRUFDN0QsY0FBTSxPQUFBLGFBQWEsQ0FBQyx1QkFBdUIsQ0FDdkMsU0FBUyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQ3pELGFBQWEsRUFBRSxlQUFlLENBQUMsRUFGN0IsQ0FFNkIsQ0FBQyxDQUFDO1FBRXpDLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXpFLGFBQWEsQ0FBQyxrQkFBa0IsQ0FDNUIsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQ2pFLFlBQVksRUFBRSxRQUFRLENBQUMsVUFBVSxFQUFFLEVBQUUsZ0JBQWdCLEVBQ3JELE1BQU0sSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxHQUFHLElBQUksRUFDM0MsTUFBTSxJQUFJLElBQUksR0FBRyxjQUFjLEdBQUcsSUFBSSxFQUN0QyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxVQUFVLEVBQUUsR0FBRyxJQUFJLEVBQ3pDLEtBQUssSUFBSSxJQUFJLEdBQUcsYUFBYSxHQUFHLElBQUksRUFBRSxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFFekUsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNoQixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7WUFDcEIsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3JCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLEtBQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQixDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUNsQixNQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVELE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRVMsMENBQWlCLEdBQTNCLFVBQStDLENBQUksRUFBRSxNQUFnQjtRQUNuRSxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVTLG9DQUFXLEdBQXJCLFVBQXNCLENBQVU7UUFDOUIsSUFBTSxPQUFPLEdBQUcsSUFBSSxnQ0FBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0MsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRVMsdUNBQWMsR0FBeEIsVUFBeUIsQ0FBVTtRQUNqQyxJQUFNLE9BQU8sR0FBRyxJQUFJLGdDQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDcEQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRVMsdUNBQWMsR0FBeEIsVUFBeUIsQ0FBVTtRQUNqQyxJQUFNLE9BQU8sR0FBRyxJQUFJLGdDQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDcEQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRVMsNkNBQW9CLEdBQTlCLFVBQStCLEVBQVcsRUFBRSxFQUFXO1FBQ3JELElBQU0sT0FBTyxHQUFHLElBQUksc0NBQW1CLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVTLHFDQUFZLEdBQXRCLFVBQXVCLE9BQWdCLEVBQUUsQ0FBUztRQUVoRCxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVTLG9DQUFXLEdBQXJCLFVBQXNCLENBQVU7UUFDOUIsSUFBTSxPQUFPLEdBQUcsSUFBSSwwQkFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDakQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRVMsb0NBQVcsR0FBckIsVUFBc0IsQ0FBVTtRQUM5QixJQUFNLE9BQU8sR0FBRyxJQUFJLDBCQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNqRCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFUyx1Q0FBYyxHQUF4QixVQUE0QyxDQUFJLEVBQUUsQ0FBSTtRQUNwRCxJQUFNLE9BQU8sR0FBRyxJQUFJLDhCQUFlLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFhLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFUyxvQ0FBVyxHQUFyQixVQUF5QyxDQUFJLEVBQUUsQ0FBSTtRQUNqRCxJQUFNLE9BQU8sR0FBRyxJQUFJLDhCQUFlLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFhLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFUyxvQ0FBVyxHQUFyQixVQUF5QyxDQUFJLEVBQUUsQ0FBSTtRQUNqRCxJQUFNLE9BQU8sR0FBRyxJQUFJLDhCQUFlLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFhLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFUywwQ0FBaUIsR0FBM0IsVUFBNEIsQ0FBVTtRQUNwQyxJQUFNLE9BQU8sR0FBRyxJQUFJLGdDQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFUyxvQ0FBVyxHQUFyQixVQUF5QyxDQUFJO1FBQzNDLElBQU0sT0FBTyxHQUFHLElBQUksNEJBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLHFCQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQU8sT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRVMsb0NBQVcsR0FBckIsVUFBeUMsQ0FBSTtRQUMzQyxJQUFNLE9BQU8sR0FBRyxJQUFJLDRCQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxxQkFBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFPLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVTLHFDQUFZLEdBQXRCLFVBQTBDLENBQUk7UUFDNUMsSUFBTSxPQUFPLEdBQUcsSUFBSSw0QkFBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUscUJBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxRCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBTyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFUyx3Q0FBZSxHQUF6QixVQUE2QyxDQUFJO1FBQy9DLElBQU0sT0FBTyxHQUFHLElBQUksNEJBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLHFCQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0QsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQU8sT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRVMscUNBQVksR0FBdEIsVUFBMEMsQ0FBSTtRQUM1QyxJQUFNLE9BQU8sR0FBRyxJQUFJLDRCQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxxQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFELE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFPLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVTLG9DQUFXLEdBQXJCLFVBQXlDLENBQUk7UUFDM0MsSUFBTSxPQUFPLEdBQUcsSUFBSSw0QkFBYyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUscUJBQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6RCxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBTyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFUyxxQ0FBWSxHQUF0QixVQUEwQyxDQUFJO1FBQzVDLElBQU0sT0FBTyxHQUFHLElBQUksNEJBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLHFCQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQU8sT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRVMsdUNBQWMsR0FBeEIsVUFDSSxDQUFVLEVBQUUsT0FBZ0IsRUFBRSxNQUFvQixFQUFFLE1BQWMsRUFDbEUsT0FBZTtRQUNqQixJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEMsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQyxJQUFNLE9BQU8sR0FBRztZQUNkLFdBQVcsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sSUFBSSxJQUFJO1NBQ3JFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRTtZQUM5QyxNQUFNLENBQUMsUUFBUSxDQUFDLHVCQUF1QixDQUNuQyxDQUFDLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLElBQUksSUFBSSxDQUFDLENBQUM7UUFDeEUsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELElBQU0sU0FBUyxHQUNYLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3pFLElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUlsRSxJQUFNLGVBQWUsR0FBRyxDQUFDLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xELENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN0QyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzdELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xELE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNsRCxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckIsRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDbkIsSUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQy9ELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ25ELFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDbEIsQ0FBQztRQUNILENBQUM7UUFFRCxJQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQzlDLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDdEQsSUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3BFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXJFLFFBQVEsQ0FBQyxRQUFRLENBQ2IsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFDekQsTUFBTSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxFQUFFLEdBQUcsSUFBSSxFQUFFLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUU1RSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMvQixNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbkIsQ0FBQztRQUVELE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixXQUFXLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFUywrQ0FBc0IsR0FBaEMsVUFDSSxDQUFVLEVBQUUsRUFBVyxFQUFFLE9BQWdCLEVBQUUsTUFBYyxFQUN6RCxHQUFXO1FBQ2IsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQixJQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzRCxJQUFNLFNBQVMsR0FDWCxTQUFTLENBQUMsc0JBQXNCLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNyRSxJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBSTVELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFNLGVBQWUsR0FBRyxDQUFDLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3RDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFNLGVBQWUsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDeEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3hDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDNUQsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsQyxJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQ25DLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFnQixNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFbEQsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNiLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNkLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsQ0FBQztRQUNELE1BQU0sQ0FBQyxFQUFDLEVBQUUsSUFBQSxFQUFFLEVBQUUsSUFBQSxFQUFFLEVBQUUsSUFBQSxFQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVTLGdEQUF1QixHQUFqQyxVQUNJLENBQVUsRUFBRSxPQUFnQixFQUFFLE1BQW9CLEVBQUUsVUFBa0IsRUFDdEUsT0FBZTtRQUNqQixJQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLElBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekMsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVuQyxJQUFNLE9BQU8sR0FBRztZQUNkLHFCQUFxQixFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxVQUFVO1lBQ3JFLE9BQU8sRUFBRSxNQUFNLElBQUksSUFBSTtTQUN4QixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNaLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLEVBQUU7WUFDOUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLG9DQUFvQyxDQUN6RCxDQUFDLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFDdkQsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzRCxJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsc0JBQXNCLENBQzlDLGNBQWMsRUFBRSxlQUFlLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDaEQsSUFBTSxZQUFZLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBSXJFLElBQU0sZUFBZSxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3RDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDN0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsT0FBTyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ2xELFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDbEIsQ0FBQztRQUVELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNuQixJQUFNLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUNsRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsa0JBQWtCLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4RCxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ25ELFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDbEIsQ0FBQztRQUNILENBQUM7UUFHRCxJQUFNLFNBQVMsR0FDWCxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNyRSxJQUFNLEdBQUcsR0FBRyxTQUFTLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUNwQyxJQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQzlDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsRUFBRSxTQUFTLEVBQ3hELGNBQWMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDNUIsSUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3BFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXJFLGlCQUFpQixDQUFDLGFBQWEsQ0FDM0IsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFDekQsTUFBTSxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxFQUFFLEdBQUcsSUFBSSxFQUFFLFNBQVMsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUU1RSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixNQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsQ0FBQztRQUVELE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixXQUFXLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCx5Q0FBZ0IsR0FBaEIsVUFDSSxDQUFVLEVBQUUsRUFBVyxFQUFFLEtBQWEsRUFBRSxNQUFjLEVBQ3RELE9BQWU7UUFDakIsSUFBTSxVQUFVLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QixJQUFNLFdBQVcsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLElBQU0sT0FBTyxHQUFHO1lBQ2QsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxPQUFPO1NBQy9ELENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRTtZQUM5QyxNQUFNLENBQUMsaUJBQWlCLENBQUMsaUNBQWlDLENBQ3RELENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEQsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzNELElBQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxvQkFBb0IsQ0FDekMsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNsRCxJQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFJMUQsSUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDdEMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO1FBRUQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQU0sZUFBZSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN4RCxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDeEMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO1FBRUQsSUFBTSxjQUFjLEdBQ2hCLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3JFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXJFLGlCQUFpQixDQUFDLFVBQVUsQ0FDeEIsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxVQUFVLEVBQUUsRUFBRSxTQUFTLEVBQy9ELGNBQWMsQ0FBQyxDQUFDO1FBRXBCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZCxDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNiLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLENBQUM7UUFFRCxJQUFNLFlBQVksR0FDZCxTQUFTLENBQUMscUJBQXFCLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNwRSxNQUFNLENBQUMsaUJBQU8sQ0FBQyxJQUFJLENBQ2YsWUFBWSxFQUFFLEVBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBRUQsc0NBQWEsR0FBYixVQUFjLEVBQVc7UUFDdkIsSUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxJQUFNLE9BQU8sR0FBRyxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkQsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRTtZQUM5QyxNQUFNLENBQUMsaUJBQWlCLENBQUMsOEJBQThCLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BFLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUk1RCxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3hELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xELEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUN4QyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxJQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDcEUsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFckUsaUJBQWlCLENBQUMsT0FBTyxDQUNyQixJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLEVBQUUsU0FBUyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRXJFLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDYixFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZixDQUFDO1FBRUQsTUFBTSxDQUFDLGlCQUFPLENBQUMsSUFBSSxDQUNmLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUMsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFTyw2QkFBSSxHQUFaLFVBQ0ksT0FBcUIsRUFBRSxDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFDaEUsR0FBVztRQUNiLElBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFJM0QsSUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDdEMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO1FBRUQsSUFBTSxXQUFXLEdBQ2IsU0FBUyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzVFLElBQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNwRSxJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUV6RSxRQUFRLENBQUMsVUFBVSxDQUNmLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFFeEUsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNiLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNkLENBQUM7UUFFRCxNQUFNLENBQUMsaUJBQU8sQ0FBQyxJQUFJLENBQ2YsV0FBVyxFQUFFLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRVMsd0NBQWUsR0FBekIsVUFDSSxDQUFVLEVBQUUsS0FBYSxFQUFFLE1BQWMsRUFBRSxHQUFXO1FBQ3hELElBQU0sY0FBYyxHQUNoQixDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNELElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLEVBQUU7WUFDNUQsTUFBTSxDQUFDLFlBQVksQ0FBQyw4QkFBOEIsQ0FDOUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFUyx3Q0FBZSxHQUF6QixVQUNJLENBQVUsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUFFLEdBQVc7UUFDeEQsSUFBTSxjQUFjLEdBQ2hCLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0QsSUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGNBQWMsRUFBRTtZQUM1RCxNQUFNLENBQUMsWUFBWSxDQUFDLDhCQUE4QixDQUM5QyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVTLHdDQUFlLEdBQXpCLFVBQ0ksQ0FBVSxFQUFFLEtBQWEsRUFBRSxNQUFjLEVBQUUsR0FBVztRQUN4RCxJQUFNLGNBQWMsR0FDaEIsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMzRCxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsY0FBYyxFQUFFO1lBQzVELE1BQU0sQ0FBQyxZQUFZLENBQUMsOEJBQThCLENBQzlDLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNuQyxDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRVMsZ0RBQXVCLEdBQWpDLFVBQ0ksRUFBVyxFQUFFLENBQVUsRUFBRSxLQUFhLEVBQUUsVUFBa0IsRUFDMUQsT0FBZTtRQUNqQixJQUFNLHVCQUF1QixHQUFHO1lBQzlCLHVCQUF1QixFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPO1NBQzdELENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1osSUFBTSx1QkFBdUIsR0FDekIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLHVCQUF1QixFQUFFO1lBQzlDLE1BQU0sQ0FBQyxZQUFZLENBQUMsdUNBQXVDLENBQ3ZELENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUMsQ0FBQztRQUVQLElBQU0sa0JBQWtCLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUNyRCxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNyRCxJQUFNLHFCQUFxQixHQUN2QixTQUFTLENBQUMscUJBQXFCLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUN4RCxJQUFNLHlCQUF5QixHQUMzQixJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRzlELElBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0QsSUFBTSxlQUFlLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztRQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsZUFBZSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRCxDQUFDLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDdEMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNsQixDQUFDO1FBRUQsWUFBWSxDQUFDLGFBQWEsQ0FDdEIsSUFBSSxDQUFDLEtBQUssRUFBRSx1QkFBdUIsRUFBRSxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQ25ELHlCQUF5QixFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFFdEQsSUFBTSxzQkFBc0IsR0FBRztZQUM3QixzQkFBc0IsRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTztTQUM3RCxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNaLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxzQkFBc0IsRUFBRTtZQUM3RCxNQUFNLENBQUMscUJBQXFCLENBQUMsZ0NBQWdDLENBQ3pELEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztRQUVILElBQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFJN0QsSUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUQsSUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEQsRUFBRSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1lBQ3pDLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDbkIsQ0FBQztRQUVELElBQU0sV0FBVyxHQUNiLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZFLElBQU0sR0FBRyxHQUFHLEtBQUssR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBQ2hDLElBQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxvQkFBb0IsQ0FDakQsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQ3BFLEdBQUcsQ0FBQyxDQUFDO1FBQ1QsSUFBTSxjQUFjLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3ZFLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXJFLHFCQUFxQixDQUFDLGVBQWUsQ0FDakMsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFDLFVBQVUsRUFBRSxFQUFFLHlCQUF5QixFQUMvRCxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFFL0IsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUNkLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUM5Qix5QkFBeUIsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO1FBRXRELE1BQU0sQ0FBQyxpQkFBTyxDQUFDLElBQUksQ0FDZixjQUFjLEVBQUUsRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFUyxpREFBd0IsR0FBbEMsVUFDSSxDQUFVLEVBQUUsVUFBNEIsRUFDeEMsWUFBcUI7UUFDdkIsSUFBTSxVQUFVLEdBQ1osQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFeEUsSUFBTSxXQUFXLEdBQ2IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQyxJQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFcEUsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUNsQyxVQUFVLEVBQ1YsY0FBTSxPQUFBLG1CQUFtQixDQUFDLHVCQUF1QixDQUM3QyxDQUFDLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxZQUFZLENBQUMsRUFEaEMsQ0FDZ0MsQ0FBQyxDQUFDO1FBRTVDLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXpFLG1CQUFtQixDQUFDLGNBQWMsQ0FDOUIsSUFBSSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFLGFBQWEsRUFBRSxjQUFjLENBQUMsQ0FBQztRQUV4RSxNQUFNLENBQUMsaUJBQU8sQ0FBQyxJQUFJLENBQ2YsV0FBVyxFQUFFLEVBQUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRU8seUNBQWdCLEdBQXhCLFVBQXlCLEdBQVcsRUFBRSxTQUE0QjtRQUVoRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVPLDBDQUFpQixHQUF6QixVQUEwQixVQUFrQixFQUFFLGVBQTZCO1FBRXpFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQztnQkFDekIsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztRQUNsRCxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVPLHlDQUFnQixHQUF4QixVQUF5QixDQUFVLEVBQUUsQ0FBVTtRQUM3QyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUVkLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUVyQixDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQztRQUM3QyxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBRUQsMENBQWlCLEdBQWpCO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDN0IsQ0FBQztJQUVELGdDQUFPLEdBQVA7UUFDRSxHQUFHLENBQUMsQ0FBQyxJQUFNLFVBQVUsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUMzQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pELElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMxRCxDQUFDO1FBQ0gsQ0FBQztRQUNELEdBQUcsQ0FBQyxDQUFDLElBQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDL0QsQ0FBQztRQUNELElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFOUIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3ZCLENBQUM7SUFDSCxDQUFDO0lBQ0gscUJBQUM7QUFBRCxDQWo1QkEsQUFpNUJDLENBajVCbUMsa0JBQVcsR0FpNUI5QztBQWo1Qlksd0NBQWM7Ozs7Ozs7Ozs7Ozs7OztBQ3BFM0IsOEJBQWdDO0FBSWhDLCtDQUFpRDtBQUt0QyxRQUFBLEtBQUssR0FBaUIsSUFBSyxDQUFDO0FBRTVCLFFBQUEsZUFBZSxHQUFtQixJQUFLLENBQUM7QUFXbkQsdUJBQ0ksS0FBbUIsRUFBRSxjQUE4QjtJQUNyRCxhQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ2QsdUJBQWUsR0FBRyxjQUFjLENBQUM7QUFDbkMsQ0FBQztBQUpELHNDQUlDO0FBRUQ7SUFDRSxFQUFFLENBQUMsQ0FBQyxhQUFLLElBQUksSUFBSSxJQUFJLHVCQUFlLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM3QyxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDekMsQ0FBQztBQUNILENBQUM7QUFFRDtJQWVFLGlCQUFzQixLQUFlLEVBQUUsSUFBaUI7UUFFdEQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksRUFDM0MsOENBQThDLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsTUFBTSxDQUNQLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsRUFDckQsMERBQTBELENBQUMsQ0FBQztRQUVoRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdEMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3hCLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFDaEMsaUNBQWlDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxvQkFBb0I7Z0JBQ2hFLHFCQUFxQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQzVELENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUU5QixFQUFFLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNaLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUdOLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUNsQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVELENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUdNLGFBQUssR0FBWixVQUFhLEtBQWU7UUFDMUIsSUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzNELE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFDLE1BQU0sUUFBQSxFQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBSU0saUJBQVMsR0FBaEIsVUFBb0MsT0FBVTtRQUM1QyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFNLENBQUM7SUFDM0MsQ0FBQztJQUdNLFlBQUksR0FBWCxVQUErQixPQUFVO1FBQ3ZDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBTU0sWUFBSSxHQUFYLFVBQStCLEtBQWUsRUFBRSxJQUFpQjtRQUMvRCxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNyQixLQUFLLENBQUM7Z0JBQ0osTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBTSxDQUFDO1lBQy9CLEtBQUssQ0FBQztnQkFFSixNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFRLENBQUM7WUFDbEMsS0FBSyxDQUFDO2dCQUVKLE1BQU0sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUF5QixFQUFFLElBQUksQ0FBUSxDQUFDO1lBQzdELEtBQUssQ0FBQztnQkFFSixNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBaUMsRUFBRSxJQUFJLENBQVEsQ0FBQztZQUNyRSxLQUFLLENBQUM7Z0JBQ0osTUFBTSxDQUFDLElBQUksT0FBTyxDQUVQLEtBQXlDLEVBQUUsSUFBSSxDQUFRLENBQUM7WUFDckU7Z0JBRUUsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQVEsQ0FBQztRQUMzQyxDQUFDO0lBQ0gsQ0FBQztJQUdELHlCQUFPLEdBQVAsVUFBMkIsUUFBa0I7UUFDM0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUczQyxNQUFNLENBQUMsSUFBVyxDQUFDO1FBQ3JCLENBQUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUNQLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsRUFDMUMsZ0VBQWdFLENBQUMsQ0FBQztRQUV0RSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBSSxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRCwwQkFBUSxHQUFSO1FBQ0UsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxzQkFBSSxHQUFKO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQsc0JBQUksR0FBSixVQUFLLElBQVksRUFBRSxPQUFlO1FBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVELHNCQUFJLEdBQUosVUFBSyxJQUFZLEVBQUUsT0FBZSxFQUFFLEtBQWE7UUFDL0MsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQVUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVELHNCQUFJLEdBQUosVUFBSyxJQUFZLEVBQUUsT0FBZSxFQUFFLEtBQWEsRUFBRSxNQUFjO1FBQy9ELE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsc0JBQUkseUJBQUk7YUFBUjtZQUNFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUMzQixDQUFDOzs7T0FBQTtJQUVELHFCQUFHLEdBQUg7UUFBSSxjQUFpQjthQUFqQixVQUFpQixFQUFqQixxQkFBaUIsRUFBakIsSUFBaUI7WUFBakIseUJBQWlCOztRQUNuQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDekMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksS0FBYTtRQUFFLGNBQWlCO2FBQWpCLFVBQWlCLEVBQWpCLHFCQUFpQixFQUFqQixJQUFpQjtZQUFqQiw2QkFBaUI7O1FBQ2xDLElBQUksQ0FBQyxHQUFHLE9BQVIsSUFBSSxHQUFLLElBQUksQ0FBQyxHQUFHLE9BQVIsSUFBSSxFQUFRLElBQUksSUFBSSxLQUFLLFNBQUssSUFBSSxHQUFFO0lBQy9DLENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksS0FBYTtRQUFFLGNBQWlCO2FBQWpCLFVBQWlCLEVBQWpCLHFCQUFpQixFQUFqQixJQUFpQjtZQUFqQiw2QkFBaUI7O1FBQ2xDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUN6QyxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDbEMsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxJQUFjO1FBQ3ZCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUN6QyxLQUFLLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsNEJBQVUsR0FBVixVQUFXLEtBQWE7UUFDdEIsSUFBTSxJQUFJLEdBQWEsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNwRCxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDekMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUM5QixNQUFNLENBQUMsSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELHNCQUFJLEdBQUosVUFBSyxLQUFhO1FBQ2hCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVELHlCQUFPLEdBQVA7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsMkJBQVMsR0FBVDtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDN0Isd0JBQXdCLEVBQUUsQ0FBQztZQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxhQUFLLENBQUMseUJBQXlCLENBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBZSxDQUFDLENBQUMsQ0FBQyxFQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN4QixDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQzFCLENBQUM7SUFFTyw2QkFBVyxHQUFuQixVQUFvQixpQkFBb0M7UUFDdEQsd0JBQXdCLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxVQUFVLENBQUMsK0JBQStCLENBQ2pFLGFBQUssQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTztZQUNiLHVCQUFlLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFN0QsYUFBSyxDQUFDLHFCQUFxQixDQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFPLENBQUMsQ0FBQztRQUVwRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFLLENBQUM7SUFDM0IsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxnQkFBbUM7UUFDNUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDckMsQ0FBQztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQVEsQ0FBQztJQUM1QixDQUFDO0lBRUQsbUNBQWlCLEdBQWpCLFVBQWtCLGdCQUFtQztRQUNuRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNyQyxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBZSxDQUFDO0lBQ25DLENBQUM7SUFFRCx5QkFBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSyxDQUFDO1FBQ25CLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3hCLENBQUM7SUFDSCxDQUFDO0lBRU8sZ0NBQWMsR0FBdEI7UUFDRSx3QkFBd0IsRUFBRSxDQUFDO1FBQzNCLHVCQUFlLENBQUMsY0FBYyxDQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWUsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUssQ0FBQztRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFLLENBQUM7SUFDbkMsQ0FBQztJQUVELHVCQUFLLEdBQUw7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDO0lBQ25DLENBQUM7SUFFRCx3QkFBTSxHQUFOLFVBQU8sQ0FBVTtRQUNmLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQztZQUN4QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRU0sWUFBSSxHQUFYLFVBQStCLEtBQWUsRUFBRSxZQUEwQjtRQUV4RSxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZDLElBQU0sTUFBTSxHQUFHLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3RDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDOUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLFlBQVksRUFBRSxDQUFDO1FBQzdCLENBQUM7UUFFRCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBSSxLQUFLLEVBQUUsRUFBQyxNQUFNLFFBQUEsRUFBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVNLGtCQUFVLEdBQWpCLFVBQXFDLEtBQWUsRUFBRSxJQUFRLEVBQUUsTUFBVTtRQUFwQixxQkFBQSxFQUFBLFFBQVE7UUFBRSx1QkFBQSxFQUFBLFVBQVU7UUFDeEUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUksS0FBSyxFQUFFLGNBQU0sT0FBQSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBNUIsQ0FBNEIsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFTSwyQkFBbUIsR0FBMUIsVUFDSSxLQUFlLEVBQUUsSUFBUSxFQUFFLE1BQVU7UUFBcEIscUJBQUEsRUFBQSxRQUFRO1FBQUUsdUJBQUEsRUFBQSxVQUFVO1FBQ3ZDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFJLEtBQUssRUFBRSxjQUFNLE9BQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFsQyxDQUFrQyxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUVNLG1CQUFXLEdBQWxCLFVBQXNDLEtBQWUsRUFBRSxDQUFTLEVBQUUsQ0FBUztRQUN6RSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBSSxLQUFLLEVBQUUsY0FBTSxPQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUF0QixDQUFzQixDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUNILGNBQUM7QUFBRCxDQTdRQSxBQTZRQyxJQUFBO0FBN1FZLDBCQUFPO0FBK1FwQjtJQUE0QiwwQkFBTztJQUNqQyxnQkFBWSxJQUFpQjtRQUE3QixpQkFLQztRQUpDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN6QixJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQy9CLENBQUM7UUFDRCxRQUFBLGtCQUFNLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBQzs7SUFDbEIsQ0FBQztJQUVNLFVBQUcsR0FBVixVQUFXLEtBQWE7UUFDdEIsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLEVBQUMsTUFBTSxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQU9ELG9CQUFHLEdBQUg7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxvQkFBRyxHQUFILFVBQUksS0FBYTtRQUNmLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDOUIsQ0FBQztJQUVELG9CQUFHLEdBQUgsVUFBSSxLQUFhO1FBQ2YsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQztJQUMvQixDQUFDO0lBZk0sV0FBSSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsVUFBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEIsVUFBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEIsY0FBTyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQWFsQyxhQUFDO0NBNUJELEFBNEJDLENBNUIyQixPQUFPLEdBNEJsQztBQTVCWSx3QkFBTTtBQThCbkI7SUFBNkIsMkJBQU87SUFHbEMsaUJBQVksSUFBaUI7UUFBN0IsaUJBS0M7UUFKQyxJQUFNLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDO1lBQy9CLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7WUFDcEIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFlLENBQUMsQ0FBQyxDQUFDO1FBQy9DLFFBQUEsa0JBQU0sS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFDOztJQUNyQixDQUFDO0lBRU0sV0FBRyxHQUFWLFVBQVcsTUFBNkI7UUFDdEMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsTUFBTSxDQUNQLGFBQWEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUMxQixpREFBK0MsYUFBYSxTQUFNO2dCQUM5RCxvQkFBb0IsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsRUFBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLENBQVM7UUFDWCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksS0FBYSxFQUFFLENBQVM7UUFDMUIsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUM5QixDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLEtBQWEsRUFBRSxDQUFTO1FBQzFCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUM7SUFDL0IsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxHQUFhO1FBQ3RCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEIsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxLQUFhO1FBQ3RCLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pCLENBQUM7SUFFTSxhQUFLLEdBQVosVUFBYSxLQUFlO1FBQzFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBWSxDQUFDO0lBQ3pDLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0E1Q0EsQUE0Q0MsQ0E1QzRCLE9BQU8sR0E0Q25DO0FBNUNZLDBCQUFPO0FBOENwQjtJQUE2QiwyQkFBTztJQUtsQyxpQkFBWSxLQUF1QixFQUFFLElBQWlCO1FBQXRELGlCQUlDO1FBSEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSw2QkFBNkIsQ0FBQyxDQUFDO1FBQy9ELFFBQUEsa0JBQU0sS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFDO1FBQ25CLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFDakMsQ0FBQztJQUVNLFdBQUcsR0FBVixVQUNJLEtBQXVCLEVBQUUsTUFBd0M7UUFDbkUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxpQkFBaUIsQ0FDbEIsS0FBSyxFQUFFLGFBQWEsRUFDcEIsbURBQW1EO3FCQUM1QyxhQUFhLHdDQUFxQyxDQUFBO3FCQUNsRCxLQUFLLE9BQUksQ0FBQSxDQUFDLENBQUM7WUFDeEIsQ0FBQztRQUNILENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxDQUFTLEVBQUUsQ0FBUztRQUN0QixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksS0FBYSxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQ3JDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDakQsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxLQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDckMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQztJQUNsRCxDQUFDO0lBRUQsNEJBQVUsR0FBVixVQUFXLElBQXNCO1FBQy9CLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxLQUFhO1FBQ3RCLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFTSxhQUFLLEdBQVosVUFBYSxLQUF1QjtRQUNsQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQVksQ0FBQztJQUN6QyxDQUFDO0lBQ0gsY0FBQztBQUFELENBakRBLEFBaURDLENBakQ0QixPQUFPLEdBaURuQztBQWpEWSwwQkFBTztBQW1EcEI7SUFBNkIsMkJBQU87SUFLbEMsaUJBQVksS0FBK0IsRUFBRSxJQUFpQjtRQUE5RCxpQkFLQztRQUpDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztRQUMvRCxRQUFBLGtCQUFNLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBQztRQUNuQixLQUFJLENBQUMsT0FBTyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsS0FBSSxDQUFDLE9BQU8sR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUNqQyxDQUFDO0lBRU0sV0FBRyxHQUFWLFVBQ0ksS0FBK0IsRUFDL0IsTUFBMEM7UUFDNUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sWUFBWSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdCLElBQUksQ0FBQyxpQkFBaUIsQ0FDbEIsS0FBSyxFQUFFLGFBQWEsRUFDcEIsbURBQW1EO3FCQUM1QyxhQUFhLHdDQUFxQyxDQUFBO3FCQUNsRCxLQUFLLE9BQUksQ0FBQSxDQUFDLENBQUM7WUFDeEIsQ0FBQztRQUNILENBQUM7UUFDRCxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDakMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLEtBQWEsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDaEQsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNwRSxDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLEtBQWEsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVM7UUFDaEQsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQztJQUNyRSxDQUFDO0lBRUQsNEJBQVUsR0FBVixVQUFXLElBQThCO1FBQ3ZDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxLQUFhO1FBQ3RCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDMUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFTSxhQUFLLEdBQVosVUFBYSxLQUErQjtRQUMxQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQVksQ0FBQztJQUN6QyxDQUFDO0lBQ0gsY0FBQztBQUFELENBckRBLEFBcURDLENBckQ0QixPQUFPLEdBcURuQztBQXJEWSwwQkFBTztBQXVEcEI7SUFBNkIsMkJBQU87SUFNbEMsaUJBQVksS0FBdUMsRUFBRSxJQUFpQjtRQUF0RSxpQkFNQztRQUxDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztRQUMvRCxRQUFBLGtCQUFNLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBQztRQUNuQixLQUFJLENBQUMsT0FBTyxHQUFHLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsS0FBSSxDQUFDLE9BQU8sR0FBRyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9CLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFDakMsQ0FBQztJQUVNLFdBQUcsR0FBVixVQUNJLEtBQXVDLEVBQ3ZDLE1BQTRDO1FBQzlDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLFlBQVksWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDOUMsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QixJQUFJLENBQUMsaUJBQWlCLENBQ2xCLEtBQUssRUFBRSxhQUFhLEVBQ3BCLG1EQUFtRDtxQkFDNUMsYUFBYSx3Q0FBcUMsQ0FBQTtxQkFDbEQsS0FBSyxPQUFJLENBQUEsQ0FBQyxDQUFDO1lBQ3hCLENBQUM7UUFDSCxDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsTUFBTSxDQUFDLEVBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUztRQUM1QyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDO0lBRUQscUJBQUcsR0FBSCxVQUFJLEtBQWEsRUFBRSxDQUFTLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTO1FBQzNELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FDWCxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDM0UsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxLQUFhLEVBQUUsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsQ0FBUztRQUMzRCxJQUFJLENBQUMsU0FBUyxFQUFFLENBQ1gsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDO0lBQzVFLENBQUM7SUFFRCw0QkFBVSxHQUFWLFVBQVcsSUFBc0M7UUFDL0MsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELDRCQUFVLEdBQVYsVUFBVyxLQUFhO1FBQ3RCLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxLQUFLLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDMUIsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUMxQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFTSxhQUFLLEdBQVosVUFBYSxLQUF1QztRQUNsRCxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQVksQ0FBQztJQUN6QyxDQUFDO0lBQ0gsY0FBQztBQUFELENBN0RBLEFBNkRDLENBN0Q0QixPQUFPLEdBNkRuQztBQTdEWSwwQkFBTztBQWlFcEIsc0JBQXNCLENBQVk7SUFDaEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0UsQ0FBQzs7Ozs7QUMxaUJELGlEQUE2QztBQUU3QztJQUNFLE1BQU0sQ0FBQyx3bUJBaUJILENBQUM7QUFDUCxDQUFDO0FBbkJELDBEQW1CQztBQUVELDJCQUNJLEtBQW1CLEVBQUUsd0JBQXNDLEVBQzNELENBQWUsRUFBRSxDQUFlLEVBQUUsSUFBWSxFQUFFLE9BQWUsRUFDL0QsT0FBcUIsRUFBRSxPQUFxQixFQUFFLE1BQW9CO0lBQ3BFLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3BELEtBQUssQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUMzQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QyxLQUFLLENBQUMscUJBQXFCLENBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RCxLQUFLLENBQUMscUJBQXFCLENBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6RCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDekIsQ0FBQztBQVhELDhDQVdDO0FBRUQseUNBQ0ksQ0FBZSxFQUFFLENBQWUsRUFBRSxJQUFZLEVBQUUsT0FBZSxFQUMvRCxPQUFlLEVBQUUsT0FBZTtJQUNsQyxJQUFNLEtBQUssR0FBRyxJQUFJLDRCQUFZLEVBQUUsQ0FBQztJQUNqQyxJQUFNLE9BQU8sR0FBaUIsS0FBSyxDQUFDLGFBQWEsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDLENBQUM7SUFFN0UsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RCxJQUFNLElBQUksR0FBRyxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RELElBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkQsSUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRCxJQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTNELEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNwRCxLQUFLLENBQUMscUJBQXFCLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEQsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNFLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUzRSxpQkFBaUIsQ0FDYixLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUNqRSxTQUFTLENBQUMsQ0FBQztJQUVmLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXpFLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3JDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN0QyxLQUFLLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFaEIsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBaENELDBFQWdDQzs7Ozs7QUNwRUQsK0NBQWlEO0FBR2pEO0lBTUUsNkJBQVksS0FBYSxFQUFFLEtBQWE7UUFMeEMsa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzQixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUMzQixXQUFNLEdBQWMsRUFBRSxDQUFDO1FBSXJCLElBQU0sUUFBUSxHQUFHLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RFLElBQU0sUUFBUSxHQUFHLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxRQUFRLEdBQUcsYUFDWixRQUFRLGdCQUNSLFFBQVEsNFhBaUJYLENBQUM7SUFDSixDQUFDO0lBQ0gsMEJBQUM7QUFBRCxDQTlCQSxBQThCQyxJQUFBO0FBOUJZLGtEQUFtQjs7Ozs7QUNEaEMsNkJBQW9DLEVBQWUsRUFBRSxPQUFlLEVBQ2hFLElBQVk7SUFDZCxJQUFNLE1BQU0sR0FBRyxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDO0lBQzFDLE1BQU0sQ0FBQyw2QkFDZSxPQUFPLHVFQUVGLE9BQU8sZ0RBRVIsSUFBSSxrRkFFRCxPQUFPLHVIQUlkLE1BQU0sNElBTzNCLENBQUM7QUFDSixDQUFDO0FBdEJELGtEQXNCQztBQUVEO0lBTUUsMEJBQVksS0FBYSxFQUFFLE1BQW1CO1FBTDlDLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUt6QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkIsSUFBTSxRQUFRLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsUUFBUSxHQUFHLGFBQ1osUUFBUSxnRkFLWCxDQUFDO0lBQ0osQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FqQkEsQUFpQkMsSUFBQTtBQWpCWSw0Q0FBZ0I7Ozs7O0FDekI3QixxQ0FBdUM7QUFFdkMsd0NBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUNsRSxHQUFXO0lBQ2IsTUFBTSxDQUFDLFFBQVEsQ0FBQyxpQ0FBaUMsQ0FDN0MsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNuRCxDQUFDO0FBTEQsd0VBS0M7QUFFRCxpQkFDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsQ0FBZSxFQUMzRCxNQUFvQixFQUFFLGlCQUFtQztJQUMzRCxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFKRCwwQkFJQzs7Ozs7QUNaRCxpQ0FDSSxXQUE2QixFQUFFLGNBQWdDLEVBQy9ELGtCQUFvQyxFQUNwQyxnQkFBdUMsRUFDdkMsZUFBdUMsRUFBRSxlQUF1QjtJQUF2QixnQ0FBQSxFQUFBLHVCQUF1QjtJQUNsRSxJQUFJLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztJQUM5QixJQUFJLGdDQUFnQyxHQUFHLEVBQUUsQ0FBQztJQUMxQyxJQUFJLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztJQUM3QixJQUFJLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDekIsSUFBSSxrQkFBa0IsR0FBRyxFQUFFLENBQUM7SUFDNUIsSUFBSSxzQkFBc0IsR0FBRyxLQUFLLENBQUM7SUFFbkMsSUFBSSxtQkFBbUIsR0FBRyxFQUFFLENBQUM7SUFDN0IsSUFBSSwrQkFBK0IsR0FBRyxFQUFFLENBQUM7SUFDekMsSUFBSSxrQkFBa0IsR0FBRyxFQUFFLENBQUM7SUFDNUIsSUFBSSxjQUFjLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLElBQUksaUJBQWlCLEdBQUcsRUFBRSxDQUFDO0lBQzNCLElBQUkscUJBQXFCLEdBQUcsRUFBRSxDQUFDO0lBRS9CLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDN0Isb0JBQW9CLEdBQUcsMkJBQTJCLENBQUM7UUFDbkQsZ0NBQWdDLEdBQUcsbURBQ3pCLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxVQUFLLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxPQUFJLENBQUM7UUFDMUQsbUJBQW1CLEdBQUcsbURBQW1ELENBQUM7UUFDMUUsZUFBZTtZQUNYLDREQUE0RCxDQUFDO1FBQ2pFLGtCQUFrQixHQUFHLG9EQUFvRCxDQUFDO1FBQzFFLHNCQUFzQixHQUFHLGFBQWEsQ0FBQztJQUN6QyxDQUFDO0lBRUQsRUFBRSxDQUFDLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDNUIsbUJBQW1CLEdBQUcsMEJBQTBCLENBQUM7UUFDakQsK0JBQStCLEdBQUcsa0RBQ3hCLGVBQWUsQ0FBQyxDQUFDLENBQUMsVUFBSyxlQUFlLENBQUMsQ0FBQyxDQUFDLE9BQUksQ0FBQztRQUN4RCxrQkFBa0IsR0FBRyxpREFBaUQsQ0FBQztRQUN2RSxjQUFjLEdBQUcseURBQXlELENBQUM7UUFDM0UsaUJBQWlCLEdBQUcsaURBQWlELENBQUM7UUFDdEUscUJBQXFCLEdBQUcsb0JBQW9CLENBQUM7SUFDL0MsQ0FBQztJQUVELE1BQU0sQ0FBQywrSEFLSCxvQkFBb0IsY0FDcEIsbUJBQW1CLHlFQUlRLFdBQVcsQ0FBQyxDQUFDLENBQUMsVUFBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLDhDQUM5QixjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQUssY0FBYyxDQUFDLENBQUMsQ0FBQyw0REFFakUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLFVBQUssa0JBQWtCLENBQUMsQ0FBQyxDQUFDLGtCQUVuRCxnQ0FBZ0MsY0FDaEMsK0JBQStCLHVGQUdELGVBQWUsdU1BTzNDLG1CQUFtQixnQkFDbkIsa0JBQWtCLHNKQUlsQixlQUFlLGdCQUNmLGNBQWMsc0xBS2Qsa0JBQWtCLGdCQUNsQixpQkFBaUIsa0ZBR2pCLHFCQUFxQixzRkFFVSxzQkFBc0IscUhBSXZELENBQUM7QUFDUCxDQUFDO0FBeEZELDBEQXdGQztBQUVELDRCQUNJLEtBQW1CLEVBQUUsT0FBcUIsRUFBRSxDQUFlLEVBQzNELFlBQThCLEVBQUUsSUFBa0IsRUFDbEQsZUFBaUMsRUFBRSxRQUFzQixFQUN6RCxtQkFBcUMsRUFBRSxNQUF5QixFQUNoRSxpQkFBd0MsRUFBRSxLQUF3QixFQUNsRSxnQkFBdUMsRUFBRSxNQUFvQixFQUM3RCxpQkFBbUM7SUFDckMsS0FBSyxDQUFDLHNCQUFzQixDQUN4QixNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RCxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzdDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3JELElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNsQixFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNuQixLQUFLLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUN6RCxTQUFTLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNsQixLQUFLLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBQ0QsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3pCLENBQUM7QUF2QkQsZ0RBdUJDOzs7OztBQ2xIRCxpQ0FBbUM7QUFFbkM7SUFPRSx5QkFBWSxFQUF5QixFQUFFLE1BQWdCLEVBQUUsTUFBZ0I7UUFOekUsa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQU96QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLFFBQVEsR0FBRyw0SEFJRSxFQUFFLHdCQUVuQixDQUFDO0lBQ0osQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FuQkEsQUFtQkMsSUFBQTtBQW5CWSwwQ0FBZTs7Ozs7QUNINUIsd0NBQTBDO0FBRzFDLGlDQUNJLFVBQW9DLEVBQUUsVUFBb0MsRUFDMUUsY0FBd0MsRUFBRSxJQUFZO0lBQ3hELElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNqRSxJQUFNLFlBQVksR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFakUsSUFBTSxLQUFLLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pDLElBQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUUvQixNQUFNLENBQUMsMkhBS3lCLFlBQVksQ0FBQyxDQUFDLENBQUMsVUFBSyxZQUFZLENBQUMsQ0FBQyxDQUFDLDRDQUNuQyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQU8sWUFBWSxDQUFDLENBQUMsQ0FBQyxvUEFTbkMsY0FBYyxDQUFDLENBQUMsQ0FBQyw2Q0FDcEIsY0FBYyxDQUFDLENBQUMsQ0FBQyxzREFJdEMsVUFBVSxXQUFNLFVBQVUsQ0FBQyxJQUFJLENBQUMsZ0dBRVosVUFBVSxDQUFDLENBQUMsQ0FBQyx5SUFJbkMsVUFBVSxXQUFNLFVBQVUsV0FBTSxVQUFVLENBQUMsSUFBSSxDQUFDLGdHQUcxQixVQUFVLENBQUMsQ0FBQyxDQUFDLGdMQU12QyxDQUFDO0FBQ1AsQ0FBQztBQTdDRCwwREE2Q0M7QUFFRCxrQkFDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsRUFBZ0IsRUFDNUQsRUFBZ0IsRUFBRSxNQUFvQixFQUFFLGFBQStCO0lBQ3pFLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDMUIsS0FBSyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDekMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDekMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3pCLENBQUM7QUFSRCw0QkFRQzs7Ozs7QUMxREQsd0NBQTBDO0FBRTFDLHFDQUF1QztBQUd2QywyQ0FDSSxpQkFBMkMsRUFBRSxLQUFhLEVBQzFELFdBQW1CLEVBQUUsTUFBYyxFQUFFLE9BQWU7SUFDdEQsSUFBTSx1QkFBdUIsR0FDekIsUUFBUSxDQUFDLDhDQUE4QyxFQUFFLENBQUM7SUFDOUQsSUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFeEMsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFdkUsSUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUN6QyxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1RCxJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0IsSUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU1RCxJQUFNLG9CQUFvQixHQUFHLEtBQUssR0FBRyxVQUFVLENBQUM7SUFFaEQsSUFBTSxRQUFRLEdBQUcsdUZBSWhCLENBQUM7SUFFRixNQUFNLENBQUMsUUFBUSxHQUFHLElBQUksR0FBRyx1QkFBdUIsR0FBRyxJQUFJO1NBQ25ELCtFQUUyQixXQUFXLENBQUMsQ0FBQyxDQUFDLFVBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyw0Q0FDaEMsV0FBVyxDQUFDLENBQUMsQ0FBQyxVQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsK0tBTS9CLG9CQUFvQiwwREFDVixvQkFBb0Isb0RBQ3pCLFVBQVUsa0RBQ2IsVUFBVSxvUEFNbEIsUUFBUSxxRkFFSixNQUFNLGFBQVEsT0FBTyx3RUFHdkIsUUFBUSwrRkFFRCxNQUFNLGFBQVEsT0FBTywwTUFLbEIsVUFBVSxZQUFPLFdBQVcsMGhCQWlCaEUsQ0FBQSxDQUFDO0FBQ1AsQ0FBQztBQXhFRCw4RUF3RUM7QUFFRCw4Q0FDSSxTQUFtQyxFQUFFLEtBQWEsRUFBRSxjQUFzQixFQUMxRSxVQUFrQixFQUFFLE9BQWUsRUFBRSxPQUFnQjtJQUN2RCxJQUFNLEdBQUcsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUN6QixJQUFBLG9CQUFLLEVBQUUsb0JBQUssRUFBRSw4QkFBZSxDQUFjO0lBRWxELElBQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvRCxJQUFNLFdBQVcsR0FDYixTQUFTLENBQUMsc0JBQXNCLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUU3RSxJQUFNLFlBQVksR0FBRyxPQUFPO1FBQ3hCLFFBQVEsQ0FBQyxtQ0FBbUMsQ0FBQyxjQUFjLENBQUM7UUFDNUQsRUFBRSxDQUFDO0lBQ1AsSUFBTSxZQUFZLEdBQUcsT0FBTyxHQUFHLDJCQUEyQixHQUFHLEVBQUUsQ0FBQztJQUNoRSxJQUFNLGFBQWEsR0FBRyxPQUFPLEdBQUcsc0NBQXNDLEdBQUcsRUFBRSxDQUFDO0lBRTVFLElBQU0sUUFBUSxHQUFHLGlHQUliLFlBQVksV0FDYixDQUFDO0lBRUosTUFBTSxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsWUFBWSxHQUFHLElBQUk7U0FDeEMsK0VBRTJCLFdBQVcsQ0FBQyxDQUFDLENBQUMsVUFBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLDJDQUNqQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFVBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyx1TUFPOUIsY0FBYyw2Q0FDakIsY0FBYywyREFFRixHQUFHLFlBQU8sR0FBRyxnU0FPNUIsS0FBSyxtR0FFVSxVQUFVLDZLQUd2QixLQUFLLDJGQUlaLEtBQUsseUZBR0UsS0FBSyx1R0FFVSxVQUFVLDZDQUN2QixLQUFLLGlHQUlaLEtBQUssK0RBQ0csS0FBSyxhQUFRLGNBQWMsK0NBQzNCLGNBQWMsb0RBRWYsZUFBZSwyRkFFaEIsZUFBZSxtZEFleEMsYUFBYSwwREFFZixDQUFBLENBQUM7QUFDUCxDQUFDO0FBdkZELG9GQXVGQztBQUVELHdDQUNJLFVBQW9DO0lBQ3RDLElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUMxRCxJQUFBLHdCQUFRLEVBQUUsd0JBQVEsRUFBRSwyQkFBVyxDQUFlO0lBRXJELE1BQU0sQ0FBQyx5SUFLeUIsWUFBWSxDQUFDLENBQUMsQ0FBQyxVQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsNE5BU3ZDLFFBQVEscUZBR04sUUFBUSwwSkFHSCxXQUFXLGdSQVUxQyxDQUFDO0FBQ1AsQ0FBQztBQXBDRCx3RUFvQ0M7QUFFRCxpQkFDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsS0FBbUIsRUFDL0QsTUFBb0IsRUFBRSxnQkFBa0M7SUFDMUQsS0FBSyxDQUFDLHNCQUFzQixDQUN4QixNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RCxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBUkQsMEJBUUM7QUFFRCxvQkFDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsSUFBa0IsRUFDOUQsS0FBbUIsRUFBRSxNQUFvQixFQUN6QyxnQkFBa0M7SUFDcEMsS0FBSyxDQUFDLHNCQUFzQixDQUN4QixNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0RCxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzVDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBVkQsZ0NBVUM7QUFFRCx1QkFDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsSUFBa0IsRUFDOUQsVUFBd0IsRUFBRSxTQUE0QixFQUN0RCxTQUF1QixFQUFFLGdCQUFrQztJQUM3RCxLQUFLLENBQUMsc0JBQXNCLENBQ3hCLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pELEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDMUIsS0FBSyxDQUFDLHFCQUFxQixDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDMUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEQsRUFBRSxDQUFDLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDdEIsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUNELEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBYkQsc0NBYUM7Ozs7O0FDalBELHdDQUEwQztBQUcxQztJQUNFLE1BQU0sQ0FBQyxtSkFLa0IsQ0FBQztBQUM1QixDQUFDO0FBUEQsMEVBT0M7QUFFRDtJQUNFLE1BQU0sQ0FBQywrYkFTSCxDQUFDO0FBQ1AsQ0FBQztBQVhELHdHQVdDO0FBRUQseUNBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsV0FBbUIsRUFDdkUsTUFBYyxFQUFFLEdBQVcsRUFBRSxPQUFnQjtJQUMvQyxJQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQy9ELElBQU0sV0FBVyxHQUNiLFNBQVMsQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBRXJFLE1BQU0sQ0FBQywrRUFFd0IsV0FBVyxDQUFDLENBQUMsQ0FBQyxVQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsMkNBQ2pDLFdBQVcsQ0FBQyxDQUFDLENBQUMsVUFBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLHVNQU85QixXQUFXLDZDQUNkLFdBQVcsb0ZBR0MsTUFBTSxVQUFLLE1BQU0sNEJBQzdDLEdBQUcsWUFBTyxHQUFHLGdTQU9BLEtBQUssNEpBS0gsS0FBSyx1SUFJSCxVQUFVLDJGQUVYLFVBQVUsNkRBQ0osS0FBSyxHQUFHLFVBQVUseUNBQzVCLFVBQVUsMFhBYTNCLE9BQU8sb0hBSWIsQ0FBQztBQUNQLENBQUM7QUE3REQsMEVBNkRDO0FBRUQsNkNBQW9ELFdBQW1CO0lBRXJFLE1BQU0sQ0FBQyxxR0FFNkIsV0FBVyxtREFDWCxXQUFXLDJIQUczQyxDQUFDO0FBQ1AsQ0FBQztBQVRELGtGQVNDO0FBRUQsaUNBQ0ksaUJBQTJDLEVBQUUsV0FBbUIsRUFDaEUsU0FBaUIsRUFBRSxNQUFjLEVBQUUsT0FBZSxFQUNsRCxPQUFnQjtJQUNsQixJQUFNLFFBQVEsR0FBRywrQkFBK0IsRUFBRSxDQUFDO0lBQ25ELElBQU0sdUJBQXVCLEdBQ3pCLDhDQUE4QyxFQUFFLENBQUM7SUFDckQsSUFBTSxRQUFRLEdBQUcsK0JBQStCLENBQzVDLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6RSxJQUFNLFlBQVksR0FBRyxtQ0FBbUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUV0RSxNQUFNLENBQUM7UUFDTCxRQUFRO1FBQ1IsdUJBQXVCO1FBQ3ZCLFlBQVk7UUFDWixRQUFRO0tBQ1QsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDZixDQUFDO0FBakJELDBEQWlCQztBQUVELGtCQUNJLEtBQW1CLEVBQUUsT0FBcUIsRUFBRSxDQUFlLEVBQzNELE9BQXFCLEVBQUUsTUFBeUIsRUFBRSxNQUFvQixFQUN0RSxpQkFBbUM7SUFDckMsS0FBSyxDQUFDLHNCQUFzQixDQUN4QixNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RCxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzFCLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25ELEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25CLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFDRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDekIsQ0FBQztBQWJELDRCQWFDOzs7OztBQ2pJRCxpQ0FDSSxpQkFBbUMsRUFBRSxnQkFBa0MsRUFDdkUsY0FBZ0M7SUFDbEMsTUFBTSxDQUFDLCtLQU9JLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxVQUFLLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxzREFFN0MsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFVBQUssZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLG9EQUUzQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFVBQUssY0FBYyxDQUFDLENBQUMsQ0FBQywyZEFVOUMsQ0FBQztBQUNQLENBQUM7QUF6QkQsMERBeUJDO0FBRUQsY0FDSSxLQUFtQixFQUFFLE9BQXFCLEVBQUUsTUFBb0IsRUFDaEUsaUJBQW1DLEVBQUUsaUJBQW1DLEVBQ3hFLGdCQUFrQyxFQUFFLElBQWtCLEVBQ3RELGVBQWlDLEVBQUUsZUFBaUMsRUFDcEUsY0FBZ0M7SUFDbEMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0UsS0FBSyxDQUFDLDBCQUEwQixDQUM1QixlQUFlLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsRUFDekQsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixLQUFLLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNqRCxJQUFNLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNuRSxLQUFLLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FDZCxnQkFBZ0IsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLElBQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUMvRCxLQUFLLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsZUFBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNFLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBbEJELG9CQWtCQzs7Ozs7QUMvQ0QseUNBQTJDO0FBQzNDLHFDQUF1QztBQUN2Qyx5Q0FBMkM7QUFJM0M7SUFhRSxzQkFBWSxFQUEwQjtRQUx0QyxrQkFBYSxHQUFzQixJQUFJLENBQUM7UUFDeEMsWUFBTyxHQUFzQixJQUFJLENBQUM7UUFDMUIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixzQkFBaUIsR0FBRyxLQUFLLENBQUM7UUFHaEMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDZixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNmLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLElBQUksQ0FBQyxFQUFFLEdBQUcsVUFBVSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDNUMsQ0FBQztRQUdELEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMscUJBQXFCO2dCQUN0QixVQUFVLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBQ25FLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLElBQUksQ0FBQyx5QkFBeUI7Z0JBQzFCLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLHdCQUF3QixDQUFDLENBQUM7UUFDeEUsQ0FBQztRQUVELElBQUksQ0FBQyxvQkFBb0I7WUFDckIsVUFBVSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsb0JBQW9CLENBQ25DLENBQUM7UUFDOUIsSUFBSSxDQUFDLFlBQVksR0FBRyxVQUFVLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzNELElBQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVNLDhCQUFPLEdBQWQ7UUFBQSxpQkEwQkM7UUF6QkMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN6QixPQUFPLENBQUMsSUFBSSxDQUNSLCtEQUErRDtnQkFDL0QsNkRBQTZEO2dCQUM3RCw4Q0FBOEMsQ0FBQyxDQUFDO1FBQ3RELENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDL0IsT0FBTyxDQUFDLElBQUksQ0FDUixnRUFBZ0U7Z0JBQ2hFLGdFQUFnRTtnQkFDaEUsOERBQThEO2dCQUM5RCxZQUFZLENBQUMsQ0FBQztRQUNwQixDQUFDO1FBQ0QsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNuQixVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFYLENBQVcsQ0FBQyxDQUFDO1FBQy9DLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLEVBQXhDLENBQXdDLENBQUMsQ0FBQztRQUM1RSxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGlCQUFpQixDQUFDLEtBQUksQ0FBQyxXQUFXLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxDQUFDO1FBQzFFLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLEVBQXBDLENBQW9DLENBQUMsQ0FBQztRQUN4RSxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFlBQVksQ0FBQyxLQUFJLENBQUMsWUFBWSxDQUFDLEVBQWxDLENBQWtDLENBQUMsQ0FBQztRQUN0RSxVQUFVLENBQUMsWUFBWSxDQUNuQixFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLG9CQUFvQixFQUFFLElBQUksQ0FBQyxFQUE1QyxDQUE0QyxDQUFDLENBQUM7UUFDNUQsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxFQUFqQyxDQUFpQyxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3hDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0lBQ3ZCLENBQUM7SUFFTSxxREFBOEIsR0FBckMsVUFBc0MsT0FBZ0I7UUFDcEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE9BQU8sQ0FBQztRQUNqQyxVQUFVLENBQUMsNkJBQTZCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLDBDQUFtQixHQUExQixVQUEyQixJQUFZLEVBQUUsT0FBZTtRQUN0RCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU0sK0NBQXdCLEdBQS9CLFVBQ0ksT0FBcUIsRUFDckIsTUFBcUU7UUFDdkUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLFVBQVUsQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU0sZ0RBQXlCLEdBQWhDLFVBQWlDLElBQVksRUFBRSxPQUFlO1FBRTVELElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixNQUFNLENBQUMsVUFBVSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFTSwwQ0FBbUIsR0FBMUIsVUFBMkIsT0FBcUI7UUFBaEQsaUJBT0M7UUFOQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ25DLFVBQVUsQ0FBQyxpQ0FBaUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4RSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztRQUM1QixDQUFDO1FBQ0QsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBOUIsQ0FBOEIsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFTSw0Q0FBcUIsR0FBNUIsVUFDSSxPQUFxQixFQUFFLElBQVksRUFBRSxPQUFlLEVBQ3BELE1BQW9CO1FBQ3RCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFNLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFDdEIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxxQkFBcUIsQ0FDbkMsSUFBSSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVNLGtEQUEyQixHQUFsQyxVQUNJLE9BQXFCLEVBQUUsSUFBWSxFQUFFLE9BQWUsRUFDcEQsTUFBb0I7UUFDdEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sQ0FBQyxVQUFVLENBQUMsMkJBQTJCLENBQ3pDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVNLGdEQUF5QixHQUFoQyxVQUNJLE9BQXFCLEVBQUUsSUFBWSxFQUFFLE9BQWU7UUFEeEQsaUJBTUM7UUFKQyxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUM1QixPQUFPLEVBQ1A7WUFDSSxPQUFBLFVBQVUsQ0FBQywrQkFBK0IsQ0FBQyxLQUFJLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7UUFBbEUsQ0FBa0UsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFFTSxzREFBK0IsR0FBdEMsVUFDSSxPQUFxQixFQUFFLElBQVksRUFBRSxPQUFlO1FBRHhELGlCQU1DO1FBSkMsTUFBTSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FDNUIsT0FBTyxFQUNQLGNBQU0sT0FBQSxVQUFVLENBQUMscUNBQXFDLENBQ2xELEtBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxFQURyQixDQUNxQixDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVNLG9DQUFhLEdBQXBCLFVBQXFCLG9CQUE0QjtRQUMvQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUNuQixJQUFNLGNBQWMsR0FDaEIsVUFBVSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBQzlELElBQU0sWUFBWSxHQUFnQixVQUFVLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDcEUsSUFBTSxPQUFPLEdBQWlCLFVBQVUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0QsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxFQUF0QyxDQUFzQyxDQUFDLENBQUM7UUFDMUUsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLGNBQWMsQ0FBQyxFQUF4QyxDQUF3QyxDQUFDLENBQUM7UUFDNUUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUMzQixVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMxQyxDQUFDO1FBRUQsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRU0sb0NBQWEsR0FBcEIsVUFBcUIsT0FBcUI7UUFBMUMsaUJBUUM7UUFQQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsRUFBRSxDQUFDLENBQUMsT0FBTyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNwQixVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxFQUE5QixDQUE4QixDQUFDLENBQUM7UUFDekUsQ0FBQztJQUNILENBQUM7SUFFTSxpQ0FBVSxHQUFqQixVQUFrQixPQUEwQjtRQUE1QyxpQkFPQztRQU5DLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUNyRCxVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFDRCxVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUEzQixDQUEyQixDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVNLHlDQUFrQixHQUF6QixVQUEwQixXQUFtQjtRQUMzQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDeEIsTUFBTSxDQUFDLFVBQVUsQ0FBQyxnQ0FBZ0MsQ0FDOUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTSw0Q0FBcUIsR0FBNUIsVUFDSSxrQkFBZ0MsRUFBRSxXQUFtQixFQUNyRCxXQUFtQjtRQUNyQixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDeEIsVUFBVSxDQUFDLGtDQUFrQyxDQUN6QyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFRLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFTSw2Q0FBc0IsR0FBN0IsVUFDSSxtQkFBaUMsRUFBRSxJQUFZLEVBQUUsT0FBZTtRQUNsRSxJQUFJLENBQUMsNEJBQTRCLENBQUMsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFTSxtREFBNEIsR0FBbkMsVUFDSSx5QkFBdUMsRUFBRSxJQUFZLEVBQUUsT0FBZTtRQUN4RSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDakIsSUFBQSxtRUFDNEQsRUFEM0QsYUFBSyxFQUFFLGNBQU0sQ0FDK0M7UUFDbkUsSUFBSSxDQUFDLDRCQUE0QixDQUFDLHlCQUF5QixFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRU0saURBQTBCLEdBQWpDLFVBQ0ksUUFBZ0IsRUFBRSxPQUFlLEVBQUUsV0FBbUIsRUFDdEQsVUFBa0I7UUFDcEIsSUFBSSxDQUFDLGdDQUFnQyxDQUNqQyxXQUFXLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRU0sdURBQWdDLEdBQXZDLFVBQ0ksUUFBZ0IsRUFBRSxPQUFlLEVBQUUsV0FBbUIsRUFDdEQsVUFBa0I7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtREFBbUQsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFTSxvQ0FBYSxHQUFwQjtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN6QixVQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFDRCxVQUFVLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFTSxxQ0FBYyxHQUFyQjtRQUNFLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ25CLFVBQVUsQ0FBQyxpQ0FBaUMsQ0FDeEMsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFRLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3ZCLENBQUM7UUFDRCxVQUFVLENBQUMsWUFBWSxDQUNuQixFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsRUFBdEQsQ0FBc0QsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFTSxxREFBOEIsR0FBckM7UUFBQSxpQkFHQztRQUZDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQWhCLENBQWdCLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRU8sMkNBQW9CLEdBQTVCLFVBQ0ksT0FBcUIsRUFDckIsaUJBQXFDO1FBQ3ZDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixVQUFVLENBQUMsNkJBQTZCLENBQ3BDLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN4QyxJQUFNLE1BQU0sR0FBRyxpQkFBaUIsRUFBRSxDQUFDO1FBQ25DLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMvQixVQUFVLENBQUMsNkJBQTZCLENBQ3BDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDbkQsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztnQkFDM0IsVUFBVSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUMxQyxDQUFDO1FBQ0gsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sVUFBVSxDQUFDLGlDQUFpQyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzFFLENBQUM7UUFDRCxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTyxtREFBNEIsR0FBcEMsVUFDSSw4QkFBNEMsRUFBRSxLQUFhLEVBQzNELE1BQWM7UUFDaEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3ZCLElBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDbkIsVUFBVSxDQUFDLDZCQUE2QixDQUNwQyxFQUFFLEVBQUUsOEJBQThCLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzFELEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7WUFDM0IsVUFBVSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLENBQUM7UUFDRCxJQUFJLENBQUMsYUFBYSxHQUFHLDhCQUE4QixDQUFDO1FBQ3BELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFoQyxDQUFnQyxDQUFDLENBQUM7UUFDcEUsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQS9CLENBQStCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRU8sdURBQWdDLEdBQXhDLFVBQ0ksQ0FBUyxFQUFFLENBQVMsRUFBRSxLQUFhLEVBQUUsTUFBYztRQUR2RCxpQkFLQztRQUhDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixVQUFVLENBQUMsWUFBWSxDQUNuQixJQUFJLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsRUFBcEMsQ0FBb0MsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFTyxzQ0FBZSxHQUF2QjtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUM3RCxDQUFDO0lBQ0gsQ0FBQztJQUVPLHVDQUFnQixHQUF4QjtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7UUFDdEQsQ0FBQztJQUNILENBQUM7SUFDSCxtQkFBQztBQUFELENBN1JBLEFBNlJDLElBQUE7QUE3Ulksb0NBQVk7Ozs7O0FDSHpCLG1EQUFxRDtBQUVyRCxpQ0FBbUM7QUFtQm5DLHdCQUNJLEtBQW1CLEVBQUUsT0FBcUIsRUFBRSxNQUFXLEVBQ3ZELE1BQVM7SUFDWCxJQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0lBQ2xDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUM7UUFDaEQsSUFBTSxTQUFTLEdBQUc7WUFDaEIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO1lBQzdCLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLEVBQUU7U0FDeEMsQ0FBQztRQUNGLE1BQU0sQ0FBQyxFQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsU0FBUyxXQUFBLEVBQUMsQ0FBQztJQUM5QixDQUFDLENBQUMsQ0FBQztJQUNILElBQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsU0FBUyxFQUFYLENBQVcsQ0FBQyxDQUFDO0lBQ3RELElBQU0sWUFBWSxHQUFHO1FBQ25CLFlBQVksRUFBRSxNQUFNLENBQUMsS0FBSztRQUMxQixRQUFRLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixFQUFFO0tBQ3JDLENBQUM7SUFDRixJQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsVUFBVSxDQUNyQyxVQUFVLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFDbEMsT0FBTyxDQUFDLG9CQUFvQixLQUFLLElBQUksQ0FBQyxDQUFDO0lBQzNDLE1BQU0sQ0FBQztRQUNMLE9BQU8sU0FBQTtRQUNQLE1BQU0sUUFBQTtRQUNOLFlBQVksRUFBRSxLQUFLLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQztRQUN6QyxLQUFLLE9BQUE7UUFDTCxZQUFZLGNBQUE7UUFDWixZQUFZLGNBQUE7S0FDYixDQUFDO0FBQ0osQ0FBQztBQTNCRCx3Q0EyQkM7QUFFRCxrQ0FBa0MsVUFBdUIsRUFBRSxPQUFrQjtJQUMzRSxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQyxFQUFFLENBQUM7UUFDdEIsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQztRQUM5QixJQUFNLFNBQVMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO1FBQzdCLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDaEMsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFFakQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEMsTUFBTSxLQUFLLENBQUMsaURBQWlEO2lCQUN6RCw4QkFBNEIsTUFBTSxhQUFRLE1BQU0sZ0JBQWEsQ0FBQSxDQUFDLENBQUM7UUFDckUsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sS0FBSyxDQUFDLDREQUE0RDtpQkFDcEUsMEJBQXdCLFNBQVMsYUFBUSxTQUFTLGdCQUFhLENBQUEsQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRCxvQkFDSSxNQUFtQixFQUFFLE1BQVcsRUFBRSxNQUFTO0lBQzdDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDdEQsd0JBQXdCLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRTFELElBQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNuQyxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMvQyxJQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQzNCLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3RDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBQyxLQUFLLEVBQUUsQ0FBQztRQUN0QixJQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDL0IsS0FBSyxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2RSxDQUFDLENBQUMsQ0FBQztJQUNILEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBZkQsZ0NBZUM7QUFFRCx1QkFDSSxPQUFxQixFQUFFLE1BQWlCLEVBQ3hDLE1BQWU7SUFDakIsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUM5QixJQUFNLFFBQVEsR0FDVixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFyQyxDQUFxQyxDQUFDLENBQUM7SUFDMUUsSUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBWixDQUFZLENBQUMsQ0FBQztJQUM3QyxJQUFJLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsS0FBSyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQzdELEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNuQyxNQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN2QixDQUFDO0FBWEQsc0NBV0M7Ozs7O0FDbkdELHFDQUF1QztBQUN2Qyx5Q0FBMkM7QUFFM0M7SUFDRSxNQUFNLENBQUM7UUFDTCxLQUFLLEVBQUUsS0FBSztRQUNaLFNBQVMsRUFBRSxLQUFLO1FBQ2hCLGtCQUFrQixFQUFFLEtBQUs7UUFDekIscUJBQXFCLEVBQUUsS0FBSztRQUM1QixLQUFLLEVBQUUsS0FBSztRQUNaLE9BQU8sRUFBRSxLQUFLO1FBQ2QsNEJBQTRCLEVBQUUsSUFBSTtLQUNuQyxDQUFDO0FBQ0osQ0FBQztBQVZELDhEQVVDO0FBRUQsNEJBQW1DLE1BQTBCO0lBQzNELElBQU0sVUFBVSxHQUFHLHlCQUF5QixFQUFFLENBQUM7SUFDL0MsSUFBSSxFQUF5QixDQUFDO0lBQzlCLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ25CLEVBQUUsR0FBRyxVQUFVLENBQUMscUNBQXFDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLEVBQUUsR0FBRyxVQUFVLENBQUMsMkJBQTJCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUNELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO0lBQzdELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBM0IsQ0FBMkIsQ0FBQyxDQUFDO0lBQy9ELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBcEIsQ0FBb0IsQ0FBQyxDQUFDO0lBQ3hELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO0lBQ3pELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFsQyxDQUFrQyxDQUFDLENBQUM7SUFDdEUsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUE5QixDQUE4QixDQUFDLENBQUM7SUFDbEUsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUExQixDQUEwQixDQUFDLENBQUM7SUFDOUQsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxFQUF2QixDQUF1QixDQUFDLENBQUM7SUFDM0QsVUFBVSxDQUFDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFwQixDQUFvQixDQUFDLENBQUM7SUFDeEQsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNaLENBQUM7QUFsQkQsZ0RBa0JDO0FBRUQsNEJBQW1DLEVBQXlCO0lBQzFELElBQU0sa0JBQWtCLEdBQUcsa05BU3ZCLENBQUM7SUFDTCxNQUFNLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFaRCxnREFZQztBQUVELDRCQUFtQyxFQUF5QjtJQUUxRCxJQUFNLFdBQVcsR0FBRyxJQUFJLFlBQVksQ0FDaEMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLE1BQU0sQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFMRCxnREFLQztBQUVELDJCQUFrQyxFQUF5QjtJQUV6RCxJQUFNLHFCQUFxQixHQUFHLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLE1BQU0sQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRSxFQUFFLHFCQUFxQixDQUFDLENBQUM7QUFDdkUsQ0FBQztBQUpELDhDQUlDO0FBRUQsa0NBQ0ksRUFBeUIsRUFBRSxXQUFtQjtJQUNoRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXRCLE1BQU0sQ0FBRSxFQUFVLENBQUMsT0FBTyxDQUFDO1FBQzdCLENBQUM7UUFFRCxNQUFNLENBQUUsRUFBVSxDQUFDLElBQUksQ0FBQztJQUMxQixDQUFDO0lBQ0QsTUFBTSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7QUFDakIsQ0FBQztBQUVELDBCQUNJLEVBQXlCLEVBQUUsV0FBbUI7SUFDaEQsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxJQUFJLFdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRELE1BQU0sQ0FBRSxFQUFVLENBQUMsR0FBRyxDQUFDO0lBQ3pCLENBQUM7SUFDRCxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQztBQUNqQixDQUFDO0FBRUQsbUNBQ0ksRUFBeUIsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUN4RCxXQUFtQjtJQUNyQixVQUFVLENBQUMsbUJBQW1CLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNsRCxJQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRTdDLElBQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUM7SUFDNUIsSUFBTSxjQUFjLEdBQUcsd0JBQXdCLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ2pFLElBQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNqRCxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQTlCLENBQThCLENBQUMsQ0FBQztJQUNsRSxVQUFVLENBQUMsWUFBWSxDQUNuQixFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUE1RCxDQUE0RCxDQUFDLENBQUM7SUFDNUUsVUFBVSxDQUFDLFlBQVksQ0FDbkIsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBNUQsQ0FBNEQsQ0FBQyxDQUFDO0lBQzVFLFVBQVUsQ0FBQyxZQUFZLENBQ25CLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBMUQsQ0FBMEQsQ0FBQyxDQUFDO0lBQzFFLFVBQVUsQ0FBQyxZQUFZLENBQ25CLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBMUQsQ0FBMEQsQ0FBQyxDQUFDO0lBQzFFLFVBQVUsQ0FBQyxZQUFZLENBQ25CLEVBQUUsRUFDRixjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FDZixLQUFLLEVBQUUsQ0FBQyxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFEakUsQ0FDaUUsQ0FBQyxDQUFDO0lBQzdFLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQW5DLENBQW1DLENBQUMsQ0FBQztJQUN2RSxNQUFNLENBQUMsT0FBTyxDQUFDO0FBQ2pCLENBQUM7QUFFRCw2QkFDSSxFQUF5QixFQUFFLElBQVksRUFBRSxPQUFlO0lBQ3BELElBQUEscUVBQzhELEVBRDdELGFBQUssRUFBRSxjQUFNLENBQ2lEO0lBQ3JFLElBQU0sV0FBVyxHQUFHLENBQUMsQ0FBQztJQUN0QixNQUFNLENBQUMseUJBQXlCLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDbkUsQ0FBQztBQU5ELGtEQU1DO0FBRUQsa0NBQ0ksRUFBeUIsRUFBRSxJQUFZLEVBQUUsT0FBZTtJQUNwRCxJQUFBLGtFQUMyRCxFQUQxRCxhQUFLLEVBQUUsY0FBTSxDQUM4QztJQUNsRSxJQUFNLFdBQVcsR0FBRyxDQUFDLENBQUM7SUFDdEIsTUFBTSxDQUFDLHlCQUF5QixDQUFDLEVBQUUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFORCw0REFNQztBQUVELG1DQUNJLEVBQXlCLEVBQUUsSUFBWSxFQUFFLE9BQWU7SUFDcEQsSUFBQSxtRUFDNEQsRUFEM0QsYUFBSyxFQUFFLGNBQU0sQ0FDK0M7SUFDbkUsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBTkQsOERBTUM7QUFFRCwyQ0FDSSxFQUF5QixFQUFFLE9BQXFCLEVBQ2hELFlBQXlCO0lBQzNCLElBQU0sU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNwQixJQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLElBQU0sTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLFVBQVUsQ0FBQyxZQUFZLENBQ25CLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxFQUE1QyxDQUE0QyxDQUFDLENBQUM7SUFDNUQsVUFBVSxDQUFDLGtDQUFrQyxDQUN6QyxFQUFFLEVBQUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRSxJQUFJLENBQUM7UUFDSCxVQUFVLENBQUMsa0NBQWtDLENBQ3pDLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBSVgsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RELE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBckJELDhFQXFCQztBQUVELGtDQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFDaEQsTUFBcUU7SUFDdkUsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLElBQU0sY0FBYyxHQUFHLHdCQUF3QixDQUFDLEVBQUUsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNqRSxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxFQUF0QyxDQUFzQyxDQUFDLENBQUM7SUFDMUUsVUFBVSxDQUFDLFlBQVksQ0FDbkIsRUFBRSxFQUNGLGNBQU0sT0FBQSxFQUFFLENBQUMsVUFBVSxDQUNmLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLGNBQWMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBRDFELENBQzBELENBQUMsQ0FBQztJQUN0RSxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQVhELDREQVdDO0FBRUQsNkJBQ0ksRUFBeUIsRUFBRSxPQUFxQixFQUFFLEtBQWEsRUFDL0QsTUFBYyxFQUFFLElBQWtCLEVBQUUsV0FBbUI7SUFDekQsSUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRXhELFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xELFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLEVBQXRDLENBQXNDLENBQUMsQ0FBQztJQUMxRSxVQUFVLENBQUMsWUFBWSxDQUNuQixFQUFFLEVBQ0YsY0FBTSxPQUFBLEVBQUUsQ0FBQyxhQUFhLENBQ2xCLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFDOUQsSUFBSSxDQUFDLEVBRkgsQ0FFRyxDQUFDLENBQUM7SUFDZixVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUVELCtCQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFBRSxJQUFZLEVBQzlELE9BQWUsRUFBRSxNQUFvQixFQUFFLFdBQW1CO0lBQ3RELElBQUEscUVBQzhELEVBRDdELFNBQUMsRUFBRSxTQUFDLENBQzBEO0lBRXJFLElBQU0sa0JBQWtCLEdBQ3BCLFdBQVcsS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDLHFCQUFxQixFQUFFLEdBQUcsV0FBVyxDQUFDO0lBQ3pFLElBQU0sYUFBYSxHQUNmLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxrQ0FBa0MsQ0FDeEQsTUFBTSxDQUFDLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFDNUMsUUFBUSxDQUFDLDJCQUEyQixDQUNoQyxNQUFNLEVBQUUsYUFBYSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFFL0MsbUJBQW1CLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLGFBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBZkQsc0RBZUM7QUFFRCxxQ0FDSSxFQUF5QixFQUFFLE9BQXFCLEVBQUUsSUFBWSxFQUM5RCxPQUFlLEVBQUUsTUFBb0I7SUFDakMsSUFBQSxtRUFBdUUsRUFBdEUsU0FBQyxFQUFFLFNBQUMsQ0FBbUU7SUFDOUUsSUFBTSxVQUFVLEdBQUcsSUFBSSxZQUFZLENBQy9CLFFBQVEsQ0FBQyxxQ0FBcUMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNuRSxRQUFRLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDckUsSUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLG1CQUFtQixDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDbEUsQ0FBQztBQVRELGtFQVNDO0FBRUQseUNBQ0ksRUFBeUIsRUFBRSxJQUFZLEVBQUUsT0FBZTtJQUNwRCxJQUFBLHFFQUM4RCxFQUQ3RCxTQUFDLEVBQUUsU0FBQyxDQUMwRDtJQUVyRSxJQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQztJQUM3QixJQUFNLGFBQWEsR0FDZixJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsa0NBQWtDLENBQ3hELElBQUksR0FBRyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0lBQzdDLFVBQVUsQ0FBQyxZQUFZLENBQ25CLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxFQUEzRCxDQUEyRCxDQUFDLENBQUM7SUFFM0UsSUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELFFBQVEsQ0FBQyw2QkFBNkIsQ0FDbEMsYUFBYSxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQy9DLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWhCRCwwRUFnQkM7QUFFRCwrQ0FDSSxFQUF5QixFQUFFLElBQVksRUFBRSxPQUFlO0lBQ3BELElBQUEsbUVBQXVFLEVBQXRFLFNBQUMsRUFBRSxTQUFDLENBQW1FO0lBQzlFLElBQU0sVUFBVSxHQUFHLElBQUksWUFBWSxDQUMvQixRQUFRLENBQUMscUNBQXFDLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDbkUsVUFBVSxDQUFDLFlBQVksQ0FDbkIsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLEVBQXhELENBQXdELENBQUMsQ0FBQztJQUN4RSxJQUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDaEQsTUFBTSxDQUFDLFFBQVEsQ0FBQywwQkFBMEIsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNoRixDQUFDO0FBVEQsc0ZBU0M7Ozs7O0FDOU9EO0lBTUUsMEJBQVksS0FBYTtRQUx6QixrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsV0FBTSxHQUFjLEVBQUUsQ0FBQztRQUN2QixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUl6QixJQUFJLENBQUMsUUFBUSxHQUFHLDZGQUdVLEtBQUsseUlBS0wsS0FBSyxzSUFNOUIsQ0FBQztJQUNKLENBQUM7SUFDSCx1QkFBQztBQUFELENBdkJBLEFBdUJDLElBQUE7QUF2QlksNENBQWdCOzs7OztBQ0Y3Qix3Q0FBMEM7QUFHMUMsMENBQ0ksVUFBb0MsRUFBRSxLQUFhLEVBQUUsVUFBa0IsRUFDdkUsT0FBZTtJQUNqQixJQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsSUFBTSxHQUFHLEdBQUcsS0FBSyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDekIsSUFBQSxzQkFBTSxFQUFFLHNCQUFNLEVBQUUscUJBQUssQ0FBZTtJQUUzQyxJQUFNLFlBQVksR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFFakUsTUFBTSxDQUFDLHdLQU15QixZQUFZLENBQUMsQ0FBQyxDQUFDLFVBQUssWUFBWSxDQUFDLENBQUMsQ0FBQywrTUFPL0IsY0FBYyw2Q0FDbkIsY0FBYyw4REFFQyxHQUFHLFlBQU8sR0FBRyx1U0FPL0IsS0FBSyxxR0FFWSxVQUFVLGdMQUd2QixNQUFNLGtJQU1SLEtBQUsseUdBRVksVUFBVSwrQ0FDdkIsTUFBTSx3R0FJVCxLQUFLLHFRQVF0QixLQUFLLEdBQUcsS0FBSyxHQUFHLENBQUMsNkxBSVUsS0FBSywyTUFPMUMsQ0FBQztBQUNQLENBQUM7QUF0RUQsNEVBc0VDO0FBRUQseUJBQ0ksS0FBbUIsRUFBRSxPQUFxQixFQUFFLEtBQW1CLEVBQy9ELGVBQTZCLEVBQUUsU0FBdUIsRUFDdEQsZ0JBQWtDO0lBQ3BDLEtBQUssQ0FBQyxzQkFBc0IsQ0FDeEIsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekQsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixLQUFLLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1QyxLQUFLLENBQUMscUJBQXFCLENBQUMsZUFBZSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUMxRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDekIsQ0FBQztBQVZELDBDQVVDOzs7OztBQ3BGRCxxQ0FBdUM7QUFFdkMsaURBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUNsRSxHQUFXO0lBQ2IsTUFBTSxDQUFDLG9DQUFvQyxDQUN2QyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUxELDBGQUtDO0FBRUQsd0NBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUNsRSxHQUFXO0lBQ2IsTUFBTSxDQUFDLG9DQUFvQyxDQUN2QyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUxELHdFQUtDO0FBRUQsOENBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUNsRSxHQUFXLEVBQUUsbUJBQTRCO0lBQzNDLE1BQU0sQ0FBQyxRQUFRLENBQUMsaUNBQWlDLENBQzdDLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBRUQsdUJBQ0ksS0FBbUIsRUFBRSxPQUFxQixFQUFFLENBQWUsRUFDM0QsTUFBb0IsRUFBRSxpQkFBbUM7SUFDM0QsUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBSkQsc0NBSUM7Ozs7O0FDM0JELHFDQUF1QztBQUV2Qyx3Q0FDSSxTQUFtQyxFQUFFLEtBQWEsRUFBRSxNQUFjLEVBQ2xFLEdBQVc7SUFDYixNQUFNLENBQUMsUUFBUSxDQUFDLGlDQUFpQyxDQUM3QyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUFMRCx3RUFLQztBQUVELGlCQUNJLEtBQW1CLEVBQUUsT0FBcUIsRUFBRSxDQUFlLEVBQzNELE1BQW9CLEVBQUUsaUJBQW1DO0lBQzNELFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixDQUFDLENBQUM7QUFDcEUsQ0FBQztBQUpELDBCQUlDOzs7OztBQ1pEO0lBTUUsdUJBQVksS0FBYSxFQUFFLE1BQW1CO1FBTDlDLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUV0QixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUl6QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLFFBQVEsR0FBRyw4RkFHVSxLQUFLLDZMQU1mLE1BQU0sNkVBSXJCLENBQUM7SUFDSixDQUFDO0lBQ0gsb0JBQUM7QUFBRCxDQXZCQSxBQXVCQyxJQUFBO0FBdkJZLHNDQUFhOzs7OztBQ0YxQixnQ0FBMEM7QUFHMUM7SUFNRSx1QkFBWSxNQUF3QixFQUFFLE1BQXdCLEVBQzFELE9BQW1DLEVBQ25DLE9BQW1DO1FBRG5DLHdCQUFBLEVBQUEsVUFBVSx3QkFBaUIsQ0FBQyxPQUFPO1FBQ25DLHdCQUFBLEVBQUEsVUFBVSx3QkFBaUIsQ0FBQyxPQUFPO1FBUHZDLGtCQUFhLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFRckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVqQyxJQUFNLFdBQVcsR0FDYixDQUFDLE9BQU8sS0FBSyx3QkFBaUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLElBQU0sV0FBVyxHQUNiLENBQUMsT0FBTyxLQUFLLHdCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUU5QyxJQUFNLFNBQVMsR0FDYixDQUFDLE9BQU8sS0FBSyx3QkFBaUIsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLElBQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxLQUFLLHdCQUFpQixDQUFDLE9BQU8sQ0FBQztZQUNwRCxlQUFlLEdBQUcsZUFBZSxDQUFDO1FBQ3RDLElBQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxLQUFLLHdCQUFpQixDQUFDLE9BQU8sQ0FBQztZQUNwRCxlQUFlLEdBQUcsZUFBZSxDQUFDO1FBRXRDLElBQUksQ0FBQyxRQUFRLEdBQUcsbUNBQ1UsU0FBUyxnTkFNTixRQUFRLDJDQUNSLFFBQVEsbU5BVXBDLENBQUM7SUFDSixDQUFDO0lBQ0gsb0JBQUM7QUFBRCxDQTVDQSxBQTRDQyxJQUFBO0FBNUNZLHNDQUFhOzs7OztBQ0gxQix3Q0FBMEM7QUFHMUMsMkNBQ0ksU0FBbUMsRUFBRSxLQUFhLEVBQUUsTUFBYyxFQUNsRSxHQUFXLEVBQUUsUUFBMkIsRUFBRSxnQkFBeUI7SUFDckUsRUFBRSxDQUFDLENBQUMsUUFBUSxLQUFLLEtBQUssSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRCxJQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFM0IsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRS9ELElBQUksV0FBVyxHQUFHLGFBQWEsQ0FBQztJQUNoQyxFQUFFLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDckIsV0FBVyxHQUFHLGdCQUFnQixDQUFDO0lBQ2pDLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDOUIsV0FBVyxHQUFHLFVBQVUsQ0FBQztJQUMzQixDQUFDO0lBRUQsTUFBTSxDQUFDLG1LQU13QixXQUFXLENBQUMsQ0FBQyxDQUFDLFVBQUssV0FBVyxDQUFDLENBQUMsQ0FBQyxzUkFXOUIsS0FBSyw0Q0FDVCxLQUFLLDJEQUVRLE1BQU0sVUFBSyxNQUFNLDRCQUM3QyxHQUFHLFlBQU8sR0FBRyw4VUFXQSxLQUFLLDRKQUtILEtBQUssa0lBR04sS0FBSyxpbEJBa0JwQixRQUFRLEtBQUssS0FBSyw4Q0FDQSxLQUFLLEdBQUcsS0FBSyxpUkFNdkIsUUFBUSxLQUFLLEtBQUssR0FBRyxJQUFJLEdBQUcsSUFBSSw4SEFHcEMsZ0JBQWdCLHlEQUNVLEtBQUssbUhBTXZCLFdBQVcsdUJBQ2pDLENBQUM7QUFDUCxDQUFDO0FBL0ZELDhFQStGQztBQUVELG9CQUNJLEtBQW1CLEVBQUUsT0FBcUIsRUFBRSxDQUFlLEVBQzNELE1BQW9CLEVBQUUsaUJBQW1DO0lBQzNELEtBQUssQ0FBQyxzQkFBc0IsQ0FDeEIsTUFBTSxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEQsS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDekIsQ0FBQztBQVJELGdDQVFDOzs7OztBQzFHRDtJQU1FLDBCQUFtQixLQUFhO1FBQWIsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUxoQyxrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsV0FBTSxHQUFjLEVBQUUsQ0FBQztRQUN2QixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUl6QixJQUFJLENBQUMsUUFBUSxHQUFHLGtGQUdVLEtBQUssc0dBSzlCLENBQUM7SUFDSixDQUFDO0lBQ0gsdUJBQUM7QUFBRCxDQWpCQSxBQWlCQyxJQUFBO0FBakJZLDRDQUFnQjs7Ozs7QUNBN0IseUNBQTJDO0FBRTNDLDRCQUNJLEtBQW1CLEVBQUUsZ0JBQXdCO0lBQy9DLElBQU0sb0JBQW9CLEdBQUcsbUlBS00sZ0JBQWdCLDRlQWdCL0MsQ0FBQztJQUVMLE1BQU0sQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDbkQsQ0FBQztBQTFCRCxnREEwQkM7QUFFRCx3QkFDSSxLQUFtQixFQUFFLFlBQTBCLEVBQUUsU0FBdUI7SUFDMUUsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3QyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3RELENBQUM7QUFKRCx3Q0FJQztBQUVELDZCQUNJLEtBQW1CLEVBQUUsWUFBMEIsRUFBRSxTQUF1QjtJQUMxRSxLQUFLLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQy9CLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BELEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBTEQsa0RBS0M7Ozs7O0FDM0NELGlDQUFtQztBQUduQztJQUNFLE1BQU0sQ0FBQywwdEJBb0JILENBQUM7QUFDUCxDQUFDO0FBdEJELDBEQXNCQztBQUVELGlCQUNJLEtBQW1CLEVBQUUsY0FBNEIsRUFBRSxDQUFlLEVBQ2xFLFFBQWdCLEVBQUUsUUFBZ0IsRUFBRSxNQUFvQixFQUN4RCxhQUFxQixFQUFFLGFBQXFCO0lBQzlDLElBQU0sU0FBUyxHQUFHLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDdEMsSUFBTSxVQUFVLEdBQUcsYUFBYSxHQUFHLGFBQWEsQ0FBQztJQUNqRCxJQUFJLENBQUMsTUFBTSxDQUNQLFNBQVMsS0FBSyxVQUFVLEVBQ3hCLHFCQUFtQixTQUFTLDJCQUFzQixVQUFVLE9BQUk7UUFDNUQsWUFBWSxDQUFDLENBQUM7SUFFdEIsS0FBSyxDQUFDLHNCQUFzQixDQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDbkUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNqQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUU3QyxJQUFNLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNsRSxLQUFLLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFM0QsSUFBTSxtQkFBbUIsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDcEUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEVBQUUsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRXRFLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN6QixDQUFDO0FBdEJELDBCQXNCQzs7Ozs7QUNqREQsd0NBQTBDO0FBSTFDLGlDQUNJLGFBQXVDLEVBQ3ZDLHNCQUF3QyxFQUFFLFlBQXFCO0lBQ2pFLElBQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUvQixJQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMscUJBQXFCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFdkUsSUFBTSxzQkFBc0IsR0FBRyxZQUFZO1FBQ3ZDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQztRQUNuRCxhQUFhLENBQUM7SUFFbEIsSUFBTSx1QkFBdUIsR0FBRyxZQUFZO1FBQ3hDLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUM7UUFDckUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUVsRSxNQUFNLENBQUMsNktBTTRCLGFBQWEsQ0FBQyxDQUFDLENBQUMsVUFBSyxhQUFhLENBQUMsQ0FBQyxDQUFDLDREQUVoRSxlQUFlLENBQUMsQ0FBQyxDQUFDLFVBQUssZUFBZSxDQUFDLENBQUMsQ0FBQyw4RUFHekMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEdBQUcsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLG1CQUN0RCxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsR0FBRyx1QkFBdUIsQ0FBQyxDQUFDLENBQUMsa0dBR2xDLEtBQUsscVFBUU0sS0FBSyx1REFDZCxLQUFLLHM1QkFxQi9CLENBQUM7QUFDUCxDQUFDO0FBN0RELDBEQTZEQztBQUVELHdCQUNJLEtBQW1CLEVBQUUscUJBQW1DLEVBQUUsQ0FBZSxFQUN6RSxNQUFvQixFQUFFLGlCQUFtQztJQUMzRCxLQUFLLENBQUMsc0JBQXNCLENBQ3hCLE1BQU0sRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hELEtBQUssQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUN4QyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QyxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDekIsQ0FBQztBQVJELHdDQVFDOzs7OztBQzNFRCxpQ0FBbUM7QUFZbkMsb0JBQTJCLFVBQXVCLEVBQUUsV0FBc0IsRUFDdEUsUUFBZ0IsRUFBRSxTQUFrQjtJQUN0QyxJQUFNLGtCQUFrQixHQUNwQixVQUFVLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsdUJBQXFCLENBQUMsQ0FBQyxJQUFJLE1BQUcsRUFBOUIsQ0FBOEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuRSxJQUFNLG9CQUFvQixHQUN0QixVQUFVLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsdUJBQXVCLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsRUFBbEQsQ0FBa0QsQ0FBQztTQUNsRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEIsSUFBTSxXQUFXLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQztJQUN6QyxJQUFNLHFCQUFxQixHQUN2Qix3QkFBd0IsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3BFLElBQU0sTUFBTSxHQUFHO1FBQ2IsYUFBYSxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQjtRQUN2RSxpQkFBaUIsRUFBRSxpQkFBaUIsRUFBRSxvQkFBb0I7UUFDMUQscUJBQXFCLEVBQUUsUUFBUTtLQUNoQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNiLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWhCRCxnQ0FnQkM7QUFFRCxpQ0FDSSxNQUFpQixFQUFFLFlBQXVCLEVBQUUsU0FBa0I7SUFDaEUsSUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUM7SUFDNUMsSUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUM7SUFDM0MsSUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUUxQyxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDYixNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNyQixLQUFLLENBQUM7WUFDSixHQUFHLElBQUksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JDLEtBQUssQ0FBQztRQUNSLEtBQUssQ0FBQztZQUNKLEdBQUcsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztZQUMzQyxLQUFLLENBQUM7UUFDUixLQUFLLENBQUM7WUFDSixHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBeUIsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RSxLQUFLLENBQUM7UUFDUixLQUFLLENBQUM7WUFDSixHQUFHLElBQUksWUFBWSxDQUNmLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBaUMsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUM5RCxLQUFLLENBQUM7UUFDUixLQUFLLENBQUM7WUFDSixHQUFHLElBQUksWUFBWSxDQUNmLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBeUMsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RSxLQUFLLENBQUM7UUFDUjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQ1IsS0FBSyxDQUFDLE1BQU0sc0JBQW1CO2dCQUNsQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFJRCxFQUFFLENBQUMsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FDekIsTUFBTSxDQUFDLFNBQVMsQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRSxHQUFHO1lBQ0Msd0JBQXdCLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7SUFDRCxHQUFHLElBQUksY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDN0MsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCxrQ0FDSSxRQUFrQixFQUFFLFdBQTZCO0lBQ25ELE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLEtBQUssQ0FBQztZQUVKLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDWixLQUFLLENBQUM7WUFDSixNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBb0IsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM5RCxLQUFLLENBQUM7WUFDSixNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBNEIsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUN0RSxLQUFLLENBQUM7WUFDSixNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBb0MsRUFDekQsV0FBVyxDQUFDLENBQUM7UUFDbkIsS0FBSyxDQUFDO1lBQ0osTUFBTSxDQUFDLGlCQUFpQixDQUFDLFFBQTRDLEVBQ25FLFdBQVcsQ0FBQyxDQUFDO1FBQ2pCO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FDUixRQUFRLENBQUMsTUFBTSw0Q0FBeUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7QUFDSCxDQUFDO0FBRUQsSUFBTSxhQUFhLEdBQUcsc1BBWXJCLENBQUM7QUFFRixJQUFNLGlCQUFpQixHQUFHLHVSQU96QixDQUFDO0FBRUYsSUFBTSxpQkFBaUIsR0FBRyw0V0FTekIsQ0FBQztBQUVGLElBQU0saUJBQWlCLEdBQUcsOFpBU3pCLENBQUM7QUFFRixJQUFNLGlCQUFpQixHQUFHLDBlQVd6QixDQUFDO0FBRUYsMkJBQ0ksS0FBZSxFQUFFLFFBQTBCO0lBQzdDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0sQ0FBQyx5RkFJTixDQUFDO0lBQ0osQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0sQ0FBQyx5RkFJTixDQUFDO0lBQ0osQ0FBQztJQUNELE1BQU0sQ0FBQyxxSEFHeUIsUUFBUSxDQUFDLENBQUMsQ0FBQywwQkFFMUMsQ0FBQztBQUNKLENBQUM7QUFFRCwyQkFBMkIsS0FBK0IsRUFDdEQsUUFBMEI7SUFDNUIsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekIsTUFBTSxDQUFDLDJIQUdnQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGtEQUNwQixPQUFPLGlDQUNsQixPQUFPLDJDQUNJLE9BQU8seUNBQ1YsT0FBTyxpREFHakMsQ0FBQztBQUNKLENBQUM7QUFFRCwyQkFBMkIsS0FBdUMsRUFDaEUsUUFBMEI7SUFDMUIsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDbkMsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUNuQyxNQUFNLENBQUMsMkhBR2dDLFFBQVEsQ0FBQyxDQUFDLENBQUMsb0RBRXBCLE9BQU8saUNBQ2xCLE9BQU8sNkNBRUksT0FBTyxpQ0FDbEIsT0FBTyw2Q0FFSSxPQUFPLDBDQUNULE9BQU8sdURBSWxDLENBQUM7QUFDSixDQUFDO0FBRUQsMkJBQ0ksS0FBdUIsRUFBRSxRQUEwQjtJQUNyRCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsTUFBTSxDQUFDLHlGQUlOLENBQUM7SUFDSixDQUFDO0lBQ0QsTUFBTSxDQUFDLDJIQUdnQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGtEQUNwQixLQUFLLENBQUMsQ0FBQyxDQUFDLHlDQUNYLEtBQUssQ0FBQyxDQUFDLENBQUMsOENBR2xDLENBQUM7QUFDSixDQUFDO0FBRUQsMEJBQTBCLE9BQWU7SUFDdkMsSUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RSxNQUFNLENBQUMsaUJBQ0csUUFBUSxxQ0FDSyxPQUFPLDRCQUU3QixDQUFDO0FBQ0osQ0FBQztBQUVELHNCQUNJLE9BQWUsRUFBRSxRQUEwQjtJQUM3QyxJQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVFLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QixJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLENBQUMsbUJBQ0csUUFBUSxrREFDSyxPQUFPLGdDQUU3QixDQUFDO0lBQ0osQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0sQ0FBQyxtQkFDRyxRQUFRLHFFQUN3QixFQUFFLHVDQUNyQixPQUFPLDRCQUU3QixDQUFDO0lBQ0osQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RCLE1BQU0sQ0FBQyxtQkFDRyxRQUFRLGdFQUNtQixFQUFFLDRDQUNoQixPQUFPLDRCQUU3QixDQUFDO0lBQ0osQ0FBQztJQUNELE1BQU0sQ0FBQyxpQkFDRyxRQUFRLCtDQUNJLE9BQU8sVUFBSyxFQUFFLFlBQU8sRUFBRSwyQkFFNUMsQ0FBQztBQUNKLENBQUM7QUFFRCxzQkFDSSxPQUFlLEVBQUUsS0FBK0IsRUFDaEQsUUFBMEI7SUFDNUIsSUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1RSxJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZCLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLE1BQU0sQ0FBQyxpQkFDRyxRQUFRLHFFQUNJLE9BQU8sVUFBSyxFQUFFLFlBQU8sRUFBRSxZQUFPLE9BQU8sWUFBTyxPQUFPLGdEQUd4RSxDQUFDO0FBQ0osQ0FBQztBQUVELHNCQUNJLE9BQWUsRUFBRSxLQUF1QyxFQUN4RCxRQUEwQjtJQUM1QixJQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVFLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QixJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pCLElBQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDbkMsSUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztJQUVuQyxNQUFNLENBQUMsZUFDQyxRQUFRLGlGQUNJLE9BQU8sVUFBSyxFQUFFLFlBQU8sRUFBRSxZQUFPLE9BQU8sWUFBTyxPQUFPLHFCQUMvRCxPQUFPLHlDQUVoQixDQUFDO0FBQ0YsQ0FBQztBQUVELHNCQUNJLE9BQWUsRUFBRSxLQUF1QixFQUN4QyxRQUEwQjtJQUM1QixJQUFNLFFBQVEsR0FBRyxLQUFLLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVFLElBQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2QixJQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxtQkFDRyxRQUFRLHFGQUMrQixFQUFFLFlBQU8sRUFBRSx1Q0FDckMsT0FBTyw0QkFFN0IsQ0FBQztJQUNKLENBQUM7SUFDRCxNQUFNLENBQUMsaUJBQ0csUUFBUSx3REFDSSxPQUFPLFVBQUssRUFBRSxZQUFPLEVBQUUsWUFBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLDhCQUUzRCxDQUFDO0FBQ0osQ0FBQztBQUVELHdCQUF3QixPQUFlLEVBQUUsUUFBMEI7SUFDakUsSUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDdkUsTUFBTSxDQUFDO0lBQ1gsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQixFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9CLE1BQU0sQ0FBQyxtQkFDRyxRQUFRLGtEQUNLLE9BQU8sZ0NBRTdCLENBQUM7SUFDSixDQUFDO0lBQ0QsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEIsTUFBTSxDQUFDLG1CQUNHLFFBQVEscUVBQ3dCLEtBQUssdUNBQ3hCLE9BQU8sNEJBRTdCLENBQUM7SUFDSixDQUFDO0lBQ0QsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEIsTUFBTSxDQUFDLG1CQUNHLFFBQVEsZ0VBQ21CLEtBQUssNENBQ25CLE9BQU8sNEJBRTdCLENBQUM7SUFDSixDQUFDO0lBQ0QsTUFBTSxDQUFDLGlCQUNHLFFBQVEsMERBQ2UsS0FBSyw0Q0FDUixLQUFLLGlFQUNnQixLQUFLLFlBQU8sS0FBSyxxQ0FDN0MsT0FBTyx3QkFFN0IsQ0FBQztBQUNKLENBQUM7QUFFRCxrQ0FBa0MsT0FBZSxFQUFFLFVBQTRCLEVBQzNFLFdBQTZCLEVBQUUsU0FBa0I7SUFDbkQsSUFBTSxRQUFRLEdBQUcsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDekUsYUFBYSxDQUFDO0lBQ2hCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QyxNQUFNLENBQUMsbUJBQ0csUUFBUSx1Q0FDSyxPQUFPLGtDQUU3QixDQUFDO0lBQ0osQ0FBQztJQUNELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUMsSUFBTSxnQkFBZ0IsR0FBRyxTQUFTLEdBQUcsd0JBQXNCLE1BQU0sU0FBTSxHQUFHLEVBQUUsQ0FBQztJQUU3RSxNQUFNLENBQUMsaUJBQ0csUUFBUSxvR0FFcUIsV0FBVyxDQUFDLENBQUMsQ0FBQywwQkFDL0MsZ0JBQWdCLDJDQUNXLFVBQVUsQ0FBQyxDQUFDLENBQUMsNENBQ2hCLFVBQVUsQ0FBQyxDQUFDLENBQUMsbUZBRXJCLFVBQVUsQ0FBQyxDQUFDLENBQUMsWUFBTyxVQUFVLENBQUMsQ0FBQyxDQUFDLHFDQUNoQyxPQUFPLHdCQUU3QixDQUFDO0FBQ0osQ0FBQzs7Ozs7QUNoWkQsa0RBQ0ksSUFBWSxFQUFFLE9BQWU7SUFDL0IsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFIRCw0RkFHQztBQUVELDRDQUNJLFVBQWtCLEVBQUUsa0JBQTBCO0lBQ2hELE1BQU0sQ0FBQyxVQUFVLEdBQUcsa0JBQWtCLENBQUM7QUFDekMsQ0FBQztBQUhELGdGQUdDO0FBRUQsK0NBQ0ksSUFBWSxFQUFFLE9BQWU7SUFDL0IsTUFBTSxDQUFDLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBSEQsc0ZBR0M7QUFFRCw0Q0FDSSxZQUFvQixFQUFFLGtCQUEwQjtJQUNsRCxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsa0JBQWtCLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QyxNQUFNLElBQUksS0FBSyxDQUNYLGdCQUFnQixHQUFHLFlBQVksR0FBRywwQkFBMEI7WUFDNUQsa0JBQWtCLENBQUMsQ0FBQztJQUMxQixDQUFDO0lBQ0QsTUFBTSxDQUFDLFlBQVksR0FBRyxrQkFBa0IsQ0FBQztBQUMzQyxDQUFDO0FBUkQsZ0ZBUUM7QUFFRCxxQ0FDSSxNQUFvQixFQUFFLGFBQTJCLEVBQ2pELGtCQUEwQjtJQUM1QixJQUFNLFlBQVksR0FDZCxrQ0FBa0MsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDMUUsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQ1gsd0JBQXdCLEdBQUcsYUFBYSxDQUFDLE1BQU07WUFDL0MsZUFBZSxHQUFHLFlBQVksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFDRCxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDWixHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUM3QyxhQUFhLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLEdBQUcsSUFBSSxrQkFBa0IsQ0FBQztJQUM1QixDQUFDO0FBQ0gsQ0FBQztBQWZELGtFQWVDO0FBRUQsdUNBQ0ksYUFBMkIsRUFBRSxNQUFvQixFQUNqRCxrQkFBMEI7SUFDNUIsSUFBTSxZQUFZLEdBQUcsa0NBQWtDLENBQ25ELGFBQWEsQ0FBQyxNQUFNLEVBQUUsa0JBQWtCLENBQUMsQ0FBQztJQUM5QyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDakMsTUFBTSxJQUFJLEtBQUssQ0FDWCxpQkFBaUIsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLGVBQWUsR0FBRyxZQUFZLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBQ0QsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ1osR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxhQUFhLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO1FBQ3hFLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDO0FBQ0gsQ0FBQztBQWJELHNFQWFDO0FBRUQsZ0RBQ0ksSUFBWSxFQUFFLE9BQWU7SUFDL0IsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDO0FBSEQsd0ZBR0M7QUFFRCwrQ0FDSSxJQUFZLEVBQUUsT0FBZTtJQUN6QixJQUFBLDBEQUE4RCxFQUE3RCxTQUFDLEVBQUUsU0FBQyxDQUEwRDtJQUNyRSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUpELHNGQUlDO0FBRUQsa0NBQ0ksTUFBb0IsRUFBRSxJQUFZLEVBQUUsT0FBZSxFQUNuRCxVQUF3QjtJQUMxQixJQUFNLFlBQVksR0FBRyxxQ0FBcUMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDMUUsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQ1gscUJBQXFCLEdBQUcsVUFBVSxDQUFDLE1BQU07WUFDekMsZUFBZSxHQUFHLFlBQVksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFlSyxJQUFBLDBEQUNtRCxFQURsRCxvQkFBWSxFQUFFLHFCQUFhLENBQ3dCO0lBQzFELElBQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyxJQUFNLFNBQVMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsSUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNsRCxJQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBR2hELENBQUM7UUFDQyxJQUFNLFNBQVMsR0FBRyxDQUFDLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNaLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsa0JBQWtCLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUMzRCxJQUFNLFlBQVksR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7WUFDNUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxpQkFBaUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFDO2dCQUMxRCxJQUFNLFlBQVksR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQyxJQUFNLEdBQUcsR0FBRyxZQUFZLEdBQUcsWUFBWSxDQUFDO2dCQUN4QyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUM5QixVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RDLFVBQVUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsQ0FBQztnQkFDM0MsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDL0MsR0FBRyxJQUFJLENBQUMsQ0FBQztZQUNYLENBQUM7WUFDRCxHQUFHLElBQUksU0FBUyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0lBR0QsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNiLElBQUksR0FBRyxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDdEIsSUFBSSxHQUFHLEdBQUcsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQU0sU0FBUyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDOUIsSUFBTSxTQUFTLEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQztRQUNuQyxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLGtCQUFrQixFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUM7WUFDM0QsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5QixVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDLENBQUM7WUFDNUMsR0FBRyxJQUFJLFNBQVMsQ0FBQztZQUNqQixHQUFHLElBQUksU0FBUyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0lBR0QsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNkLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUMvQixJQUFJLEdBQUcsR0FBRyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ2pELEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsaUJBQWlCLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUMxRCxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUNsQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztZQUNsQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ1gsQ0FBQztJQUNILENBQUM7SUFHRCxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQztRQUMxQixVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBakZELDREQWlGQztBQUVELG9DQUNJLFVBQXdCLEVBQUUsSUFBWSxFQUFFLE9BQWUsRUFDdkQsTUFBb0I7SUFDdEIsSUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLE9BQU8sQ0FBQztJQUNwQyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDakMsTUFBTSxJQUFJLEtBQUssQ0FDWCxpQkFBaUIsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLGVBQWUsR0FBRyxZQUFZLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBQ0QsSUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLElBQU0sU0FBUyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNuQyxJQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ2xELElBQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUMsSUFBQSwwREFDbUQsRUFEbEQsb0JBQVksRUFBRSxxQkFBYSxDQUN3QjtJQUcxRCxDQUFDO1FBQ0MsSUFBTSxTQUFTLEdBQUcsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsSUFBTSxTQUFTLEdBQUcsT0FBTyxHQUFHLENBQUMsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMvQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDWixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDaEIsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3RCLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxHQUFHLENBQUMsRUFBRSxNQUFNLEdBQUcsa0JBQWtCLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQztZQUMzRCxHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLGlCQUFpQixFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUM7Z0JBQzFELE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO2dCQUN0QyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztnQkFDdEMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7Z0JBQ3RDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLENBQUM7WUFDRCxHQUFHLElBQUksU0FBUyxDQUFDO1lBQ2pCLE9BQU8sSUFBSSxTQUFTLENBQUM7WUFDckIsT0FBTyxJQUFJLFNBQVMsQ0FBQztRQUN2QixDQUFDO0lBQ0gsQ0FBQztJQUdELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDYixJQUFJLEdBQUcsR0FBRyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxHQUFHLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUN0QixJQUFNLFNBQVMsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLElBQU0sU0FBUyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDOUIsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxrQkFBa0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFDO1lBQzNELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzVDLEdBQUcsSUFBSSxTQUFTLENBQUM7WUFDakIsR0FBRyxJQUFJLFNBQVMsQ0FBQztRQUNuQixDQUFDO0lBQ0gsQ0FBQztJQUdELEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDZCxJQUFJLEdBQUcsR0FBRyxDQUFDLGFBQWEsR0FBRyxDQUFDLENBQUMsR0FBRyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ2pELElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUMvQixHQUFHLENBQUMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTSxHQUFHLGlCQUFpQixFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUM7WUFDMUQsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDbEMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDbEMsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNYLENBQUM7SUFDSCxDQUFDO0lBR0QsRUFBRSxDQUFDLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVELE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQWxFRCxnRUFrRUM7Ozs7O0FDdk5EO0lBT0Usd0JBQW9CLEtBQW1CO1FBQW5CLFVBQUssR0FBTCxLQUFLLENBQWM7UUFOL0Isb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFDcEIsb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFDcEIsaUJBQVksR0FBc0MsRUFBRSxDQUFDO1FBQ3JELGVBQVUsR0FBRyxLQUFLLENBQUM7UUFDbkIscUJBQWdCLEdBQThCLEVBQUUsQ0FBQztJQUVmLENBQUM7SUFFM0MsdUNBQWMsR0FBZCxVQUFlLE9BQXlCO1FBQ3RDLElBQU0sUUFBUSxHQUFHLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2pELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNuQyxDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFFbEMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDdkIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNYLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssRUFBRyxDQUFDO1FBQzlDLENBQUM7UUFDRCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRVgsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRCx1Q0FBYyxHQUFkLFVBQWUsT0FBcUIsRUFBRSxLQUF1QjtRQUMzRCxJQUFNLFFBQVEsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbkMsQ0FBQztRQUNELElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2IsQ0FBQztJQUVPLDRCQUFHLEdBQVg7UUFDRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLE1BQU0sQ0FBQztRQUNULENBQUM7UUFDRCxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDMUQsT0FBTyxDQUFDLEdBQUcsQ0FDUCxXQUFXLEVBQUUsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFDaEUsTUFBSSxLQUFLLE1BQUcsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFFRCwyQ0FBa0IsR0FBbEI7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUM5QixDQUFDO0lBRUQsMkNBQWtCLEdBQWxCO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDOUIsQ0FBQztJQUVELGdDQUFPLEdBQVA7UUFDRSxHQUFHLENBQUMsQ0FBQyxJQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUN0QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztvQkFDekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzlELENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFDSCxxQkFBQztBQUFELENBdEVBLEFBc0VDLElBQUE7QUF0RVksd0NBQWM7QUF3RTNCLGdDQUFnQyxZQUE4QjtJQUM1RCxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQzs7Ozs7QUMxRUQsSUFBWSxPQUVYO0FBRkQsV0FBWSxPQUFPO0lBQ2pCLG1DQUFHLENBQUE7SUFBRSxtQ0FBRyxDQUFBO0lBQUUsbUNBQUcsQ0FBQTtJQUFFLHFDQUFJLENBQUE7SUFBRSwyQ0FBTyxDQUFBO0lBQUUscUNBQUksQ0FBQTtJQUFFLG1DQUFHLENBQUE7SUFBRSxxQ0FBSSxDQUFBO0FBQy9DLENBQUMsRUFGVyxPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFFbEI7QUFFRDtJQU1FLHdCQUFZLE1BQWdCLEVBQUUsRUFBVztRQUx6QyxrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFNcEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUM7UUFDMUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsMEVBR1YsWUFBWSxDQUFDLEVBQUUsQ0FBQywyQ0FHckIsQ0FBQztJQUNKLENBQUM7SUFDSCxxQkFBQztBQUFELENBakJBLEFBaUJDLElBQUE7QUFqQlksd0NBQWM7QUFtQjNCLHNCQUFzQixFQUFXO0lBQy9CLE1BQU0sQ0FBQSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDVixLQUFLLE9BQU8sQ0FBQyxHQUFHO1lBQ2QsTUFBTSxDQUFDLG1CQUFtQixDQUFDO1FBQzdCLEtBQUssT0FBTyxDQUFDLEdBQUc7WUFDZCxNQUFNLENBQUMsbUJBQW1CLENBQUM7UUFDN0IsS0FBSyxPQUFPLENBQUMsR0FBRztZQUNkLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDekIsS0FBSyxPQUFPLENBQUMsSUFBSTtZQUNmLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQztRQUMxQyxLQUFLLE9BQU8sQ0FBQyxPQUFPO1lBQ2xCLE1BQU0sQ0FBQyx3Q0FBd0MsQ0FBQztRQUNsRCxLQUFLLE9BQU8sQ0FBQyxJQUFJO1lBQ2YsTUFBTSxDQUFDLGlEQUFpRCxDQUFDO1FBQzNELEtBQUssT0FBTyxDQUFDLEdBQUc7WUFDZCxNQUFNLENBQUMsbUJBQW1CLENBQUM7UUFDN0IsS0FBSyxPQUFPLENBQUMsSUFBSTtZQUNmLE1BQU0sQ0FBQywrRkFDZ0QsQ0FBQztRQUMxRDtZQUNFLE1BQU0sS0FBSyxDQUFDLDZCQUE2QixHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7QUFDSCxDQUFDOzs7OztBQy9DRCxJQUFJLHlCQUF5QixHQUFHLElBQUksQ0FBQztBQUNyQyxJQUFJLGNBQWMsR0FBc0IsSUFBSyxDQUFDO0FBQzlDLElBQUksZ0JBQWdCLEdBQVcsSUFBSyxDQUFDO0FBRXJDLGlDQUFtQztBQWNuQyxxQ0FBNEMsVUFBa0M7SUFFNUUsSUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNqQixNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNsQixNQUFNLENBQUMscUNBQXFDLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFORCxrRUFNQztBQU1EO0lBQ0UseUJBQXlCLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDeEIsQ0FBQztBQUhELG9DQUdDO0FBS0Q7SUFDRSx5QkFBeUIsR0FBRyxJQUFJLENBQUM7SUFDakMsY0FBYyxHQUFHLElBQUksQ0FBQztBQUN4QixDQUFDO0FBSEQsb0NBR0M7QUFFRDtJQUNFLEVBQUUsQ0FBQyxDQUFDLENBQUMseUJBQXlCLENBQUMsQ0FBQyxDQUFDO1FBQy9CLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsRUFBRSxDQUFDLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDM0IsSUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNwRCxJQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2YsY0FBYyxHQUFHLElBQUksQ0FBQztZQUV0QixJQUFNLG9CQUFvQixHQUN0QixtQkFBbUIsQ0FDZixFQUEyQixFQUFFLG9CQUFvQixDQUM1QixDQUFDO1lBQzlCLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3JDLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFDekIsQ0FBQztJQUNILENBQUM7SUFDRCxNQUFNLENBQUMsY0FBYyxDQUFDO0FBQ3hCLENBQUM7QUFyQkQsMENBcUJDO0FBRUQsK0NBQ0ksTUFBeUIsRUFDekIsVUFBa0M7SUFDcEMsSUFBSSxFQUF5QixDQUFDO0lBQzlCLEVBQUUsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QixFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUEwQixDQUFDO0lBQ3hFLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQztZQUN0QyxNQUFNLENBQUMsVUFBVSxDQUFDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxDQUNoQyxDQUFDO0lBQzVCLENBQUM7SUFFRCxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBQ0QsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNaLENBQUM7QUFoQkQsc0ZBZ0JDO0FBRUQsc0JBQWdDLEVBQXlCLEVBQUUsSUFBYTtJQUN0RSxJQUFNLFdBQVcsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUMzQixlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDcEIsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUNyQixDQUFDO0FBSkQsb0NBSUM7QUFFRCxJQUFJLDhCQUE4QixHQUFHLEtBQUssQ0FBQztBQUUzQyx1Q0FBOEMsT0FBZ0I7SUFDNUQsOEJBQThCLEdBQUcsT0FBTyxDQUFDO0FBQzNDLENBQUM7QUFGRCxzRUFFQztBQUVELHlCQUFnQyxFQUF5QjtJQUN2RCxFQUFFLENBQUMsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzVCLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsR0FBRyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFQRCwwQ0FPQztBQUVELDhCQUNJLEVBQXlCLEVBQUUsTUFBYztJQUMzQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ2YsS0FBSyxFQUFFLENBQUMsUUFBUTtZQUNkLE1BQU0sQ0FBQyxVQUFVLENBQUM7UUFDcEIsS0FBSyxFQUFFLENBQUMsWUFBWTtZQUNsQixNQUFNLENBQUMsY0FBYyxDQUFDO1FBQ3hCLEtBQUssRUFBRSxDQUFDLGFBQWE7WUFDbkIsTUFBTSxDQUFDLGVBQWUsQ0FBQztRQUN6QixLQUFLLEVBQUUsQ0FBQyxpQkFBaUI7WUFDdkIsTUFBTSxDQUFDLG1CQUFtQixDQUFDO1FBQzdCLEtBQUssRUFBRSxDQUFDLDZCQUE2QjtZQUNuQyxNQUFNLENBQUMsK0JBQStCLENBQUM7UUFDekMsS0FBSyxFQUFFLENBQUMsYUFBYTtZQUNuQixNQUFNLENBQUMsZUFBZSxDQUFDO1FBQ3pCLEtBQUssRUFBRSxDQUFDLGtCQUFrQjtZQUN4QixNQUFNLENBQUMsb0JBQW9CLENBQUM7UUFDOUI7WUFDRSxNQUFNLENBQUMscUJBQXFCLEdBQUcsTUFBTSxDQUFDO0lBQzFDLENBQUM7QUFDSCxDQUFDO0FBcEJELG9EQW9CQztBQUVELDZCQUNJLEVBQXlCLEVBQUUsYUFBcUI7SUFDbEQsTUFBTSxDQUFDLFdBQVcsQ0FDZCxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLEVBQTlCLENBQThCLEVBQ3hDLGFBQWEsR0FBRyxhQUFhLEdBQUcsa0NBQWtDLENBQUMsQ0FBQztBQUMxRSxDQUFDO0FBTEQsa0RBS0M7QUFFRCw0QkFDSSxFQUF5QixFQUFFLGtCQUEwQjtJQUN2RCxJQUFNLFlBQVksR0FBZ0IsV0FBVyxDQUN6QyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFqQyxDQUFpQyxFQUMzQyxzQ0FBc0MsQ0FBQyxDQUFDO0lBQzVDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLGtCQUFrQixDQUFDLEVBQWpELENBQWlELENBQUMsQ0FBQztJQUMxRSxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxFQUE5QixDQUE4QixDQUFDLENBQUM7SUFDdkQsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNyRSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQy9DLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBQ0QsTUFBTSxDQUFDLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBWkQsZ0RBWUM7QUFFRCw4QkFDSSxFQUF5QixFQUFFLG9CQUE0QjtJQUN6RCxJQUFNLGNBQWMsR0FBZ0IsV0FBVyxDQUMzQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFuQyxDQUFtQyxFQUM3Qyx3Q0FBd0MsQ0FBQyxDQUFDO0lBQzlDLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxZQUFZLENBQUMsY0FBYyxFQUFFLG9CQUFvQixDQUFDLEVBQXJELENBQXFELENBQUMsQ0FBQztJQUM5RSxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxFQUFoQyxDQUFnQyxDQUFDLENBQUM7SUFDekQsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztRQUN2RSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1FBQ2pELE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQ0QsTUFBTSxDQUFDLGNBQWMsQ0FBQztBQUN4QixDQUFDO0FBWkQsb0RBWUM7QUFFRCx1QkFBOEIsRUFBeUI7SUFDckQsTUFBTSxDQUFDLFdBQVcsQ0FDZCxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxhQUFhLEVBQUUsRUFBbEIsQ0FBa0IsRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ3RFLENBQUM7QUFIRCxzQ0FHQztBQUVELHFCQUE0QixFQUF5QixFQUFFLE9BQXFCO0lBQzFFLFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQXZCLENBQXVCLENBQUMsQ0FBQztJQUNoRCxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzlELE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7QUFDSCxDQUFDO0FBTkQsa0NBTUM7QUFFRCx5QkFDSSxFQUF5QixFQUFFLE9BQXFCO0lBQ2xELFlBQVksQ0FBQyxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQTNCLENBQTJCLENBQUMsQ0FBQztJQUNwRCxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7QUFDSCxDQUFDO0FBUEQsMENBT0M7QUFFRCxrQ0FDSSxFQUF5QixFQUFFLElBQWtCO0lBQy9DLElBQU0sTUFBTSxHQUFnQixXQUFXLENBQ25DLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFlBQVksRUFBRSxFQUFqQixDQUFpQixFQUFFLDhCQUE4QixDQUFDLENBQUM7SUFDakUsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxFQUF0QyxDQUFzQyxDQUFDLENBQUM7SUFDL0QsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQXBELENBQW9ELENBQUMsQ0FBQztJQUM3RSxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFQRCw0REFPQztBQUVELGlDQUNJLEVBQXlCLEVBQUUsSUFBaUI7SUFDOUMsSUFBTSxNQUFNLEdBQWdCLFdBQVcsQ0FDbkMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsWUFBWSxFQUFFLEVBQWpCLENBQWlCLEVBQUUsOEJBQThCLENBQUMsQ0FBQztJQUNqRSxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRSxNQUFNLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDO0lBQ3ZFLFlBQVksQ0FDUixFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLG9CQUFvQixFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLEVBQTVELENBQTRELENBQUMsQ0FBQztJQUM1RSxNQUFNLENBQUMsTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFSRCwwREFRQztBQUVELDZCQUFvQyxFQUF5QjtJQUMzRCxFQUFFLENBQUMsQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzdCLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztJQUMxQixDQUFDO0lBQ0QsZ0JBQWdCO1FBQ1osWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRyxDQUFDLFlBQVksQ0FBQyxFQUFHLENBQUMsZ0JBQWdCLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxDQUFDO0lBQ25FLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztBQUMxQixDQUFDO0FBUEQsa0RBT0M7QUFFRDtJQUNFLEVBQUUsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QixNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUNELE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBTEQsc0RBS0M7QUFFRCx1QkFBOEIsRUFBeUI7SUFDckQsTUFBTSxDQUFDLFdBQVcsQ0FDZCxFQUFFLEVBQUUsY0FBTSxPQUFBLEVBQUUsQ0FBQyxhQUFhLEVBQUUsRUFBbEIsQ0FBa0IsRUFBRSxnQ0FBZ0MsQ0FBQyxDQUFDO0FBQ3RFLENBQUM7QUFIRCxzQ0FHQztBQUVELDZCQUNJLEVBQXlCLEVBQUUsS0FBYSxFQUFFLE1BQWM7SUFDMUQsSUFBTSxjQUFjLEdBQVcsbUJBQW1CLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDdkQsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLElBQU0sU0FBUyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDbkQsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsR0FBRyxTQUFTLEdBQUcsY0FBYyxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRCxJQUFNLFNBQVMsR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBQ25ELElBQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxjQUFjLEdBQUcsR0FBRyxHQUFHLGNBQWMsR0FBRyxHQUFHLENBQUM7UUFDOUQsTUFBTSxJQUFJLEtBQUssQ0FDWCx5QkFBeUIsR0FBRyxTQUFTO1lBQ3JDLG9EQUFvRCxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUN4RSxDQUFDO0FBQ0gsQ0FBQztBQWRELGtEQWNDO0FBRUQsMkJBQWtDLEVBQXlCO0lBQ3pELE1BQU0sQ0FBQyxXQUFXLENBQ2QsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsRUFBdEIsQ0FBc0IsRUFBRSxvQ0FBb0MsQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFIRCw4Q0FHQztBQUVELDRDQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFBRSxTQUFpQixFQUNuRSxNQUFtQixFQUFFLG1CQUEyQixFQUFFLGlCQUF5QixFQUMzRSxpQkFBeUI7SUFDM0IsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyRCxFQUFFLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2YsSUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLENBQ25CLDJCQUEyQixHQUFHLFNBQVMsR0FBRyxvQkFBb0IsQ0FBQyxDQUFDO1FBRW5FLEtBQWEsQ0FBQyw0QkFBNEIsR0FBRyxTQUFTLENBQUM7UUFDeEQsTUFBTSxLQUFLLENBQUM7SUFDZCxDQUFDO0lBQ0QsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxFQUF0QyxDQUFzQyxDQUFDLENBQUM7SUFDL0QsWUFBWSxDQUNSLEVBQUUsRUFDRixjQUFNLE9BQUEsRUFBRSxDQUFDLG1CQUFtQixDQUN4QixHQUFHLEVBQUUsbUJBQW1CLEVBQUUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsaUJBQWlCLEVBQzVELGlCQUFpQixDQUFDLEVBRmhCLENBRWdCLENBQUMsQ0FBQztJQUM1QixZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsdUJBQXVCLENBQUMsR0FBRyxDQUFDLEVBQS9CLENBQStCLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBbkJELGdGQW1CQztBQUVELHlCQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFBRSxXQUFtQjtJQUN2RSxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxFQUEzQyxDQUEyQyxDQUFDLENBQUM7SUFDcEUsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxFQUF0QyxDQUFzQyxDQUFDLENBQUM7QUFDakUsQ0FBQztBQUxELDBDQUtDO0FBRUQsMkJBQ0ksRUFBeUIsRUFBRSxXQUFtQjtJQUNoRCxtQkFBbUIsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsUUFBUSxHQUFHLFdBQVcsQ0FBQyxFQUEzQyxDQUEyQyxDQUFDLENBQUM7SUFDcEUsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7QUFDOUQsQ0FBQztBQUxELDhDQUtDO0FBRUQsMENBQ0ksRUFBeUIsRUFBRSxPQUFxQixFQUNoRCxXQUFtQjtJQUNyQixNQUFNLENBQUMsV0FBVyxDQUNkLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsRUFBM0MsQ0FBMkMsRUFDckQsV0FBVyxHQUFHLFdBQVcsR0FBRywyQkFBMkIsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFORCw0RUFNQztBQUVELDRDQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFBRSxPQUFxQixFQUN2RSxrQkFBMEIsRUFBRSxXQUFtQjtJQUNqRCxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxlQUFlLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxXQUFXLENBQUMsRUFBekMsQ0FBeUMsQ0FBQyxDQUFDO0lBQ2xFLElBQU0sZUFBZSxHQUNqQixnQ0FBZ0MsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDdEUsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFNBQVMsQ0FBQyxlQUFlLEVBQUUsV0FBVyxDQUFDLEVBQTFDLENBQTBDLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBUEQsZ0ZBT0M7QUFFRCxpQ0FBd0MsRUFBeUI7SUFDL0QsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUF4QyxDQUF3QyxDQUFDLENBQUM7SUFDakUsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQXBELENBQW9ELENBQUMsQ0FBQztJQUM3RSxZQUFZLENBQUMsRUFBRSxFQUFFLGNBQU0sT0FBQSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBbkQsQ0FBbUQsQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFKRCwwREFJQztBQUVELHVDQUNJLEVBQXlCLEVBQUUsT0FBcUIsRUFDaEQsV0FBNkI7SUFDL0IsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxFQUEvQyxDQUErQyxDQUFDLENBQUM7SUFDeEUsWUFBWSxDQUNSLEVBQUUsRUFDRixjQUFNLE9BQUEsRUFBRSxDQUFDLG9CQUFvQixDQUN6QixFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFEOUQsQ0FDOEQsQ0FBQyxDQUFDO0FBQzVFLENBQUM7QUFSRCxzRUFRQztBQUVELDJDQUNJLEVBQXlCLEVBQUUsV0FBNkI7SUFDMUQsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxFQUEvQyxDQUErQyxDQUFDLENBQUM7SUFDeEUsWUFBWSxDQUNSLEVBQUUsRUFDRixjQUFNLE9BQUEsRUFBRSxDQUFDLG9CQUFvQixDQUN6QixFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFEM0QsQ0FDMkQsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFQRCw4RUFPQztBQUVELDZCQUFvQyxFQUF5QjtJQUMzRCxJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsc0JBQXNCLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3pELEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxFQUFFLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQ1gsNkJBQTZCLEdBQUcsMEJBQTBCLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDOUUsQ0FBQztBQUNILENBQUM7QUFORCxrREFNQztBQUVELG9DQUNJLEVBQXlCLEVBQUUsTUFBYztJQUMzQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ2YsS0FBSyxFQUFFLENBQUMsaUNBQWlDO1lBQ3ZDLE1BQU0sQ0FBQyxtQ0FBbUMsQ0FBQztRQUM3QyxLQUFLLEVBQUUsQ0FBQyx5Q0FBeUM7WUFDL0MsTUFBTSxDQUFDLDJDQUEyQyxDQUFDO1FBQ3JELEtBQUssRUFBRSxDQUFDLGlDQUFpQztZQUN2QyxNQUFNLENBQUMsbUNBQW1DLENBQUM7UUFDN0MsS0FBSyxFQUFFLENBQUMsdUJBQXVCO1lBQzdCLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQztRQUNuQztZQUNFLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7SUFDckMsQ0FBQztBQUNILENBQUM7QUFkRCxnRUFjQztBQUVELHFCQUNJLEVBQXlCLEVBQUUsYUFBNkIsRUFDeEQsY0FBc0I7SUFDeEIsSUFBTSxPQUFPLEdBQVcsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFNLE9BQUEsYUFBYSxFQUFFLEVBQWYsQ0FBZSxDQUFDLENBQUM7SUFDaEUsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBQ0QsTUFBTSxDQUFDLE9BQVksQ0FBQztBQUN0QixDQUFDO0FBRUQsNkJBQTZCLEVBQXlCLEVBQUUsV0FBbUI7SUFDekUsSUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDLGdDQUFnQyxHQUFHLENBQUMsQ0FBQztJQUMvRCxJQUFNLGFBQWEsR0FBRyxXQUFXLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQztJQUNoRCxFQUFFLENBQUMsQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLFFBQVEsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUNsRSxJQUFNLGdCQUFnQixHQUFHLDBCQUEwQixHQUFHLGNBQWMsR0FBRyxHQUFHLENBQUM7UUFDM0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsR0FBRyxnQkFBZ0IsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUN0RSxDQUFDO0FBQ0gsQ0FBQztBQUVELHlDQUNJLEVBQXlCLEVBQUUsWUFBc0IsRUFDakQsaUJBQW9DO0lBQ3RDLElBQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzNDLElBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDOUMsRUFBRSxDQUFDLENBQUMsaUJBQWlCLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM5QixJQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxJQUFJLEtBQUssYUFBYSxFQUN0QixvQkFBa0IsSUFBSSwwQkFBdUI7YUFDekMscUJBQW1CLGFBQWEsTUFBRyxDQUFBLENBQUMsQ0FBQztRQUM3QyxFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxVQUFVO1lBQ2xDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLGlCQUFpQixDQUFDO1FBQzNCLENBQUM7SUFDSCxDQUFDO0lBRUQsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQ04sWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVU7UUFDMUQsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDbEMsTUFBTSxDQUFDLFlBQWdDLENBQUM7SUFDMUMsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FDTixZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksVUFBVTtRQUMxRCxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDcEQsTUFBTSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFDTixNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hDLENBQUM7QUFDSCxDQUFDO0FBOUJELDBFQThCQzs7Ozs7QUMxWUQsaUNBQXVXO0FBQ3ZXLHlDQUEyQztBQUMzQyxpQ0FBOEI7QUFDOUIsdUNBQW9DO0FBQ3BDLG1EQUFnRDtBQUNoRCwyQ0FBd0M7QUFDeEMsaURBQWdEO0FBQ2hELHVDQUFvQztBQUNwQyx5RUFBMEU7QUFDMUUsNkRBQXdEO0FBQ3hELGlDQUE4QjtBQUM5QiwrREFBMkQ7QUFDM0QsaUNBQThCO0FBQzlCLHVDQUFvQztBQUNwQywyQ0FBdUM7QUFDdkMsMkNBQXdDO0FBRXhDLCtDQUEyQztBQUMzQyx5Q0FBc0M7QUFDdEMseUNBQStEO0FBQy9ELHFDQUFrQztBQUNsQywyQ0FBd0M7QUFFeEMsNEJBQW1DLEtBQWE7SUFDOUMsSUFBTSxHQUFHLEdBQWdCLEVBQUUsQ0FBQztJQUM1QixLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBckQsQ0FBcUQsQ0FBQyxDQUFDO0lBQzdFLE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDYixDQUFDO0FBSkQsZ0RBSUM7QUFFRCx3QkFBd0IsSUFBVTtJQUNoQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksbUJBQVcsQ0FBQyxDQUFDLENBQUM7UUFDaEMsTUFBTSxDQUFDLENBQUMsSUFBSSxpQkFBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSxrQkFBVSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEMsSUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxDQUFDLElBQUksZUFBTSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVkseUJBQWlCLENBQUMsQ0FBQyxDQUFDO1FBQzdDLElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMseUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0MsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyx5QkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLHlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sQ0FBQyxDQUFDLElBQUksMkJBQWEsQ0FDckIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFDbkUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksbUJBQVcsQ0FBQyxDQUFDLENBQUM7UUFDdkMsSUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxDQUFDLElBQUksa0JBQU8sQ0FDZixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksZUFBTyxDQUFDLENBQUMsQ0FBQztRQUNuQyxNQUFNLENBQUMsQ0FBQyxJQUFJLFNBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSxlQUFPLENBQUMsQ0FBQyxDQUFDO1FBQ25DLE1BQU0sQ0FBQyxDQUFDLElBQUksU0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLGdCQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sQ0FBQyxDQUFDLElBQUksOEJBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksZ0JBQVEsQ0FBQyxDQUFDLENBQUM7UUFDcEMsTUFBTSxDQUFDLENBQUMsSUFBSSw4QkFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSxtQkFBVyxDQUFDLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsQ0FBQyxJQUFJLGlDQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLG1DQUEyQixDQUFDLENBQUMsQ0FBQztRQUN2RCxJQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLG1DQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsbUNBQTJCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDL0QsTUFBTSxDQUFDLENBQUMsSUFBSSxpQ0FBdUIsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLG1CQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sQ0FBQyxDQUFDLElBQUksaUJBQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksMkJBQW1CLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsMkJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQywyQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvRCxNQUFNLENBQUMsQ0FBQyxJQUFJLG1DQUFlLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSx3QkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDNUMsTUFBTSxDQUFDLENBQUMsSUFBSSwyQkFBWSxDQUNwQixJQUFJLENBQUMsTUFBTSxDQUFDLHdCQUFnQixDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsd0JBQWdCLENBQUMsRUFBRSxDQUFDLEVBQ2xFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLGtCQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxDQUFDLElBQUksZUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksa0NBQTBCLENBQUMsQ0FBQyxDQUFDO1FBQ3RELE1BQU0sQ0FBQyxDQUFDLElBQUksc0NBQWlCLENBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQTBCLENBQUMsRUFBRSxDQUFDLEVBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQTBCLENBQUMsRUFBRSxDQUFDLEVBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQTBCLENBQUMsRUFBRSxDQUFDLEVBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQTBCLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksb0JBQVksQ0FBQyxDQUFDLENBQUM7UUFDeEMsTUFBTSxDQUFDLENBQUMsSUFBSSxtQkFBUSxDQUNoQixJQUFJLENBQUMsTUFBTSxDQUFDLG9CQUFZLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQkFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQ3JFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLGtCQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxDQUFDLElBQUksZ0NBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksZUFBTyxDQUFDLENBQUMsQ0FBQztRQUNuQyxNQUFNLENBQUMsQ0FBQyxJQUFJLFNBQUcsQ0FDWCxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSxvQkFBWSxDQUFDLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsQ0FBQyxJQUFJLG1CQUFRLENBQ2hCLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQVksQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLG9CQUFZLENBQUMsRUFBRSxDQUFDLEVBQzFELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxZQUFZLG9CQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxDQUFDLElBQUksbUJBQVEsQ0FDaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQkFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQVksQ0FBQyxFQUFFLENBQUMsRUFDMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksa0JBQVUsQ0FBQyxDQUFDLENBQUM7UUFDdEMsTUFBTSxDQUFDLENBQUMsSUFBSSxlQUFNLENBQ2QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsa0JBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksWUFBWSxpQkFBUyxDQUFDLENBQUMsQ0FBQztRQUNyQyxNQUFNLENBQUMsQ0FBQyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVkscUJBQWEsQ0FBQyxDQUFDLENBQUM7UUFDekMsTUFBTSxDQUFDLENBQUMsSUFBSSxzQkFBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMscUJBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxFQUFFLENBQUM7SUFDWixDQUFDO0lBQUMsSUFBSSxDQUFDLENBQUM7UUFFTixNQUFNLEtBQUssQ0FBQyx5QkFBeUIsR0FBSSxJQUFJLENBQUMsV0FBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxRSxDQUFDO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDN0dELDBDQUE0QztBQUU1QywyQ0FBZ0Q7QUFFaEQsOEJBQWdDO0FBRWhDLDJCQUErQjtBQUsvQjtJQUF5Qix1QkFBUztJQUloQyxhQUNZLFFBQWdCLEVBQVUsUUFBZ0IsRUFDMUMsT0FBZTtRQUYzQixZQUdFLGlCQUFPLFNBT1I7UUFUVyxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQVUsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUMxQyxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBRXpCLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNwQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ3BELDJEQUEyRDtZQUN2RCxnQkFBZ0IsQ0FBQyxDQUFDOztJQUM1QixDQUFDO0lBRUQseUJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBZUM7UUFkQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQUksTUFBZSxDQUFDO1lBQ3BCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakMsTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDeEMsQ0FBQztZQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNOLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM1QixDQUFDO1lBQ0QsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ2xELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHNCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQWdDQztRQTdCQyxJQUFNLEVBQUUsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU1QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDNUMsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDekIsRUFBRSxDQUFDLENBQUMsS0FBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixLQUFJLENBQUMsWUFBWSxHQUFHLGdCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUMsQ0FBQztvQkFDRCxjQUFjLENBQUMsR0FBRyxDQUNkLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUN4QyxDQUFDO1lBQ0gsQ0FBQztZQUVELEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDNUMsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDekIsRUFBRSxDQUFDLENBQUMsS0FBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixLQUFJLENBQUMsWUFBWSxHQUFHLGdCQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUMsQ0FBQztvQkFDRCxjQUFjLENBQUMsR0FBRyxDQUNkLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUN4QyxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHFCQUFPLEdBQVA7UUFDRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5QixDQUFDO0lBQ0gsQ0FBQztJQUNILFVBQUM7QUFBRCxDQXhFQSxBQXdFQyxDQXhFd0IsY0FBUyxHQXdFakM7QUF4RVksa0JBQUc7Ozs7Ozs7Ozs7Ozs7OztBQ1JoQiwyQkFBK0I7QUFLL0I7SUFBNEIsMEJBQVM7SUFJbkMsZ0JBQW9CLE9BQWUsRUFBVSxPQUFlO1FBQTVELFlBQ0UsaUJBQU8sU0FDUjtRQUZtQixhQUFPLEdBQVAsT0FBTyxDQUFRO1FBQVUsYUFBTyxHQUFQLE9BQU8sQ0FBUTs7SUFFNUQsQ0FBQztJQUVELDRCQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQUtDO1FBSkMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHlCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBQ0gsYUFBQztBQUFELENBcEJBLEFBb0JDLENBcEIyQixjQUFTLEdBb0JwQztBQXBCWSx3QkFBTTs7Ozs7Ozs7Ozs7Ozs7O0FDTG5CLDJCQUErQjtBQUsvQjtJQUFrQyxnQ0FBUztJQUl6QyxzQkFDWSxRQUFnQixFQUFVLFFBQWdCLEVBQzFDLE9BQWU7UUFGM0IsWUFHRSxpQkFBTyxTQUNSO1FBSFcsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUFVLGNBQVEsR0FBUixRQUFRLENBQVE7UUFDMUMsYUFBTyxHQUFQLE9BQU8sQ0FBUTs7SUFFM0IsQ0FBQztJQUVELGtDQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQU1DO1FBTEMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwrQkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUNoQyxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUNILG1CQUFDO0FBQUQsQ0F2QkEsQUF1QkMsQ0F2QmlDLGNBQVMsR0F1QjFDO0FBdkJZLG9DQUFZOzs7Ozs7Ozs7Ozs7Ozs7QUNSekIscURBQXVEO0FBS3ZELDJCQUErQjtBQUsvQjtJQUE4Qiw0QkFBUztJQU1yQyxrQkFDWSxRQUFnQixFQUFVLFFBQWdCLEVBQVUsSUFBWSxFQUNoRSxPQUFlO1FBRjNCLFlBR0UsaUJBQU8sU0FHUjtRQUxXLGNBQVEsR0FBUixRQUFRLENBQVE7UUFBVSxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQVUsVUFBSSxHQUFKLElBQUksQ0FBUTtRQUNoRSxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBRXpCLGFBQWEsQ0FBQyx5QkFBeUIsQ0FDbkMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDOztJQUM1QyxDQUFDO0lBRUQsOEJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBUUM7UUFQQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQVksQ0FBQztRQUN6RCxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQVksQ0FBQztRQUV6RCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEQsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBQ3hELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDJCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBQ0gsZUFBQztBQUFELENBN0JBLEFBNkJDLENBN0I2QixjQUFTLEdBNkJ0QztBQTdCWSw0QkFBUTs7Ozs7Ozs7Ozs7Ozs7O0FDVnJCLDZDQUErQztBQUkvQyw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBSy9CO0lBQW1DLGlDQUFTO0lBaUIxQyx1QkFDWSxPQUFlLEVBQVUsT0FBZSxFQUFVLE9BQWUsRUFDakUsT0FBZSxFQUFVLFNBQWlCLEVBQzFDLFdBQW1CLEVBQVUsTUFBVSxFQUFFLE9BQWdCO1FBQTVCLHVCQUFBLEVBQUEsVUFBVTtRQUhuRCxZQUlFLGlCQUFPLFNBV1I7UUFkVyxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBQVUsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFVLGFBQU8sR0FBUCxPQUFPLENBQVE7UUFDakUsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFVLGVBQVMsR0FBVCxTQUFTLENBQVE7UUFDMUMsaUJBQVcsR0FBWCxXQUFXLENBQVE7UUFBVSxZQUFNLEdBQU4sTUFBTSxDQUFJO1FBRWpELEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkMsS0FBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksSUFBSTtZQUMxQixPQUFPO1lBQ1AsU0FBUyxDQUFDLGlCQUFpQixDQUN2QixLQUFJLENBQUMsT0FBTyxDQUFDLEtBQWlDLEVBQUUsS0FBSSxDQUFDLFNBQVMsRUFDOUQsS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLEVBQ3hCLHVCQUFxQixLQUFJLENBQUMsT0FBTyxzQ0FBbUM7WUFDaEUsbUNBQW1DLENBQUMsQ0FBQzs7SUFDL0MsQ0FBQztJQUVELG1DQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQVVDO1FBVEMsSUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDN0QsSUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDNUQsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFFdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUNmLEtBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGdDQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQWNDO1FBWEMsSUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDN0QsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDdkQsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFFdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDUixJQUFBLHFFQUM0RCxFQUQzRCxVQUFFLEVBQUUsVUFBRSxFQUFFLFVBQUUsQ0FDa0Q7WUFDbkUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzNDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUMzQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sMENBQWtCLEdBQTFCLFVBQTJCLFlBQXNCO1FBQy9DLElBQUksQ0FBQyxNQUFNLENBQ1AsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTO1lBQzlCLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUztZQUNsQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLFlBQVksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsV0FBVyxFQUN4QywrQkFBNkIsSUFBSSxDQUFDLFNBQVMsU0FBSSxJQUFJLENBQUMsU0FBUyxNQUFHO2FBQ3pELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFJLElBQUksQ0FBQyxXQUFXLHNCQUFtQixDQUFBO2FBQy9ELFlBQVUsWUFBWSxNQUFHLENBQUEsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFDSCxvQkFBQztBQUFELENBeEVBLEFBd0VDLENBeEVrQyxjQUFTLEdBd0UzQztBQXhFWSxzQ0FBYTs7Ozs7Ozs7Ozs7Ozs7O0FDWDFCLDBDQUE0QztBQUk1Qyw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBSy9CO0lBQTRCLDBCQUFTO0lBTW5DLGdCQUNZLFFBQWdCLEVBQVUsUUFBZ0IsRUFDMUMsT0FBZTtRQUYzQixZQUdFLGlCQUFPLFNBT1I7UUFUVyxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQVUsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUMxQyxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBRXpCLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNwQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ3BELDJEQUEyRDtZQUN2RCxnQkFBZ0IsQ0FBQyxDQUFDOztJQUM1QixDQUFDO0lBRUQsNEJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBZUM7UUFkQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQUksTUFBZSxDQUFDO1lBQ3BCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakMsTUFBTSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDN0MsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzdDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDL0IsQ0FBQztZQUNELGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCx5QkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFpREM7UUE5Q0MsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFaEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7b0JBQ2YsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBRWhDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRXZELEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDaEIsQ0FBQztnQkFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztvQkFDdEIsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDTixjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0QsQ0FBQztZQUNILENBQUM7WUFFRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRTdDLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUU5QyxJQUFJLGVBQWUsU0FBUyxDQUFDO2dCQUM3QixFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO29CQUNmLGVBQWUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUM3RCxDQUFDO2dCQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO29CQUN0QixlQUFlLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDN0QsQ0FBQztnQkFBQyxJQUFJLENBQUMsQ0FBQztvQkFDTixlQUFlLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQy9DLENBQUM7Z0JBRUQsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDdEMsSUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFFdkQsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztvQkFDZixjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZFLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Z0JBQzdELENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0gsYUFBQztBQUFELENBckZBLEFBcUZDLENBckYyQixjQUFTLEdBcUZwQztBQXJGWSx3QkFBTTs7Ozs7Ozs7Ozs7Ozs7O0FDVm5CLHFFQUE2RztBQUk3RywyQkFBK0I7QUFLL0I7SUFBMkMseUNBQVM7SUFDbEQsK0JBQ2MsT0FBZSxFQUFZLE9BQWUsRUFDNUMsSUFBd0I7UUFGcEMsWUFHRSxpQkFBTyxTQUNSO1FBSGEsYUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFZLGFBQU8sR0FBUCxPQUFPLENBQVE7UUFDNUMsVUFBSSxHQUFKLElBQUksQ0FBb0I7O0lBRXBDLENBQUM7SUFFRCwyQ0FBVyxHQUFYLFVBQVksSUFBaUIsRUFBRSxlQUErQjtRQUE5RCxpQkFNQztRQUxDLElBQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTVDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHdDQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQWNDO1FBVEMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxJQUFNLElBQUksR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCw0QkFBQztBQUFELENBOUJBLEFBOEJDLENBOUIwQyxjQUFTLEdBOEJuRDtBQTlCWSxzREFBcUI7QUFtQ2xDO0lBQTBCLHdCQUFxQjtJQUM3QyxjQUFZLE9BQWUsRUFBRSxPQUFlO2VBQzFDLGtCQUFNLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSwrQkFBUSxFQUFFLENBQUM7SUFDekMsQ0FBQztJQUNILFdBQUM7QUFBRCxDQUpBLEFBSUMsQ0FKeUIscUJBQXFCLEdBSTlDO0FBSlksb0JBQUk7QUFTakI7SUFBMEIsd0JBQXFCO0lBQzdDLGNBQVksT0FBZSxFQUFFLE9BQWU7ZUFDMUMsa0JBQU0sT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLCtCQUFRLEVBQUUsQ0FBQztJQUN6QyxDQUFDO0lBQ0gsV0FBQztBQUFELENBSkEsQUFJQyxDQUp5QixxQkFBcUIsR0FJOUM7QUFKWSxvQkFBSTtBQVNqQjtJQUE2QiwyQkFBcUI7SUFDaEQsaUJBQVksT0FBZSxFQUFFLE9BQWU7ZUFDMUMsa0JBQU0sT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLGtDQUFXLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBQ0gsY0FBQztBQUFELENBSkEsQUFJQyxDQUo0QixxQkFBcUIsR0FJakQ7QUFKWSwwQkFBTztBQVNwQjtJQUE0QiwwQkFBcUI7SUFDL0MsZ0JBQVksT0FBZSxFQUFFLE9BQWU7ZUFDMUMsa0JBQU0sT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLGlDQUFVLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBQ0gsYUFBQztBQUFELENBSkEsQUFJQyxDQUoyQixxQkFBcUIsR0FJaEQ7QUFKWSx3QkFBTTs7Ozs7Ozs7Ozs7Ozs7O0FDeEVuQiwwQ0FBNEM7QUFDNUMseURBQStFO0FBRS9FLDJDQUF1QztBQUV2Qyw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBSy9CO0lBQXFDLG1DQUFTO0lBRzVDLHlCQUNjLFFBQWdCLEVBQVksUUFBZ0IsRUFDNUMsT0FBZSxFQUFZLElBQTZCO1FBRnRFLFlBR0UsaUJBQU8sU0FFUjtRQUphLGNBQVEsR0FBUixRQUFRLENBQVE7UUFBWSxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQzVDLGFBQU8sR0FBUCxPQUFPLENBQVE7UUFBWSxVQUFJLEdBQUosSUFBSSxDQUF5QjtRQUVwRSxLQUFJLENBQUMsY0FBYyxHQUFHLGdCQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDOztJQUMzRSxDQUFDO0lBRUQscUNBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBVUM7UUFUQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQU0sZUFBZSxHQUFHLEtBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDckQsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUN0QyxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSSxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztZQUMvRCxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDbEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsa0NBQVEsR0FBUixVQUNJLElBQWlCLEVBQUUsZUFBK0IsRUFDbEQsY0FBOEI7UUFGbEMsaUJBY0M7UUFYQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RSxDQUFDO1lBQ0QsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxpQ0FBTyxHQUFQO1FBQ0UsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFDSCxzQkFBQztBQUFELENBMUNBLEFBMENDLENBMUNvQyxjQUFTLEdBMEM3QztBQTFDWSwwQ0FBZTtBQStDNUI7SUFBcUMsbUNBQWU7SUFDbEQseUJBQVksUUFBZ0IsRUFBRSxRQUFnQixFQUFFLE9BQWU7ZUFDN0Qsa0JBQU0sUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsSUFBSSwrQkFBYyxFQUFFLENBQUM7SUFDMUQsQ0FBQztJQUNILHNCQUFDO0FBQUQsQ0FKQSxBQUlDLENBSm9DLGVBQWUsR0FJbkQ7QUFKWSwwQ0FBZTs7Ozs7Ozs7Ozs7Ozs7O0FDM0Q1QiwwQ0FBNEM7QUFJNUMsMkJBQStCO0FBSy9CO0lBQXlCLHVCQUFTO0lBSWhDLGFBQW9CLE9BQWUsRUFBVSxPQUFlO1FBQTVELFlBQ0UsaUJBQU8sU0FDUjtRQUZtQixhQUFPLEdBQVAsT0FBTyxDQUFRO1FBQVUsYUFBTyxHQUFQLE9BQU8sQ0FBUTs7SUFFNUQsQ0FBQztJQUVELHlCQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQU1DO1FBTEMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHNCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQVdDO1FBUkMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxVQUFDO0FBQUQsQ0E1QkEsQUE0QkMsQ0E1QndCLGNBQVMsR0E0QmpDO0FBNUJZLGtCQUFHOzs7Ozs7Ozs7Ozs7Ozs7QUNUaEIsMENBQTRDO0FBSTVDLDJCQUErQjtBQUsvQjtJQUF1QyxxQ0FBUztJQU85QywyQkFDWSxRQUFnQixFQUFVLFFBQWdCLEVBQzFDLFFBQWdCLEVBQVUsUUFBZ0IsRUFDMUMsU0FBaUI7UUFIN0IsWUFJRSxpQkFBTyxTQUNSO1FBSlcsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUFVLGNBQVEsR0FBUixRQUFRLENBQVE7UUFDMUMsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUFVLGNBQVEsR0FBUixRQUFRLENBQVE7UUFDMUMsZUFBUyxHQUFULFNBQVMsQ0FBUTs7SUFFN0IsQ0FBQztJQUVELHVDQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQVVDO1FBVEMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDekQsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFekQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUNmLEtBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELG9DQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQTRCQztRQXpCQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDN0MsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6RSxDQUFDO1lBRUQsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pFLENBQUM7WUFFRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNoRCxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7WUFFRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUNoRCxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCx3QkFBQztBQUFELENBdkRBLEFBdURDLENBdkRzQyxjQUFTLEdBdUQvQztBQXZEWSw4Q0FBaUI7Ozs7Ozs7Ozs7Ozs7OztBQ1Q5QiwwQ0FBNEM7QUFJNUMsMkJBQStCO0FBSy9CO0lBQXlCLHVCQUFTO0lBSWhDLGFBQW9CLE9BQWUsRUFBVSxPQUFlO1FBQTVELFlBQ0UsaUJBQU8sU0FDUjtRQUZtQixhQUFPLEdBQVAsT0FBTyxDQUFRO1FBQVUsYUFBTyxHQUFQLE9BQU8sQ0FBUTs7SUFFNUQsQ0FBQztJQUVELHlCQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQU1DO1FBTEMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHNCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQVdDO1FBUkMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzdELENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxVQUFDO0FBQUQsQ0E1QkEsQUE0QkMsQ0E1QndCLGNBQVMsR0E0QmpDO0FBNUJZLGtCQUFHOzs7Ozs7Ozs7Ozs7Ozs7QUNUaEIsMENBQTRDO0FBQzVDLHFDQUE0RDtBQUk1RCwyQkFBK0I7QUFLL0I7SUFBNEIsMEJBQVM7SUFDbkMsZ0JBQ1ksUUFBZ0IsRUFBVSxRQUFnQixFQUMxQyxPQUFlO1FBRjNCLFlBR0UsaUJBQU8sU0FDUjtRQUhXLGNBQVEsR0FBUixRQUFRLENBQVE7UUFBVSxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQzFDLGFBQU8sR0FBUCxPQUFPLENBQVE7O0lBRTNCLENBQUM7SUFFRCw0QkFBVyxHQUFYLFVBQVksSUFBaUIsRUFBRSxlQUErQjtRQUE5RCxpQkFrQkM7UUFqQkMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkQsZUFBZSxDQUFDLEdBQUcsQ0FDZixLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQWEsRUFBRSxFQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckUsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDMUQsZUFBZSxDQUFDLEdBQUcsQ0FDZixLQUFJLENBQUMsT0FBTyxFQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBYSxFQUFFLEVBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRSxDQUFDO1lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxlQUFlLENBQUMsR0FBRyxDQUNmLEtBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFhLEVBQUUsRUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCx5QkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFxQ0M7UUFsQ0MsSUFBSSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUMsSUFBSSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUMsSUFBSSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFMUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQyxDQUFDO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFJZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQ25CLEVBQWEsRUFBRSxFQUFhLEVBQUUsd0JBQWlCLENBQUMsT0FBTyxFQUN2RCx3QkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDbEMsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsUUFBUSxFQUNiLElBQUksQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7WUFDRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQ25CLEVBQWEsRUFBRSxFQUFhLEVBQUUsd0JBQWlCLENBQUMsVUFBVSxFQUMxRCx3QkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDL0IsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsUUFBUSxFQUNiLElBQUksQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxhQUFDO0FBQUQsQ0FqRUEsQUFpRUMsQ0FqRTJCLGNBQVMsR0FpRXBDO0FBakVZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7QUNWbkIsNkNBQStDO0FBSS9DLDhCQUFnQztBQUVoQywyQkFBK0I7QUFLL0I7SUFBNkIsMkJBQVM7SUFHcEMsaUJBQ1ksT0FBZSxFQUFVLE9BQWUsRUFDeEMsU0FBaUIsRUFBVSxNQUFVLEVBQUUsR0FBWTtRQUF4Qix1QkFBQSxFQUFBLFVBQVU7UUFGakQsWUFHRSxpQkFBTyxTQWNSO1FBaEJXLGFBQU8sR0FBUCxPQUFPLENBQVE7UUFBVSxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ3hDLGVBQVMsR0FBVCxTQUFTLENBQVE7UUFBVSxZQUFNLEdBQU4sTUFBTSxDQUFJO1FBRy9DLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLEtBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLEtBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLGlCQUFpQixDQUNsQyxPQUFPLENBQUMsS0FBaUMsRUFBRSxLQUFJLENBQUMsU0FBUyxFQUN6RCxLQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkIsQ0FBQztRQUVELElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFJLENBQUMsR0FBRyxDQUFDLEVBQ3BCLHVCQUFxQixLQUFJLENBQUMsR0FBRyxzQ0FBbUM7WUFDNUQsbUNBQW1DLENBQUMsQ0FBQzs7SUFDL0MsQ0FBQztJQUVELDZCQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQU9DO1FBTkMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxlQUFlLENBQUMsR0FBRyxDQUNmLEtBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEtBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDBCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQVlDO1FBVEMsSUFBTSxDQUFDLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFDdkQsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFZLENBQUM7UUFFdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxjQUFjLENBQUMsR0FBRyxDQUNkLEtBQUksQ0FBQyxPQUFPLEVBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQ3JCLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSSxDQUFDLFNBQVMsRUFBRSxLQUFJLENBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0gsY0FBQztBQUFELENBNUNBLEFBNENDLENBNUM0QixjQUFTLEdBNENyQztBQTVDWSwwQkFBTzs7Ozs7Ozs7Ozs7Ozs7O0FDWHBCLDBDQUE0QztBQUk1Qyw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBSy9CO0lBQThCLDRCQUFTO0lBS3JDLGtCQUNZLFFBQWdCLEVBQVUsUUFBZ0IsRUFDMUMsT0FBZTtRQUYzQixZQUdFLGlCQUFPLFNBT1I7UUFUVyxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBQVUsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQUMxQyxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBRXpCLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUNwQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQ3BELDJEQUEyRDtZQUN2RCxnQkFBZ0IsQ0FBQyxDQUFDOztJQUM1QixDQUFDO0lBRUQsOEJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBZUM7UUFkQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQUksTUFBZSxDQUFDO1lBQ3BCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakMsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDekMsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkMsQ0FBQztZQUNELGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwyQkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFvQ0M7UUFqQ0MsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzdDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzVDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUV4QyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUV6RCxDQUFDO2dCQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3hDLGNBQWMsQ0FBQyxHQUFHLENBQ2QsS0FBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzFELENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZFLENBQUM7WUFDSCxDQUFDO1lBRUQsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3QyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM1QyxJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFeEMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFekQsQ0FBQztnQkFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN4QyxjQUFjLENBQUMsR0FBRyxDQUNkLEtBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNOLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUN2RSxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUNILGVBQUM7QUFBRCxDQXZFQSxBQXVFQyxDQXZFNkIsY0FBUyxHQXVFdEM7QUF2RVksNEJBQVE7Ozs7O0FDTnJCO0lBQUE7SUFZQSxDQUFDO0lBSkMsMENBQXNCLEdBQXRCLFVBQ0ksZUFBK0IsRUFBRSxjQUE4QixJQUFHLENBQUM7SUFFdkUsMkJBQU8sR0FBUCxjQUFXLENBQUM7SUFDZCxnQkFBQztBQUFELENBWkEsQUFZQyxJQUFBO0FBWnFCLDhCQUFTOzs7Ozs7Ozs7Ozs7Ozs7QUNML0IsMENBQTRDO0FBRTVDLDJDQUF3QztBQUV4Qyw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBSy9CO0lBQStCLDZCQUFTO0lBRXRDLG1CQUFvQixDQUFTLEVBQVUsU0FBaUI7UUFBeEQsWUFDRSxpQkFBTyxTQUVSO1FBSG1CLE9BQUMsR0FBRCxDQUFDLENBQVE7UUFBVSxlQUFTLEdBQVQsU0FBUyxDQUFRO1FBRXRELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztJQUM5QyxDQUFDO0lBSUQsK0JBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBTUM7UUFMQyxJQUFNLENBQUMsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV0QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsNEJBQVEsR0FBUixVQUNJLElBQWlCLEVBQUUsZUFBK0IsRUFDbEQsY0FBOEI7UUFGbEMsaUJBZ0JDO1FBYkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDO1FBQ1QsQ0FBQztRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDOUMsRUFBRSxDQUFDLENBQUMsS0FBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN0QixJQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsS0FBSSxDQUFDLElBQUksR0FBRyxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEMsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsQ0FBQztZQUNELGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsRUFBRSxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3pFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUNILGdCQUFDO0FBQUQsQ0FsQ0EsQUFrQ0MsQ0FsQzhCLGNBQVMsR0FrQ3ZDO0FBbENZLDhCQUFTOzs7Ozs7Ozs7Ozs7Ozs7QUNSdEIsOEJBQWdDO0FBRWhDLDJCQUErQjtBQUUvQjtJQUFxRSwyQkFBUztJQUM1RSxpQkFBb0IsT0FBZSxFQUFVLE9BQWU7UUFBNUQsWUFDRSxpQkFBTyxTQU1SO1FBUG1CLGFBQU8sR0FBUCxPQUFPLENBQVE7UUFBVSxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBRTFELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxNQUFNLENBQ1AsS0FBSyxLQUFLLEtBQUssRUFDZixxQkFBbUIsS0FBSywyQkFBc0IsS0FBSyxpQkFBYyxDQUFDLENBQUM7O0lBQ3pFLENBQUM7SUFFRCw2QkFBVyxHQUFYLFVBQVksSUFBaUIsRUFBRSxlQUErQjtRQUE5RCxpQkFPQztRQU5DLElBQU0sQ0FBQyxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBTyxDQUFDO1FBRWxELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsZUFBZSxDQUFDLEdBQUcsQ0FDZixLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFTLENBQUMsRUFBRSxLQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwwQkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFTQztRQU5DLElBQU0sRUFBRSxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBTyxDQUFDO1FBRWxELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFTLEVBQUUsRUFBRSxLQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxjQUFDO0FBQUQsQ0E3QkEsQUE2QkMsQ0E3Qm9FLGNBQVMsR0E2QjdFO0FBN0JZLDBCQUFPOzs7Ozs7Ozs7Ozs7Ozs7QUNScEIsa0NBQWdDO0FBRWhDLDJDQUFnRDtBQUVoRCw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBRS9CO0lBQTZCLDJCQUFTO0lBQ3BDLGlCQUFvQixZQUFvQixFQUFVLE1BQWM7UUFBaEUsWUFDRSxpQkFBTyxTQUNSO1FBRm1CLGtCQUFZLEdBQVosWUFBWSxDQUFRO1FBQVUsWUFBTSxHQUFOLE1BQU0sQ0FBUTs7SUFFaEUsQ0FBQztJQUVELDZCQUFXLEdBQVgsVUFBWSxJQUFpQixFQUFFLGVBQStCO1FBQTlELGlCQUtDO1FBSkMsSUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFZLENBQUM7UUFDakUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ3JCLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0QsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsMEJBQVEsR0FBUjtRQUNFLE1BQU0sS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUNILGNBQUM7QUFBRCxDQWZBLEFBZUMsQ0FmNEIsY0FBUyxHQWVyQztBQWZZLDBCQUFPO0FBaUJwQjtJQUE2QywyQ0FBUztJQUNwRCxpQ0FDWSxZQUFvQixFQUFVLFdBQW1CLEVBQ2pELE9BQWU7UUFGM0IsWUFHRSxpQkFBTyxTQUVSO1FBSlcsa0JBQVksR0FBWixZQUFZLENBQVE7UUFBVSxpQkFBVyxHQUFYLFdBQVcsQ0FBUTtRQUNqRCxhQUFPLEdBQVAsT0FBTyxDQUFRO1FBd0NuQixhQUFPLEdBQUcsZ0JBQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUF0Q2pDLEtBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxjQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDOztJQUN0RCxDQUFDO0lBRUQsNkNBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBWUM7UUFYQyxJQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQVksQ0FBQztRQUNqRSxJQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQVksQ0FBQztRQUUvRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFM0MsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQzdELGVBQWUsQ0FBQyxHQUFHLENBQ2YsS0FBSSxDQUFDLE9BQU8sRUFDWixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwwQ0FBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFTQztRQU5DLElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3hELElBQU0sS0FBSyxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXBELElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeEUsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsd0RBQXNCLEdBQXRCLFVBQ0ksZUFBK0IsRUFBRSxjQUE4QjtRQUNqRSxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQseUNBQU8sR0FBUDtRQUNFLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUlILDhCQUFDO0FBQUQsQ0E1Q0EsQUE0Q0MsQ0E1QzRDLGNBQVMsR0E0Q3JEO0FBNUNZLDBEQUF1QjtBQThDcEMsMEJBQ0ksSUFBaUIsRUFBRSxDQUFVLEVBQUUsTUFBZSxFQUFFLE9BQWU7SUFDakUsSUFBSSxDQUFDLE1BQU0sQ0FDUCxDQUFDLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsNkNBQTZDLENBQUMsQ0FBQztJQUUzRSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNoQixJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNsRCxJQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JDLElBQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzVELElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDOUIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBWkQsNENBWUM7Ozs7Ozs7Ozs7Ozs7OztBQ2xGRCwwQ0FBNEM7QUFHNUMsOEJBQWdDO0FBRWhDLDJCQUErQjtBQU0vQjtJQUEyQix5QkFBUztJQUNsQyxlQUFvQixLQUFhLEVBQVUsT0FBaUI7UUFBNUQsWUFDRSxpQkFBTyxTQUlSO1FBTG1CLFdBQUssR0FBTCxLQUFLLENBQVE7UUFBVSxhQUFPLEdBQVAsT0FBTyxDQUFVO1FBRTFELE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNO1lBQ3BCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRCxDQUFDLENBQUMsQ0FBQzs7SUFDTCxDQUFDO0lBRUQsMkJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFDNUQsSUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQSxNQUFNO1lBQ3pCLGVBQWUsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELHdCQUFRLEdBQVIsVUFDSSxJQUFpQixFQUFFLGVBQStCLEVBQ2xELGNBQThCO1FBRmxDLGlCQWlCQztRQWRDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNDLE1BQU0sQ0FBQztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQ2IsY0FBYyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQ25DLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFekMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsTUFBTTtnQkFDbEMsRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNoRCxDQUFDLENBQUMsQ0FBQztZQUNILGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFDSCxZQUFDO0FBQUQsQ0FqQ0EsQUFpQ0MsQ0FqQzBCLGNBQVMsR0FpQ25DO0FBakNZLHNCQUFLOzs7Ozs7Ozs7Ozs7Ozs7QUNYbEIsMENBQTRDO0FBRTVDLDJDQUFnRDtBQUVoRCw4QkFBZ0M7QUFFaEMsMkJBQStCO0FBRS9CO0lBQThCLDRCQUFTO0lBT3JDLGtCQUNZLEVBQVUsRUFBVSxFQUFVLEVBQVUsU0FBaUI7UUFEckUsWUFFRSxpQkFBTyxTQU9SO1FBUlcsUUFBRSxHQUFGLEVBQUUsQ0FBUTtRQUFVLFFBQUUsR0FBRixFQUFFLENBQVE7UUFBVSxlQUFTLEdBQVQsU0FBUyxDQUFRO1FBRW5FLElBQUksQ0FBQyxNQUFNLENBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztZQUM5QixJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1lBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQ3hDLDJEQUEyRDtZQUN2RCxnQkFBZ0IsQ0FBQyxDQUFDOztJQUM1QixDQUFDO0lBRUQsOEJBQVcsR0FBWCxVQUFZLElBQWlCLEVBQUUsZUFBK0I7UUFBOUQsaUJBZUM7UUFkQyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN4QyxJQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV4QyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSTtZQUNkLElBQUksTUFBZSxDQUFDO1lBQ3BCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakMsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDekMsQ0FBQztZQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDNUIsQ0FBQztZQUNELGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNwRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCwyQkFBUSxHQUFSLFVBQ0ksSUFBaUIsRUFBRSxlQUErQixFQUNsRCxjQUE4QjtRQUZsQyxpQkFpQ0M7UUE5QkMsSUFBTSxFQUFFLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFOUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBQ3pCLEVBQUUsQ0FBQyxDQUFDLEtBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsS0FBSSxDQUFDLFlBQVksR0FBRyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzFDLENBQUM7b0JBQ0QsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNOLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDeEMsQ0FBQztZQUNILENBQUM7WUFFRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEtBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RDLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7b0JBQ3pCLElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzdCLEVBQUUsQ0FBQyxDQUFDLEtBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQzt3QkFDOUIsS0FBSSxDQUFDLFlBQVksR0FBRyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzFDLENBQUM7b0JBQ0QsY0FBYyxDQUFDLEdBQUcsQ0FDZCxLQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUM3RCxDQUFDO2dCQUFDLElBQUksQ0FBQyxDQUFDO29CQUNOLGNBQWMsQ0FBQyxHQUFHLENBQUMsS0FBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsMEJBQU8sR0FBUDtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzlCLENBQUM7SUFDSCxDQUFDO0lBQ0gsZUFBQztBQUFELENBM0VBLEFBMkVDLENBM0U2QixjQUFTLEdBMkV0QztBQTNFWSw0QkFBUTs7Ozs7QUNKckI7SUFJRSxtQkFBWSxxQkFBOEI7UUFDeEMsRUFBRSxDQUFDLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMsc0JBQXNCLEdBQUcscUJBQXVDLENBQUM7UUFDeEUsQ0FBQztJQUNILENBQUM7SUFrQkgsZ0JBQUM7QUFBRCxDQTFCQSxBQTBCQyxJQUFBO0FBMUJxQiw4QkFBUzs7Ozs7QUNDL0Isd0JBQWtDLENBQUksRUFBRSxDQUFJO0lBQzFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1osTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7QUFDSCxDQUFDO0FBUkQsd0NBUUM7QUF5QkQ7SUFTRSx1QkFDWSxVQUF5QixFQUN6QixhQUFnQztRQURoQyxlQUFVLEdBQVYsVUFBVSxDQUFlO1FBQ3pCLGtCQUFhLEdBQWIsYUFBYSxDQUFtQjtRQVZwQyxTQUFJLEdBQVEsRUFBRSxDQUFDO0lBVXdCLENBQUM7SUFNaEQsK0JBQU8sR0FBUCxVQUFRLENBQUk7UUFDVixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFPRCwrQkFBTyxHQUFQO1FBQ0UsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7UUFDN0QsQ0FBQztRQUNELElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNoQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pCLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBV0QsOEJBQU0sR0FBTixVQUFPLElBQU8sRUFBRSxLQUFhO1FBRzNCLElBQU0sSUFBSSxHQUFHLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzlDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLENBQUM7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQU9WLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLENBQUM7WUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQzVDLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDdkIsQ0FBQztRQUNILENBQUM7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFNRCw2QkFBSyxHQUFMO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRU8sc0NBQWMsR0FBdEIsVUFBdUIsQ0FBSSxFQUFFLFFBQWdCO1FBQzNDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2xDLENBQUM7SUFDSCxDQUFDO0lBU08sc0NBQWMsR0FBdEIsVUFBdUIsS0FBYTtRQUNsQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDWixDQUFDO1FBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVPLHlDQUFpQixHQUF6QixVQUEwQixLQUFhO1FBQ3JDLElBQU0sU0FBUyxHQUFHLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFTywwQ0FBa0IsR0FBMUIsVUFBMkIsS0FBYTtRQUN0QyxJQUFNLFNBQVMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoQyxNQUFNLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU8sbUNBQVcsR0FBbkIsVUFBb0IsS0FBYTtRQUMvQixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9DLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ1osQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLFdBQVcsQ0FBQztRQUNyQixDQUFDO1FBQ0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVPLDhCQUFNLEdBQWQsVUFBZSxLQUFhO1FBQzFCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsT0FBTyxTQUFTLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztZQUM1QixLQUFLLEdBQUcsU0FBUyxDQUFDO1lBQ2xCLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLENBQUM7SUFDSCxDQUFDO0lBRU8scUNBQWEsR0FBckIsVUFBc0IsS0FBYTtRQUNqQyxFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQzlCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNaLENBQUM7UUFDRCxJQUFJLGlCQUFpQixHQUFHLEtBQUssQ0FBQztRQUM5QixJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckQsRUFBRSxDQUFDLENBQUMsQ0FBQyxjQUFjLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDdkIsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxRCxpQkFBaUIsR0FBRyxjQUFjLENBQUM7UUFDckMsQ0FBQztRQUNELElBQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN2RCxFQUFFLENBQUMsQ0FBQyxDQUFDLGVBQWUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUN4QixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNELGlCQUFpQixHQUFHLGVBQWUsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsTUFBTSxDQUFDLENBQUMsaUJBQWlCLEtBQUssS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsaUJBQWlCLENBQUM7SUFDaEUsQ0FBQztJQUVPLGdDQUFRLEdBQWhCLFVBQWlCLEtBQWE7UUFDNUIsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxQyxPQUFPLFNBQVMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzVCLEtBQUssR0FBRyxTQUFTLENBQUM7WUFDbEIsU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsQ0FBQztJQUNILENBQUM7SUFFTywrQkFBTyxHQUFmLFVBQWdCLE1BQWMsRUFBRSxNQUFjO1FBQzVDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFTyw0QkFBSSxHQUFaLFVBQWEsQ0FBUyxFQUFFLENBQVM7UUFDL0IsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBQ0gsb0JBQUM7QUFBRCxDQXhLQSxBQXdLQyxJQUFBO0FBeEtZLHNDQUFhOzs7OztBQ3BDMUIsMENBQStDO0FBQy9DLHVEQUF5RDtBQUd6RCw2Q0FBK0M7QUFDL0MsdURBQWtEO0FBQ2xELDZCQUErQjtBQW1CL0I7SUFPRSx3QkFBWSxXQUF5QjtRQUFyQyxpQkFJQztRQVZELFNBQUksR0FBb0MsRUFBRSxDQUFDO1FBT3pDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDaEIsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQWxDLENBQWtDLENBQUMsQ0FBQztRQUNuRSxDQUFDO0lBQ0gsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FaQSxBQVlDLElBQUE7QUFaWSx3Q0FBYztBQWMzQixJQUFZLGFBSVg7QUFKRCxXQUFZLGFBQWE7SUFDdkIsaURBQUksQ0FBQTtJQUNKLCtDQUFHLENBQUE7SUFDSCxpREFBSSxDQUFBO0FBQ04sQ0FBQyxFQUpXLGFBQWEsR0FBYixxQkFBYSxLQUFiLHFCQUFhLFFBSXhCO0FBU0Q7SUFLRSxpQkFBWSxLQUFZLEVBQVUsSUFBaUI7UUFBakIsU0FBSSxHQUFKLElBQUksQ0FBYTtRQW1NbkQsdUJBQWtCLEdBQUcsSUFBSSxpQ0FBYyxFQUFFLENBQUM7UUFFMUMscUJBQWdCLEdBQUcsSUFBSSxpQ0FBYyxFQUFFLENBQUM7UUFDaEMsaUJBQVksR0FBb0MsRUFBRSxDQUFDO1FBSW5ELGNBQVMsR0FBRyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQTFNb0IsQ0FBQztJQUt2RCx5QkFBTyxHQUFQO1FBQUEsaUJBYUM7UUFaQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRztZQUN4QyxJQUFNLE9BQU8sR0FBRyxLQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEVBQUUsSUFBSSxPQUFBLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBWixDQUFZLENBQUMsQ0FBQztZQUNqRCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQyxDQUFDO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBWUQseUJBQU8sR0FBUCxVQUFRLE9BQWlCLEVBQUUsV0FBd0I7UUFBbkQsaUJBMkJDO1FBMUJDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztZQUNyQixJQUFNLElBQUksR0FBRyxJQUFJLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM3QyxJQUFNLE9BQU8sR0FBRyxLQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRXZELElBQU0sV0FBVyxHQUFHLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQztZQUU1QyxZQUFZLENBQUMsb0NBQW9DLENBQzdDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDaEMsWUFBWSxDQUFDLCtCQUErQixDQUN4QyxPQUFPLENBQUMsVUFBVSxFQUFFLEtBQUksQ0FBQyxrQkFBa0IsRUFBRSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUV4RSxZQUFZLENBQUMsbUNBQW1DLENBQzVDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDaEMsWUFBWSxDQUFDLDRDQUE0QyxDQUNyRCxJQUFJLEVBQUUsV0FBVyxFQUFFLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVsQyxPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEVBQUUsSUFBSSxPQUFBLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxDQUFDO1lBRXpFLElBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFsQixDQUFrQixDQUFDLENBQUM7WUFDckQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQXJCLENBQXFCLENBQUMsQ0FBQztZQUU1QyxZQUFZLENBQUMsNkNBQTZDLENBQ3RELElBQUksRUFBRSxXQUFXLEVBQUUsS0FBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWxDLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDakIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBV0Qsc0JBQUksR0FBSixVQUFLLE1BQWMsRUFBRSxXQUF3QjtRQUMzQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFpQkQsdUJBQUssR0FBTCxVQUNJLFVBQWtCLEVBQUUsV0FBd0IsRUFBRSxTQUFpQixFQUMvRCxTQUFvQixFQUFFLGFBQWtDO1FBRjVELGlCQTZEQztRQTNEeUIsOEJBQUEsRUFBQSxnQkFBZ0IsYUFBYSxDQUFDLElBQUk7UUFDMUQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFDcEMsa0RBQWtELENBQUMsQ0FBQztRQUV4RCxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7WUFDL0IsSUFBSSxDQUFDLGVBQWUsR0FBRyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQsSUFBTSxJQUFJLEdBQUcsSUFBSSxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0MsWUFBWSxDQUFDLHFDQUFxQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXpELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVELElBQU0sbUJBQW1CLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUMvQyxJQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDaEUsSUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDO1FBQzVDLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztRQUN4QyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFMUMsWUFBWSxDQUFDLG1DQUFtQyxDQUM1QyxPQUFPLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBRWhDLFNBQVMsQ0FBQyxXQUFXLENBQ2pCLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFM0QsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUs7WUFDakMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLGdCQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFaEMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDbkMsWUFBWSxDQUFDLG9DQUFvQyxDQUM3QyxPQUFPLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO2dCQUNoQyxZQUFZLENBQUMsMkNBQTJDLENBQ3BELE9BQU8sQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQzlCLFlBQVksQ0FBQywrQkFBK0IsQ0FDeEMsT0FBTyxDQUFDLFVBQVUsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBRWhELFlBQVksQ0FBQyw0Q0FBNEMsQ0FDckQsSUFBSSxFQUFFLFdBQVcsRUFBRSxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRWxDLG1CQUFtQixDQUFDLE9BQU8sQ0FDdkIsVUFBQSxFQUFFLElBQUksT0FBQSxFQUFFLENBQUMsV0FBVyxDQUFDLEtBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLEVBQXRDLENBQXNDLENBQUMsQ0FBQztnQkFDbEQsa0JBQWtCLENBQUMsT0FBTyxDQUN0QixVQUFBLEVBQUUsSUFBSSxPQUFBLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLEVBQTlDLENBQThDLENBQUMsQ0FBQztnQkFFMUQsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFJLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBRW5FLFlBQVksQ0FBQyw2Q0FBNkMsQ0FDdEQsSUFBSSxFQUFFLFdBQVcsRUFBRSxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRWxDLElBQUksR0FBRyxLQUFJLENBQUMsb0JBQW9CLENBQzVCLElBQUksRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBQ3hELENBQUM7WUFFRCxTQUFTLENBQUMsVUFBVSxDQUNoQixLQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRTNELE1BQU0sQ0FBQyxLQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3RELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLHNDQUFvQixHQUE1QixVQUNJLFNBQWlCLEVBQUUsUUFBZ0IsRUFDbkMsYUFBNEI7UUFDOUIsRUFBRSxDQUFDLENBQUMsYUFBYSxLQUFLLGFBQWEsQ0FBQyxJQUFJO1lBQ3BDLGFBQWEsS0FBSyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN4QyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFTyxvQ0FBa0IsR0FBMUIsVUFBMkIsU0FBaUIsRUFBRSxhQUE0QjtRQUV4RSxFQUFFLENBQUMsQ0FBQyxhQUFhLEtBQUssYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDM0QsQ0FBQztRQUNELE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVPLG9DQUFrQixHQUExQixVQUEyQixPQUFpQixFQUFFLElBQW9CO1FBRWhFLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDcEQsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNyQyxFQUFFLENBQUMsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztZQUMxQixJQUFJLEtBQUssR0FDTCxZQUFZLENBQUMscUNBQXFDLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBSXRFLEtBQUssR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzFDLFlBQVksQ0FBQywwQ0FBMEMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDckUsWUFBWSxDQUFDLGlEQUFpRCxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RFLElBQU0sVUFBVSxHQUFHLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9ELE9BQU8sR0FBRyxFQUFDLEtBQUssT0FBQSxFQUFFLFVBQVUsWUFBQSxFQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDbkMsQ0FBQztRQUVELE1BQU0sQ0FBQyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVPLHFDQUFtQixHQUEzQixVQUE0QixPQUFpQixFQUFFLElBQW9CO1FBQ2pFLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEVBQUUsRUFBSixDQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSTtZQUNqRCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQVdILGNBQUM7QUFBRCxDQWhOQSxBQWdOQyxJQUFBO0FBaE5ZLDBCQUFPOzs7OztBQ3REcEIsaUNBQTZGO0FBQzdGLHlDQUEyQztBQUczQywwQ0FBdUM7QUFJdkMsNkJBQStCO0FBVy9CLCtDQUNJLGNBQThCO0lBQ2hDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7U0FDbEMsR0FBRyxDQUFDLFVBQUEsUUFBUSxJQUFJLE9BQUEsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQTFDLENBQTBDLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBSkQsc0ZBSUM7QUFXRCwrQ0FDSSxXQUFxQixFQUFFLGNBQThCO0lBQ3ZELElBQU0sZ0JBQWdCLEdBQ2xCLHFDQUFxQyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzFELElBQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsSUFBSSxFQUFOLENBQU0sQ0FBQyxDQUFDO0lBQy9DLElBQU0sc0JBQXNCLEdBQ3hCLFVBQVUsQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUN0RSxJQUFNLG9CQUFvQixHQUN0QixVQUFVLENBQUMsdUJBQXVCLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUMvRCxNQUFNLENBQUMsb0JBQW9CLENBQUM7QUFDOUIsQ0FBQztBQVZELHNGQVVDO0FBV0QsNkNBQ0ksYUFBcUIsRUFBRSxjQUE4QjtJQUN2RCxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUN4QixFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksb0JBQVksSUFBSSxJQUFJLFlBQVksb0JBQVksQ0FBQyxDQUFDLENBQUM7WUFDakUsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBUEQsa0ZBT0M7QUFLRCwyQ0FBa0QsYUFBcUI7SUFFckUsSUFBTSxLQUFLLEdBQW1CLEVBQUUsQ0FBQztJQUNqQyxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUN4QixFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksb0JBQVksQ0FBQyxDQUFDLENBQUM7WUFDakMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQVRELDhFQVNDO0FBS0QsK0NBQ0ksY0FBOEI7SUFDaEMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUEsUUFBUTtRQUMvQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxZQUFZLGlCQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzNELE1BQU0sSUFBSSxLQUFLLENBQ1gsK0RBQStEO2dCQUMvRCxtQkFBbUIsQ0FBQyxDQUFDO1FBQzNCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFURCxzRkFTQztBQUtELHNEQUNJLFNBQXlCLEVBQUUsV0FBMkIsRUFBRSxJQUFpQjtJQUMzRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxRQUFRO1FBQzFDLElBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1QyxJQUFJLElBQWEsQ0FBQztRQUNsQixFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxZQUFZLGlCQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksR0FBRyxTQUFTLENBQUMsSUFBZSxDQUFDO1FBQ25DLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQztZQUNOLElBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxJQUFxQixDQUFDO1lBQ2pELElBQUksR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLENBQUM7UUFFRCxJQUFJLENBQUMsTUFBTSxDQUNQLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUNwRCx1REFBcUQsSUFBSSxDQUFDLEtBQUssTUFBRzthQUM5RCxnQ0FBOEIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLGNBQVcsQ0FBQTthQUN6RCxTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssTUFBRyxDQUFBLENBQUMsQ0FBQztRQUN0QyxXQUFXLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBcEJELG9HQW9CQztBQU1ELHVEQUNJLFNBQXlCLEVBQUUsV0FBMkIsRUFBRSxJQUFpQjtJQUMzRSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxRQUFRO1FBQzFDLElBQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU1QyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksWUFBWSxpQkFBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxJQUFxQixDQUFDO1lBRWpELElBQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3pELFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFFRCxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFkRCxzR0FjQztBQVlELG9EQUNJLGNBQThCLEVBQUUsYUFBcUI7SUFDdkQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ1YsT0FBTyxDQUFDLEdBQUcsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ2hDLElBQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QixFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNoRCxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3QixDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixFQUFFLENBQUMsQ0FBQztRQUNOLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQVhELGdHQVdDO0FBVUQsOENBQ0ksYUFBcUIsRUFBRSxjQUE4QjtJQUN2RCxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUN4QixFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hELGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNDLENBQUM7WUFDRCxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDeEMsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQVZELG9GQVVDO0FBVUQscURBQ0ksYUFBcUIsRUFBRSxTQUF5QjtJQUNsRCxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUN4QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxTQUFTO1lBQ3hDLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDckMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEUsU0FBUyxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoQyxDQUFDO1lBQ0QsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFYRCxrR0FXQztBQVlELHlDQUNJLFVBQXVCLEVBQUUsV0FBMkIsRUFDcEQsU0FBeUI7SUFDM0IsVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEVBQUUsSUFBSSxPQUFBLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXLEVBQUUsU0FBUyxDQUFDLEVBQWpELENBQWlELENBQUMsQ0FBQztBQUM5RSxDQUFDO0FBSkQsMEVBSUM7QUFVRCwyREFDSSxhQUFxQjtJQUN2QixhQUFhLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUN4QixFQUFFLENBQUMsQ0FBQyxJQUFJLFlBQVksdUJBQWUsQ0FBQyxDQUFDLENBQUM7WUFDcEMsSUFBTSxLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FDWCxvQkFBb0IsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLO2dCQUMvQyxrQ0FBa0MsQ0FBQyxDQUFDO1FBQzFDLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFWRCw4R0FVQztBQVNELHVCQUE4QixLQUFhO0lBQ3pDLElBQU0sb0JBQW9CLEdBQWEsRUFBRSxDQUFDO0lBQzFDLElBQU0saUJBQWlCLEdBQWtDLEVBQUUsQ0FBQztJQUc1RCxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSTtRQUNoQixJQUFNLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUEsR0FBRztZQUNkLElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDckMsSUFBTSxLQUFLLEdBQUcsV0FBVyxDQUFDLElBQUksQ0FBQztZQUMvQixFQUFFLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDM0Msb0JBQW9CLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNyQyxDQUFDO1lBQ0Qsb0JBQW9CLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDakMsRUFBRSxDQUFDLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7Z0JBQ2xDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUN4QyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxpQkFBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDeEUsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFRSCxJQUFNLFFBQVEsR0FBVyxFQUFFLENBQUM7SUFDNUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUk7UUFDaEIsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUNqQyxJQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0MsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMzQixDQUFDO1FBQ0QsSUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFBLEdBQUc7WUFDZCxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3JDLElBQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ3BDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUNyRSxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQTVDRCxzQ0E0Q0M7Ozs7Ozs7Ozs7Ozs7OztBQy9SRCwwQ0FBK0M7QUFDL0MseUNBQXNDO0FBRXRDLDZDQUErQztBQUMvQyx1REFBa0Q7QUFFbEQ7SUFBa0MsZ0NBQVM7SUFDekMsc0JBQW9CLFlBQW9CLEVBQUUscUJBQThCO1FBQXhFLFlBQ0Usa0JBQU0scUJBQXFCLENBQUMsU0FDN0I7UUFGbUIsa0JBQVksR0FBWixZQUFZLENBQVE7UUFnRWhDLHVCQUFpQixHQUFHLElBQUksaUNBQWMsRUFBRSxDQUFDO1FBRXpDLFNBQUcsR0FBRyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7SUFoRTVCLENBQUM7SUFFRCxrQ0FBVyxHQUFYLFVBQ0ksSUFBaUIsRUFBRSxTQUFpQixFQUFFLE9BQXVCLEVBQzdELGtCQUFrQyxFQUFFLGdCQUFnQztRQUZ4RSxpQkFhQztRQVZDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixJQUFJLElBQUk7WUFDcEQsWUFBWSxDQUFDLGlDQUFpQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7WUFDN0QsSUFBSSxDQUFDLHNCQUFzQixDQUFDO1FBQ2hDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUNyQyxJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztZQUMvQixJQUFJLENBQUMsQ0FBQyxHQUFHLGdCQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUMsQ0FBQztRQUN0RCxDQUFDO1FBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQ3RCLFVBQUEsSUFBSSxJQUFJLE9BQUEsS0FBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FDOUIsSUFBSSxDQUFDLE1BQU0sRUFBRSxpQkFBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBRDFDLENBQzBDLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRUQsbUNBQVksR0FBWixVQUNJLElBQWlCLEVBQUUsT0FBdUIsRUFDMUMsa0JBQWtDLEVBQUUsZ0JBQWdDO1FBRnhFLGlCQVlDO1FBVEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLElBQUk7WUFDZCxLQUFJLENBQUMsYUFBYyxDQUFDLE9BQU8sQ0FBQyxVQUFBLElBQUk7Z0JBQzlCLElBQU0sUUFBUSxHQUFHLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ25ELElBQU0sbUJBQW1CLEdBQUcsS0FBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3BFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQ3RCLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNoRSxtQkFBbUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNoQyxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGlDQUFVLEdBQVYsVUFDSSxJQUFpQixFQUFFLFNBQWlCLEVBQUUsT0FBdUIsRUFDN0Qsa0JBQWtDLEVBQUUsZ0JBQWdDO1FBRnhFLGlCQWtCQztRQWZDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBQyxJQUFJO1lBQ2QsS0FBSSxDQUFDLGFBQWMsQ0FBQyxPQUFPLENBQUMsVUFBQSxJQUFJO2dCQUM5QixJQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN4RCxJQUFNLFFBQVEsR0FBRyxLQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDekQsSUFBTSxRQUFRLEdBQ1YsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFJLENBQUMsQ0FBRSxFQUFFLFFBQVEsRUFBRSxLQUFJLENBQUMsR0FBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO2dCQUNuRSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUM7Z0JBRXJCLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN4QixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLGlDQUFjLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBRUQsOEJBQU8sR0FBUDtRQUNFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNuQixJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ25CLENBQUM7UUFDRCxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRCxzQ0FBZSxHQUFmLFVBQWdCLFlBQW9CO1FBQ2xDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO0lBQ25DLENBQUM7SUFNSCxtQkFBQztBQUFELENBckVBLEFBcUVDLENBckVpQyxxQkFBUyxHQXFFMUM7QUFyRVksb0NBQVk7Ozs7O0FDQXpCO0lBQUE7UUFrRlUsU0FBSSxHQUF5QyxFQUFFLENBQUM7SUFDMUQsQ0FBQztJQTdFQyw0QkFBRyxHQUFILFVBQUksTUFBYyxFQUFFLEtBQW1CO1FBQ3JDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUMvQixDQUFDO0lBVUQsNEJBQUcsR0FBSCxVQUFJLE1BQWMsRUFBRSxVQUFrQjtRQUFsQiwyQkFBQSxFQUFBLGtCQUFrQjtRQUNwQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3RELE1BQU0sSUFBSSxLQUFLLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxFQUFFLEdBQUcsb0JBQW9CLENBQUMsQ0FBQztRQUNoRSxDQUFDO1FBQ0QsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFDRCxNQUFNLENBQUMsR0FBSSxDQUFDO0lBQ2QsQ0FBQztJQU1ELCtCQUFNLEdBQU4sVUFBTyxNQUFjO1FBQ25CLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELHFDQUFZLEdBQVosVUFBYSxNQUFjO1FBQ3pCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDO1FBQ1QsQ0FBQztRQUNELElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLE1BQU0sQ0FBQztRQUNULENBQUM7UUFDRCxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDOUIsQ0FBQztJQUtELDZCQUFJLEdBQUo7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3ZDLENBQUM7SUFLRCxnQ0FBTyxHQUFQO1FBQUEsaUJBUUM7UUFQQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQSxRQUFRO1lBQ3JDLElBQU0sR0FBRyxHQUFHLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUNSLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNoQixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBUUQscUNBQVksR0FBWixVQUFhLE1BQWM7UUFDekIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLG9CQUFvQixDQUFDLENBQUM7UUFDaEUsQ0FBQztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUM7SUFDdkMsQ0FBQztJQUdILHFCQUFDO0FBQUQsQ0FuRkEsQUFtRkMsSUFBQTtBQW5GWSx3Q0FBYzs7Ozs7QUNIM0IsaUJBQXdCLEtBQ1k7SUFDbEMsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUMzQixJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFDYixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFFZCxPQUFPLE9BQU8sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUVuQixLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRDLE9BQU8sRUFBRSxDQUFDO1FBRVYsSUFBSSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDdEIsQ0FBQztBQUNILENBQUM7QUFoQkQsMEJBZ0JDO0FBR0QsZUFBc0IsR0FBVyxFQUFFLENBQVMsRUFBRSxHQUFXO0lBQ3ZELE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFGRCxzQkFFQztBQUdELHFCQUE0QixDQUFTLEVBQUUsQ0FBUztJQUM5QyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNyQyxDQUFDO0FBRkQsa0NBRUM7QUFRRCxtQkFBMEIsSUFBUSxFQUFFLE1BQVUsRUFBRSxTQUFpQjtJQUF2QyxxQkFBQSxFQUFBLFFBQVE7SUFBRSx1QkFBQSxFQUFBLFVBQVU7SUFBRSwwQkFBQSxFQUFBLGlCQUFpQjtJQUMvRCxJQUFJLEVBQVUsRUFBRSxFQUFVLEVBQUUsQ0FBUyxDQUFDO0lBQ3RDLEdBQUcsQ0FBQztRQUNGLEVBQUUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMzQixFQUFFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtJQUVoQixJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BELEVBQUUsQ0FBQyxDQUFDLFNBQVMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUNELE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUNoQyxDQUFDO0FBYkQsOEJBYUM7QUFHRCxxQkFBNEIsQ0FBUyxFQUFFLENBQVM7SUFDOUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2YsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDbEMsSUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6QixNQUFNLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztJQUN4QixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBUEQsa0NBT0M7QUFFRCxnQkFBdUIsSUFBYSxFQUFFLEdBQVc7SUFDL0MsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0FBQ0gsQ0FBQztBQUpELHdCQUlDO0FBRUQsMkJBQ0ksTUFBZ0IsRUFBRSxNQUFnQixFQUFFLGtCQUF1QjtJQUF2QixtQ0FBQSxFQUFBLHVCQUF1QjtJQUM3RCxNQUFNLENBQ0YsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFDM0Isa0JBQWtCLElBQUcsWUFBVSxNQUFNLGFBQVEsTUFBTSxnQkFBYSxDQUFBLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBTEQsOENBS0M7QUFHRCxpQkFBd0IsR0FBVSxFQUFFLEdBQWM7SUFDaEQsR0FBRyxHQUFHLENBQUMsR0FBRyxLQUFLLFNBQVMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7SUFDckMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDcEMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN2QixDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25CLENBQUM7SUFDSCxDQUFDO0lBQ0QsTUFBTSxDQUFDLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFWRCwwQkFVQztBQUlELG9CQUEyQixHQUFjO0lBQ3ZDLElBQU0sS0FBSyxHQUFhLEVBQUUsQ0FBQztJQUMzQixPQUFPLEdBQUcsWUFBWSxLQUFLLEVBQUUsQ0FBQztRQUM1QixLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN2QixHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2YsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDZixDQUFDO0FBUEQsZ0NBT0M7QUFFRCx1QkFBOEIsS0FBZTtJQUMzQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdkIsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFDRCxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEIsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDdEMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNkLENBQUM7QUFWRCxzQ0FVQztBQUVELHVCQUE4QixLQUFlO0lBQzNDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBRkQsc0NBRUM7QUFHRCxxQkFBNEIsRUFBc0IsRUFBRSxFQUFzQjtJQUN4RSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQ0QsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDbkMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEIsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNmLENBQUM7SUFDSCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNkLENBQUM7QUFWRCxrQ0FVQztBQUVELGVBQXNCLENBQVM7SUFDN0IsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JCLENBQUM7QUFGRCxzQkFFQztBQUVELGNBQXFCLENBQVM7SUFFNUIsRUFBRSxDQUFDLENBQUUsSUFBWSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRS9CLE1BQU0sQ0FBRSxJQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNaLENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLElBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvQixDQUFDO0FBQ0gsQ0FBQztBQWRELG9CQWNDO0FBRUQsNkJBQW9DLElBQVk7SUFDOUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3JELEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLENBQUM7SUFDSCxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFQRCxrREFPQztBQUVELCtCQUFzQyxDQUFTO0lBQzdDLElBQU0sZUFBZSxHQUFHLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDM0IsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBQ0QsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3pCLE1BQU0sQ0FBQyxlQUFlLENBQUM7QUFDekIsQ0FBQztBQVBELHNEQU9DO0FBRUQsc0NBQ0ksTUFBZ0IsRUFBRSxNQUFnQjtJQUNwQyxJQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsSUFBSSxpQkFBaUIsR0FBRyxLQUFLLENBQUM7SUFDOUIsSUFBSSxpQkFBaUIsR0FBRyxLQUFLLENBQUM7SUFDOUIsSUFBTSxNQUFNLEdBQUcsdURBQXVEO1NBQy9ELE1BQU0sYUFBUSxNQUFNLG9DQUFpQyxDQUFBO1FBQ3hELDhDQUE4QyxDQUFDO0lBQ25ELElBQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFFakQsTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNsQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ2xDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDM0IsSUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRSxNQUFNLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBQ0QsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQixpQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDM0IsQ0FBQztRQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckIsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1FBQzNCLENBQUM7UUFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDOUIsTUFBTSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEIsQ0FBQztRQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBQ0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUMxQixDQUFDO0FBOUJELG9FQThCQyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8vIFRoaXMgZmlsZSBpcyBqdXN0IGFuIGFsaWFzIHRoYXQgcG9pbnRzIHRvIHRoZSBjdXJyZW50IGRlZXBsZWFybmpzIHZlcnNpb25cbi8vIGF0IHRoaXMgYnJhbmNoLCBzbyBkZW1vcyBjYW4gaW1wb3J0IHRoZSBsaWJyYXJ5IGFzICcuLi9kZWVwbGVhcm5qcycuXG5leHBvcnQgKiBmcm9tICcuLi9zcmMvaW5kZXgnO1xuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0FycmF5MUQsIEFycmF5MkQsIENoZWNrcG9pbnRMb2FkZXIsIE5EQXJyYXlNYXRoLCBOREFycmF5TWF0aEdQVSxcbiAgICBTY2FsYXJ9IGZyb20gJy4uL2RlZXBsZWFybmpzJztcblxuY29uc3QgUGlhbm86YW55ID0gcmVxdWlyZSgndG9uZS1waWFubycpLlBpYW5vXG5cbmNvbnN0IHBpYW5vID0gbmV3IFBpYW5vKHt2ZWxvY2l0aWVzIDogNH0pLnRvTWFzdGVyKClcblxuLy8gbWFuaWZlc3QuanNvbiBsaXZlcyBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG5waWFuby5sb2FkKCdodHRwczovL3RhbWJpZW4uZ2l0aHViLmlvL1BpYW5vL1NhbGFtYW5kZXIvJykudGhlbigoKSA9PiB7XG5cdGNvbnN0IHJlYWRlciA9IG5ldyBDaGVja3BvaW50TG9hZGVyKCcuJyk7XG5cdHJldHVybiByZWFkZXIuZ2V0QWxsVmFyaWFibGVzKClcbn0pLnRoZW4oKHZhcnM6IGFueSkgPT4ge1xuXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc3RhdHVzJykudGV4dENvbnRlbnQgPSAnUGxheWluZydcblx0Ly9zdGFydCBpdCBhdCB0aGUgYXVkaW8gY29udGV4dCBjdXJyZW50IHRpbWVcblx0Y3VycmVudFRpbWUgPSBwaWFuby5ub3coKVxuXHRnZW5lcmF0ZVN0ZXAodmFycylcbn0pO1xuXG5sZXQgY3VycmVudFRpbWUgPSAwO1xubGV0IGN1cnJlbnRWZWxvY2l0eSA9IDE7XG5jb25zdCBtYXRoID0gbmV3IE5EQXJyYXlNYXRoR1BVKCk7XG5cbmNvbnN0IElOUFVUX1NJWkUgPSAzODg7XG5jb25zdCBQUklNRVJfSURYID0gMzU1OyAvLyBzaGlmdCAxcy5cbmxldCBsYXN0U2FtcGxlID0gUFJJTUVSX0lEWFxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN0ZXAodmFyczogYW55KXtcblxuXHRjb25zdCBsc3RtS2VybmVsMSA9IHZhcnNbXG5cdFx0J3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzAvYmFzaWNfbHN0bV9jZWxsL2tlcm5lbCddIGFzIEFycmF5MkQ7XG5cdGNvbnN0IGxzdG1CaWFzMSA9IHZhcnNbXG5cdFx0J3Jubi9tdWx0aV9ybm5fY2VsbC9jZWxsXzAvYmFzaWNfbHN0bV9jZWxsL2JpYXMnXSBhcyBBcnJheTFEO1xuXG5cdGNvbnN0IGxzdG1LZXJuZWwyID0gdmFyc1tcblx0XHQncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMS9iYXNpY19sc3RtX2NlbGwva2VybmVsJ10gYXMgQXJyYXkyRDtcblx0Y29uc3QgbHN0bUJpYXMyID0gdmFyc1tcblx0XHQncm5uL211bHRpX3Jubl9jZWxsL2NlbGxfMS9iYXNpY19sc3RtX2NlbGwvYmlhcyddIGFzIEFycmF5MUQ7XG5cblx0Y29uc3QgbHN0bUtlcm5lbDMgPSB2YXJzW1xuXHRcdCdybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8yL2Jhc2ljX2xzdG1fY2VsbC9rZXJuZWwnXSBhcyBBcnJheTJEO1xuXHRjb25zdCBsc3RtQmlhczMgPSB2YXJzW1xuXHRcdCdybm4vbXVsdGlfcm5uX2NlbGwvY2VsbF8yL2Jhc2ljX2xzdG1fY2VsbC9iaWFzJ10gYXMgQXJyYXkxRDtcblxuXHRjb25zdCBmdWxseUNvbm5lY3RlZEJpYXNlcyA9IHZhcnNbJ2Z1bGx5X2Nvbm5lY3RlZC9iaWFzZXMnXSBhcyBBcnJheTFEO1xuXHRjb25zdCBmdWxseUNvbm5lY3RlZFdlaWdodHMgPSB2YXJzWydmdWxseV9jb25uZWN0ZWQvd2VpZ2h0cyddIGFzIEFycmF5MkQ7XG5cblx0Ly8gY29uc3Qgc3RhcnRUaW1lID0gY3VycmVudFRpbWVcblxuXHRtYXRoLnNjb3BlKChrZWVwLCB0cmFjaykgPT4ge1xuXHRcdGNvbnN0IGZvcmdldEJpYXMgPSB0cmFjayhTY2FsYXIubmV3KDEuMCkpO1xuXHRcdGNvbnN0IGxzdG0xID0gbWF0aC5iYXNpY0xTVE1DZWxsLmJpbmQobWF0aCwgZm9yZ2V0QmlhcywgbHN0bUtlcm5lbDEsXG5cdFx0ICBsc3RtQmlhczEpO1xuXHRcdGNvbnN0IGxzdG0yID0gbWF0aC5iYXNpY0xTVE1DZWxsLmJpbmQobWF0aCwgZm9yZ2V0QmlhcywgbHN0bUtlcm5lbDIsXG5cdFx0ICBsc3RtQmlhczIpO1xuXHRcdGNvbnN0IGxzdG0zID0gbWF0aC5iYXNpY0xTVE1DZWxsLmJpbmQobWF0aCwgZm9yZ2V0QmlhcywgbHN0bUtlcm5lbDMsXG5cdFx0ICBsc3RtQmlhczMpO1xuXG5cdFx0bGV0IGMgPSBbXG5cdFx0ICB0cmFjayhBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczEuc2hhcGVbMF0gLyA0XSkpLFxuXHRcdCAgdHJhY2soQXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMyLnNoYXBlWzBdIC8gNF0pKSxcblx0XHQgIHRyYWNrKEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMy5zaGFwZVswXSAvIDRdKSksXG5cdFx0ICBdO1xuXHRcdGxldCBoID0gW1xuXHRcdCAgdHJhY2soQXJyYXkyRC56ZXJvcyhbMSwgbHN0bUJpYXMxLnNoYXBlWzBdIC8gNF0pKSxcblx0XHQgIHRyYWNrKEFycmF5MkQuemVyb3MoWzEsIGxzdG1CaWFzMi5zaGFwZVswXSAvIDRdKSksXG5cdFx0ICB0cmFjayhBcnJheTJELnplcm9zKFsxLCBsc3RtQmlhczMuc2hhcGVbMF0gLyA0XSkpLFxuXHRcdCAgXTtcblxuXHRcdGxldCBpbnB1dCA9IHRyYWNrKEFycmF5MkQuemVyb3MoWzEsIElOUFVUX1NJWkVdKSk7XG5cdFx0aW5wdXQuc2V0KDEuMCwgMCwgbGFzdFNhbXBsZSk7XG5cblx0XHQvL2dlbmVyYXRlIHNvbWUgbm90ZXNcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKXtcblx0XHRcdGNvbnN0IG91dHB1dCA9IG1hdGgubXVsdGlSTk5DZWxsKFtsc3RtMSwgbHN0bTIsIGxzdG0zXSwgaW5wdXQsIGMsIGgpO1xuXG5cdFx0XHRjID0gb3V0cHV0WzBdO1xuXHRcdFx0aCA9IG91dHB1dFsxXTtcblxuXHRcdFx0Y29uc3Qgb3V0cHV0SCA9IGhbMl07XG5cdFx0XHRjb25zdCB3ZWlnaHRlZFJlc3VsdCA9IG1hdGgubWF0TXVsKG91dHB1dEgsIGZ1bGx5Q29ubmVjdGVkV2VpZ2h0cyk7XG5cdFx0XHRjb25zdCBsb2dpdHMgPSBtYXRoLmFkZCh3ZWlnaHRlZFJlc3VsdCwgZnVsbHlDb25uZWN0ZWRCaWFzZXMpO1xuXG5cdFx0XHRjb25zdCBzb2Z0bWF4ID0gbWF0aC5zb2Z0bWF4KGxvZ2l0cy5hczFEKCkpO1xuXHRcdFx0Y29uc3Qgc2FtcGxlZE91dHB1dCA9IHNhbXBsZUZyb21Tb2Z0bWF4KG1hdGgsIHNvZnRtYXgpO1xuXG5cdFx0XHRwbGF5T3V0cHV0KHNhbXBsZWRPdXRwdXQpO1xuXHRcdFx0bGFzdFNhbXBsZSA9IHNhbXBsZWRPdXRwdXRcblxuXHRcdFx0Ly8gdXNlIG91dHB1dCBhcyB0aGUgbmV4dCBpbnB1dC5cblx0XHRcdGlucHV0ID0gdHJhY2soQXJyYXkyRC56ZXJvcyhbMSwgSU5QVVRfU0laRV0pKTtcblx0XHRcdGlucHV0LnNldCgxLjAsIDAsIGxhc3RTYW1wbGUpO1xuXHRcdH1cblx0fSk7XG5cdC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzdGF0dXMnKS50ZXh0Q29udGVudCA9IGBQbGF5aW5nICR7Y3VycmVudFRpbWV9ICR7cGlhbm8ubm93KCl9YFxuXHRjb25zdCBkZWx0YSA9IGN1cnJlbnRUaW1lIC0gcGlhbm8ubm93KClcblx0c2V0VGltZW91dCgoKSA9PiBnZW5lcmF0ZVN0ZXAodmFycyksIGRlbHRhICogMTAwMClcbn1cblxuXG5jb25zdCBNSU5fTUlESV9QSVRDSCA9IDA7XG5jb25zdCBNQVhfTUlESV9QSVRDSCA9IDEyNztcbmNvbnN0IFZFTE9DSVRZX0JJTlMgPSAzMjtcbmNvbnN0IE1BWF9TSElGVF9TVEVQUyA9IDEwMDtcbmNvbnN0IFNURVBTX1BFUl9TRUNPTkQgPSAxMDA7XG5cbmNvbnN0IEVWRU5UX1JBTkdFUyA9IFtcbiAgICBbJ25vdGVfb24nLCBNSU5fTUlESV9QSVRDSCwgTUFYX01JRElfUElUQ0hdLFxuICAgIFsnbm90ZV9vZmYnLCBNSU5fTUlESV9QSVRDSCwgTUFYX01JRElfUElUQ0hdLFxuICAgIFsndGltZV9zaGlmdCcsIDEsIE1BWF9TSElGVF9TVEVQU10sXG4gICAgWyd2ZWxvY2l0eV9jaGFuZ2UnLCAxLCBWRUxPQ0lUWV9CSU5TXSxcbl07XG5cbmZ1bmN0aW9uIHBsYXlPdXRwdXQoaW5kZXg6IG51bWJlcikge1xuXHRsZXQgb2Zmc2V0ID0gMDtcblx0Zm9yKGNvbnN0IGV2ZW50UmFuZ2Ugb2YgRVZFTlRfUkFOR0VTKSB7XG5cdFx0Y29uc3QgZXZlbnRUeXBlID0gZXZlbnRSYW5nZVswXSBhcyBzdHJpbmc7XG5cdFx0Y29uc3QgbWluVmFsdWUgPSBldmVudFJhbmdlWzFdIGFzIG51bWJlcjtcblx0XHRjb25zdCBtYXhWYWx1ZSA9IGV2ZW50UmFuZ2VbMl0gYXMgbnVtYmVyO1xuXHRcdGlmIChvZmZzZXQgPD0gaW5kZXggJiYgaW5kZXggPD0gb2Zmc2V0ICsgbWF4VmFsdWUgLSBtaW5WYWx1ZSkge1xuXHRcdFx0aWYgKGV2ZW50VHlwZSA9PT0gJ25vdGVfb24nKSB7XG5cdFx0XHRcdHJldHVybiBwaWFuby5rZXlEb3duKGluZGV4IC0gb2Zmc2V0LCBjdXJyZW50VGltZSwgY3VycmVudFZlbG9jaXR5KVxuXHRcdFx0fSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdub3RlX29mZicpIHtcblx0XHRcdFx0cmV0dXJuIFx0cGlhbm8ua2V5VXAoaW5kZXggLSBvZmZzZXQsIGN1cnJlbnRUaW1lKVxuXHRcdFx0fSBlbHNlIGlmIChldmVudFR5cGUgPT09ICd0aW1lX3NoaWZ0Jykge1xuXHRcdFx0XHRjdXJyZW50VGltZSArPSAoaW5kZXggLSBvZmZzZXQgKyAxKSAvIFNURVBTX1BFUl9TRUNPTkRcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUaW1lXG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZlbG9jaXR5X2NoYW5nZScpIHtcblx0XHRcdFx0Y3VycmVudFZlbG9jaXR5ID0gKGluZGV4IC0gb2Zmc2V0ICsgMSkgKiBNYXRoLmNlaWwoMTI3IC8gVkVMT0NJVFlfQklOUylcblx0XHRcdFx0Y3VycmVudFZlbG9jaXR5ID0gY3VycmVudFZlbG9jaXR5LzEyN1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudFZlbG9jaXR5XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgZXZlbnRUeXBlOiAnICsgZXZlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0b2Zmc2V0ICs9IG1heFZhbHVlIC0gbWluVmFsdWUgKyAxO1xuXHR9XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlY29kZSBpbmRleDogJyArIGluZGV4KTtcbn1cblxuXG4vKipcbiogU2FtcGxlIGZyb20gYSBzb2Z0bWF4LlxuKi9cbmZ1bmN0aW9uIHNhbXBsZUZyb21Tb2Z0bWF4KG1hdGg6IE5EQXJyYXlNYXRoLCBzb2Z0bWF4OiBBcnJheTFEKTogbnVtYmVyIHtcblx0Y29uc3Qgc29mdG1heFZhbHVlcyA9IHNvZnRtYXguZ2V0VmFsdWVzKCk7XG5cdGNvbnN0IHJhbmQgPSBTY2FsYXIucmFuZFVuaWZvcm0oW10sIDAsIDEpLmdldCgpO1xuXHRsZXQgY2RmID0gMDtcblx0Zm9yKGxldCBpID0gMDsgaSA8IHNvZnRtYXhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRjZGYgKz0gc29mdG1heFZhbHVlc1tpXTtcblx0XHRpZiAoY2RmID4gcmFuZCkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHNhbXBsZSBmcm9tIHNvZnRtYXguJyk7XG59XG4iLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJ0b25lXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcInRvbmVcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QaWFubz10KHJlcXVpcmUoXCJ0b25lXCIpKTplLlBpYW5vPXQoZS50b25lKX0odGhpcyxmdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihuW3JdKXJldHVybiBuW3JdLmV4cG9ydHM7dmFyIG89bltyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsdCksby5sPSEwLG8uZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5pPWZ1bmN0aW9uKGUpe3JldHVybiBlfSx0LmQ9ZnVuY3Rpb24oZSxuLHIpe3QubyhlLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6cn0pfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIG49ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChuLFwiYVwiLG4pLG59LHQubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdC5wPVwiXCIsdCh0LnM9OCl9KFtmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9bigyKTt0LmRlZmF1bHQ9e2dldFJlbGVhc2VzVXJsOmZ1bmN0aW9uKGUpe3JldHVyblwicmVsXCIrKGUtMjApK1wiLlttcDN8b2dnXVwifSxnZXRIYXJtb25pY3NVcmw6ZnVuY3Rpb24oZSl7cmV0dXJuXCJoYXJtTFwiKygwLHIubWlkaVRvTm90ZSkoZSkucmVwbGFjZShcIiNcIixcInNcIikrXCIuW21wM3xvZ2ddXCJ9LGdldE5vdGVzVXJsOmZ1bmN0aW9uKGUsdCl7cmV0dXJuKDAsci5taWRpVG9Ob3RlKShlKS5yZXBsYWNlKFwiI1wiLFwic1wiKStcInZcIit0K1wiLlttcDN8b2dnXVwifX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybigwLHMuRnJlcXVlbmN5KShlKS50b01pZGkoKX1mdW5jdGlvbiBvKGUpe3JldHVybigwLHMuRnJlcXVlbmN5KShlLFwibWlkaVwiKS50b05vdGUoKX1mdW5jdGlvbiBpKGUpe3ZhciB0PWUlMztyZXR1cm4gMT09PXQ/W2UtMSxjLmRlZmF1bHQuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKDEpXToyPT09dD9bZSsxLGMuZGVmYXVsdC5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oLTEpXTpbZSwxXX1mdW5jdGlvbiB1KGUpe3JldHVybiBuZXcgcy5CdWZmZXJTb3VyY2UoZSl9ZnVuY3Rpb24gYShlLHQpe3JldHVybiBNYXRoLnJhbmRvbSgpKih0LWUpK2V9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5yYW5kb21CZXR3ZWVuPXQubWlkaVRvRnJlcXVlbmN5UmF0aW89dC5jcmVhdGVTb3VyY2U9dC5ub3RlVG9NaWRpPXQubWlkaVRvTm90ZT12b2lkIDA7dmFyIHM9bigwKSxjPWZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX0ocyk7dC5taWRpVG9Ob3RlPW8sdC5ub3RlVG9NaWRpPXIsdC5jcmVhdGVTb3VyY2U9dSx0Lm1pZGlUb0ZyZXF1ZW5jeVJhdGlvPWksdC5yYW5kb21CZXR3ZWVuPWF9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBvKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gaShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksYT1uKDApLHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fShhKSxjPWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06MDtyKHRoaXMsdCk7dmFyIG49byh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTtyZXR1cm4gbi5jcmVhdGVJbnNPdXRzKDAsMSksbi52b2x1bWU9ZSxufXJldHVybiBpKHQsZSksdSh0LFt7a2V5Olwidm9sdW1lXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuZGVmYXVsdC5nYWluVG9EYih0aGlzLm91dHB1dC5nYWluLnZhbHVlKX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMub3V0cHV0LmdhaW4udmFsdWU9cy5kZWZhdWx0LmRiVG9HYWluKGUpfX1dKSx0fShhLkF1ZGlvTm9kZSk7dC5kZWZhdWx0PWN9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCkscz1uKDEpLGM9cihzKSxsPW4oMyksZj1yKGwpLHA9bigyKSxoPW4oMCksZD1bMjEsMjQsMjcsMzAsMzMsMzYsMzksNDIsNDUsNDgsNTEsNTQsNTcsNjAsNjMsNjYsNjksNzIsNzUsNzgsODEsODQsODddLF89ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbMjEsMTA4XTtvKHRoaXMsdCk7dmFyIG49aSh0aGlzLCh0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKSxyPWQuZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0Pj1lWzBdfSksdT1kLmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdD49ZVsxXX0pO3U9LTE9PT11P3U9ZC5sZW5ndGg6dTt2YXIgYT1kLnNsaWNlKHIsdSk7bi5fc2FtcGxlcz17fTt2YXIgcz0hMCxsPSExLGY9dm9pZCAwO3RyeXtmb3IodmFyIHAsaD1hW1N5bWJvbC5pdGVyYXRvcl0oKTshKHM9KHA9aC5uZXh0KCkpLmRvbmUpO3M9ITApe3ZhciBfPXAudmFsdWU7bi5fc2FtcGxlc1tfXT1jLmRlZmF1bHQuZ2V0SGFybW9uaWNzVXJsKF8pfX1jYXRjaChlKXtsPSEwLGY9ZX1maW5hbGx5e3RyeXshcyYmaC5yZXR1cm4mJmgucmV0dXJuKCl9ZmluYWxseXtpZihsKXRocm93IGZ9fXJldHVybiBufXJldHVybiB1KHQsZSksYSh0LFt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7ZT49ZFswXSYmZTw9ZFtkLmxlbmd0aC0xXSYmdGhpcy5fc2FtcGxlci50cmlnZ2VyQXR0YWNrKCgwLHAubWlkaVRvTm90ZSkoZSksdCxuKigwLHAucmFuZG9tQmV0d2VlbikoLjUsMSkpfX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihuLHIpe3QuX3NhbXBsZXI9bmV3IGguU2FtcGxlcih0Ll9zYW1wbGVzLG4sZSkuY29ubmVjdCh0Lm91dHB1dCksdC5fc2FtcGxlci5yZWxlYXNlPTF9KX19XSksdH0oZi5kZWZhdWx0KTt0LmRlZmF1bHQ9X30sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIG8oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIGkoZSx0KXtpZighZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2U6dH1mdW5jdGlvbiB1KGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIrdHlwZW9mIHQpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLHQmJihPYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsdCk6ZS5fX3Byb3RvX189dCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Ob3Rlcz12b2lkIDA7dmFyIGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7dmFyIG49W10scj0hMCxvPSExLGk9dm9pZCAwO3RyeXtmb3IodmFyIHUsYT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KHU9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHUudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChlKXtvPSEwLGk9ZX1maW5hbGx5e3RyeXshciYmYS5yZXR1cm4mJmEucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IGl9fXJldHVybiBufXJldHVybiBmdW5jdGlvbih0LG4pe2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQ7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KSlyZXR1cm4gZSh0LG4pO3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0oKSxzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCksYz1uKDApLGw9KHIoYyksbigxKSksZj1yKGwpLHA9bigzKSxoPXIocCksZD1uKDIpLF89ezE6WzhdLDI6WzYsMTJdLDM6WzEsOCwxNV0sNDpbMSw1LDEwLDE1XSw1OlsxLDQsOCwxMiwxNl0sNjpbMSwzLDcsMTAsMTMsMTZdLDc6WzEsMyw2LDksMTEsMTMsMTZdLDg6WzEsMyw1LDcsOSwxMSwxMywxNV0sOTpbMSwzLDUsNyw5LDExLDEzLDE1LDE2XSwxMDpbMSwyLDMsNSw3LDksMTEsMTMsMTUsMTZdLDExOlsxLDIsMyw1LDcsOSwxMSwxMywxNCwxNSwxNl0sMTI6WzEsMiwzLDQsNSw3LDksMTEsMTMsMTQsMTUsMTZdLDEzOlsxLDIsMyw0LDUsNyw5LDExLDEyLDEzLDE0LDE1LDE2XSwxNDpbMSwyLDMsNCw1LDYsNyw5LDExLDEyLDEzLDE0LDE1LDE2XSwxNTpbMSwyLDMsNCw1LDYsNyw5LDEwLDExLDEyLDEzLDE0LDE1LDE2XSwxNjpbMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTZdfSx5PVsyMSwyNCwyNywzMCwzMywzNiwzOSw0Miw0NSw0OCw1MSw1NCw1Nyw2MCw2Myw2Niw2OSw3Miw3NSw3OCw4MSw4NCw4Nyw5MCw5Myw5Niw5OSwxMDIsMTA1LDEwOF07dC5Ob3Rlcz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOlsyMSwxMDhdLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOjE7byh0aGlzLHQpO3ZhciByPWkodGhpcywodC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSksdT15LmZpbmRJbmRleChmdW5jdGlvbih0KXtyZXR1cm4gdD49ZVswXX0pLGE9eS5maW5kSW5kZXgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PWVbMV19KTthPS0xPT09YT9hPXkubGVuZ3RoOmErMTt2YXIgcz15LnNsaWNlKHUsYSk7cmV0dXJuIHIuX3NhbXBsZXJzPV9bbl0uc2xpY2UoKSxyLl9hY3RpdmVOb3Rlcz1uZXcgTWFwLHIuX3NhbXBsZXJzLmZvckVhY2goZnVuY3Rpb24oZSx0KXtyLl9zYW1wbGVyc1t0XT17fSxzLmZvckVhY2goZnVuY3Rpb24obil7ci5fc2FtcGxlcnNbdF1bbl09Zi5kZWZhdWx0LmdldE5vdGVzVXJsKG4sZSl9KX0pLHJ9cmV0dXJuIHUodCxlKSxzKHQsW3trZXk6XCJfaGFzTm90ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX3NhbXBsZXJzLmhhc093blByb3BlcnR5KHQpJiZ0aGlzLl9zYW1wbGVyc1t0XS5oYXMoZSl9fSx7a2V5OlwiX2dldE5vdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl9zYW1wbGVyc1t0XS5nZXQoZSl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLl9hY3RpdmVOb3Rlcy5oYXMoZSkmJih0aGlzLl9hY3RpdmVOb3Rlcy5nZXQoZSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLnN0b3AodCsxLDEpfSksdGhpcy5fYWN0aXZlTm90ZXMuZGVsZXRlKGUpKX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1uKih0aGlzLl9zYW1wbGVycy5sZW5ndGgtMSksbz1NYXRoLnJvdW5kKHIpLGk9by1yLHU9MS0uNSppOzE9PT10aGlzLl9zYW1wbGVycy5sZW5ndGgmJih1PW4pO3ZhciBzPSgwLGQubWlkaVRvRnJlcXVlbmN5UmF0aW8pKGUpLGM9YShzLDIpLGw9Y1swXSxmPWNbMV07aWYodGhpcy5faGFzTm90ZShsLG8pKXt2YXIgcD0oMCxkLmNyZWF0ZVNvdXJjZSkodGhpcy5fZ2V0Tm90ZShsLG8pKTtwLnBsYXliYWNrUmF0ZS52YWx1ZT1mLHAuY29ubmVjdCh0aGlzLm91dHB1dCkscC5jdXJ2ZT1cImV4cG9uZW50aWFsXCIscC5zdGFydCh0LDAsdm9pZCAwLHUsMCksdGhpcy5fYWN0aXZlTm90ZXMuaGFzKGUpfHx0aGlzLl9hY3RpdmVOb3Rlcy5zZXQoZSxbXSksdGhpcy5fYWN0aXZlTm90ZXMuZ2V0KGUpLnB1c2gocCl9fX0se2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49W107cmV0dXJuIHRoaXMuX3NhbXBsZXJzLmZvckVhY2goZnVuY3Rpb24ocixvKXt2YXIgaT1uZXcgUHJvbWlzZShmdW5jdGlvbihuKXt0Ll9zYW1wbGVyc1tvXT1uZXcgYy5CdWZmZXJzKHIsbixlKX0pO24ucHVzaChpKX0pLFByb21pc2UuYWxsKG4pfX1dKSx0fShoLmRlZmF1bHQpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2lmKCFlKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4hdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZTp0fWZ1bmN0aW9uIHUoZSx0KXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZudWxsIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIit0eXBlb2YgdCk7ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0JiZ0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmKE9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YoZSx0KTplLl9fcHJvdG9fXz10KX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbih0LG4scil7cmV0dXJuIG4mJmUodC5wcm90b3R5cGUsbiksciYmZSh0LHIpLHR9fSgpLHM9bigzKSxjPXIocyksbD1uKDEpLGY9KHIobCksbigyKSkscD1uKDApLGg9KHIocCksZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe28odGhpcyx0KTt2YXIgZT1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO3JldHVybiBlLl9kb3duVGltZT0xLzAsZS5fY3VycmVudFNvdW5kPW51bGwsZS5fYnVmZmVycz1udWxsLGV9cmV0dXJuIHUodCxlKSxhKHQsW3trZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obil7dC5fYnVmZmVycz1uZXcgcC5CdWZmZXJzKHt1cDpcInBlZGFsVTEubXAzXCIsZG93bjpcInBlZGFsRDEubXAzXCJ9LG4sZSl9KX19LHtrZXk6XCJfc3F1YXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fY3VycmVudFNvdW5kJiZ0aGlzLl9jdXJyZW50U291bmQuc3RvcChlKy4xLC4xKSx0aGlzLl9jdXJyZW50U291bmQ9bnVsbH19LHtrZXk6XCJfcGxheVNhbXBsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5fY3VycmVudFNvdW5kPSgwLGYuY3JlYXRlU291cmNlKSh0aGlzLl9idWZmZXJzLmdldCh0KSksdGhpcy5fY3VycmVudFNvdW5kLmN1cnZlPVwiZXhwb25lbnRpYWxcIix0aGlzLl9jdXJyZW50U291bmQuY29ubmVjdCh0aGlzLm91dHB1dCkuc3RhcnQoZSwoMCxmLnJhbmRvbUJldHdlZW4pKDAsLjAxKSx2b2lkIDAsLjUqKDAsZi5yYW5kb21CZXR3ZWVuKSguNSwxKSwuMDUpfX0se2tleTpcImRvd25cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9zcXVhc2goZSksdGhpcy5fZG93blRpbWU9ZSx0aGlzLl9wbGF5U2FtcGxlKGUsXCJkb3duXCIpfX0se2tleTpcInVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fc3F1YXNoKGUpLHRoaXMuX2Rvd25UaW1lPTEvMCx0aGlzLl9wbGF5U2FtcGxlKGUsXCJ1cFwiKX19LHtrZXk6XCJpc0Rvd25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZT50aGlzLl9kb3duVGltZX19XSksdH0oYy5kZWZhdWx0KSk7dC5kZWZhdWx0PWh9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCkscz1uKDEpLGM9cihzKSxsPW4oMyksZj1yKGwpLHA9bigyKSxoPW4oMCksZD1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe28odGhpcyx0KTt2YXIgbj1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO24uX2J1ZmZlcnM9e307Zm9yKHZhciByPWVbMF07cjw9ZVsxXTtyKyspbi5fYnVmZmVyc1tyXT1jLmRlZmF1bHQuZ2V0UmVsZWFzZXNVcmwocik7cmV0dXJuIG59cmV0dXJuIHUodCxlKSxhKHQsW3trZXk6XCJsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obil7dC5fYnVmZmVycz1uZXcgaC5CdWZmZXJzKHQuX2J1ZmZlcnMsbixlKX0pfX0se2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKHRoaXMuX2J1ZmZlcnMuaGFzKGUpKXt2YXIgcj0oMCxwLmNyZWF0ZVNvdXJjZSkodGhpcy5fYnVmZmVycy5nZXQoZSkpLmNvbm5lY3QodGhpcy5vdXRwdXQpO24qPSgwLHAucmFuZG9tQmV0d2VlbikoLjUsMSksci5zdGFydCh0LDAsdm9pZCAwLC4wMTUqbiwwKX19fV0pLHR9KGYuZGVmYXVsdCk7dC5kZWZhdWx0PWR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBvKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBpKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9ZnVuY3Rpb24gdShlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGlhbm89dm9pZCAwO3ZhciBhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gbiYmZSh0LnByb3RvdHlwZSxuKSxyJiZlKHQsciksdH19KCkscz1uKDApLGM9cihzKSxsPW4oNiksZj1yKGwpLHA9big1KSxoPW4oNCksZD1yKGgpLF89big3KSx5PXIoXyksdj1uKDEpO3IodiksdC5QaWFubz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7byh0aGlzLHQpO3ZhciBlPWMuZGVmYXVsdC5kZWZhdWx0cyhhcmd1bWVudHMsW1wicmFuZ2VcIixcInZlbG9jaXRpZXNcIl0se3ZlbG9jaXRpZXM6MSxyYW5nZTpbMjEsMTA4XSxyZWxlYXNlOiEwfSksbj1pKHRoaXMsKHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpO3JldHVybiBuLmNyZWF0ZUluc091dHMoMCwxKSxuLl9sb2FkZWQ9ITEsbi5faGVsZE5vdGVzPW5ldyBNYXAsbi5fc3VzdGFpbmVkTm90ZXM9bmV3IE1hcCxuLl9ub3Rlcz1uZXcgcC5Ob3RlcyhlLnJhbmdlLGUudmVsb2NpdGllcykuY29ubmVjdChuLm91dHB1dCksbi5fcGVkYWw9KG5ldyBmLmRlZmF1bHQpLmNvbm5lY3Qobi5vdXRwdXQpLGUucmVsZWFzZSYmKG4uX2hhcm1vbmljcz1uZXcgZC5kZWZhdWx0KGUucmFuZ2UpLmNvbm5lY3Qobi5vdXRwdXQpLG4uX3JlbGVhc2U9bmV3IHkuZGVmYXVsdChlLnJhbmdlKS5jb25uZWN0KG4ub3V0cHV0KSksbn1yZXR1cm4gdSh0LGUpLGEodCxbe2tleTpcImxvYWRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJodHRwczovL3RhbWJpZW4uZ2l0aHViLmlvL1BpYW5vL1NhbGFtYW5kZXIvXCIsbj1bdGhpcy5fbm90ZXMubG9hZCh0KSx0aGlzLl9wZWRhbC5sb2FkKHQpXTtyZXR1cm4gdGhpcy5faGFybW9uaWNzJiZuLnB1c2godGhpcy5faGFybW9uaWNzLmxvYWQodCkpLHRoaXMuX3JlbGVhc2UmJm4ucHVzaCh0aGlzLl9yZWxlYXNlLmxvYWQodCkpLFByb21pc2UuYWxsKG4pLnRoZW4oZnVuY3Rpb24oKXtlLl9sb2FkZWQ9ITB9KX19LHtrZXk6XCJwZWRhbERvd25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5sb2FkZWQmJihlPXRoaXMudG9TZWNvbmRzKGUpLHRoaXMuX3BlZGFsLmlzRG93bihlKXx8dGhpcy5fcGVkYWwuZG93bihlKSksdGhpc319LHtrZXk6XCJwZWRhbFVwXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdGhpcy5sb2FkZWQmJihlPXRoaXMudG9TZWNvbmRzKGUpLHRoaXMuX3BlZGFsLmlzRG93bihlKSYmKHRoaXMuX3BlZGFsLnVwKGUpLHRoaXMuX3N1c3RhaW5lZE5vdGVzLmZvckVhY2goZnVuY3Rpb24obixyKXt0Ll9oZWxkTm90ZXMuaGFzKHIpfHx0Ll9ub3Rlcy5zdG9wKHIsZSl9KSx0aGlzLl9zdXN0YWluZWROb3Rlcy5jbGVhcigpKSksdGhpc319LHtrZXk6XCJrZXlEb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOmMuZGVmYXVsdC5ub3coKSxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTouODtyZXR1cm4gdGhpcy5sb2FkZWQmJih0PXRoaXMudG9TZWNvbmRzKHQpLGMuZGVmYXVsdC5pc1N0cmluZyhlKSYmKGU9TWF0aC5yb3VuZCgoMCxzLkZyZXF1ZW5jeSkoZSkudG9NaWRpKCkpKSx0aGlzLl9oZWxkTm90ZXMuaGFzKGUpfHwodGhpcy5faGVsZE5vdGVzLnNldChlLHt0aW1lOnQsdmVsb2NpdHk6bn0pLHRoaXMuX25vdGVzLnN0YXJ0KGUsdCxuKSkpLHRoaXN9fSx7a2V5Olwia2V5VXBcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06Yy5kZWZhdWx0Lm5vdygpLG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOi44O2lmKHRoaXMubG9hZGVkJiYodD10aGlzLnRvU2Vjb25kcyh0KSxjLmRlZmF1bHQuaXNTdHJpbmcoZSkmJihlPU1hdGgucm91bmQoKDAscy5GcmVxdWVuY3kpKGUpLnRvTWlkaSgpKSksdGhpcy5faGVsZE5vdGVzLmhhcyhlKSkpe3ZhciByPXRoaXMuX2hlbGROb3Rlcy5nZXQoZSk7dGhpcy5faGVsZE5vdGVzLmRlbGV0ZShlKSx0aGlzLl9yZWxlYXNlJiZ0aGlzLl9yZWxlYXNlLnN0YXJ0KGUsdCxuKTt2YXIgbz10LXIudGltZSxpPXIudmVsb2NpdHksdT0uNS9NYXRoLm1heChvLC4xKStpK247dT1NYXRoLnBvdyhNYXRoLmxvZyhNYXRoLm1heCh1LDEpKSwyKS8yLHRoaXMuX3BlZGFsLmlzRG93bih0KT90aGlzLl9zdXN0YWluZWROb3Rlcy5oYXMoZSl8fHRoaXMuX3N1c3RhaW5lZE5vdGVzLnNldChlLHQpOih0aGlzLl9ub3Rlcy5zdG9wKGUsdCxuKSx0aGlzLl9oYXJtb25pY3MmJnRoaXMuX2hhcm1vbmljcy5zdGFydChlLHQsdSkpfXJldHVybiB0aGlzfX0se2tleTpcInNldFZvbHVtZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKGUpe2Nhc2VcIm5vdGVcIjp0aGlzLl9ub3Rlcy52b2x1bWU9dDticmVhaztjYXNlXCJwZWRhbFwiOnRoaXMuX3BlZGFsLnZvbHVtZT10O2JyZWFrO2Nhc2VcInJlbGVhc2VcIjp0aGlzLl9yZWxlYXNlJiYodGhpcy5fcmVsZWFzZS52b2x1bWU9dCk7YnJlYWs7Y2FzZVwiaGFybW9uaWNzXCI6dGhpcy5faGFybW9uaWNzJiYodGhpcy5faGFybW9uaWNzLnZvbHVtZT10KX1yZXR1cm4gdGhpc319LHtrZXk6XCJzdG9wQWxsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiB0aGlzLnBlZGFsVXAoKSx0aGlzLl9oZWxkTm90ZXMuZm9yRWFjaChmdW5jdGlvbih0LG4pe2Uua2V5VXAobil9KSx0aGlzfX0se2tleTpcInByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHMuQnVmZmVyLm9uKFwicHJvZ3Jlc3NcIixlKSx0aGlzfX0se2tleTpcImxvYWRlZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sb2FkZWR9fV0pLHR9KHMuQXVkaW9Ob2RlKX1dKX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGlhbm8uanMubWFwIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3Rvcnkpe1xuXG5cdC8vVU1EXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoKTtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gXHR9IGVsc2Uge1xuXHRcdHJvb3QuVG9uZSA9IGZhY3RvcnkoKTtcblx0fVxuXG59KHRoaXMsIGZ1bmN0aW9uKCl7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXHR2YXIgVG9uZTtcblx0Ly9jb25zdHJ1Y3RzIHRoZSBtYWluIFRvbmUgb2JqZWN0XG5cdGZ1bmN0aW9uIE1haW4oZnVuYyl7XG5cdFx0VG9uZSA9IGZ1bmMoKTtcblx0fVxuXHQvL2ludm9rZXMgZWFjaCBvZiB0aGUgbW9kdWxlcyB3aXRoIHRoZSBtYWluIFRvbmUgb2JqZWN0IGFzIHRoZSBhcmd1bWVudFxuXHRmdW5jdGlvbiBNb2R1bGUoZnVuYyl7XG5cdFx0ZnVuYyhUb25lKTtcblx0fVx0LyoqXG5cdCAqICBUb25lLmpzXG5cdCAqICBAYXV0aG9yIFlvdGFtIE1hbm5cblx0ICogIEBsaWNlbnNlIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQgTUlUIExpY2Vuc2Vcblx0ICogIEBjb3B5cmlnaHQgMjAxNC0yMDE3IFlvdGFtIE1hbm5cblx0ICovXG5cdE1haW4oZnVuY3Rpb24gKCkge1xuXHQgICAgXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRUT05FXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgYWxsIG90aGVyIGNsYXNzZXMuXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgdmFyIFRvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBAcmV0dXJucyB7c3RyaW5nfSByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBhcyBhIHN0cmluZ1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgY2xhc3NOYW1lIGluIFRvbmUpIHtcblx0ICAgICAgICAgICAgdmFyIGlzTGV0dGVyID0gY2xhc3NOYW1lWzBdLm1hdGNoKC9eW0EtWl0kLyk7XG5cdCAgICAgICAgICAgIHZhciBzYW1lQ29uc3RydWN0b3IgPSBUb25lW2NsYXNzTmFtZV0gPT09IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzRnVuY3Rpb24oVG9uZVtjbGFzc05hbWVdKSAmJiBpc0xldHRlciAmJiBzYW1lQ29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuICdUb25lJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIGRpc2Nvbm5lY3QgYW5kIGRpc3Bvc2Vcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0R0VUL1NFVFxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBwYXJhbWV0ZXJzIGF0IG9uY2UuIEVpdGhlciBwYXNzIGluIGFuXG5cdFx0ICogIG9iamVjdCBtYXBwaW5nIHBhcmFtZXRlcnMgdG8gdmFsdWVzLCBvciB0byBzZXQgYVxuXHRcdCAqICBzaW5nbGUgcGFyYW1ldGVyLCBieSBwYXNzaW5nIGluIGEgc3RyaW5nIGFuZCB2YWx1ZS5cblx0XHQgKiAgVGhlIGxhc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgcmFtcCB0aW1lIHdoaWNoXG5cdFx0ICogIHdpbGwgcmFtcCBhbnkgc2lnbmFsIHZhbHVlcyB0byB0aGVpciBkZXN0aW5hdGlvbiB2YWx1ZVxuXHRcdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcGFyYW1zXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmV9IHRoaXNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUjXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdmFsdWVzIHVzaW5nIGFuIG9iamVjdFxuXHRcdCAqIGZpbHRlci5zZXQoe1xuXHRcdCAqIFx0XCJmcmVxdWVuY3lcIiA6IDMwMCxcblx0XHQgKiBcdFwidHlwZVwiIDogaGlnaHBhc3Ncblx0XHQgKiB9KTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBmaWx0ZXIuc2V0KFwidHlwZVwiLCBcImhpZ2hwYXNzXCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcmFtcCB0byB0aGUgdmFsdWUgMjIwIG92ZXIgMyBzZWNvbmRzLlxuXHRcdCAqIG9zY2lsbGF0b3Iuc2V0KHtcblx0XHQgKiBcdFwiZnJlcXVlbmN5XCIgOiAyMjBcblx0XHQgKiB9LCAzKTtcblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlLCByYW1wVGltZSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KHBhcmFtcykpIHtcblx0ICAgICAgICAgICAgcmFtcFRpbWUgPSB2YWx1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcocGFyYW1zKSkge1xuXHQgICAgICAgICAgICB2YXIgdG1wT2JqID0ge307XG5cdCAgICAgICAgICAgIHRtcE9ialtwYXJhbXNdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IHRtcE9iajtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFyYW1Mb29wOlxuXHQgICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIHBhcmFtcykge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbXNbYXR0cl07XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmIChhdHRyLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clNwbGl0ID0gYXR0ci5zcGxpdCgnLicpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0clNwbGl0Lmxlbmd0aCAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbYXR0clNwbGl0W2ldXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJTcGxpdC5zcGxpY2UoMCwgaSArIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyUGFyYW0gPSBhdHRyU3BsaXQuam9pbignLicpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnNldChpbm5lclBhcmFtLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBwYXJhbUxvb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJTcGxpdFthdHRyU3BsaXQubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBwYXJlbnRbYXR0cl07XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHBhcmFtKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuU2lnbmFsICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5TaWduYWwgfHwgVG9uZS5QYXJhbSAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuUGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW0udmFsdWUgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLmlzVW5kZWYocmFtcFRpbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0ucmFtcFRvKHZhbHVlLCByYW1wVGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgQXVkaW9QYXJhbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbS52YWx1ZSAhPT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0udmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtIGluc3RhbmNlb2YgVG9uZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtLnNldCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmFtICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmVudFthdHRyXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgb2JqZWN0J3MgYXR0cmlidXRlcy4gR2l2ZW4gbm8gYXJndW1lbnRzIGdldFxuXHRcdCAqICB3aWxsIHJldHVybiBhbGwgYXZhaWxhYmxlIG9iamVjdCBwcm9wZXJ0aWVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nXG5cdFx0ICogIHZhbHVlcy4gUGFzcyBpbiBhIHNpbmdsZSBhdHRyaWJ1dGUgdG8gcmV0cmlldmUgb3IgYW4gYXJyYXlcblx0XHQgKiAgb2YgYXR0cmlidXRlcy4gVGhlIGF0dHJpYnV0ZSBzdHJpbmdzIGNhbiBhbHNvIGluY2x1ZGUgYSBcIi5cIlxuXHRcdCAqICB0byBhY2Nlc3MgZGVlcGVyIHByb3BlcnRpZXMuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIG9zYy5nZXQoKTtcblx0XHQgKiAvL3JldHVybnMge1widHlwZVwiIDogXCJzaW5lXCIsIFwiZnJlcXVlbmN5XCIgOiA0NDAsIC4uLmV0Y31cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBvc2MuZ2V0KFwidHlwZVwiKTtcblx0XHQgKiAvL3JldHVybnMgeyBcInR5cGVcIiA6IFwic2luZVwifVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy91c2UgZG90IG5vdGF0aW9uIHRvIGFjY2VzcyBkZWVwIHByb3BlcnRpZXNcblx0XHQgKiBzeW50aC5nZXQoW1wiZW52ZWxvcGUuYXR0YWNrXCIsIFwiZW52ZWxvcGUucmVsZWFzZVwiXSk7XG5cdFx0ICogLy9yZXR1cm5zIHtcImVudmVsb3BlXCIgOiB7XCJhdHRhY2tcIiA6IDAuMiwgXCJyZWxlYXNlXCIgOiAwLjR9fVxuXHRcdCAqICBAcGFyYW0ge0FycmF5PXxzdHJpbmd8dW5kZWZpbmVkfSBwYXJhbXMgdGhlIHBhcmFtZXRlcnMgdG8gZ2V0LCBvdGhlcndpc2Ugd2lsbCByZXR1cm5cblx0XHQgKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgIGFsbCBhdmFpbGFibGUuXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihwYXJhbXMpKSB7XG5cdCAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMuX2NvbGxlY3REZWZhdWx0cyh0aGlzLmNvbnN0cnVjdG9yKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNTdHJpbmcocGFyYW1zKSkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbcGFyYW1zXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJldCA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBhdHRyID0gcGFyYW1zW2ldO1xuXHQgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHN1YlJldCA9IHJldDtcblx0ICAgICAgICAgICAgaWYgKGF0dHIuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGF0dHJTcGxpdCA9IGF0dHIuc3BsaXQoJy4nKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXR0clNwbGl0Lmxlbmd0aCAtIDE7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdWJBdHRyID0gYXR0clNwbGl0W2pdO1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YlJldFtzdWJBdHRyXSA9IHN1YlJldFtzdWJBdHRyXSB8fCB7fTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJSZXQgPSBzdWJSZXRbc3ViQXR0cl07XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W3N1YkF0dHJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJTcGxpdFthdHRyU3BsaXQubGVuZ3RoIC0gMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyZW50W2F0dHJdO1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdChwYXJhbXNbYXR0cl0pKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS5nZXQoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLlNpZ25hbCAmJiBwYXJhbSBpbnN0YW5jZW9mIFRvbmUuU2lnbmFsKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLlBhcmFtICYmIHBhcmFtIGluc3RhbmNlb2YgVG9uZS5QYXJhbSkge1xuXHQgICAgICAgICAgICAgICAgc3ViUmV0W2F0dHJdID0gcGFyYW0udmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW5zdGFuY2VvZiBBdWRpb1BhcmFtKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbnN0YW5jZW9mIFRvbmUpIHtcblx0ICAgICAgICAgICAgICAgIHN1YlJldFthdHRyXSA9IHBhcmFtLmdldCgpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFUb25lLmlzRnVuY3Rpb24ocGFyYW0pICYmICFUb25lLmlzVW5kZWYocGFyYW0pKSB7XG5cdCAgICAgICAgICAgICAgICBzdWJSZXRbYXR0cl0gPSBwYXJhbTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmV0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjb2xsZWN0IGFsbCBvZiB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGluIG9uZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHIgdGhlIGNvbnN0cnVjdG9yIHRvIGZpbmQgdGhlIGRlZmF1bHRzIGZyb21cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9IGFsbCBvZiB0aGUgYXR0cmlidXRlcyB3aGljaCBiZWxvbmcgdG8gdGhlIGNsYXNzXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5fY29sbGVjdERlZmF1bHRzID0gZnVuY3Rpb24gKGNvbnN0cikge1xuXHQgICAgICAgIHZhciByZXQgPSBbXTtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihjb25zdHIuZGVmYXVsdHMpKSB7XG5cdCAgICAgICAgICAgIHJldCA9IE9iamVjdC5rZXlzKGNvbnN0ci5kZWZhdWx0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGNvbnN0ci5fc3VwZXIpKSB7XG5cdCAgICAgICAgICAgIHZhciBzdXBlckRlZnMgPSB0aGlzLl9jb2xsZWN0RGVmYXVsdHMoY29uc3RyLl9zdXBlcik7XG5cdCAgICAgICAgICAgIC8vZmlsdGVyIG91dCByZXBlYXRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VwZXJEZWZzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocmV0LmluZGV4T2Yoc3VwZXJEZWZzW2ldKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXQucHVzaChzdXBlckRlZnNbaV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXQ7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0REVGQVVMVFNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgdmFsdWVzICBUaGUgYXJndW1lbnRzIGFycmF5XG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAga2V5cyAgICBUaGUgbmFtZXMgb2YgdGhlIGFyZ3VtZW50c1xuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gY29uc3RyIFRoZSBjbGFzcyBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgQW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSAgZGVmYXVsdHMgYmV0d2VlbiB0aGUgY2xhc3MnIGRlZmF1bHRzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHBhc3NlZCBpbiBhcmd1bWVudHMuXG5cdFx0ICovXG5cdCAgICBUb25lLmRlZmF1bHRzID0gZnVuY3Rpb24gKHZhbHVlcywga2V5cywgY29uc3RyKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBUb25lLmlzT2JqZWN0KHZhbHVlc1swXSkpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHZhbHVlc1swXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5c1tpXV0gPSB2YWx1ZXNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYoY29uc3RyLmRlZmF1bHRzKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIGNvbnN0ci5kZWZhdWx0cyk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzT2JqZWN0KGNvbnN0cikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBjb25zdHIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSWYgdGhlIGBnaXZlbmAgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCwgdXNlIHRoZSBgZmFsbGJhY2tgLlxuXHRcdCAqICBJZiBib3RoIGBnaXZlbmAgYW5kIGBmYWxsYmFja2AgYXJlIG9iamVjdCBsaXRlcmFscywgaXQgd2lsbFxuXHRcdCAqICByZXR1cm4gYSBkZWVwIGNvcHkgd2hpY2ggaW5jbHVkZXMgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIGZyb20gYm90aFxuXHRcdCAqICBvYmplY3RzLiBJZiBhIHBhcmFtZXRlciBpcyB1bmRlZmluZWQgaW4gZ2l2ZW4sIGl0IHdpbGwgcmV0dXJuXG5cdFx0ICogIHRoZSBmYWxsYmFjayBwcm9wZXJ0eS5cblx0XHQgKiAgPGJyPjxicj5cblx0XHQgKiAgV0FSTklORzogaWYgb2JqZWN0IGlzIHNlbGYgcmVmZXJlbnRpYWwsIGl0IHdpbGwgZ28gaW50byBhbiBhblxuXHRcdCAqICBpbmZpbml0ZSByZWN1cnNpdmUgbG9vcC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHBhcmFtICB7Kn0gZ2l2ZW5cblx0XHQgKiAgQHBhcmFtICB7Kn0gZmFsbGJhY2tcblx0XHQgKiAgQHJldHVybiB7Kn1cblx0XHQgKi9cblx0ICAgIFRvbmUuZGVmYXVsdEFyZyA9IGZ1bmN0aW9uIChnaXZlbiwgZmFsbGJhY2spIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc09iamVjdChnaXZlbikgJiYgVG9uZS5pc09iamVjdChmYWxsYmFjaykpIHtcblx0ICAgICAgICAgICAgdmFyIHJldCA9IHt9O1xuXHQgICAgICAgICAgICAvL21ha2UgYSBkZWVwIGNvcHkgb2YgdGhlIGdpdmVuIG9iamVjdFxuXHQgICAgICAgICAgICBmb3IgKHZhciBnaXZlblByb3AgaW4gZ2l2ZW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldFtnaXZlblByb3BdID0gVG9uZS5kZWZhdWx0QXJnKGZhbGxiYWNrW2dpdmVuUHJvcF0sIGdpdmVuW2dpdmVuUHJvcF0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZvciAodmFyIGZhbGxiYWNrUHJvcCBpbiBmYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgcmV0W2ZhbGxiYWNrUHJvcF0gPSBUb25lLmRlZmF1bHRBcmcoZ2l2ZW5bZmFsbGJhY2tQcm9wXSwgZmFsbGJhY2tbZmFsbGJhY2tQcm9wXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5pc1VuZGVmKGdpdmVuKSA/IGZhbGxiYWNrIDogZ2l2ZW47XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdENPTk5FQ1RJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBjb25uZWN0IHRvZ2V0aGVyIGFsbCBvZiB0aGUgYXJndW1lbnRzIGluIHNlcmllc1xuXHRcdCAqICBAcGFyYW0gey4uLkF1ZGlvUGFyYW18VG9uZXxBdWRpb05vZGV9IG5vZGVzXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLmNvbm5lY3RTZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRVbml0ID0gYXJndW1lbnRzWzBdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB0b1VuaXQgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgICAgICAgIGN1cnJlbnRVbml0LmNvbm5lY3QodG9Vbml0KTtcblx0ICAgICAgICAgICAgY3VycmVudFVuaXQgPSB0b1VuaXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBUb25lO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gVFlQRSBDSEVDS0lOR1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgdGVzdCBpZiB0aGUgYXJnIGlzIHVuZGVmaW5lZFxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIHVuZGVmaW5lZFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzVW5kZWYgPSBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB0ZXN0IGlmIHRoZSBhcmcgaXMgYSBmdW5jdGlvblxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgZnVuY3Rpb25cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlci5cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIG51bWJlclxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzTnVtYmVyID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYW4gb2JqZWN0IGxpdGVyYWwgKGkuZS4gYHt9YCk7XG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYW4gb2JqZWN0IGxpdGVyYWwuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNPYmplY3QgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBhcmcuY29uc3RydWN0b3IgPT09IE9iamVjdDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBib29sZWFuLlxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGEgYm9vbGVhblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhbiBBcnJheVxuXHRcdCAqICBAcGFyYW0geyp9IGFyZyB0aGUgYXJndW1lbnQgdG8gdGVzdFxuXHRcdCAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXJnIGlzIGFuIGFycmF5XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpIHtcblx0ICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUZXN0IGlmIHRoZSBhcmd1bWVudCBpcyBhIHN0cmluZy5cblx0XHQgKiAgQHBhcmFtIHsqfSBhcmcgdGhlIGFyZ3VtZW50IHRvIHRlc3Rcblx0XHQgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGFyZyBpcyBhIHN0cmluZ1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmlzU3RyaW5nID0gZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGVzdCBpZiB0aGUgYXJndW1lbnQgaXMgaW4gdGhlIGZvcm0gb2YgYSBub3RlIGluIHNjaWVudGlmaWMgcGl0Y2ggbm90YXRpb24uXG5cdFx0ICogIGUuZy4gXCJDNFwiXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJnIHRoZSBhcmd1bWVudCB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBhcmcgaXMgYSBzdHJpbmdcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5pc05vdGUgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuaXNTdHJpbmcoYXJnKSAmJiAvXihbYS1nXXsxfSg/OmJ8I3x4fGJiKT8pKC0/WzAtOV0rKS9pLnRlc3QoYXJnKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQW4gZW1wdHkgZnVuY3Rpb24uXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUubm9PcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWFrZSB0aGUgcHJvcGVydHkgbm90IHdyaXRhYmxlLiBJbnRlcm5hbCB1c2Ugb25seS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7c3RyaW5nfSAgcHJvcGVydHkgIHRoZSBwcm9wZXJ0eSB0byBtYWtlIG5vdCB3cml0YWJsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuX3JlYWRPbmx5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHkpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRPbmx5KHByb3BlcnR5W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eSwge1xuXHQgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1ha2UgYW4gYXR0cmlidXRlIHdyaXRlYWJsZS4gSW50ZXJhbCB1c2Ugb25seS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7c3RyaW5nfSAgcHJvcGVydHkgIHRoZSBwcm9wZXJ0eSB0byBtYWtlIHdyaXRhYmxlXG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5fd3JpdGFibGUgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGFibGUocHJvcGVydHlbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBQb3NzaWJsZSBwbGF5IHN0YXRlcy5cblx0XHQgKiBAZW51bSB7c3RyaW5nfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGF0ZSA9IHtcblx0ICAgICAgICBTdGFydGVkOiAnc3RhcnRlZCcsXG5cdCAgICAgICAgU3RvcHBlZDogJ3N0b3BwZWQnLFxuXHQgICAgICAgIFBhdXNlZDogJ3BhdXNlZCdcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIENPTlZFUlNJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBFcXVhbCBwb3dlciBnYWluIHNjYWxlLiBHb29kIGZvciBjcm9zcy1mYWRpbmcuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSBwZXJjZW50ICgwLTEpXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn0gICAgICAgICBvdXRwdXQgZ2FpbiAoMC0xKVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLmVxdWFsUG93ZXJTY2FsZSA9IGZ1bmN0aW9uIChwZXJjZW50KSB7XG5cdCAgICAgICAgdmFyIHBpRmFjdG9yID0gMC41ICogTWF0aC5QSTtcblx0ICAgICAgICByZXR1cm4gTWF0aC5zaW4ocGVyY2VudCAqIHBpRmFjdG9yKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBkZWNpYmVscyBpbnRvIGdhaW4uXG5cdFx0ICogIEBwYXJhbSAge0RlY2liZWxzfSBkYlxuXHRcdCAqICBAcmV0dXJuIHtOdW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuZGJUb0dhaW4gPSBmdW5jdGlvbiAoZGIpIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgZGIgLyA2KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBnYWluIHRvIGRlY2liZWxzLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9IGdhaW4gKDAtMSlcblx0XHQgKiAgQHJldHVybiB7RGVjaWJlbHN9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIFRvbmUuZ2FpblRvRGIgPSBmdW5jdGlvbiAoZ2Fpbikge1xuXHQgICAgICAgIHJldHVybiAyMCAqIChNYXRoLmxvZyhnYWluKSAvIE1hdGguTE4xMCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYW4gaW50ZXJ2YWwgKGluIHNlbWl0b25lcykgdG8gYSBmcmVxdWVuY3kgcmF0aW8uXG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsfSBpbnRlcnZhbCB0aGUgbnVtYmVyIG9mIHNlbWl0b25lcyBhYm92ZSB0aGUgYmFzZSBub3RlXG5cdFx0ICogIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgdGhlIGZyZXF1ZW5jeSByYXRpb1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oMCk7IC8vIDFcblx0XHQgKiB0b25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygxMik7IC8vIDJcblx0XHQgKiB0b25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbygtMTIpOyAvLyAwLjVcblx0XHQgKi9cblx0ICAgIFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIGludGVydmFsIC8gMTIpO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRJTUlOR1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIEF1ZGlvQ29udGV4dCBjbG9jay5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSB0aGUgY3VycmVudFRpbWUgZnJvbSB0aGUgQXVkaW9Db250ZXh0XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBUb25lLmNvbnRleHQubm93KCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgY3VycmVudCB0aW1lIG9mIHRoZSBBdWRpb0NvbnRleHQgY2xvY2suXG5cdFx0ICogIEByZXR1cm4ge051bWJlcn0gdGhlIGN1cnJlbnRUaW1lIGZyb20gdGhlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICovXG5cdCAgICBUb25lLm5vdyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gVG9uZS5jb250ZXh0Lm5vdygpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEFkZHMgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiB0aGUgc2NoZWR1bGVkIHRpbWUgaGFzIHBhc3NlZC5cblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuaXNQYXN0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGltZSA8IFRvbmUuY29udGV4dC5jdXJyZW50VGltZSkge1xuXHQgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RpbWUgXFwnJyArIHRpbWUgKyAnXFwnIGlzIGluIHRoZSBwYXN0LiBTY2hlZHVsZWQgdGltZSBtdXN0IGJlIFxcdTIyNjUgQXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdElOSEVSSVRBTkNFXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBoYXZlIGEgY2hpbGQgaW5oZXJpdCBhbGwgb2YgVG9uZSdzIChvciBhIHBhcmVudCdzKSBwcm90b3R5cGVcblx0XHQgKiAgdG8gaW5oZXJpdCB0aGUgcGFyZW50J3MgcHJvcGVydGllcywgbWFrZSBzdXJlIHRvIGNhbGxcblx0XHQgKiAgUGFyZW50LmNhbGwodGhpcykgaW4gdGhlIGNoaWxkJ3MgY29uc3RydWN0b3Jcblx0XHQgKlxuXHRcdCAqICBiYXNlZCBvbiBjbG9zdXJlIGxpYnJhcnkncyBpbmhlcml0IGZ1bmN0aW9uXG5cdFx0ICpcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcGFyYW0gIHtmdW5jdGlvbn0gXHRjaGlsZFxuXHRcdCAqICBAcGFyYW0gIHtmdW5jdGlvbj19IHBhcmVudCAob3B0aW9uYWwpIHBhcmVudCB0byBpbmhlcml0IGZyb21cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm8gcGFyZW50IGlzIHN1cHBsaWVkLCB0aGUgY2hpbGRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBpbmhlcml0IGZyb20gVG9uZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5leHRlbmQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYocGFyZW50KSkge1xuXHQgICAgICAgICAgICBwYXJlbnQgPSBUb25lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBUZW1wQ29uc3RydWN0b3IoKSB7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRlbXBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuXHQgICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBUZW1wQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICAvKiogQG92ZXJyaWRlICovXG5cdCAgICAgICAgY2hpbGQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG5cdCAgICAgICAgY2hpbGQuX3N1cGVyID0gcGFyZW50O1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdENPTlRFWFRcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEEgc3RhdGljIHBvaW50ZXIgdG8gdGhlIGF1ZGlvIGNvbnRleHQgYWNjZXNzaWJsZSBhcyBUb25lLmNvbnRleHQuXG5cdFx0ICogIEB0eXBlIHtUb25lLkNvbnRleHR9XG5cdFx0ICogIEBuYW1lIGNvbnRleHRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnY29udGV4dCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5UT05FX0FVRElPX0NPTlRFWFQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLkNvbnRleHQgJiYgY29udGV4dCBpbnN0YW5jZW9mIFRvbmUuQ29udGV4dCkge1xuXHQgICAgICAgICAgICAgICAgd2luZG93LlRPTkVfQVVESU9fQ09OVEVYVCA9IGNvbnRleHQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3aW5kb3cuVE9ORV9BVURJT19DT05URVhUID0gbmV3IFRvbmUuQ29udGV4dChjb250ZXh0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIG5ldyBhdWRpbyBjb250ZXh0XG5cdCAgICAgICAgICAgIFRvbmUuQ29udGV4dC5lbWl0KCdpbml0Jywgd2luZG93LlRPTkVfQVVESU9fQ09OVEVYVCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAdHlwZSB7VG9uZS5Db250ZXh0fVxuXHRcdCAqICBAbmFtZSBjb250ZXh0XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lI1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ2NvbnRleHQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmNvbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVG9uZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgYSBjb250ZXh0IG9uIGluaXQsIGJ1dCBpZiB5b3UgYXJlIHdvcmtpbmdcblx0XHQgKiAgd2l0aCBvdGhlciBsaWJyYXJpZXMgd2hpY2ggYWxzbyBjcmVhdGUgYW4gQXVkaW9Db250ZXh0LCBpdCBjYW4gYmVcblx0XHQgKiAgdXNlZnVsIHRvIHNldCB5b3VyIG93bi4gSWYgeW91IGFyZSBnb2luZyB0byBzZXQgeW91ciBvd24gY29udGV4dCxcblx0XHQgKiAgYmUgc3VyZSB0byBkbyBpdCBhdCB0aGUgc3RhcnQgb2YgeW91ciBjb2RlLCBiZWZvcmUgY3JlYXRpbmcgYW55IG9iamVjdHMuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHBhcmFtIHtBdWRpb0NvbnRleHR9IGN0eCBUaGUgbmV3IGF1ZGlvIGNvbnRleHQgdG8gc2V0XG5cdFx0ICovXG5cdCAgICBUb25lLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY3R4KSB7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gY3R4O1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFUVFJJQlVURVNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiAxIHByb2Nlc3NpbmcgYmxvY2sgKDEyOCBzYW1wbGVzKVxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSBibG9ja1RpbWVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ2Jsb2NrVGltZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDEyOCAvIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkdXJhdGlvbiBpbiBzZWNvbmRzIG9mIG9uZSBzYW1wbGUuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIHNhbXBsZVRpbWVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLnByb3RvdHlwZSwgJ3NhbXBsZVRpbWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxIC8gdGhpcy5jb250ZXh0LnNhbXBsZVJhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgV2hldGhlciBvciBub3QgYWxsIHRoZSB0ZWNobm9sb2dpZXMgdGhhdCBUb25lLmpzIHJlbGllcyBvbiBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqICBAbmFtZSBzdXBwb3J0ZWRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmVcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnc3VwcG9ydGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaGFzQXVkaW9Db250ZXh0ID0gd2luZG93Lmhhc093blByb3BlcnR5KCdBdWRpb0NvbnRleHQnKSB8fCB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdEF1ZGlvQ29udGV4dCcpO1xuXHQgICAgICAgICAgICB2YXIgaGFzUHJvbWlzZXMgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1Byb21pc2UnKTtcblx0ICAgICAgICAgICAgdmFyIGhhc1dvcmtlcnMgPSB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ1dvcmtlcicpO1xuXHQgICAgICAgICAgICByZXR1cm4gaGFzQXVkaW9Db250ZXh0ICYmIGhhc1Byb21pc2VzICYmIGhhc1dvcmtlcnM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQm9vbGVhbiB2YWx1ZSBpZiB0aGUgYXVkaW8gY29udGV4dCBoYXMgYmVlbiBpbml0aWFsaXplZC5cblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQG5hbWUgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLCAnaW5pdGlhbGl6ZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAhVG9uZS5pc1VuZGVmKHdpbmRvdy5UT05FX0FVRElPX0NPTlRFWFQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgY29udGV4dCB3aGVuIGl0IGJlY29tZXMgYXZhaWxhYmxlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgcmVzb2x2ZSAgQ2FsbGJhY2sgd2hlbiB0aGUgY29udGV4dCBpcyBpbml0aWFsaXplZFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaW5pdGlhbGl6ZWQpIHtcblx0ICAgICAgICAgICAgcmVzb2x2ZShUb25lLmNvbnRleHQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciByZXNDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJlc29sdmUoVG9uZS5jb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgIFRvbmUuQ29udGV4dC5vZmYoJ2luaXQnLCByZXNDYWxsYmFjayk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFRvbmUuQ29udGV4dC5vbignaW5pdCcsIHJlc0NhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFRvbmU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHZlcnNpb24gbnVtYmVyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAc3RhdGljXG5cdFx0ICovXG5cdCAgICBUb25lLnZlcnNpb24gPSAncjEyLWRldic7XG5cdCAgICByZXR1cm4gVG9uZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRW1pdHRlciBnaXZlcyBjbGFzc2VzIHdoaWNoIGV4dGVuZCBpdFxuXHRcdCAqICAgICAgICAgdGhlIGFiaWxpdHkgdG8gbGlzdGVuIGZvciBhbmQgZW1pdCBldmVudHMuIFxuXHRcdCAqICAgICAgICAgSW5zcGlyYXRpb24gYW5kIHJlZmVyZW5jZSBmcm9tIEplcm9tZSBFdGllbm5lJ3MgW01pY3JvRXZlbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJvbWVldGllbm5lL21pY3JvZXZlbnQuanMpLlxuXHRcdCAqICAgICAgICAgTUlUIChjKSAyMDExIEplcm9tZSBFdGllbm5lLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDb250YWlucyBhbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBCaW5kIGEgY2FsbGJhY2sgdG8gYSBzcGVjaWZpYyBldmVudC5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgICBldmVudCAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgZW1pdHRlZFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vc3BsaXQgdGhlIGV2ZW50XG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IGV2ZW50LnNwbGl0KC9cXFcrLyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXIuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgZXZlbnQgICAgIFRoZSBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB3aGljaCB3YXMgYm91bmQgdG8gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudCB3aXRoIFRvbmUuRW1pdHRlci5vbi5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgZ2l2ZW4sIGFsbCBjYWxsYmFja3Ncblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzIGFyZSByZW1vdmVkLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB2YXIgZXZlbnRzID0gZXZlbnQuc3BsaXQoL1xcVysvKTtcblx0ICAgICAgICBmb3IgKHZhciBldiA9IDA7IGV2IDwgZXZlbnRzLmxlbmd0aDsgZXYrKykge1xuXHQgICAgICAgICAgICBldmVudCA9IGV2ZW50c1tldl07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKGNhbGxiYWNrKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TGlzdCA9IHRoaXMuX2V2ZW50c1tldmVudF07XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TGlzdFtpXSA9PT0gY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdC5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludm9rZSBhbGwgb2YgdGhlIGNhbGxiYWNrcyBib3VuZCB0byB0aGUgZXZlbnRcblx0XHQgKiAgd2l0aCBhbnkgYXJndW1lbnRzIHBhc3NlZCBpbi4gXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGV2ZW50ICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSB7Kn0gYXJncy4uLiBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9ucyBsaXN0ZW5pbmcuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkVtaXR0ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRzKSB7XG5cdCAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2ZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdFtpXS5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIEVtaXR0ZXIgZnVuY3Rpb25zIChvbi9vZmYvZW1pdCkgdG8gdGhlIG9iamVjdFxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R8RnVuY3Rpb259ICBvYmplY3QgIFRoZSBvYmplY3Qgb3IgY2xhc3MgdG8gZXh0ZW5kLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLm1peGluID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXHQgICAgICAgIHZhciBmdW5jdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICdvbicsXG5cdCAgICAgICAgICAgICdvZmYnLFxuXHQgICAgICAgICAgICAnZW1pdCdcblx0ICAgICAgICBdO1xuXHQgICAgICAgIG9iamVjdC5fZXZlbnRzID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbnNbaV07XG5cdCAgICAgICAgICAgIHZhciBlbWl0dGVyRnVuYyA9IFRvbmUuRW1pdHRlci5wcm90b3R5cGVbZnVuY107XG5cdCAgICAgICAgICAgIG9iamVjdFtmdW5jXSA9IGVtaXR0ZXJGdW5jO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gVG9uZS5FbWl0dGVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FbWl0dGVyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVtaXR0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIFRpbWVsaW5lIGNsYXNzIGZvciBzY2hlZHVsaW5nIGFuZCBtYWludGFpbmluZyBzdGF0ZVxuXHRcdCAqICAgICAgICAgYWxvbmcgYSB0aW1lbGluZS4gQWxsIGV2ZW50cyBtdXN0IGhhdmUgYSBcInRpbWVcIiBwcm9wZXJ0eS5cblx0XHQgKiAgICAgICAgIEludGVybmFsbHksIGV2ZW50cyBhcmUgc3RvcmVkIGluIHRpbWUgb3JkZXIgZm9yIGZhc3Rcblx0XHQgKiAgICAgICAgIHJldHJpZXZhbC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IFttZW1vcnk9SW5maW5pdHldIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgZXZlbnRzIHRoYXQgYXJlIHJldGFpbmVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ21lbW9yeSddLCBUb25lLlRpbWVsaW5lKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIHNjaGVkdWxlZCB0aW1lbGluZSBldmVudHNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90aW1lbGluZSA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuIGFycmF5IG9mIGl0ZW1zIHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdG9SZW1vdmUgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbiBhcnJheSBvZiBpdGVtcyB0byBhZGQgZnJvbSB0aGUgbGlzdCAob25jZSBpdCdzIGRvbmUgaXRlcmF0aW5nKVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdG9BZGQgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBGbGFnIGlmIHRoZSB0aW1lbGluZSBpcyBtaWQgaXRlcmF0aW9uXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGluZyA9IGZhbHNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtZW1vcnkgb2YgdGhlIHRpbWVsaW5lLCBpLmUuXG5cdFx0XHQgKiAgaG93IG1hbnkgZXZlbnRzIGluIHRoZSBwYXN0IGl0IHdpbGwgcmV0YWluXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tZW1vcnkgPSBvcHRpb25zLm1lbW9yeTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLmRlZmF1bHRzID0geyAnbWVtb3J5JzogSW5maW5pdHkgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVGltZWxpbmUjXG5cdFx0ICogIEBuYW1lIGxlbmd0aFxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpbWVsaW5lLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnNlcnQgYW4gZXZlbnQgb2JqZWN0IG9udG8gdGhlIHRpbWVsaW5lLiBFdmVudHMgbXVzdCBoYXZlIGEgXCJ0aW1lXCIgYXR0cmlidXRlLlxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdCB0byBpbnNlcnQgaW50byB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgLy90aGUgZXZlbnQgbmVlZHMgdG8gaGF2ZSBhIHRpbWUgYXR0cmlidXRlXG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihldmVudC50aW1lKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuVGltZWxpbmU6IGV2ZW50cyBtdXN0IGhhdmUgYSB0aW1lIGF0dHJpYnV0ZScpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5faXRlcmF0aW5nKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RvQWRkLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaChldmVudC50aW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4ICsgMSwgMCwgZXZlbnQpO1xuXHQgICAgICAgICAgICAvL2lmIHRoZSBsZW5ndGggaXMgbW9yZSB0aGFuIHRoZSBtZW1vcnksIHJlbW92ZSB0aGUgcHJldmlvdXMgb25lc1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLm1lbW9yeSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLmxlbmd0aCAtIHRoaXMubWVtb3J5O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKDAsIGRpZmYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0IHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2l0ZXJhdGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl90b1JlbW92ZS5wdXNoKGV2ZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lbGluZS5pbmRleE9mKGV2ZW50KTtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBuZWFyZXN0IGV2ZW50IHdob3NlIHRpbWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgY29tcGFyYXRvciBXaGljaCB2YWx1ZSBpbiB0aGUgb2JqZWN0IHRvIGNvbXBhcmVcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBzZXQgYWZ0ZXIgdGhhdCB0aW1lLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRpbWUsIGNvbXBhcmF0b3IpIHtcblx0ICAgICAgICBjb21wYXJhdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcmF0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUsIGNvbXBhcmF0b3IpO1xuXHQgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4XTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIHdpdGhvdXQgcmVtb3ZpbmcgaXRcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGZpcnN0IGV2ZW50IG9iamVjdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbMF07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZmlyc3QgZXZlbnQgaW4gdGhlIHRpbWVsaW5lIGFuZCByZW1vdmUgaXRcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGZpcnN0IGV2ZW50IG9iamVjdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lLnNoaWZ0KCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgZXZlbnQgd2hpY2ggaXMgc2NoZWR1bGVkIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgY29tcGFyYXRvciBXaGljaCB2YWx1ZSBpbiB0aGUgb2JqZWN0IHRvIGNvbXBhcmVcblx0XHQgKiAgQHJldHVybnMge09iamVjdH0gVGhlIGV2ZW50IG9iamVjdCBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZ2V0QWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY29tcGFyYXRvcikge1xuXHQgICAgICAgIGNvbXBhcmF0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyYXRvciwgJ3RpbWUnKTtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9zZWFyY2godGltZSwgY29tcGFyYXRvcik7XG5cdCAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX3RpbWVsaW5lLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbaW5kZXggKyAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgZXZlbnQgYmVmb3JlIHRoZSBldmVudCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcmF0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBldmVudCBvYmplY3QgYmVmb3JlIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5nZXRCZWZvcmUgPSBmdW5jdGlvbiAodGltZSwgY29tcGFyYXRvcikge1xuXHQgICAgICAgIGNvbXBhcmF0b3IgPSBUb25lLmRlZmF1bHRBcmcoY29tcGFyYXRvciwgJ3RpbWUnKTtcblx0ICAgICAgICB2YXIgbGVuID0gdGhpcy5fdGltZWxpbmUubGVuZ3RoO1xuXHQgICAgICAgIC8vaWYgaXQncyBhZnRlciB0aGUgbGFzdCBpdGVtLCByZXR1cm4gdGhlIGxhc3QgaXRlbVxuXHQgICAgICAgIGlmIChsZW4gPiAwICYmIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdW2NvbXBhcmF0b3JdIDwgdGltZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVbbGVuIC0gMV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3NlYXJjaCh0aW1lLCBjb21wYXJhdG9yKTtcblx0ICAgICAgICBpZiAoaW5kZXggLSAxID49IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVsaW5lW2luZGV4IC0gMV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWwgZXZlbnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKGFmdGVyKTtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVtpbmRleF0udGltZSA9PT0gYWZ0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZmlyc3QgaXRlbSB3aXRoIHRoYXQgdGltZVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lW2ldLnRpbWUgPT09IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRoaXMuX3RpbWVsaW5lLnNsaWNlKDAsIGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSB0aGlzLl90aW1lbGluZS5zbGljZSgwLCBpbmRleCArIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGltZWxpbmUubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgIC8vdGhlIGZpcnN0IGl0ZW0ncyB0aW1lXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90aW1lbGluZVswXS50aW1lID49IGFmdGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl90aW1lbGluZSA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWwgZXZlbnRzIGJlZm9yZSBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gY2FuY2VsIGJlZm9yZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmNhbmNlbEJlZm9yZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gdGhpcy5fdGltZWxpbmUuc2xpY2UoaW5kZXggKyAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcHJldmlvdXMgZXZlbnQgaWYgdGhlcmUgaXMgb25lLiBudWxsIG90aGVyd2lzZVxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IHRvIGZpbmQgdGhlIHByZXZpb3VzIG9uZSBvZlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gICAgICAgVGhlIGV2ZW50IHJpZ2h0IGJlZm9yZSB0aGUgZ2l2ZW4gZXZlbnRcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLnByZXZpb3VzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl90aW1lbGluZS5pbmRleE9mKGV2ZW50KTtcblx0ICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZVtpbmRleCAtIDFdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG9lcyBhIGJpbmFyeSBzZWFyY2ggb24gdGhlIHRpbWVsaW5lIGFycmF5IGFuZCByZXR1cm5zIHRoZVxuXHRcdCAqICBuZWFyZXN0IGV2ZW50IGluZGV4IHdob3NlIHRpbWUgaXMgYWZ0ZXIgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIElmIGEgdGltZSBpcyBzZWFyY2hlZCBiZWZvcmUgdGhlIGZpcnN0IGluZGV4IGluIHRoZSB0aW1lbGluZSwgLTEgaXMgcmV0dXJuZWQuXG5cdFx0ICogIElmIHRoZSB0aW1lIGlzIGFmdGVyIHRoZSBlbmQsIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtIGlzIHJldHVybmVkLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGNvbXBhcmF0b3IgV2hpY2ggdmFsdWUgaW4gdGhlIG9iamVjdCB0byBjb21wYXJlXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9IHRoZSBpbmRleCBpbiB0aGUgdGltZWxpbmUgYXJyYXlcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9zZWFyY2ggPSBmdW5jdGlvbiAodGltZSwgY29tcGFyYXRvcikge1xuXHQgICAgICAgIGlmICh0aGlzLl90aW1lbGluZS5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb21wYXJhdG9yID0gVG9uZS5kZWZhdWx0QXJnKGNvbXBhcmF0b3IsICd0aW1lJyk7XG5cdCAgICAgICAgdmFyIGJlZ2lubmluZyA9IDA7XG5cdCAgICAgICAgdmFyIGxlbiA9IHRoaXMuX3RpbWVsaW5lLmxlbmd0aDtcblx0ICAgICAgICB2YXIgZW5kID0gbGVuO1xuXHQgICAgICAgIGlmIChsZW4gPiAwICYmIHRoaXMuX3RpbWVsaW5lW2xlbiAtIDFdW2NvbXBhcmF0b3JdIDw9IHRpbWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxlbiAtIDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHdoaWxlIChiZWdpbm5pbmcgPCBlbmQpIHtcblx0ICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtaWRwb2ludCBmb3Igcm91Z2hseSBlcXVhbCBwYXJ0aXRpb25cblx0ICAgICAgICAgICAgdmFyIG1pZFBvaW50ID0gTWF0aC5mbG9vcihiZWdpbm5pbmcgKyAoZW5kIC0gYmVnaW5uaW5nKSAvIDIpO1xuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludF07XG5cdCAgICAgICAgICAgIHZhciBuZXh0RXZlbnQgPSB0aGlzLl90aW1lbGluZVttaWRQb2ludCArIDFdO1xuXHQgICAgICAgICAgICBpZiAoZXZlbnRbY29tcGFyYXRvcl0gPT09IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vY2hvb3NlIHRoZSBsYXN0IG9uZSB0aGF0IGhhcyB0aGUgc2FtZSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWlkUG9pbnQ7IGkgPCB0aGlzLl90aW1lbGluZS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0RXZlbnQgPSB0aGlzLl90aW1lbGluZVtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGVzdEV2ZW50W2NvbXBhcmF0b3JdID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1pZFBvaW50ID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWlkUG9pbnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRbY29tcGFyYXRvcl0gPCB0aW1lICYmIG5leHRFdmVudFtjb21wYXJhdG9yXSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtaWRQb2ludDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudFtjb21wYXJhdG9yXSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vc2VhcmNoIGxvd2VyXG5cdCAgICAgICAgICAgICAgICBlbmQgPSBtaWRQb2ludDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vc2VhcmNoIHVwcGVyXG5cdCAgICAgICAgICAgICAgICBiZWdpbm5pbmcgPSBtaWRQb2ludCArIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBpdGVyYXRvci4gQXBwbGllcyBleHRyYSBzYWZldHkgY2hlY2tzIGZvclxuXHRcdCAqICByZW1vdmluZyBpdGVtcyBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFja1xuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXI9fSAgICBsb3dlckJvdW5kXG5cdFx0ICogIEBwYXJhbSAge051bWJlcj19ICAgIHVwcGVyQm91bmRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLl9pdGVyYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG5cdCAgICAgICAgdGhpcy5faXRlcmF0aW5nID0gdHJ1ZTtcblx0ICAgICAgICBsb3dlckJvdW5kID0gVG9uZS5kZWZhdWx0QXJnKGxvd2VyQm91bmQsIDApO1xuXHQgICAgICAgIHVwcGVyQm91bmQgPSBUb25lLmRlZmF1bHRBcmcodXBwZXJCb3VuZCwgdGhpcy5fdGltZWxpbmUubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IGxvd2VyQm91bmQ7IGkgPD0gdXBwZXJCb3VuZDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdGltZWxpbmVbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9pdGVyYXRpbmcgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl90b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICB0aGlzLnJlbW92ZShldmVudCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl90b1JlbW92ZSA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3RvQWRkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKGV2ZW50KTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX3RvQWRkID0gW107XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdGhpcy5faXRlcmF0ZShjYWxsYmFjayk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEl0ZXJhdGUgb3ZlciBldmVyeXRoaW5nIGluIHRoZSBhcnJheSBhdCBvciBiZWZvcmUgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQmVmb3JlID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIHVwcGVyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKHVwcGVyQm91bmQgIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIDAsIHVwcGVyQm91bmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBiZWZvcmVcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZXZlcnkgaXRlbVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEFmdGVyID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIGxvd2VyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgdGhpcy5faXRlcmF0ZShjYWxsYmFjaywgbG93ZXJCb3VuZCArIDEpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgYXJyYXkgYXQgb3IgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuIFNpbWlsYXIgdG9cblx0XHQgKiAgZm9yRWFjaEFmdGVyLCBidXQgaW5jbHVkZXMgdGhlIGl0ZW0ocykgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoRnJvbSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIC8vaXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBpbiByZXZlcnNlIHNvIHRoYXQgcmVtb3ZpbmcgYW4gaXRlbSBkb2Vzbid0IGJyZWFrIHRoaW5nc1xuXHQgICAgICAgIHZhciBsb3dlckJvdW5kID0gdGhpcy5fc2VhcmNoKHRpbWUpO1xuXHQgICAgICAgIC8vd29yayBiYWNrd2FyZHMgdW50aWwgdGhlIGV2ZW50IHRpbWUgaXMgbGVzcyB0aGFuIHRpbWVcblx0ICAgICAgICB3aGlsZSAobG93ZXJCb3VuZCA+PSAwICYmIHRoaXMuX3RpbWVsaW5lW2xvd2VyQm91bmRdLnRpbWUgPj0gdGltZSkge1xuXHQgICAgICAgICAgICBsb3dlckJvdW5kLS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2l0ZXJhdGUoY2FsbGJhY2ssIGxvd2VyQm91bmQgKyAxKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgVGhlIHRpbWUgdG8gY2hlY2sgaWYgaXRlbXMgYXJlIGJlZm9yZVxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgLy9pdGVyYXRlIG92ZXIgdGhlIGl0ZW1zIGluIHJldmVyc2Ugc28gdGhhdCByZW1vdmluZyBhbiBpdGVtIGRvZXNuJ3QgYnJlYWsgdGhpbmdzXG5cdCAgICAgICAgdmFyIHVwcGVyQm91bmQgPSB0aGlzLl9zZWFyY2godGltZSk7XG5cdCAgICAgICAgaWYgKHVwcGVyQm91bmQgIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2l0ZXJhdGUoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGltZSA9PT0gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCAwLCB1cHBlckJvdW5kKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90b1JlbW92ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdG9BZGQgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKCF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ0F1ZGlvQ29udGV4dCcpICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnd2Via2l0QXVkaW9Db250ZXh0JykpIHtcblx0ICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgV3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBBdWRpb0NvbnRleHQuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVtaXR0ZXJ9XG5cdFx0ICogIEBwYXJhbSB7QXVkaW9Db250ZXh0PX0gY29udGV4dCBvcHRpb25hbGx5IHBhc3MgaW4gYSBjb250ZXh0XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydjb250ZXh0J10sIFRvbmUuQ29udGV4dCk7XG5cdCAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRleHQpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5jb250ZXh0ID0gbmV3IHdpbmRvdy5BdWRpb0NvbnRleHQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcblx0ICAgICAgICAvLyBleHRlbmQgYWxsIG9mIHRoZSBtZXRob2RzXG5cdCAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9jb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlZmluZVByb3BlcnR5KHRoaXMuX2NvbnRleHQsIHByb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVmYXVsdCBsYXRlbmN5IGhpbnRcblx0XHRcdCAqICBAdHlwZSAge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGF0ZW5jeUhpbnQgPSBvcHRpb25zLmxhdGVuY3lIaW50O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgY29uc3RhbnRzIEF1ZGlvQnVmZmVyU291cmNlTm9kZXNcblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvLyBXT1JLRVJcblx0ICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgdGltZSBldmVudHMgYXJlIHNjaGVkdWxlZFxuXHRcdFx0ICogIGludG8gdGhlIGZ1dHVyZVxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IG9wdGlvbnMubG9va0FoZWFkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgcmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgY29tcHV0ZWQgdXBkYXRlIGludGVydmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbXB1dGVkVXBkYXRlSW50ZXJ2YWwgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgcmVsaWFibGUgY2FsbGJhY2sgbWV0aG9kXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSAge1RpY2tlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpY2tlciA9IG5ldyBUaWNrZXIodGhpcy5lbWl0LmJpbmQodGhpcywgJ3RpY2snKSwgb3B0aW9ucy5jbG9ja1NvdXJjZSwgb3B0aW9ucy51cGRhdGVJbnRlcnZhbCk7XG5cdCAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAvLyBUSU1FT1VUU1xuXHQgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWxsIG9mIHRoZSBzZXRUaW1lb3V0IGV2ZW50cy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRzID0gbmV3IFRvbmUuVGltZWxpbmUoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdGltZW91dCBpZCBjb3VudGVyXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGltZW91dElkcyA9IDA7XG5cdCAgICAgICAgdGhpcy5vbigndGljaycsIHRoaXMuX3RpbWVvdXRMb29wLmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ29udGV4dCwgVG9uZS5FbWl0dGVyKTtcblx0ICAgIFRvbmUuRW1pdHRlci5taXhpbihUb25lLkNvbnRleHQpO1xuXHQgICAgLyoqXG5cdFx0ICogZGVmYXVsdHNcblx0XHQgKiBAc3RhdGljXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnY2xvY2tTb3VyY2UnOiAnd29ya2VyJyxcblx0ICAgICAgICAnbGF0ZW5jeUhpbnQnOiAnaW50ZXJhY3RpdmUnLFxuXHQgICAgICAgICdsb29rQWhlYWQnOiAwLjEsXG5cdCAgICAgICAgJ3VwZGF0ZUludGVydmFsJzogMC4wM1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGlzIFRvbmUuQ29udGV4dC5cblx0XHQgKiAgVGhpcyBpcyB1c2VkIHRvIGV4dGVuZCB0aGUgbmF0aXZlIEF1ZGlvQ29udGV4dFxuXHRcdCAqICBAcGFyYW0gIHtBdWRpb0NvbnRleHR9ICBjb250ZXh0XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3Bcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUuX2RlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHByb3ApIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHRoaXNbcHJvcF0pKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wLCB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHRbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbcHJvcF0uYmluZChjb250ZXh0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dFtwcm9wXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dFtwcm9wXSA9IHZhbDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBhdWRpbyBjb250ZXh0IHRpbWVcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udGV4dC5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rQWhlYWQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlIGEgbG9vcGVkIGJ1ZmZlciBhdCBzb21lIGNvbnN0YW50IHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB2YWxcblx0XHQgKiAgQHJldHVybiAge0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLmdldENvbnN0YW50ID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9jb25zdGFudHNbdmFsXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RhbnRzW3ZhbF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEyOCwgdGhpcy5fY29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICAgICAgdmFyIGFyciA9IGJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGFycltpXSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgY29uc3RhbnQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHQgICAgICAgICAgICBjb25zdGFudC5jaGFubmVsQ291bnQgPSAxO1xuXHQgICAgICAgICAgICBjb25zdGFudC5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAgICAgY29uc3RhbnQuYnVmZmVyID0gYnVmZmVyO1xuXHQgICAgICAgICAgICBjb25zdGFudC5sb29wID0gdHJ1ZTtcblx0ICAgICAgICAgICAgY29uc3RhbnQuc3RhcnQoMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnN0YW50c1t2YWxdID0gY29uc3RhbnQ7XG5cdCAgICAgICAgICAgIHJldHVybiBjb25zdGFudDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwcml2YXRlIGxvb3Agd2hpY2gga2VlcHMgdHJhY2sgb2YgdGhlIGNvbnRleHQgc2NoZWR1bGVkIHRpbWVvdXRzXG5cdFx0ICogIElzIGludm9rZWQgZnJvbSB0aGUgY2xvY2sgc291cmNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLl90aW1lb3V0TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5fdGltZW91dHMgJiYgdGhpcy5fdGltZW91dHMubGVuZ3RoICYmIHRoaXMuX3RpbWVvdXRzLnBlZWsoKS50aW1lIDw9IG5vdykge1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lb3V0cy5zaGlmdCgpLmNhbGxiYWNrKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIHNldFRpbWVvdXQgd2hpY2ggaXMgZ2F1cmVudGVlZCBieSB0aGUgY2xvY2sgc291cmNlLlxuXHRcdCAqICBBbHNvIHJ1bnMgaW4gdGhlIG9mZmxpbmUgY29udGV4dC5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBmbiAgICAgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlXG5cdFx0ICogIEBwYXJhbSAge1NlY29uZHN9ICAgIHRpbWVvdXQgIFRoZSB0aW1lb3V0IGluIHNlY29uZHNcblx0XHQgKiAgQHJldHVybnMge051bWJlcn0gSUQgdG8gdXNlIHdoZW4gaW52b2tpbmcgVG9uZS5Db250ZXh0LmNsZWFyVGltZW91dFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGZuLCB0aW1lb3V0KSB7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dElkcysrO1xuXHQgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRzLmFkZCh7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiBmbixcblx0ICAgICAgICAgICAgdGltZTogbm93ICsgdGltZW91dCxcblx0ICAgICAgICAgICAgaWQ6IHRoaXMuX3RpbWVvdXRJZHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dElkcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYXJzIGEgcHJldmlvdXNseSBzY2hlZHVsZWQgdGltZW91dCB3aXRoIFRvbmUuY29udGV4dC5zZXRUaW1lb3V0XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIGlkICBUaGUgSUQgcmV0dXJuZWQgZnJvbSBzZXRUaW1lb3V0XG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkNvbnRleHR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnRleHQucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChpZCkge1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5pZCA9PT0gaWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV2ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBIb3cgb2Z0ZW4gdGhlIFdlYiBXb3JrZXIgY2FsbGJhY2sgaXMgaW52b2tlZC5cblx0XHQgKiAgVGhpcyBudW1iZXIgY29ycmVzcG9uZHMgdG8gaG93IHJlc3BvbnNpdmUgdGhlIHNjaGVkdWxpbmdcblx0XHQgKiAgY2FuIGJlLiBDb250ZXh0LnVwZGF0ZUludGVydmFsICsgQ29udGV4dC5sb29rQWhlYWQgZ2l2ZXMgeW91IHRoZVxuXHRcdCAqICB0b3RhbCBsYXRlbmN5IGJldHdlZW4gc2NoZWR1bGluZyBhbiBldmVudCBhbmQgaGVhcmluZyBpdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0XHQgKiAgQG5hbWUgdXBkYXRlSW50ZXJ2YWxcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCAndXBkYXRlSW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXIudXBkYXRlSW50ZXJ2YWw7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl90aWNrZXIudXBkYXRlSW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBXaGF0IHRoZSBzb3VyY2Ugb2YgdGhlIGNsb2NrIGlzLCBlaXRoZXIgXCJ3b3JrZXJcIiAoV2ViIFdvcmtlciBbZGVmYXVsdF0pLFxuXHRcdCAqICBcInRpbWVvdXRcIiAoc2V0VGltZW91dCksIG9yIFwib2ZmbGluZVwiIChub25lKS5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0XHQgKiAgQG5hbWUgY2xvY2tTb3VyY2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNvbnRleHQucHJvdG90eXBlLCAnY2xvY2tTb3VyY2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGlja2VyLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0eXBlIG9mIHBsYXliYWNrLCB3aGljaCBhZmZlY3RzIHRyYWRlb2ZmcyBiZXR3ZWVuIGF1ZGlvXG5cdFx0ICogIG91dHB1dCBsYXRlbmN5IGFuZCByZXNwb25zaXZlbmVzcy5cblx0XHQgKlxuXHRcdCAqICBJbiBhZGRpdGlvbiB0byBzZXR0aW5nIHRoZSB2YWx1ZSBpbiBzZWNvbmRzLCB0aGUgbGF0ZW5jeUhpbnQgYWxzb1xuXHRcdCAqICBhY2NlcHRzIHRoZSBzdHJpbmdzIFwiaW50ZXJhY3RpdmVcIiAocHJpb3JpdGl6ZXMgbG93IGxhdGVuY3kpLFxuXHRcdCAqICBcInBsYXliYWNrXCIgKHByaW9yaXRpemVzIHN1c3RhaW5lZCBwbGF5YmFjayksIFwiYmFsYW5jZWRcIiAoYmFsYW5jZXNcblx0XHQgKiAgbGF0ZW5jeSBhbmQgcGVyZm9ybWFuY2UpLCBhbmQgXCJmYXN0ZXN0XCIgKGxvd2VzdCBsYXRlbmN5LCBtaWdodCBnbGl0Y2ggbW9yZSBvZnRlbikuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd8U2Vjb25kc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQ29udGV4dCNcblx0XHQgKiAgQG5hbWUgbGF0ZW5jeUhpbnRcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgbG9va0FoZWFkIHRvIDAuMyBzZWNvbmRzXG5cdFx0ICogVG9uZS5jb250ZXh0LmxhdGVuY3lIaW50ID0gMC4zO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ29udGV4dC5wcm90b3R5cGUsICdsYXRlbmN5SGludCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lIaW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaGludCkge1xuXHQgICAgICAgICAgICB2YXIgbG9va0FoZWFkID0gaGludDtcblx0ICAgICAgICAgICAgdGhpcy5fbGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICBpZiAoVG9uZS5pc1N0cmluZyhoaW50KSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChoaW50KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlICdpbnRlcmFjdGl2ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4xO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAncGxheWJhY2snOlxuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IDAuODtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxhdGVuY3lIaW50ID0gaGludDtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcblx0ICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSAwLjI1O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGF0ZW5jeUhpbnQgPSBoaW50O1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnZmFzdGVzdCc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5sYXRlbmN5SGludCA9ICdpbnRlcmFjdGl2ZSc7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gMC4wMTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVJbnRlcnZhbCA9IGxvb2tBaGVhZCAvIDM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29udGV4dH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQ29udGV4dC5lbWl0KCdjbG9zZScsIHRoaXMpO1xuXHQgICAgICAgIFRvbmUuRW1pdHRlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3RpY2tlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGlja2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90aW1lb3V0cy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdGltZW91dHMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGNvbiBpbiB0aGlzLl9jb25zdGFudHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY29uc3RhbnRzW2Nvbl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2xvc2UoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBAY2xhc3MgQSBjbGFzcyB3aGljaCBwcm92aWRlcyBhIHJlbGlhYmxlIGNhbGxiYWNrIHVzaW5nIGVpdGhlclxuXHRcdCAqICAgICAgICBhIFdlYiBXb3JrZXIsIG9yIGlmIHRoYXQgaXNuJ3Qgc3VwcG9ydGVkLCBmYWxscyBiYWNrIHRvIHNldFRpbWVvdXQuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIHZhciBUaWNrZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHR5cGUsIHVwZGF0ZUludGVydmFsKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBFaXRoZXIgXCJ3b3JrZXJcIiBvciBcInRpbWVvdXRcIlxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB1cGRhdGUgaW50ZXJ2YWwgb2YgdGhlIHdvcmtlclxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCA9IHVwZGF0ZUludGVydmFsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHRvIGludm9rZSBhdCByZWd1bGFyIGludGVydmFsc1xuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIC8vY3JlYXRlIHRoZSBjbG9jayBzb3VyY2UgZm9yIHRoZSBmaXJzdCB0aW1lXG5cdCAgICAgICAgdGhpcy5fY3JlYXRlQ2xvY2soKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcG9zc2libGUgdGlja2VyIHR5cGVzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLlR5cGUgPSB7XG5cdCAgICAgICAgV29ya2VyOiAnd29ya2VyJyxcblx0ICAgICAgICBUaW1lb3V0OiAndGltZW91dCcsXG5cdCAgICAgICAgT2ZmbGluZTogJ29mZmxpbmUnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdlbmVyYXRlIGEgd2ViIHdvcmtlclxuXHRcdCAqICBAcmV0dXJuICB7V2ViV29ya2VyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLnByb3RvdHlwZS5fY3JlYXRlV29ya2VyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vVVJMIFNoaW1cblx0ICAgICAgICB3aW5kb3cuVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXHQgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWy8vdGhlIGluaXRpYWwgdGltZW91dCB0aW1lXG5cdCAgICAgICAgICAgICd2YXIgdGltZW91dFRpbWUgPSAnICsgKHRoaXMuX3VwZGF0ZUludGVydmFsICogMTAwMCkudG9GaXhlZCgxKSArICc7JyArIC8vb25tZXNzYWdlIGNhbGxiYWNrXG5cdCAgICAgICAgICAgICdzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZyl7JyArICdcXHR0aW1lb3V0VGltZSA9IHBhcnNlSW50KG1zZy5kYXRhKTsnICsgJ307JyArIC8vdGhlIHRpY2sgZnVuY3Rpb24gd2hpY2ggcG9zdHMgYSBtZXNzYWdlXG5cdCAgICAgICAgICAgIC8vYW5kIHNjaGVkdWxlcyBhIG5ldyB0aWNrXG5cdCAgICAgICAgICAgICdmdW5jdGlvbiB0aWNrKCl7JyArICdcXHRzZXRUaW1lb3V0KHRpY2ssIHRpbWVvdXRUaW1lKTsnICsgJ1xcdHNlbGYucG9zdE1lc3NhZ2UoXFwndGlja1xcJyk7JyArICd9JyArIC8vY2FsbCB0aWNrIGluaXRpYWxseVxuXHQgICAgICAgICAgICAndGljaygpOyddKTtcblx0ICAgICAgICB2YXIgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdCAgICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG5cdCAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENyZWF0ZSBhIHRpbWVvdXQgbG9vcFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUaWNrZXIucHJvdG90eXBlLl9jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY3JlYXRlVGltZW91dCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9jYWxsYmFjaygpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5fdXBkYXRlSW50ZXJ2YWwgKiAxMDAwKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDcmVhdGUgdGhlIGNsb2NrIHNvdXJjZS5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVGlja2VyLnByb3RvdHlwZS5fY3JlYXRlQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRpY2tlci5UeXBlLldvcmtlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlV29ya2VyKCk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHdvcmtlcnMgbm90IHN1cHBvcnRlZCwgZmFsbGJhY2sgdG8gdGltZW91dFxuXHQgICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IFRpY2tlci5UeXBlLlRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUaWNrZXIuVHlwZS5UaW1lb3V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVRpbWVvdXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQG1lbWJlck9mIFRpY2tlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHVwZGF0ZUludGVydmFsXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWNrZXIucHJvdG90eXBlLCAndXBkYXRlSW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsID0gTWF0aC5tYXgoaW50ZXJ2YWwsIDEyOCAvIDQ0MTAwKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRpY2tlci5UeXBlLldvcmtlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKE1hdGgubWF4KGludGVydmFsICogMTAwMCwgMSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgdGlja2VyLCBlaXRoZXIgYSB3b3JrZXIgb3IgYSB0aW1lb3V0XG5cdFx0ICogQG1lbWJlck9mIFRpY2tlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRpY2tlci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUNsb2NrKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9jcmVhdGVDbG9jaygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogQ2xlYW4gdXAgdGhlIGN1cnJlbnQgY2xvY2sgc291cmNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuX2Rpc3Bvc2VDbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdGltZW91dCkge1xuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fd29ya2VyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fd29ya2VyLm9ubWVzc2FnZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRpY2tlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9kaXNwb3NlQ2xvY2soKTtcblx0ICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNoaW0gYWxsIGNvbm5lY3QvZGlzY29ubmVjdCBhbmQgc29tZSBkZXByZWNhdGVkIG1ldGhvZHMgd2hpY2ggYXJlIHN0aWxsIGluXG5cdFx0ICogIHNvbWUgb2xkZXIgaW1wbGVtZW50YXRpb25zLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5nZXRDb250ZXh0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbmF0aXZlQ29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdDtcblx0ICAgICAgICB2YXIgbmF0aXZlRGlzY29ubmVjdCA9IEF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdDtcblx0ICAgICAgICAvL3JlcGxhY2UgdGhlIG9sZCBjb25uZWN0IG1ldGhvZFxuXHQgICAgICAgIGZ1bmN0aW9uIHRvbmVDb25uZWN0KEIsIG91dE51bSwgaW5OdW0pIHtcblx0ICAgICAgICAgICAgaWYgKEIuaW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIGluTnVtID0gVG9uZS5kZWZhdWx0QXJnKGluTnVtLCAwKTtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLmlzQXJyYXkoQi5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dFtpbk51bV0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoQi5pbnB1dCwgb3V0TnVtLCBpbk51bSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChCIGluc3RhbmNlb2YgQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hdGl2ZUNvbm5lY3QuY2FsbCh0aGlzLCBCLCBvdXROdW0sIGluTnVtKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDb25uZWN0LmNhbGwodGhpcywgQiwgb3V0TnVtKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcnJvciBjb25uZWN0aW5nIHRvIG5vZGU6ICcgKyBCICsgJ1xcbicgKyBlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3JlcGxhY2UgdGhlIG9sZCBkaXNjb25uZWN0IG1ldGhvZFxuXHQgICAgICAgIGZ1bmN0aW9uIHRvbmVEaXNjb25uZWN0KEIsIG91dE51bSwgaW5OdW0pIHtcblx0ICAgICAgICAgICAgaWYgKEIgJiYgQi5pbnB1dCAmJiBUb25lLmlzQXJyYXkoQi5pbnB1dCkpIHtcblx0ICAgICAgICAgICAgICAgIGluTnVtID0gVG9uZS5kZWZhdWx0QXJnKGluTnVtLCAwKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChCLmlucHV0W2luTnVtXSwgb3V0TnVtLCAwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChCICYmIEIuaW5wdXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChCLmlucHV0LCBvdXROdW0sIGluTnVtKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmF0aXZlRGlzY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXJyb3IgZGlzY29ubmVjdGluZyBub2RlOiAnICsgQiArICdcXG4nICsgZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKEF1ZGlvTm9kZS5wcm90b3R5cGUuY29ubmVjdCAhPT0gdG9uZUNvbm5lY3QpIHtcblx0ICAgICAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0ID0gdG9uZUNvbm5lY3Q7XG5cdCAgICAgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IHRvbmVEaXNjb25uZWN0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gc2V0IHRoZSBhdWRpbyBjb250ZXh0IGluaXRpYWxseSwgYW5kIGlmIG9uZSBpcyBub3QgYWxyZWFkeSBjcmVhdGVkXG5cdCAgICBpZiAoVG9uZS5zdXBwb3J0ZWQgJiYgIVRvbmUuaW5pdGlhbGl6ZWQpIHtcblx0ICAgICAgICBUb25lLmNvbnRleHQgPSBuZXcgVG9uZS5Db250ZXh0KCk7XG5cdCAgICAgICAgLy8gbG9nIG9uIGZpcnN0IGluaXRpYWxpemF0aW9uXG5cdCAgICAgICAgLy8gYWxsb3cgb3B0aW9uYWwgc2lsZW5jaW5nIG9mIHRoaXMgbG9nXG5cdCAgICAgICAgaWYgKCF3aW5kb3cuVE9ORV9TSUxFTkNFX1ZFUlNJT05fTE9HR0lORykge1xuXHQgICAgICAgICAgICBjb25zb2xlLmxvZygnJWMgKiBUb25lLmpzICcgKyBUb25lLnZlcnNpb24gKyAnICogJywgJ2JhY2tncm91bmQ6ICMwMDA7IGNvbG9yOiAjZmZmJyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIGlmICghVG9uZS5zdXBwb3J0ZWQpIHtcblx0ICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFRvbmUuanMnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBUb25lLkNvbnRleHQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BdWRpb05vZGUgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNsYXNzZXMgd2hpY2ggcHJvY2VzcyBhdWRpby5cblx0XHQgKiAgICAgICAgIEF1ZGlvTm9kZXMgaGF2ZSBpbnB1dHMgYW5kIG91dHB1dHMuXG5cdFx0ICogIEBwYXJhbVx0e0F1ZGlvQ29udGV4dD19IGNvbnRleHRcdFRoZSBhdWRpbyBjb250ZXh0IHRvIHVzZSB3aXRoIHRoZSBjbGFzc1xuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvL3VzZSB0aGUgZGVmYXVsdCBjb250ZXh0IGlmIG9uZSBpcyBub3QgcGFzc2VkIGluXG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydjb250ZXh0J10sIHsgJ2NvbnRleHQnOiBUb25lLmNvbnRleHQgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgQXVkaW9Db250ZXh0IG9mIHRoaXMgaW5zdGFuY2Vcblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKiBAdHlwZSB7QXVkaW9Db250ZXh0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiBHZXQgdGhlIGF1ZGlvIGNvbnRleHQgYmVsb25naW5nIHRvIHRoaXMgaW5zdGFuY2UuXG5cdFx0ICogQHR5cGUge1RvbmUuQ29udGV4dH1cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdWRpb05vZGUjXG5cdFx0ICogQG5hbWUgY29udGV4dFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZSwgJ2NvbnRleHQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENyZWF0ZSBpbnB1dCBhbmQgb3V0cHV0cyBmb3IgdGhpcyBvYmplY3QuXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIFtpbnB1dD0wXSAgIFRoZSBudW1iZXIgb2YgaW5wdXRzXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIFtvdXRwdXRzPTBdICBUaGUgbnVtYmVyIG9mIG91dHB1dHNcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQXVkaW9Ob2RlfSAgdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmNyZWF0ZUluc091dHMgPSBmdW5jdGlvbiAoaW5wdXRzLCBvdXRwdXRzKSB7XG5cdCAgICAgICAgaWYgKGlucHV0cyA9PT0gMSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGlucHV0cyA+IDEpIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBBcnJheShpbnB1dHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3V0cHV0cyA9PT0gMSkge1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChvdXRwdXRzID4gMSkge1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBBcnJheShvdXRwdXRzKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaW5wdXRzIGZlZWRpbmcgaW50byB0aGUgQXVkaW9Ob2RlLlxuXHRcdCAqICBGb3Igc291cmNlIG5vZGVzLCB0aGlzIHdpbGwgYmUgMC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgbnVtYmVyT2ZJbnB1dHNcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLCAnbnVtYmVyT2ZJbnB1dHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlucHV0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHRoaXMuaW5wdXQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG51bWJlciBvZiBvdXRwdXRzIGNvbWluZyBvdXQgb2YgdGhlIEF1ZGlvTm9kZS5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgbnVtYmVyT2ZPdXRwdXRzXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZSwgJ251bWJlck9mT3V0cHV0cycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjb25uZWN0IHRoZSBvdXRwdXQgb2YgYSBUb25lTm9kZSB0byBhbiBBdWRpb1BhcmFtLCBBdWRpb05vZGUsIG9yIFRvbmVOb2RlXG5cdFx0ICogIEBwYXJhbSAge1RvbmUgfCBBdWRpb1BhcmFtIHwgQXVkaW9Ob2RlfSB1bml0XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggb3V0cHV0IHRvIGNvbm5lY3QgZnJvbVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggaW5wdXQgdG8gY29ubmVjdCB0b1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVuaXQsIG91dHB1dE51bSwgaW5wdXROdW0pIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICBvdXRwdXROdW0gPSBUb25lLmRlZmF1bHRBcmcob3V0cHV0TnVtLCAwKTtcblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXRbb3V0cHV0TnVtXS5jb25uZWN0KHVuaXQsIDAsIGlucHV0TnVtKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLm91dHB1dC5jb25uZWN0KHVuaXQsIG91dHB1dE51bSwgaW5wdXROdW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZGlzY29ubmVjdCB0aGUgb3V0cHV0XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfEF1ZGlvTm9kZX0gb3V0cHV0IEVpdGhlciB0aGUgb3V0cHV0IGluZGV4IHRvIGRpc2Nvbm5lY3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhlIG91dHB1dCBpcyBhbiBhcnJheSwgb3IgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgdG8gZGlzY29ubmVjdCBmcm9tLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBvdXRwdXROdW0sIGlucHV0TnVtKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLm91dHB1dCkpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIoZGVzdGluYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFtkZXN0aW5hdGlvbl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgb3V0cHV0TnVtID0gVG9uZS5kZWZhdWx0QXJnKG91dHB1dE51bSwgMCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFtvdXRwdXROdW1dLmRpc2Nvbm5lY3QoZGVzdGluYXRpb24sIDAsIGlucHV0TnVtKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QuYXBwbHkodGhpcy5vdXRwdXQsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb25uZWN0IHRoZSBvdXRwdXQgb2YgdGhpcyBub2RlIHRvIHRoZSByZXN0IG9mIHRoZSBub2RlcyBpbiBzZXJpZXMuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIC8vY29ubmVjdCBhIG5vZGUgdG8gYW4gZWZmZWN0LCBwYW5Wb2wgYW5kIHRoZW4gdG8gdGhlIG1hc3RlciBvdXRwdXRcblx0XHQgKiAgbm9kZS5jaGFpbihlZmZlY3QsIHBhblZvbCwgVG9uZS5NYXN0ZXIpO1xuXHRcdCAqICBAcGFyYW0gey4uLkF1ZGlvUGFyYW18VG9uZXxBdWRpb05vZGV9IG5vZGVzXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjdXJyZW50VW5pdCA9IHRoaXM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRvVW5pdCA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgICAgICAgY3VycmVudFVuaXQuY29ubmVjdCh0b1VuaXQpO1xuXHQgICAgICAgICAgICBjdXJyZW50VW5pdCA9IHRvVW5pdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNvbm5lY3QgdGhlIG91dHB1dCBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlc3Qgb2YgdGhlIG5vZGVzIGluIHBhcmFsbGVsLlxuXHRcdCAqICBAcGFyYW0gey4uLkF1ZGlvUGFyYW18VG9uZXxBdWRpb05vZGV9IG5vZGVzXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1ZGlvTm9kZX0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmZhbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLmNvbm5lY3QoYXJndW1lbnRzW2ldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgaWYgKHdpbmRvdy5BdWRpb05vZGUpIHtcblx0ICAgICAgICAvL2dpdmUgbmF0aXZlIG5vZGVzIGNoYWluIGFuZCBmYW4gbWV0aG9kc1xuXHQgICAgICAgIEF1ZGlvTm9kZS5wcm90b3R5cGUuY2hhaW4gPSBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuY2hhaW47XG5cdCAgICAgICAgQXVkaW9Ob2RlLnByb3RvdHlwZS5mYW4gPSBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZmFuO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogRGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuQXVkaW9Ob2RlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZih0aGlzLmlucHV0KSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbnB1dCBpbnN0YW5jZW9mIEF1ZGlvTm9kZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHRoaXMub3V0cHV0KSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXQgaW5zdGFuY2VvZiBBdWRpb05vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0LmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkF1ZGlvTm9kZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBCYXNlIGNsYXNzIGZvciBhbGwgU2lnbmFscy4gVXNlZCBJbnRlcm5hbGx5LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsQmFzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2lnbmFsQmFzZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS5cblx0XHQgKiAgRm9yIGFsbCBvdGhlciBub2RlcywgdGhlIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGEgZGVmYXVsdCA8Y29kZT5jb25uZWN0PC9jb2RlPi5cblx0XHQgKlxuXHRcdCAqICBAb3ZlcnJpZGVcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1BhcmFtfEF1ZGlvTm9kZXxUb25lLlNpZ25hbHxUb25lfSBub2RlXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNpZ25hbEJhc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChub2RlLCBvdXRwdXROdW1iZXIsIGlucHV0TnVtYmVyKSB7XG5cdCAgICAgICAgLy96ZXJvIGl0IG91dCBzbyB0aGF0IHRoZSBzaWduYWwgY2FuIGhhdmUgZnVsbCBjb250cm9sXG5cdCAgICAgICAgaWYgKFRvbmUuU2lnbmFsICYmIFRvbmUuU2lnbmFsID09PSBub2RlLmNvbnN0cnVjdG9yIHx8IFRvbmUuUGFyYW0gJiYgVG9uZS5QYXJhbSA9PT0gbm9kZS5jb25zdHJ1Y3RvciB8fCBUb25lLlRpbWVsaW5lU2lnbmFsICYmIFRvbmUuVGltZWxpbmVTaWduYWwgPT09IG5vZGUuY29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgLy9jYW5jZWwgY2hhbmdlc1xuXHQgICAgICAgICAgICBub2RlLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cdCAgICAgICAgICAgIC8vcmVzZXQgdGhlIHZhbHVlXG5cdCAgICAgICAgICAgIG5vZGUuX3BhcmFtLnZhbHVlID0gMDtcblx0ICAgICAgICAgICAgLy9tYXJrIHRoZSB2YWx1ZSBhcyBvdmVycmlkZGVuXG5cdCAgICAgICAgICAgIG5vZGUub3ZlcnJpZGRlbiA9IHRydWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXVkaW9QYXJhbSkge1xuXHQgICAgICAgICAgICBub2RlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcygwKTtcblx0ICAgICAgICAgICAgbm9kZS52YWx1ZSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcywgbm9kZSwgb3V0cHV0TnVtYmVyLCBpbnB1dE51bWJlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2lnbmFsQmFzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBzIHRoZSBuYXRpdmUgV2ViIEF1ZGlvIEFQSSBcblx0XHQgKiAgICAgICAgIFtXYXZlU2hhcGVyTm9kZV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtd2F2ZXNoYXBlcm5vZGUtaW50ZXJmYWNlKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbnxBcnJheXxOdW1iZXJ9IG1hcHBpbmcgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZGVmaW5lIHRoZSB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24gc2hvdWxkIHRha2UgdHdvIGFyZ3VtZW50czogXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3QgaXMgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFycmF5IHBvc2l0aW9uLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgdGhhdCBhcnJheSB3aWxsIGJlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQgYXMgdGhlIHdhdmUgc2hhcGluZyBmdW5jdGlvbi4gVGhlIGlucHV0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgaXMgYW4gQXVkaW9SYW5nZSBbLTEsIDFdIHZhbHVlIGFuZCB0aGUgb3V0cHV0XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgY2FuIHRha2Ugb24gYW55IG51bWVyaWNhbCB2YWx1ZXMuIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBbYnVmZmVyTGVuPTEwMjRdIFRoZSBsZW5ndGggb2YgdGhlIFdhdmVTaGFwZXJOb2RlIGJ1ZmZlci5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgdGltZXNUd28gPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uKHZhbCl7XG5cdFx0ICogXHRyZXR1cm4gdmFsICogMjtcblx0XHQgKiB9LCAyMDQ4KTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2Egd2F2ZXNoYXBlciBjYW4gYWxzbyBiZSBjb25zdHJ1Y3RlZCB3aXRoIGFuIGFycmF5IG9mIHZhbHVlc1xuXHRcdCAqIHZhciBpbnZlcnQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKFsxLCAtMV0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlU2hhcGVyID0gZnVuY3Rpb24gKG1hcHBpbmcsIGJ1ZmZlckxlbikge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB3YXZlc2hhcGVyXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlV2F2ZVNoYXBlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB3YXZlc2hhcGVycyBjdXJ2ZVxuXHRcdFx0ICogIEB0eXBlIHtGbG9hdDMyQXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2N1cnZlID0gbnVsbDtcblx0ICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLmN1cnZlID0gbWFwcGluZztcblx0ICAgICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG1hcHBpbmcpIHx8IFRvbmUuaXNVbmRlZihtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoVG9uZS5kZWZhdWx0QXJnKG1hcHBpbmcsIDEwMjQpKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNGdW5jdGlvbihtYXBwaW5nKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkoVG9uZS5kZWZhdWx0QXJnKGJ1ZmZlckxlbiwgMTAyNCkpO1xuXHQgICAgICAgICAgICB0aGlzLnNldE1hcChtYXBwaW5nKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5XYXZlU2hhcGVyLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFVzZXMgYSBtYXBwaW5nIGZ1bmN0aW9uIHRvIHNldCB0aGUgdmFsdWUgb2YgdGhlIGN1cnZlLiBcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gbWFwcGluZyBUaGUgZnVuY3Rpb24gdXNlZCB0byBkZWZpbmUgdGhlIHZhbHVlcy4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG1hcHBpbmcgZnVuY3Rpb24gdGFrZSB0d28gYXJndW1lbnRzOiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlyc3QgaXMgdGhlIHZhbHVlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGdvZXMgZnJvbSAtMSB0byAxIG92ZXIgdGhlIG51bWJlciBvZiBlbGVtZW50c1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBjdXJ2ZSBhcnJheS4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgYXJyYXkgcG9zaXRpb24uIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5XYXZlU2hhcGVyfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9tYXAgdGhlIGlucHV0IHNpZ25hbCBmcm9tIFstMSwgMV0gdG8gWzAsIDEwXVxuXHRcdCAqIHNoYXBlci5zZXRNYXAoZnVuY3Rpb24odmFsLCBpbmRleCl7XG5cdFx0ICogXHRyZXR1cm4gKHZhbCArIDEpICogNTtcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiAobWFwcGluZykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jdXJ2ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGkgLyAobGVuIC0gMSkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgdGhpcy5fY3VydmVbaV0gPSBtYXBwaW5nKG5vcm1hbGl6ZWQsIGkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zaGFwZXIuY3VydmUgPSB0aGlzLl9jdXJ2ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXJyYXkgdG8gc2V0IGFzIHRoZSB3YXZlc2hhcGVyIGN1cnZlLiBGb3IgbGluZWFyIGN1cnZlc1xuXHRcdCAqIGFycmF5IGxlbmd0aCBkb2VzIG5vdCBtYWtlIG11Y2ggZGlmZmVyZW5jZSwgYnV0IGZvciBjb21wbGV4IGN1cnZlc1xuXHRcdCAqIGxvbmdlciBhcnJheXMgd2lsbCBwcm92aWRlIHNtb290aGVyIGludGVycG9sYXRpb24uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLldhdmVTaGFwZXIjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIGN1cnZlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5XYXZlU2hhcGVyLnByb3RvdHlwZSwgJ2N1cnZlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLmN1cnZlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWFwcGluZykge1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJ2ZSA9IG5ldyBGbG9hdDMyQXJyYXkobWFwcGluZyk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5jdXJ2ZSA9IHRoaXMuX2N1cnZlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogU3BlY2lmaWVzIHdoYXQgdHlwZSBvZiBvdmVyc2FtcGxpbmcgKGlmIGFueSkgc2hvdWxkIGJlIHVzZWQgd2hlbiBcblx0XHQgKiBhcHBseWluZyB0aGUgc2hhcGluZyBjdXJ2ZS4gQ2FuIGVpdGhlciBiZSBcIm5vbmVcIiwgXCIyeFwiIG9yIFwiNHhcIi4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuV2F2ZVNoYXBlciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLCAnb3ZlcnNhbXBsZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlci5vdmVyc2FtcGxlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAob3ZlcnNhbXBsaW5nKSB7XG5cdCAgICAgICAgICAgIGlmIChbXG5cdCAgICAgICAgICAgICAgICAgICAgJ25vbmUnLFxuXHQgICAgICAgICAgICAgICAgICAgICcyeCcsXG5cdCAgICAgICAgICAgICAgICAgICAgJzR4J1xuXHQgICAgICAgICAgICAgICAgXS5pbmRleE9mKG92ZXJzYW1wbGluZykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaGFwZXIub3ZlcnNhbXBsZSA9IG92ZXJzYW1wbGluZztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUb25lLldhdmVTaGFwZXI6IG92ZXJzYW1wbGluZyBtdXN0IGJlIGVpdGhlciBcXCdub25lXFwnLCBcXCcyeFxcJywgb3IgXFwnNHhcXCcnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5XYXZlU2hhcGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLldhdmVTaGFwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2N1cnZlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5XYXZlU2hhcGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVGltZUJhc2UgaXMgYSBmbGV4aWJsZSBlbmNvZGluZyBvZiB0aW1lXG5cdFx0ICogICAgICAgICB3aGljaCBjYW4gYmUgZXZhbHVhdGVkIHRvIGFuZCBmcm9tIGEgc3RyaW5nLlxuXHRcdCAqICAgICAgICAgUGFyc2luZyBjb2RlIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC90YXBkaWdpdC9cblx0XHQgKiAgICAgICAgIENvcHlyaWdodCAyMDExIDIwMTIgQXJpeWEgSGlkYXlhdCwgTmV3IEJTRCBMaWNlbnNlXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlIGFzIGEgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIFVuaXQgdmFsdWVzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZSg0LCBcIm5cIilcblx0XHQgKiBUb25lLlRpbWVCYXNlKDIsIFwidFwiKVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIydFwiKS5hZGQoXCIxbVwiKVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIydCArIDFtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZSA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgLy9hbGxvd3MgaXQgdG8gYmUgY29uc3RydWN0ZWQgd2l0aCBvciB3aXRob3V0ICduZXcnXG5cdCAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQW55IGV4cHJlc3Npb25zIHBhcnNlZCBmcm9tIHRoZSBUaW1lXG5cdFx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX2V4cHIgPSB0aGlzLl9ub09wO1xuXHQgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVG9uZS5UaW1lQmFzZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5jb3B5KHZhbCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIVRvbmUuaXNVbmRlZih1bml0cykgfHwgVG9uZS5pc051bWJlcih2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2RlZmF1bHQgdW5pdHNcblx0ICAgICAgICAgICAgICAgIHVuaXRzID0gVG9uZS5kZWZhdWx0QXJnKHVuaXRzLCB0aGlzLl9kZWZhdWx0VW5pdHMpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuX3ByaW1hcnlFeHByZXNzaW9uc1t1bml0c10ubWV0aG9kO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXhwciA9IG1ldGhvZC5iaW5kKHRoaXMsIHZhbCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyh2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldCh2YWwpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNVbmRlZih2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2RlZmF1bHQgZXhwcmVzc2lvblxuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXhwciA9IHRoaXMuX2RlZmF1bHRFeHByKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuVGltZUJhc2UodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZUJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFJlcGFsY2UgdGhlIGN1cnJlbnQgdGltZSB2YWx1ZSB3aXRoIHRoZSB2YWx1ZVxuXHRcdCAqICBnaXZlbiBieSB0aGUgZXhwcmVzc2lvbiBzdHJpbmcuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGV4cHJTdHJpbmdcblx0XHQgKiAgQHJldHVybiB7VG9uZS5UaW1lQmFzZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGV4cHJTdHJpbmcpIHtcblx0ICAgICAgICB0aGlzLl9leHByID0gdGhpcy5fcGFyc2VFeHByU3RyaW5nKGV4cHJTdHJpbmcpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gYSBjbG9uZSBvZiB0aGUgVGltZUJhc2Ugb2JqZWN0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gVGhlIG5ldyBjbG9uZWQgVG9uZS5UaW1lQmFzZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcblx0ICAgICAgICBpbnN0YW5jZS5jb3B5KHRoaXMpO1xuXHQgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29waWVzIHRoZSB2YWx1ZSBvZiB0aW1lIHRvIHRoaXMgVGltZVxuXHRcdCAqICBAcGFyYW0ge1RvbmUuVGltZUJhc2V9IHRpbWVcblx0XHQgKiAgQHJldHVybiAge1RpbWVCYXNlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRpbWUuX2V4cHIoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZXQodmFsKTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBQlNUUkFDVCBTWU5UQVggVFJFRSBQQVJTRVJcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIEFsbCB0aGUgcHJpbWFyeSBleHByZXNzaW9ucy5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zID0ge1xuXHQgICAgICAgICduJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspbi9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmVhdHNUb1VuaXRzKHRoaXMuX3RpbWVTaWduYXR1cmUoKSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMoNCAvIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3QnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyl0L2ksXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iZWF0c1RvVW5pdHMoOCAvIChwYXJzZUludCh2YWx1ZSkgKiAzKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgICdtJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCspbS9pLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUludCh2YWx1ZSkgKiB0aGlzLl90aW1lU2lnbmF0dXJlKCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnaSc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKWkvaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aWNrc1RvVW5pdHMocGFyc2VJbnQodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2h6Jzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT8paHovaSxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmVxdWVuY3lUb1VuaXRzKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3RyJzoge1xuXHQgICAgICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT8pOihcXGQrKD86XFwuXFxkKyk/KTo/KFxcZCsoPzpcXC5cXGQrKT8pPy8sXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKG0sIHEsIHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG5cdCAgICAgICAgICAgICAgICBpZiAobSAmJiBtICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9iZWF0c1RvVW5pdHModGhpcy5fdGltZVNpZ25hdHVyZSgpICogcGFyc2VGbG9hdChtKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocSAmJiBxICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChxKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocyAmJiBzICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSB0aGlzLl9iZWF0c1RvVW5pdHMocGFyc2VGbG9hdChzKSAvIDQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAncyc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/cykvLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlY29uZHNUb1VuaXRzKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3NhbXBsZXMnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKylzYW1wbGVzLyxcblx0ICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSkgLyB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2RlZmF1bHQnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL14oXFxkKyg/OlxcLlxcZCspPykvLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1hcnlFeHByZXNzaW9uc1t0aGlzLl9kZWZhdWx0VW5pdHNdLm1ldGhvZC5jYWxsKHRoaXMsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWxsIHRoZSBiaW5hcnkgZXhwcmVzc2lvbnMgdGhhdCBUaW1lQmFzZSBjYW4gYWNjZXB0LlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9iaW5hcnlFeHByZXNzaW9ucyA9IHtcblx0ICAgICAgICAnKyc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXlxcKy8sXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2U6IDIsXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoLCByaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxoKCkgKyByaCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnLSc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXlxcLS8sXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2U6IDIsXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoLCByaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxoKCkgLSByaCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnKic6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXlxcKi8sXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoLCByaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxoKCkgKiByaCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAnLyc6IHtcblx0ICAgICAgICAgICAgcmVnZXhwOiAvXlxcLy8sXG5cdCAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXG5cdCAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGxoLCByaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxoKCkgLyByaCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBbGwgdGhlIHVuYXJ5IGV4cHJlc3Npb25zLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zID0ge1xuXHQgICAgICAgICduZWcnOiB7XG5cdCAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChsaCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC1saCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTeW50YWN0aWMgZ2x1ZSB3aGljaCBob2xkcyBleHByZXNzaW9ucyB0b2dldGhlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9zeW50YXhHbHVlID0ge1xuXHQgICAgICAgICcoJzogeyByZWdleHA6IC9eXFwoLyB9LFxuXHQgICAgICAgICcpJzogeyByZWdleHA6IC9eXFwpLyB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRva2VuaXplIHRoZSBleHByZXNzaW9uIGJhc2VkIG9uIHRoZSBFeHByZXNzaW9ucyBvYmplY3Rcblx0XHQgKiAgQHBhcmFtICAge3N0cmluZ30gZXhwciBcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gICAgICByZXR1cm5zIHR3byBtZXRob2RzIG9uIHRoZSB0b2tlbml6ZWQgbGlzdCwgbmV4dCBhbmQgcGVla1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3Rva2VuaXplID0gZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgICAgICB2YXIgcG9zaXRpb24gPSAtMTtcblx0ICAgICAgICB2YXIgdG9rZW5zID0gW107XG5cdCAgICAgICAgd2hpbGUgKGV4cHIubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBleHByID0gZXhwci50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldE5leHRUb2tlbihleHByLCB0aGlzKTtcblx0ICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXHQgICAgICAgICAgICBleHByID0gZXhwci5zdWJzdHIodG9rZW4udmFsdWUubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dFRva2VuKGV4cHIsIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW1xuXHQgICAgICAgICAgICAgICAgJ19iaW5hcnlFeHByZXNzaW9ucycsXG5cdCAgICAgICAgICAgICAgICAnX3VuYXJ5RXhwcmVzc2lvbnMnLFxuXHQgICAgICAgICAgICAgICAgJ19wcmltYXJ5RXhwcmVzc2lvbnMnLFxuXHQgICAgICAgICAgICAgICAgJ19zeW50YXhHbHVlJ1xuXHQgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBjb250ZXh0W2V4cHJlc3Npb25zW2ldXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9wTmFtZSBpbiBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGdyb3VwW29wTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlZyA9IG9wLnJlZ2V4cDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBleHByLm1hdGNoKHJlZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG9wLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IG9wLnByZWNlZGVuY2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHA6IG9wLnJlZ2V4cCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaFswXVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuVGltZUJhc2U6IFVuZXhwZWN0ZWQgdG9rZW4gJyArIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zWysrcG9zaXRpb25dO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Bvc2l0aW9uICsgMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHaXZlbiBhIHRva2VuLCBmaW5kIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIGdyb3VwTmFtZVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gdG9rZW5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcHJlY2VkZW5jZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX21hdGNoR3JvdXAgPSBmdW5jdGlvbiAodG9rZW4sIGdyb3VwLCBwcmVjKSB7XG5cdCAgICAgICAgdmFyIHJldCA9IGZhbHNlO1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHRva2VuKSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcCA9IGdyb3VwW29wTmFtZV07XG5cdCAgICAgICAgICAgICAgICBpZiAob3AucmVnZXhwLnRlc3QodG9rZW4udmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYocHJlYykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLnByZWNlZGVuY2UgPT09IHByZWMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTWF0Y2ggYSBiaW5hcnkgZXhwcmVzc2lvbiBnaXZlbiB0aGUgdG9rZW4gYW5kIHRoZSBwcmVjZWRlbmNlXG5cdFx0ICogIEBwYXJhbSB7TGV4ZXJ9IGxleGVyXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwcmVjZWRlbmNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VCaW5hcnkgPSBmdW5jdGlvbiAobGV4ZXIsIHByZWNlZGVuY2UpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHByZWNlZGVuY2UpKSB7XG5cdCAgICAgICAgICAgIHByZWNlZGVuY2UgPSAyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXhwcjtcblx0ICAgICAgICBpZiAocHJlY2VkZW5jZSA8IDApIHtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuX3BhcnNlVW5hcnkobGV4ZXIpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZUJpbmFyeShsZXhlciwgcHJlY2VkZW5jZSAtIDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgd2hpbGUgKHRva2VuICYmIHRoaXMuX21hdGNoR3JvdXAodG9rZW4sIHRoaXMuX2JpbmFyeUV4cHJlc3Npb25zLCBwcmVjZWRlbmNlKSkge1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRva2VuLm1ldGhvZC5iaW5kKHRoaXMsIGV4cHIsIHRoaXMuX3BhcnNlQmluYXJ5KGxleGVyLCBwcmVjZWRlbmNlIC0gMSkpO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE1hdGNoIGEgdW5hcnkgZXhwcmVzc2lvbi5cblx0XHQgKiAgQHBhcmFtIHtMZXhlcn0gbGV4ZXJcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wYXJzZVVuYXJ5ID0gZnVuY3Rpb24gKGxleGVyKSB7XG5cdCAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXHQgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgIHZhciBvcCA9IHRoaXMuX21hdGNoR3JvdXAodG9rZW4sIHRoaXMuX3VuYXJ5RXhwcmVzc2lvbnMpO1xuXHQgICAgICAgIGlmIChvcCkge1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgZXhwciA9IHRoaXMuX3BhcnNlVW5hcnkobGV4ZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gb3AubWV0aG9kLmJpbmQodGhpcywgZXhwcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVByaW1hcnkobGV4ZXIpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYXRjaCBhIHByaW1hcnkgZXhwcmVzc2lvbiAoYSB2YWx1ZSkuXG5cdFx0ICogIEBwYXJhbSB7TGV4ZXJ9IGxleGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gKGxleGVyKSB7XG5cdCAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXHQgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgIGlmIChUb25lLmlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5UaW1lQmFzZTogVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fbWF0Y2hHcm91cCh0b2tlbiwgdGhpcy5fcHJpbWFyeUV4cHJlc3Npb25zKSkge1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gdG9rZW4udmFsdWUubWF0Y2godG9rZW4ucmVnZXhwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRva2VuLm1ldGhvZC5iaW5kKHRoaXMsIG1hdGNoaW5nWzFdLCBtYXRjaGluZ1syXSwgbWF0Y2hpbmdbM10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udmFsdWUgPT09ICcoJykge1xuXHQgICAgICAgICAgICBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9wYXJzZUJpbmFyeShsZXhlcik7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBpZiAoISh0b2tlbiAmJiB0b2tlbi52YWx1ZSA9PT0gJyknKSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdFeHBlY3RlZCApJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5UaW1lQmFzZTogQ2Fubm90IHByb2Nlc3MgdG9rZW4gJyArIHRva2VuLnZhbHVlKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVjdXJzaXZlbHkgcGFyc2UgdGhlIHN0cmluZyBleHByZXNzaW9uIGludG8gYSBzeW50YXggdHJlZS5cblx0XHQgKiAgQHBhcmFtICAge3N0cmluZ30gZXhwciBcblx0XHQgKiAgQHJldHVybiAge0Z1bmN0aW9ufSB0aGUgYm91bmQgbWV0aG9kIHRvIGJlIGV2YWx1YXRlZCBsYXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3BhcnNlRXhwclN0cmluZyA9IGZ1bmN0aW9uIChleHByU3RyaW5nKSB7XG5cdCAgICAgICAgaWYgKCFUb25lLmlzU3RyaW5nKGV4cHJTdHJpbmcpKSB7XG5cdCAgICAgICAgICAgIGV4cHJTdHJpbmcgPSBleHByU3RyaW5nLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBsZXhlciA9IHRoaXMuX3Rva2VuaXplKGV4cHJTdHJpbmcpO1xuXHQgICAgICAgIHZhciB0cmVlID0gdGhpcy5fcGFyc2VCaW5hcnkobGV4ZXIpO1xuXHQgICAgICAgIHJldHVybiB0cmVlO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdERFRkFVTFRTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgaW5pdGlhbCBleHByZXNzaW9uIHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9ICBUaGUgaW5pdGlhbCB2YWx1ZSAwXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fbm9PcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgZXhwcmVzc2lvbiB2YWx1ZSBpZiBubyBhcmd1bWVudHMgYXJlIGdpdmVuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZGVmYXVsdEV4cHIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX25vT3A7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHVuaXRzIGlmIG5vbmUgYXJlIGdpdmVuLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX2RlZmF1bHRVbml0cyA9ICdzJztcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFVOSVQgQ09OVkVSU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZnJlcXVlbmN5IGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fZnJlcXVlbmN5VG9Vbml0cyA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyBmcmVxO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBiZWF0cyBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gYmVhdHNcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9iZWF0c1RvVW5pdHMgPSBmdW5jdGlvbiAoYmVhdHMpIHtcblx0ICAgICAgICByZXR1cm4gNjAgLyBUb25lLlRyYW5zcG9ydC5icG0udmFsdWUgKiBiZWF0cztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBzZWNvbmQgaW4gdGhlIGN1cnJlbnQgdW5pdHNcblx0XHQgKiAgQHBhcmFtIHtTZWNvbmRzfSBzZWNvbmRzXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fc2Vjb25kc1RvVW5pdHMgPSBmdW5jdGlvbiAoc2Vjb25kcykge1xuXHQgICAgICAgIHJldHVybiBzZWNvbmRzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHRpY2sgaW4gdGhlIGN1cnJlbnQgdGltZSB1bml0c1xuXHRcdCAqICBAcGFyYW0ge1RpY2tzfSB0aWNrc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3RpY2tzVG9Vbml0cyA9IGZ1bmN0aW9uICh0aWNrcykge1xuXHQgICAgICAgIHJldHVybiB0aWNrcyAqICh0aGlzLl9iZWF0c1RvVW5pdHMoMSkgLyBUb25lLlRyYW5zcG9ydC5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgc2lnbmF0dXJlLlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3RpbWVTaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmU7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0RVhQUkVTU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFB1c2ggYW4gZXhwcmVzc2lvbiBvbnRvIHRoZSBleHByZXNzaW9uIGxpc3Rcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICB0eXBlXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHVuaXRzXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLl9wdXNoRXhwciA9IGZ1bmN0aW9uICh2YWwsIG5hbWUsIHVuaXRzKSB7XG5cdCAgICAgICAgLy9jcmVhdGUgdGhlIGV4cHJlc3Npb25cblx0ICAgICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSkge1xuXHQgICAgICAgICAgICB2YWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih2YWwsIHVuaXRzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IHRoaXMuX2JpbmFyeUV4cHJlc3Npb25zW25hbWVdLm1ldGhvZC5iaW5kKHRoaXMsIHRoaXMuX2V4cHIsIHZhbC5fZXhwcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCB0byB0aGUgY3VycmVudCB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHZhbCAgICBUaGUgdmFsdWUgdG8gYWRkXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgT3B0aW9uYWwgdW5pdHMgdG8gdXNlIHdpdGggdGhlIHZhbHVlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMm1cIikuYWRkKFwiMW1cIik7IC8vXCIzbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXhwcih2YWwsICcrJywgdW5pdHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdWJ0cmFjdCB0aGUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB2YWx1ZSB0byBzdWJ0cmFjdFxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIE9wdGlvbmFsIHVuaXRzIHRvIHVzZSB3aXRoIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuVGltZUJhc2V9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UaW1lQmFzZShcIjJtXCIpLnN1YihcIjFtXCIpOyAvL1wiMW1cIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnLScsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTXVsdGlwbHkgdGhlIGN1cnJlbnQgdmFsdWUgYnkgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB2YWwgICAgVGhlIHZhbHVlIHRvIG11bHRpcGx5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgT3B0aW9uYWwgdW5pdHMgdG8gdXNlIHdpdGggdGhlIHZhbHVlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lQmFzZX0gIHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRpbWVCYXNlKFwiMm1cIikubXVsdChcIjJcIik7IC8vXCI0bVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24gKHZhbCwgdW5pdHMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEV4cHIodmFsLCAnKicsIHVuaXRzKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRGl2aWRlIHRoZSBjdXJyZW50IHZhbHVlIGJ5IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB2YWx1ZSB0byBkaXZpZGUgYnlcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBPcHRpb25hbCB1bml0cyB0byB1c2Ugd2l0aCB0aGUgdmFsdWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlRpbWVCYXNlfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZUJhc2UoXCIybVwiKS5kaXYoMik7IC8vXCIxbVwiXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wdXNoRXhwcih2YWwsICcvJywgdW5pdHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBFdmFsdWF0ZSB0aGUgdGltZSB2YWx1ZS4gUmV0dXJucyB0aGUgdGltZVxuXHRcdCAqICBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc30gXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9leHByKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuVGltZUJhc2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZUJhc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGltZUJhc2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5UaW1lIGlzIGEgcHJpbWl0aXZlIHR5cGUgZm9yIGVuY29kaW5nIFRpbWUgdmFsdWVzLiBcblx0XHQgKiAgICAgICAgIEV2ZW50dWFsbHkgYWxsIHRpbWUgdmFsdWVzIGFyZSBldmFsdWF0ZWQgdG8gc2Vjb25kc1xuXHRcdCAqICAgICAgICAgdXNpbmcgdGhlIGBldmFsYCBtZXRob2QuIFRvbmUuVGltZSBjYW4gYmUgY29uc3RydWN0ZWRcblx0XHQgKiAgICAgICAgIHdpdGggb3Igd2l0aG91dCB0aGUgYG5ld2Aga2V5d29yZC4gVG9uZS5UaW1lIGNhbiBiZSBwYXNzZWRcblx0XHQgKiAgICAgICAgIGludG8gdGhlIHBhcmFtZXRlciBvZiBhbnkgbWV0aG9kIHdoaWNoIHRha2VzIHRpbWUgYXMgYW4gYXJndW1lbnQuIFxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuVGltZUJhc2V9XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICB2YWwgICAgVGhlIHRpbWUgdmFsdWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZz19ICB1bml0cyAgVGhlIHVuaXRzIG9mIHRoZSB2YWx1ZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgdCA9IFRvbmUuVGltZShcIjRuXCIpOy8vZW5jb2RlcyBhIHF1YXJ0ZXIgbm90ZVxuXHRcdCAqIHQubXVsdCg0KTsgLy8gbXVsdGlwbHkgdGhhdCB2YWx1ZSBieSA0XG5cdFx0ICogdC50b05vdGF0aW9uKCk7IC8vcmV0dXJucyBcIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZSA9IGZ1bmN0aW9uICh2YWwsIHVuaXRzKSB7XG5cdCAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBUb25lLlRpbWUpIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBJZiB0aGUgY3VycmVudCBjbG9jayB0aW1lIHNob3VsZFxuXHRcdFx0XHQgKiAgYmUgYWRkZWQgdG8gdGhlIG91dHB1dFxuXHRcdFx0XHQgKiAgQHR5cGUgIHtCb29sZWFufVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3BsdXNOb3cgPSBmYWxzZTtcblx0ICAgICAgICAgICAgVG9uZS5UaW1lQmFzZS5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5UaW1lKHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpbWUsIFRvbmUuVGltZUJhc2UpO1xuXHQgICAgLy9jbG9uZSB0aGUgZXhwcmVzc2lvbnMgc28gdGhhdCBcblx0ICAgIC8vd2UgY2FuIGFkZCBtb3JlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucyA9IE9iamVjdC5jcmVhdGUoVG9uZS5UaW1lQmFzZS5wcm90b3R5cGUuX3VuYXJ5RXhwcmVzc2lvbnMpO1xuXHQgICAgLypcblx0XHQgKiAgQWRkcyBhbiBhZGRpdGlvbmFsIHVuYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgd2hpY2ggcXVhbnRpemVzIHZhbHVlcyB0byB0aGUgbmV4dCBzdWJkaXZpc2lvblxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5xdWFudGl6ZSA9IHtcblx0ICAgICAgICByZWdleHA6IC9eQC8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocmgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0Lm5leHRTdWJkaXZpc2lvbihyaCgpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLypcblx0XHQgKiAgQWRkcyBhbiBhZGRpdGlvbmFsIHVuYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgd2hpY2ggYWRkcyB0aGUgY3VycmVudCBjbG9jayB0aW1lLlxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fdW5hcnlFeHByZXNzaW9ucy5ub3cgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXlxcKy8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobGgpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybiBsaCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUXVhbnRpemUgdGhlIHRpbWUgYnkgdGhlIGdpdmVuIHN1YmRpdmlzaW9uLiBPcHRpb25hbGx5IGFkZCBhXG5cdFx0ICogIHBlcmNlbnRhZ2Ugd2hpY2ggd2lsbCBtb3ZlIHRoZSB0aW1lIHZhbHVlIHRvd2FyZHMgdGhlIGlkZWFsXG5cdFx0ICogIHF1YW50aXplZCB2YWx1ZSBieSB0aGF0IHBlcmNlbnRhZ2UuIFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ8VGltZX0gIHZhbCAgICBUaGUgc3ViZGl2aXNpb24gdG8gcXVhbnRpemUgdG9cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBbcGVyY2VudD0xXSAgTW92ZSB0aGUgdGltZSB2YWx1ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3dhcmRzIHRoZSBxdWFudGl6ZWQgdmFsdWUgYnlcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBwZXJjZW50YWdlLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lfSAgdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZSgyMSkucXVhbnRpemUoMikgLy9yZXR1cm5zIDIyXG5cdFx0ICogVG9uZS5UaW1lKDAuNikucXVhbnRpemUoXCI0blwiLCAwLjUpIC8vcmV0dXJucyAwLjU1XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnF1YW50aXplID0gZnVuY3Rpb24gKHN1YmRpdiwgcGVyY2VudCkge1xuXHQgICAgICAgIHBlcmNlbnQgPSBUb25lLmRlZmF1bHRBcmcocGVyY2VudCwgMSk7XG5cdCAgICAgICAgdGhpcy5fZXhwciA9IGZ1bmN0aW9uIChleHByLCBzdWJkaXZpc2lvbiwgcGVyY2VudCkge1xuXHQgICAgICAgICAgICBleHByID0gZXhwcigpO1xuXHQgICAgICAgICAgICBzdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uLnRvU2Vjb25kcygpO1xuXHQgICAgICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLnJvdW5kKGV4cHIgLyBzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgICAgIHZhciBpZGVhbCA9IG11bHRpcGxlICogc3ViZGl2aXNpb247XG5cdCAgICAgICAgICAgIHZhciBkaWZmID0gaWRlYWwgLSBleHByO1xuXHQgICAgICAgICAgICByZXR1cm4gZXhwciArIGRpZmYgKiBwZXJjZW50O1xuXHQgICAgICAgIH0uYmluZCh0aGlzLCB0aGlzLl9leHByLCBuZXcgdGhpcy5jb25zdHJ1Y3RvcihzdWJkaXYpLCBwZXJjZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkcyB0aGUgY2xvY2sgdGltZSB0byB0aGUgdGltZSBleHByZXNzaW9uIGF0IHRoZSBcblx0XHQgKiAgbW9tZW50IG9mIGV2YWx1YXRpb24uIFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5UaW1lfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5hZGROb3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRydWU7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbHVlIHJldHVybiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnbm93J1xuXHRcdCAqICBAb3ZlcnJpZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUuX2RlZmF1bHRFeHByID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3BsdXNOb3cgPSB0cnVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ub09wO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb3BpZXMgdGhlIHZhbHVlIG9mIHRpbWUgdG8gdGhpcyBUaW1lXG5cdFx0ICogIEBwYXJhbSB7VG9uZS5UaW1lfSB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtUaW1lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5jb3B5LmNhbGwodGhpcywgdGltZSk7XG5cdCAgICAgICAgdGhpcy5fcGx1c05vdyA9IHRpbWUuX3BsdXNOb3c7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy9DT05WRVJTSU9OUy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIFRpbWUgdG8gTm90YXRpb24uIFZhbHVlcyB3aWxsIGJlIHRocmVzaG9sZGVkIHRvIHRoZSBuZWFyZXN0IDEyOHRoIG5vdGUuIFxuXHRcdCAqICBAcmV0dXJuIHtOb3RhdGlvbn0gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pZiB0aGUgVHJhbnNwb3J0IGlzIGF0IDEyMGJwbTpcblx0XHQgKiBUb25lLlRpbWUoMikudG9Ob3RhdGlvbigpOy8vcmV0dXJucyBcIjFtXCJcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9Ob3RhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdGltZSA9IHRoaXMudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgdmFyIHRlc3ROb3RhdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICcxbScsXG5cdCAgICAgICAgICAgICcybicsXG5cdCAgICAgICAgICAgICc0bicsXG5cdCAgICAgICAgICAgICc4bicsXG5cdCAgICAgICAgICAgICcxNm4nLFxuXHQgICAgICAgICAgICAnMzJuJyxcblx0ICAgICAgICAgICAgJzY0bicsXG5cdCAgICAgICAgICAgICcxMjhuJ1xuXHQgICAgICAgIF07XG5cdCAgICAgICAgdmFyIHJldE5vdGF0aW9uID0gdGhpcy5fdG9Ob3RhdGlvbkhlbHBlcih0aW1lLCB0ZXN0Tm90YXRpb25zKTtcblx0ICAgICAgICAvL3RyeSB0aGUgc2FtZSB0aGluZyBidXQgd2l0aCB0cmlwZWxldHNcblx0ICAgICAgICB2YXIgdGVzdFRyaXBsZXROb3RhdGlvbnMgPSBbXG5cdCAgICAgICAgICAgICcxbScsXG5cdCAgICAgICAgICAgICcybicsXG5cdCAgICAgICAgICAgICcydCcsXG5cdCAgICAgICAgICAgICc0bicsXG5cdCAgICAgICAgICAgICc0dCcsXG5cdCAgICAgICAgICAgICc4bicsXG5cdCAgICAgICAgICAgICc4dCcsXG5cdCAgICAgICAgICAgICcxNm4nLFxuXHQgICAgICAgICAgICAnMTZ0Jyxcblx0ICAgICAgICAgICAgJzMybicsXG5cdCAgICAgICAgICAgICczMnQnLFxuXHQgICAgICAgICAgICAnNjRuJyxcblx0ICAgICAgICAgICAgJzY0dCcsXG5cdCAgICAgICAgICAgICcxMjhuJ1xuXHQgICAgICAgIF07XG5cdCAgICAgICAgdmFyIHJldFRyaXBsZXROb3RhdGlvbiA9IHRoaXMuX3RvTm90YXRpb25IZWxwZXIodGltZSwgdGVzdFRyaXBsZXROb3RhdGlvbnMpO1xuXHQgICAgICAgIC8vY2hvb3NlIHRoZSBzaW1wbGVyIGV4cHJlc3Npb24gb2YgdGhlIHR3b1xuXHQgICAgICAgIGlmIChyZXRUcmlwbGV0Tm90YXRpb24uc3BsaXQoJysnKS5sZW5ndGggPCByZXROb3RhdGlvbi5zcGxpdCgnKycpLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmV0VHJpcGxldE5vdGF0aW9uO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiByZXROb3RhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEhlbHBlciBtZXRob2QgZm9yIFRvbmUudG9Ob3RhdGlvblxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gdW5pdHMgXG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IHRlc3ROb3RhdGlvbnNcblx0XHQgKiAgQHJldHVybiB7U3RyaW5nfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fdG9Ob3RhdGlvbkhlbHBlciA9IGZ1bmN0aW9uICh1bml0cywgdGVzdE5vdGF0aW9ucykge1xuXHQgICAgICAgIC8vdGhlIHRocmVzaG9sZCBpcyB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgYXJyYXlcblx0ICAgICAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5fbm90YXRpb25Ub1VuaXRzKHRlc3ROb3RhdGlvbnNbdGVzdE5vdGF0aW9ucy5sZW5ndGggLSAxXSk7XG5cdCAgICAgICAgdmFyIHJldE5vdGF0aW9uID0gJyc7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXN0Tm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBub3RhdGlvblRpbWUgPSB0aGlzLl9ub3RhdGlvblRvVW5pdHModGVzdE5vdGF0aW9uc1tpXSk7XG5cdCAgICAgICAgICAgIC8vYWNjb3VudCBmb3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzIChpLmUuIHJvdW5kIHVwIGlmIHRoZSB2YWx1ZSBpcyAwLjk5OTk5OSlcblx0ICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gdW5pdHMgLyBub3RhdGlvblRpbWU7XG5cdCAgICAgICAgICAgIHZhciBmbG9hdGluZ1BvaW50RXJyb3IgPSAwLjAwMDAwMTtcblx0ICAgICAgICAgICAgaWYgKDEgLSBtdWx0aXBsZSAlIDEgPCBmbG9hdGluZ1BvaW50RXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG11bHRpcGxlICs9IGZsb2F0aW5nUG9pbnRFcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBtdWx0aXBsZSA9IE1hdGguZmxvb3IobXVsdGlwbGUpO1xuXHQgICAgICAgICAgICBpZiAobXVsdGlwbGUgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXROb3RhdGlvbiArPSB0ZXN0Tm90YXRpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXROb3RhdGlvbiArPSBtdWx0aXBsZS50b1N0cmluZygpICsgJyonICsgdGVzdE5vdGF0aW9uc1tpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHVuaXRzIC09IG11bHRpcGxlICogbm90YXRpb25UaW1lO1xuXHQgICAgICAgICAgICAgICAgaWYgKHVuaXRzIDwgdGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldE5vdGF0aW9uICs9ICcgKyAnO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXROb3RhdGlvbiA9PT0gJycpIHtcblx0ICAgICAgICAgICAgcmV0Tm90YXRpb24gPSAnMCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXROb3RhdGlvbjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBhIG5vdGF0aW9uIHZhbHVlIHRvIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSAge05vdGF0aW9ufSAgbm90YXRpb24gXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9IFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS5fbm90YXRpb25Ub1VuaXRzID0gZnVuY3Rpb24gKG5vdGF0aW9uKSB7XG5cdCAgICAgICAgdmFyIHByaW1hcnlFeHBycyA9IHRoaXMuX3ByaW1hcnlFeHByZXNzaW9ucztcblx0ICAgICAgICB2YXIgbm90YXRpb25FeHBycyA9IFtcblx0ICAgICAgICAgICAgcHJpbWFyeUV4cHJzLm4sXG5cdCAgICAgICAgICAgIHByaW1hcnlFeHBycy50LFxuXHQgICAgICAgICAgICBwcmltYXJ5RXhwcnMubVxuXHQgICAgICAgIF07XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3RhdGlvbkV4cHJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBleHByID0gbm90YXRpb25FeHByc1tpXTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoID0gbm90YXRpb24ubWF0Y2goZXhwci5yZWdleHApO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBleHByLm1ldGhvZC5jYWxsKHRoaXMsIG1hdGNoWzFdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGVuY29kZWQgYXMgQmFyczpCZWF0czpTaXh0ZWVudGhzLlxuXHRcdCAqICBAcmV0dXJuICB7QmFyc0JlYXRzU2l4dGVlbnRoc31cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZS5wcm90b3R5cGUudG9CYXJzQmVhdHNTaXh0ZWVudGhzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0ICAgICAgICB2YXIgcXVhcnRlcnMgPSB0aGlzLnRvU2Vjb25kcygpIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgdmFyIG1lYXN1cmVzID0gTWF0aC5mbG9vcihxdWFydGVycyAvIHRoaXMuX3RpbWVTaWduYXR1cmUoKSk7XG5cdCAgICAgICAgdmFyIHNpeHRlZW50aHMgPSBxdWFydGVycyAlIDEgKiA0O1xuXHQgICAgICAgIHF1YXJ0ZXJzID0gTWF0aC5mbG9vcihxdWFydGVycykgJSB0aGlzLl90aW1lU2lnbmF0dXJlKCk7XG5cdCAgICAgICAgc2l4dGVlbnRocyA9IHNpeHRlZW50aHMudG9TdHJpbmcoKTtcblx0ICAgICAgICBpZiAoc2l4dGVlbnRocy5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgIC8vIHRoZSBhZGRpdGlvbmFsIHBhcnNlRmxvYXQgcmVtb3ZlcyBpbnNpZ25pZmljYW50IHRyYWlsaW5nIHplcm9lc1xuXHQgICAgICAgICAgICBzaXh0ZWVudGhzID0gcGFyc2VGbG9hdChwYXJzZUZsb2F0KHNpeHRlZW50aHMpLnRvRml4ZWQoMykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBbXG5cdCAgICAgICAgICAgIG1lYXN1cmVzLFxuXHQgICAgICAgICAgICBxdWFydGVycyxcblx0ICAgICAgICAgICAgc2l4dGVlbnRoc1xuXHQgICAgICAgIF07XG5cdCAgICAgICAgcmV0dXJuIHByb2dyZXNzLmpvaW4oJzonKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHRpY2tzLlxuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJUaW1lID0gdGhpcy5fYmVhdHNUb1VuaXRzKDEpO1xuXHQgICAgICAgIHZhciBxdWFydGVycyA9IHRoaXMudmFsdWVPZigpIC8gcXVhcnRlclRpbWU7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocXVhcnRlcnMgKiBUb25lLlRyYW5zcG9ydC5QUFEpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gc2FtcGxlc1xuXHRcdCAqICBAcmV0dXJuICB7U2FtcGxlc30gIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b1NhbXBsZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudG9TZWNvbmRzKCkgKiB0aGlzLmNvbnRleHQuc2FtcGxlUmF0ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGFzIGEgZnJlcXVlbmN5IHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtGcmVxdWVuY3l9IFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVGltZSgyKS50b0ZyZXF1ZW5jeSgpOyAvLzAuNVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIHRoaXMudG9TZWNvbmRzKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc30gXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdFx0ICogIEByZXR1cm4gIHtNaWxsaXNlY29uZHN9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lLnByb3RvdHlwZS50b01pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy50b1NlY29uZHMoKSAqIDEwMDA7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7U2Vjb25kc30gXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWUucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuX2V4cHIoKTtcblx0ICAgICAgICByZXR1cm4gdmFsICsgKHRoaXMuX3BsdXNOb3cgPyB0aGlzLm5vdygpIDogMCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGltZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZyZXF1ZW5jeSBpcyBhIHByaW1pdGl2ZSB0eXBlIGZvciBlbmNvZGluZyBGcmVxdWVuY3kgdmFsdWVzLlxuXHRcdCAqICAgICAgICAgRXZlbnR1YWxseSBhbGwgdGltZSB2YWx1ZXMgYXJlIGV2YWx1YXRlZCB0byBoZXJ0elxuXHRcdCAqICAgICAgICAgdXNpbmcgdGhlIGBldmFsYCBtZXRob2QuXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5UaW1lQmFzZX1cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIHZhbCAgICBUaGUgdGltZSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nPX0gIHVuaXRzICBUaGUgdW5pdHMgb2YgdGhlIHZhbHVlLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzNcIikgLy8gMjYxXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koMzgsIFwibWlkaVwiKSAvL1xuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQzNcIikudHJhbnNwb3NlKDQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5GcmVxdWVuY3kpIHtcblx0ICAgICAgICAgICAgVG9uZS5UaW1lQmFzZS5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5GcmVxdWVuY3kodmFsLCB1bml0cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRnJlcXVlbmN5LCBUb25lLlRpbWVCYXNlKTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFVR01FTlQgQkFTRSBFWFBSRVNTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL2Nsb25lIHRoZSBleHByZXNzaW9ucyBzbyB0aGF0XG5cdCAgICAvL3dlIGNhbiBhZGQgbW9yZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zID0gT2JqZWN0LmNyZWF0ZShUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zKTtcblx0ICAgIC8qXG5cdFx0ICogIG1pZGkgdHlwZSBwcmltYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLm1pZGkgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXihcXGQrKD86XFwuXFxkKyk/bWlkaSkvLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm1pZGlUb0ZyZXF1ZW5jeSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qXG5cdFx0ICogIG5vdGUgdHlwZSBwcmltYXJ5IGV4cHJlc3Npb25cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fcHJpbWFyeUV4cHJlc3Npb25zLm5vdGUgPSB7XG5cdCAgICAgICAgcmVnZXhwOiAvXihbYS1nXXsxfSg/OmJ8I3x4fGJiKT8pKC0/WzAtOV0rKS9pLFxuXHQgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHBpdGNoLCBvY3RhdmUpIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gbm90ZVRvU2NhbGVJbmRleFtwaXRjaC50b0xvd2VyQ2FzZSgpXTtcblx0ICAgICAgICAgICAgdmFyIG5vdGVOdW1iZXIgPSBpbmRleCArIChwYXJzZUludChvY3RhdmUpICsgMSkgKiAxMjtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlkaVRvRnJlcXVlbmN5KG5vdGVOdW1iZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKlxuXHRcdCAqICBCZWF0c0JhcnNTaXh0ZWVudGhzIHR5cGUgcHJpbWFyeSBleHByZXNzaW9uXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX3ByaW1hcnlFeHByZXNzaW9ucy50ciA9IHtcblx0ICAgICAgICByZWdleHA6IC9eKFxcZCsoPzpcXC5cXGQrKT8pOihcXGQrKD86XFwuXFxkKyk/KTo/KFxcZCsoPzpcXC5cXGQrKT8pPy8sXG5cdCAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAobSwgcSwgcykge1xuXHQgICAgICAgICAgICB2YXIgdG90YWwgPSAxO1xuXHQgICAgICAgICAgICBpZiAobSAmJiBtICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsICo9IHRoaXMuX2JlYXRzVG9Vbml0cyh0aGlzLl90aW1lU2lnbmF0dXJlKCkgKiBwYXJzZUZsb2F0KG0pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocSAmJiBxICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsICo9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHEpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocyAmJiBzICE9PSAnMCcpIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsICo9IHRoaXMuX2JlYXRzVG9Vbml0cyhwYXJzZUZsb2F0KHMpIC8gNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRFWFBSRVNTSU9OU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVHJhbnNwb3NlcyB0aGUgZnJlcXVlbmN5IGJ5IHRoZSBnaXZlbiBudW1iZXIgb2Ygc2VtaXRvbmVzLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbH0gIGludGVydmFsXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkZyZXF1ZW5jeX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQTRcIikudHJhbnNwb3NlKDMpOyAvL1wiQzVcIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSBmdW5jdGlvbiAoZXhwciwgaW50ZXJ2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IGV4cHIoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbCAqIFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsKTtcblx0ICAgICAgICB9LmJpbmQodGhpcywgdGhpcy5fZXhwciwgaW50ZXJ2YWwpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUYWtlcyBhbiBhcnJheSBvZiBzZW1pdG9uZSBpbnRlcnZhbHMgYW5kIHJldHVybnNcblx0XHQgKiAgYW4gYXJyYXkgb2YgZnJlcXVlbmNpZXMgdHJhbnNwb3NlZCBieSB0aG9zZSBpbnRlcnZhbHMuXG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgaW50ZXJ2YWxzXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkZyZXF1ZW5jeX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuRnJlcXVlbmN5KFwiQTRcIikuaGFybW9uaXplKFswLCAzLCA3XSk7IC8vW1wiQTRcIiwgXCJDNVwiLCBcIkU1XCJdXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuaGFybW9uaXplID0gZnVuY3Rpb24gKGludGVydmFscykge1xuXHQgICAgICAgIHRoaXMuX2V4cHIgPSBmdW5jdGlvbiAoZXhwciwgaW50ZXJ2YWxzKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBleHByKCk7XG5cdCAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHJldFtpXSA9IHZhbCAqIFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsc1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9LmJpbmQodGhpcywgdGhpcy5fZXhwciwgaW50ZXJ2YWxzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRVTklUIENPTlZFUlNJT05TXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmcmVxdWVuY3kgYXMgYSBNSURJIG5vdGVcblx0XHQgKiAgQHJldHVybiAge01JREl9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5GcmVxdWVuY3koXCJDNFwiKS50b01pZGkoKTsgLy82MFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvTWlkaSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5mcmVxdWVuY3lUb01pZGkodGhpcy52YWx1ZU9mKCkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmcmVxdWVuY3kgaW4gU2NpZW50aWZpYyBQaXRjaCBOb3RhdGlvblxuXHRcdCAqICBAcmV0dXJuICB7Tm90ZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkZyZXF1ZW5jeSg2OSwgXCJtaWRpXCIpLnRvTm90ZSgpOyAvL1wiQTRcIlxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLnRvTm90ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgZnJlcSA9IHRoaXMudmFsdWVPZigpO1xuXHQgICAgICAgIHZhciBsb2cgPSBNYXRoLmxvZyhmcmVxIC8gVG9uZS5GcmVxdWVuY3kuQTQpIC8gTWF0aC5MTjI7XG5cdCAgICAgICAgdmFyIG5vdGVOdW1iZXIgPSBNYXRoLnJvdW5kKDEyICogbG9nKSArIDU3O1xuXHQgICAgICAgIHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKG5vdGVOdW1iZXIgLyAxMik7XG5cdCAgICAgICAgaWYgKG9jdGF2ZSA8IDApIHtcblx0ICAgICAgICAgICAgbm90ZU51bWJlciArPSAtMTIgKiBvY3RhdmU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBub3RlTmFtZSA9IHNjYWxlSW5kZXhUb05vdGVbbm90ZU51bWJlciAlIDEyXTtcblx0ICAgICAgICByZXR1cm4gbm90ZU5hbWUgKyBvY3RhdmUudG9TdHJpbmcoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBkdXJhdGlvbiBvZiBvbmUgY3ljbGUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUudG9TZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiAxIC8gdGhpcy52YWx1ZU9mKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgdmFsdWUgaW4gSGVydHpcblx0XHQgKiAgQHJldHVybiAge0ZyZXF1ZW5jeX1cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybiB0aGUgZHVyYXRpb24gb2Ygb25lIGN5Y2xlIGluIHRpY2tzXG5cdFx0ICogIEByZXR1cm4gIHtUaWNrc31cblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS50b1RpY2tzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBxdWFydGVyVGltZSA9IHRoaXMuX2JlYXRzVG9Vbml0cygxKTtcblx0ICAgICAgICB2YXIgcXVhcnRlcnMgPSB0aGlzLnZhbHVlT2YoKSAvIHF1YXJ0ZXJUaW1lO1xuXHQgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHF1YXJ0ZXJzICogVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRVTklUIENPTlZFUlNJT05TIEhFTFBFUlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZnJlcXVlbmN5IGluIHRoZSBjdXJyZW50IHVuaXRzXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2ZyZXF1ZW5jeVRvVW5pdHMgPSBmdW5jdGlvbiAoZnJlcSkge1xuXHQgICAgICAgIHJldHVybiBmcmVxO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHRpY2sgaW4gdGhlIGN1cnJlbnQgdGltZSB1bml0c1xuXHRcdCAqICBAcGFyYW0ge1RpY2tzfSB0aWNrc1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3kucHJvdG90eXBlLl90aWNrc1RvVW5pdHMgPSBmdW5jdGlvbiAodGlja3MpIHtcblx0ICAgICAgICByZXR1cm4gMSAvICh0aWNrcyAqIDYwIC8gKFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSAqIFRvbmUuVHJhbnNwb3J0LlBQUSkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBiZWF0cyBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gYmVhdHNcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzID0gZnVuY3Rpb24gKGJlYXRzKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyBUb25lLlRpbWVCYXNlLnByb3RvdHlwZS5fYmVhdHNUb1VuaXRzLmNhbGwodGhpcywgYmVhdHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHNlY29uZCBpbiB0aGUgY3VycmVudCB1bml0c1xuXHRcdCAqICBAcGFyYW0ge1NlY29uZHN9IHNlY29uZHNcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5fc2Vjb25kc1RvVW5pdHMgPSBmdW5jdGlvbiAoc2Vjb25kcykge1xuXHQgICAgICAgIHJldHVybiAxIC8gc2Vjb25kcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdW5pdHMgaWYgbm9uZSBhcmUgZ2l2ZW4uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZyZXF1ZW5jeS5wcm90b3R5cGUuX2RlZmF1bHRVbml0cyA9ICdoeic7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRGUkVRVUVOQ1kgQ09OVkVSU0lPTlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIE5vdGUgdG8gc2NhbGUgaW5kZXhcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICB2YXIgbm90ZVRvU2NhbGVJbmRleCA9IHtcblx0ICAgICAgICAnY2JiJzogLTIsXG5cdCAgICAgICAgJ2NiJzogLTEsXG5cdCAgICAgICAgJ2MnOiAwLFxuXHQgICAgICAgICdjIyc6IDEsXG5cdCAgICAgICAgJ2N4JzogMixcblx0ICAgICAgICAnZGJiJzogMCxcblx0ICAgICAgICAnZGInOiAxLFxuXHQgICAgICAgICdkJzogMixcblx0ICAgICAgICAnZCMnOiAzLFxuXHQgICAgICAgICdkeCc6IDQsXG5cdCAgICAgICAgJ2ViYic6IDIsXG5cdCAgICAgICAgJ2ViJzogMyxcblx0ICAgICAgICAnZSc6IDQsXG5cdCAgICAgICAgJ2UjJzogNSxcblx0ICAgICAgICAnZXgnOiA2LFxuXHQgICAgICAgICdmYmInOiAzLFxuXHQgICAgICAgICdmYic6IDQsXG5cdCAgICAgICAgJ2YnOiA1LFxuXHQgICAgICAgICdmIyc6IDYsXG5cdCAgICAgICAgJ2Z4JzogNyxcblx0ICAgICAgICAnZ2JiJzogNSxcblx0ICAgICAgICAnZ2InOiA2LFxuXHQgICAgICAgICdnJzogNyxcblx0ICAgICAgICAnZyMnOiA4LFxuXHQgICAgICAgICdneCc6IDksXG5cdCAgICAgICAgJ2FiYic6IDcsXG5cdCAgICAgICAgJ2FiJzogOCxcblx0ICAgICAgICAnYSc6IDksXG5cdCAgICAgICAgJ2EjJzogMTAsXG5cdCAgICAgICAgJ2F4JzogMTEsXG5cdCAgICAgICAgJ2JiYic6IDksXG5cdCAgICAgICAgJ2JiJzogMTAsXG5cdCAgICAgICAgJ2InOiAxMSxcblx0ICAgICAgICAnYiMnOiAxMixcblx0ICAgICAgICAnYngnOiAxM1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzY2FsZSBpbmRleCB0byBub3RlIChzaGFycHMpXG5cdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgc2NhbGVJbmRleFRvTm90ZSA9IFtcblx0ICAgICAgICAnQycsXG5cdCAgICAgICAgJ0MjJyxcblx0ICAgICAgICAnRCcsXG5cdCAgICAgICAgJ0QjJyxcblx0ICAgICAgICAnRScsXG5cdCAgICAgICAgJ0YnLFxuXHQgICAgICAgICdGIycsXG5cdCAgICAgICAgJ0cnLFxuXHQgICAgICAgICdHIycsXG5cdCAgICAgICAgJ0EnLFxuXHQgICAgICAgICdBIycsXG5cdCAgICAgICAgJ0InXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBbY29uY2VydCBwaXRjaF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uY2VydF9waXRjaClcblx0XHQgKiAgQTQncyB2YWx1ZXMgaW4gSGVydHouXG5cdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LkE0ID0gNDQwO1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgYSBNSURJIG5vdGUgdG8gZnJlcXVlbmN5IHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtNSURJfSBtaWRpIFRoZSBtaWRpIG51bWJlciB0byBjb252ZXJ0LlxuXHRcdCAqICBAcmV0dXJuIHtGcmVxdWVuY3l9IHRoZSBjb3JyZXNwb25kaW5nIGZyZXF1ZW5jeSB2YWx1ZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHRvbmUubWlkaVRvRnJlcXVlbmN5KDY5KTsgLy8gcmV0dXJucyA0NDBcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5taWRpVG9GcmVxdWVuY3kgPSBmdW5jdGlvbiAobWlkaSkge1xuXHQgICAgICAgIHJldHVybiBUb25lLkZyZXF1ZW5jeS5BNCAqIE1hdGgucG93KDIsIChtaWRpIC0gNjkpIC8gMTIpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgZnJlcXVlbmN5IHZhbHVlIHRvIGEgTUlESSBub3RlLlxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSB2YWx1ZSB0byBmcmVxdWVuY3kgdmFsdWUgdG8gY29udmVydC5cblx0XHQgKiAgQHJldHVybnMgIHtNSURJfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHRvbmUubWlkaVRvRnJlcXVlbmN5KDQ0MCk7IC8vIHJldHVybnMgNjlcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5LnByb3RvdHlwZS5mcmVxdWVuY3lUb01pZGkgPSBmdW5jdGlvbiAoZnJlcXVlbmN5KSB7XG5cdCAgICAgICAgcmV0dXJuIDY5ICsgTWF0aC5yb3VuZCgxMiAqIE1hdGgubG9nKGZyZXF1ZW5jeSAvIFRvbmUuRnJlcXVlbmN5LkE0KSAvIE1hdGguTE4yKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GcmVxdWVuY3k7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5UcmFuc3BvcnRUaW1lIGlzIGEgdGhlIHRpbWUgYWxvbmcgdGhlIFRyYW5zcG9ydCdzXG5cdFx0ICogICAgICAgICB0aW1lbGluZS4gSXQgaXMgc2ltaWxhciB0byBUb25lLlRpbWUsIGJ1dCBpbnN0ZWFkIG9mIGV2YWx1YXRpbmdcblx0XHQgKiAgICAgICAgIGFnYWluc3QgdGhlIEF1ZGlvQ29udGV4dCdzIGNsb2NrLCBpdCBpcyBldmFsdWF0ZWQgYWdhaW5zdFxuXHRcdCAqICAgICAgICAgdGhlIFRyYW5zcG9ydCdzIHBvc2l0aW9uLiBTZWUgW1RyYW5zcG9ydFRpbWUgd2lraV0oaHR0cHM6Ly9naXRodWIuY29tL1RvbmVqcy9Ub25lLmpzL3dpa2kvVHJhbnNwb3J0VGltZSkuXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdmFsICAgIFRoZSB0aW1lIHZhbHVlIGFzIGEgbnVtYmVyIG9yIHN0cmluZ1xuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmc9fSAgdW5pdHMgIFVuaXQgdmFsdWVzXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWV9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUgPSBmdW5jdGlvbiAodmFsLCB1bml0cykge1xuXHQgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVG9uZS5UcmFuc3BvcnRUaW1lKSB7XG5cdCAgICAgICAgICAgIFRvbmUuVGltZS5jYWxsKHRoaXMsIHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5UcmFuc3BvcnRUaW1lKHZhbCwgdW5pdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRyYW5zcG9ydFRpbWUsIFRvbmUuVGltZSk7XG5cdCAgICAvL2Nsb25lIHRoZSBleHByZXNzaW9ucyBzbyB0aGF0IFxuXHQgICAgLy93ZSBjYW4gYWRkIG1vcmUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zID0gT2JqZWN0LmNyZWF0ZShUb25lLlRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zKTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGRzIGFuIGFkZGl0aW9uYWwgdW5hcnkgZXhwcmVzc2lvblxuXHRcdCAqICB3aGljaCBxdWFudGl6ZXMgdmFsdWVzIHRvIHRoZSBuZXh0IHN1YmRpdmlzaW9uXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLl91bmFyeUV4cHJlc3Npb25zLnF1YW50aXplID0ge1xuXHQgICAgICAgIHJlZ2V4cDogL15ALyxcblx0ICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChyaCkge1xuXHQgICAgICAgICAgICB2YXIgc3ViZGl2aXNpb24gPSB0aGlzLl9zZWNvbmRzVG9UaWNrcyhyaCgpKTtcblx0ICAgICAgICAgICAgdmFyIG11bHRpcGxlID0gTWF0aC5jZWlsKFRvbmUuVHJhbnNwb3J0LnRpY2tzIC8gc3ViZGl2aXNpb24pO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGlja3NUb1VuaXRzKG11bHRpcGxlICogc3ViZGl2aXNpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBzZWNvbmRzIGludG8gdGlja3Ncblx0XHQgKiAgQHBhcmFtIHtTZWNvbmRzfSBzZWNvbmRzXG5cdFx0ICogIEByZXR1cm4gIHtUaWNrc31cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZS5wcm90b3R5cGUuX3NlY29uZHNUb1RpY2tzID0gZnVuY3Rpb24gKHNlY29uZHMpIHtcblx0ICAgICAgICB2YXIgcXVhcnRlclRpbWUgPSB0aGlzLl9iZWF0c1RvVW5pdHMoMSk7XG5cdCAgICAgICAgdmFyIHF1YXJ0ZXJzID0gc2Vjb25kcyAvIHF1YXJ0ZXJUaW1lO1xuXHQgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHF1YXJ0ZXJzICogVG9uZS5UcmFuc3BvcnQuUFBRKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRXZhbHVhdGUgdGhlIHRpbWUgZXhwcmVzc2lvbi4gUmV0dXJucyB2YWx1ZXMgaW4gdGlja3Ncblx0XHQgKiAgQHJldHVybiB7VGlja3N9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuX3NlY29uZHNUb1RpY2tzKHRoaXMuX2V4cHIoKSk7XG5cdCAgICAgICAgcmV0dXJuIHZhbCArICh0aGlzLl9wbHVzTm93ID8gVG9uZS5UcmFuc3BvcnQudGlja3MgOiAwKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGluIHRpY2tzLlxuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gdGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge1NlY29uZHN9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWUucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5fZXhwcigpO1xuXHQgICAgICAgIHJldHVybiB2YWwgKyAodGhpcy5fcGx1c05vdyA/IFRvbmUuVHJhbnNwb3J0LnNlY29uZHMgOiAwKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSB0aW1lIGFzIGEgZnJlcXVlbmN5IHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtGcmVxdWVuY3l9IFxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gMSAvIHRoaXMudG9TZWNvbmRzKCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0VFlQRVNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogVW5pdHMgd2hpY2ggYSB2YWx1ZSBjYW4gdGFrZSBvbi5cblx0XHQgKiBAZW51bSB7U3RyaW5nfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UeXBlID0ge1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIERlZmF1bHQgdW5pdHNcblx0XHRcdCAqICBAdHlwZWRlZiB7RGVmYXVsdH1cblx0XHRcdCAqL1xuXHQgICAgICAgIERlZmF1bHQ6ICdudW1iZXInLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRpbWUgY2FuIGJlIGRlc2NyaWJlZCBpbiBhIG51bWJlciBvZiB3YXlzLiBSZWFkIG1vcmUgW1RpbWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RpbWUpLlxuXHRcdFx0ICpcblx0XHRcdCAqICAqIE51bWJlcnMsIHdoaWNoIHdpbGwgYmUgdGFrZW4gbGl0ZXJhbGx5IGFzIHRoZSB0aW1lIChpbiBzZWNvbmRzKS5cblx0XHRcdCAqICAqIE5vdGF0aW9uLCAoXCI0blwiLCBcIjh0XCIpIGRlc2NyaWJlcyB0aW1lIGluIEJQTSBhbmQgdGltZSBzaWduYXR1cmUgcmVsYXRpdmUgdmFsdWVzLlxuXHRcdFx0ICogICogVHJhbnNwb3J0VGltZSwgKFwiNDozOjJcIikgd2lsbCBhbHNvIHByb3ZpZGUgdGVtcG8gYW5kIHRpbWUgc2lnbmF0dXJlIHJlbGF0aXZlIHRpbWVzXG5cdFx0XHQgKiAgaW4gdGhlIGZvcm0gQkFSUzpRVUFSVEVSUzpTSVhURUVOVEhTLlxuXHRcdFx0ICogICogRnJlcXVlbmN5LCAoXCI4aHpcIikgaXMgY29udmVydGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIGN5Y2xlIGluIHNlY29uZHMuXG5cdFx0XHQgKiAgKiBOb3ctUmVsYXRpdmUsIChcIisxXCIpIHByZWZpeCBhbnkgb2YgdGhlIGFib3ZlIHdpdGggXCIrXCIgYW5kIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcblx0XHRcdCAqICBcInRoZSBjdXJyZW50IHRpbWUgcGx1cyB3aGF0ZXZlciBleHByZXNzaW9uIGZvbGxvd3NcIi5cblx0XHRcdCAqICAqIEV4cHJlc3Npb25zLCAoXCIzOjAgKyAyIC0gKDFtIC8gNylcIikgYW55IG9mIHRoZSBhYm92ZSBjYW4gYWxzbyBiZSBjb21iaW5lZFxuXHRcdFx0ICogIGludG8gYSBtYXRoZW1hdGljYWwgZXhwcmVzc2lvbiB3aGljaCB3aWxsIGJlIGV2YWx1YXRlZCB0byBjb21wdXRlIHRoZSBkZXNpcmVkIHRpbWUuXG5cdFx0XHQgKiAgKiBObyBBcmd1bWVudCwgZm9yIG1ldGhvZHMgd2hpY2ggYWNjZXB0IHRpbWUsIG5vIGFyZ3VtZW50IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcblx0XHRcdCAqICBcIm5vd1wiIChpLmUuIHRoZSBjdXJyZW50VGltZSkuXG5cdFx0XHQgKlxuXHRcdFx0ICogIEB0eXBlZGVmIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgVGltZTogJ3RpbWUnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEZyZXF1ZW5jeSBjYW4gYmUgZGVzY3JpYmVkIHNpbWlsYXIgdG8gdGltZSwgZXhjZXB0IHVsdGltYXRlbHkgdGhlXG5cdFx0XHQgKiAgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gZnJlcXVlbmN5IGluc3RlYWQgb2Ygc2Vjb25kcy4gQSBudW1iZXJcblx0XHRcdCAqICBpcyB0YWtlbiBsaXRlcmFsbHkgYXMgdGhlIHZhbHVlIGluIGhlcnR6LiBBZGRpdGlvbmFsbHkgYW55IG9mIHRoZVxuXHRcdFx0ICogIFRpbWUgZW5jb2RpbmdzIGNhbiBiZSB1c2VkLiBOb3RlIG5hbWVzIGluIHRoZSBmb3JtXG5cdFx0XHQgKiAgb2YgTk9URSBPQ1RBVkUgKGkuZS4gQzQpIGFyZSBhbHNvIGFjY2VwdGVkIGFuZCBjb252ZXJ0ZWQgdG8gdGhlaXJcblx0XHRcdCAqICBmcmVxdWVuY3kgdmFsdWUuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0ZyZXF1ZW5jeX1cblx0XHRcdCAqL1xuXHQgICAgICAgIEZyZXF1ZW5jeTogJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVHJhbnNwb3J0VGltZSBkZXNjcmliZXMgYSBwb3NpdGlvbiBhbG9uZyB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmUuIEl0IGlzXG5cdFx0XHQgKiAgc2ltaWxhciB0byBUaW1lIGluIHRoYXQgaXQgdXNlcyBhbGwgdGhlIHNhbWUgZW5jb2RpbmdzLCBidXQgVHJhbnNwb3J0VGltZSBzcGVjaWZpY2FsbHlcblx0XHRcdCAqICBwZXJ0YWlucyB0byB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmUsIHdoaWNoIGlzIHN0YXJ0YWJsZSwgc3RvcHBhYmxlLCBsb29wYWJsZSwgYW5kIHNlZWthYmxlLlxuXHRcdFx0ICogIFtSZWFkIG1vcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Ub25lanMvVG9uZS5qcy93aWtpL1RyYW5zcG9ydFRpbWUpXG5cdFx0XHQgKiAgQHR5cGVkZWYge1RyYW5zcG9ydFRpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICBUcmFuc3BvcnRUaW1lOiAndHJhbnNwb3J0VGltZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGlja3MgYXJlIHRoZSBiYXNpYyBzdWJ1bml0IG9mIHRoZSBUcmFuc3BvcnQuIFRoZXkgYXJlXG5cdFx0XHQgKiAgdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGltZSB0aGF0IHRoZSBUcmFuc3BvcnQgc3VwcG9ydHMuXG5cdFx0XHQgKiAgQHR5cGVkZWYge1RpY2tzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgVGlja3M6ICd0aWNrcycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgTm9ybWFsIHZhbHVlcyBhcmUgd2l0aGluIHRoZSByYW5nZSBbMCwgMV0uXG5cdFx0XHQgKiAgQHR5cGVkZWYge05vcm1hbFJhbmdlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgTm9ybWFsUmFuZ2U6ICdub3JtYWxSYW5nZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQXVkaW9SYW5nZSB2YWx1ZXMgYXJlIGJldHdlZW4gWy0xLCAxXS5cblx0XHRcdCAqICBAdHlwZWRlZiB7QXVkaW9SYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIEF1ZGlvUmFuZ2U6ICdhdWRpb1JhbmdlJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBEZWNpYmVscyBhcmUgYSBsb2dhcml0aG1pYyB1bml0IG9mIG1lYXN1cmVtZW50IHdoaWNoIGlzIHVzZWZ1bCBmb3Igdm9sdW1lXG5cdFx0XHQgKiAgYmVjYXVzZSBvZiB0aGUgbG9nYXJpdGhtaWMgd2F5IHRoYXQgd2UgcGVyY2VpdmUgbG91ZG5lc3MuIDAgZGVjaWJlbHNcblx0XHRcdCAqICBtZWFucyBubyBjaGFuZ2UgaW4gdm9sdW1lLiAtMTBkYiBpcyBhcHByb3hpbWF0ZWx5IGhhbGYgYXMgbG91ZCBhbmQgMTBkYlxuXHRcdFx0ICogIGlzIHR3aWNlIGlzIGxvdWQuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0RlY2liZWxzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgRGVjaWJlbHM6ICdkYicsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGFsZi1zdGVwIG5vdGUgaW5jcmVtZW50cywgaS5lLiAxMiBpcyBhbiBvY3RhdmUgYWJvdmUgdGhlIHJvb3QuIGFuZCAxIGlzIGEgaGFsZi1zdGVwIHVwLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtJbnRlcnZhbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIEludGVydmFsOiAnaW50ZXJ2YWwnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEJlYXRzIHBlciBtaW51dGUuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0JQTX1cblx0XHRcdCAqL1xuXHQgICAgICAgIEJQTTogJ2JwbScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAuXG5cdFx0XHQgKiAgQHR5cGVkZWYge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgUG9zaXRpdmU6ICdwb3NpdGl2ZScsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgR2FpbiBpcyB0aGUgcmF0aW8gYmV0d2VlbiBpbnB1dCBhbmQgb3V0cHV0IG9mIGEgc2lnbmFsLlxuXHRcdFx0ICogIEEgZ2FpbiBvZiAwIGlzIHRoZSBzYW1lIGFzIHNpbGVuY2luZyB0aGUgc2lnbmFsLiBBIGdhaW4gb2Zcblx0XHRcdCAqICAxLCBjYXVzZXMgbm8gY2hhbmdlIHRvIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0dhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICBHYWluOiAnZ2FpbicsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBjZW50IGlzIGEgaHVuZHJlZHRoIG9mIGEgc2VtaXRvbmUuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0NlbnRzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgQ2VudHM6ICdjZW50cycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQW5nbGUgYmV0d2VlbiAwIGFuZCAzNjAuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0RlZ3JlZXN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBEZWdyZWVzOiAnZGVncmVlcycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBudW1iZXIgcmVwcmVzZW50aW5nIGEgbWlkaSBub3RlLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtNSURJfVxuXHRcdFx0ICovXG5cdCAgICAgICAgTUlESTogJ21pZGknLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgY29sb24tc2VwYXJhdGVkIHJlcHJlc2VudGF0aW9uIG9mIHRpbWUgaW4gdGhlIGZvcm0gb2Zcblx0XHRcdCAqICBCYXJzOkJlYXRzOlNpeHRlZW50aHMuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0JhcnNCZWF0c1NpeHRlZW50aHN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBCYXJzQmVhdHNTaXh0ZWVudGhzOiAnYmFyc0JlYXRzU2l4dGVlbnRocycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2FtcGxpbmcgaXMgdGhlIHJlZHVjdGlvbiBvZiBhIGNvbnRpbnVvdXMgc2lnbmFsIHRvIGEgZGlzY3JldGUgc2lnbmFsLlxuXHRcdFx0ICogIEF1ZGlvIGlzIHR5cGljYWxseSBzYW1wbGVkIDQ0MTAwIHRpbWVzIHBlciBzZWNvbmQuXG5cdFx0XHQgKiAgQHR5cGVkZWYge1NhbXBsZXN9XG5cdFx0XHQgKi9cblx0ICAgICAgICBTYW1wbGVzOiAnc2FtcGxlcycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSGVydHogYXJlIGEgZnJlcXVlbmN5IHJlcHJlc2VudGF0aW9uIGRlZmluZWQgYXMgb25lIGN5Y2xlIHBlciBzZWNvbmQuXG5cdFx0XHQgKiAgQHR5cGVkZWYge0hlcnR6fVxuXHRcdFx0ICovXG5cdCAgICAgICAgSGVydHo6ICdoZXJ0eicsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQSBmcmVxdWVuY3kgcmVwcmVzZW50ZWQgYnkgYSBsZXR0ZXIgbmFtZSxcblx0XHRcdCAqICBhY2NpZGVudGFsIGFuZCBvY3RhdmUuIFRoaXMgc3lzdGVtIGlzIGtub3duIGFzXG5cdFx0XHQgKiAgW1NjaWVudGlmaWMgUGl0Y2ggTm90YXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NjaWVudGlmaWNfcGl0Y2hfbm90YXRpb24pLlxuXHRcdFx0ICogIEB0eXBlZGVmIHtOb3RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgTm90ZTogJ25vdGUnLFxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIE9uZSBtaWxsaXNlY29uZCBpcyBhIHRob3VzYW5kdGggb2YgYSBzZWNvbmQuXG5cdFx0XHQgKiAgQHR5cGVkZWYge01pbGxpc2Vjb25kc31cblx0XHRcdCAqL1xuXHQgICAgICAgIE1pbGxpc2Vjb25kczogJ21pbGxpc2Vjb25kcycsXG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2Vjb25kcyBhcmUgdGhlIHRpbWUgdW5pdCBvZiB0aGUgQXVkaW9Db250ZXh0LiBJbiB0aGUgZW5kLFxuXHRcdFx0ICogIGFsbCB2YWx1ZXMgbmVlZCB0byBiZSBldmFsdWF0ZWQgdG8gc2Vjb25kcy5cblx0XHRcdCAqICBAdHlwZWRlZiB7U2Vjb25kc31cblx0XHRcdCAqL1xuXHQgICAgICAgIFNlY29uZHM6ICdzZWNvbmRzJyxcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHN0cmluZyByZXByZXNlbnRpbmcgYSBkdXJhdGlvbiByZWxhdGl2ZSB0byBhIG1lYXN1cmUuXG5cdFx0XHQgKiAgKiBcIjRuXCIgPSBxdWFydGVyIG5vdGVcblx0XHRcdCAqICAqIFwiMm1cIiA9IHR3byBtZWFzdXJlc1xuXHRcdFx0ICogICogXCI4dFwiID0gZWlnaHRoLW5vdGUgdHJpcGxldFxuXHRcdFx0ICogIEB0eXBlZGVmIHtOb3RhdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIE5vdGF0aW9uOiAnbm90YXRpb24nXG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBBVUdNRU5UIFRPTkUncyBQUk9UT1RZUEVcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgVGltZSBpbnRvIHNlY29uZHMuXG5cdFx0ICpcblx0XHQgKiAgVW5saWtlIHRoZSBtZXRob2Qgd2hpY2ggaXQgb3ZlcnJpZGVzLCB0aGlzIHRha2VzIGludG8gYWNjb3VudFxuXHRcdCAqICB0cmFuc3BvcnR0aW1lIGFuZCBtdXNpY2FsIG5vdGF0aW9uLlxuXHRcdCAqXG5cdFx0ICogIFRpbWUgOiAxLjQwXG5cdFx0ICogIE5vdGF0aW9uOiA0biBvciAxbSBvciAydFxuXHRcdCAqICBOb3cgUmVsYXRpdmU6ICszblxuXHRcdCAqICBNYXRoOiAzbisxNm4gb3IgZXZlbiBjb21wbGljYXRlZCBleHByZXNzaW9ucyAoKDNuKjIpLzYgKyAxKVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWVcblx0XHQgKiAgQHJldHVybiB7U2Vjb25kc31cblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnRvU2Vjb25kcyA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRpbWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzVW5kZWYodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMubm93KCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgVG9uZS5UaW1lKHRpbWUpLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIFRvbmUuVGltZUJhc2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRpbWUudG9TZWNvbmRzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgZnJlcXVlbmN5IHJlcHJlc2VudGF0aW9uIGludG8gYSBudW1iZXIuXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gZnJlcVxuXHRcdCAqICBAcmV0dXJuIHtIZXJ0en0gICAgICB0aGUgZnJlcXVlbmN5IGluIGhlcnR6XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS50b0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIoZnJlcSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZyZXE7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKGZyZXEpIHx8IFRvbmUuaXNVbmRlZihmcmVxKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFRvbmUuRnJlcXVlbmN5KGZyZXEpLnZhbHVlT2YoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGZyZXEgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmcmVxLnRvRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb252ZXJ0IGEgdGltZSByZXByZXNlbnRhdGlvbiBpbnRvIHRpY2tzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lXG5cdFx0ICogIEByZXR1cm4ge1RpY2tzfSAgdGhlIHRpbWUgaW4gdGlja3Ncblx0XHQgKi9cblx0ICAgIFRvbmUucHJvdG90eXBlLnRvVGlja3MgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKHRpbWUpIHx8IFRvbmUuaXNTdHJpbmcodGltZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLlRyYW5zcG9ydFRpbWUodGltZSkudG9UaWNrcygpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydC50aWNrcztcblx0ICAgICAgICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBUb25lLlRpbWVCYXNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aW1lLnRvVGlja3MoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhcmFtIHdyYXBzIHRoZSBuYXRpdmUgV2ViIEF1ZGlvJ3MgQXVkaW9QYXJhbSB0byBwcm92aWRlXG5cdFx0ICogICAgICAgICBhZGRpdGlvbmFsIHVuaXQgY29udmVyc2lvbiBmdW5jdGlvbmFsaXR5LiBJdCBhbHNvXG5cdFx0ICogICAgICAgICBzZXJ2ZXMgYXMgYSBiYXNlLWNsYXNzIGZvciBjbGFzc2VzIHdoaWNoIGhhdmUgYSBzaW5nbGUsXG5cdFx0ICogICAgICAgICBhdXRvbWF0YWJsZSBwYXJhbWV0ZXIuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtICB7QXVkaW9QYXJhbX0gIHBhcmFtICBUaGUgcGFyYW1ldGVyIHRvIHdyYXAuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuVHlwZX0gdW5pdHMgVGhlIHVuaXRzIG9mIHRoZSBhdWRpbyBwYXJhbS5cblx0XHQgKiAgQHBhcmFtICB7Qm9vbGVhbn0gY29udmVydCBJZiB0aGUgcGFyYW0gc2hvdWxkIGJlIGNvbnZlcnRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncGFyYW0nLFxuXHQgICAgICAgICAgICAndW5pdHMnLFxuXHQgICAgICAgICAgICAnY29udmVydCdcblx0ICAgICAgICBdLCBUb25lLlBhcmFtKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBuYXRpdmUgcGFyYW1ldGVyIHRvIGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSAge0F1ZGlvUGFyYW19XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dCA9IG9wdGlvbnMucGFyYW07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHVuaXRzIG9mIHRoZSBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy51bml0cyA9IG9wdGlvbnMudW5pdHM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIHZhbHVlIHNob3VsZCBiZSBjb252ZXJ0ZWQgb3Igbm90XG5cdFx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNvbnZlcnQgPSBvcHRpb25zLmNvbnZlcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVHJ1ZSBpZiB0aGUgc2lnbmFsIHZhbHVlIGlzIGJlaW5nIG92ZXJyaWRkZW4gYnlcblx0XHRcdCAqICBhIGNvbm5lY3RlZCBzaWduYWwuXG5cdFx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0XHQgKiAgQHR5cGUgIHtib29sZWFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm92ZXJyaWRkZW4gPSBmYWxzZTtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihvcHRpb25zLnZhbHVlKSkge1xuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXJhbSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlZmF1bHQsXG5cdCAgICAgICAgJ2NvbnZlcnQnOiB0cnVlLFxuXHQgICAgICAgICdwYXJhbSc6IHVuZGVmaW5lZFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGFyYW0jXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFyYW0ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3BhcmFtLnZhbHVlKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWwgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLnZhbHVlID0gY29udmVydGVkVmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIGZyb20gdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IFRvbmUuUGFyYW0udW5pdHNcblx0XHQgKiAgaW50byB0aGUgZGVzdGluYXRpb24gdmFsdWUgKHN1Y2ggYXMgR2FpbiBvciBGcmVxdWVuY3kpLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHsqfSB2YWwgdGhlIHZhbHVlIHRvIGNvbnZlcnRcblx0XHQgKiAgQHJldHVybiB7bnVtYmVyfSAgICAgdGhlIG51bWJlciB3aGljaCB0aGUgdmFsdWUgc2hvdWxkIGJlIHNldCB0b1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuX2Zyb21Vbml0cyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAodGhpcy5jb252ZXJ0IHx8IFRvbmUuaXNVbmRlZih0aGlzLmNvbnZlcnQpKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAodGhpcy51bml0cykge1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5UaW1lOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TZWNvbmRzKHZhbCk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLkZyZXF1ZW5jeTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRnJlcXVlbmN5KHZhbCk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLkRlY2liZWxzOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFRvbmUuZGJUb0dhaW4odmFsKTtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLlR5cGUuTm9ybWFsUmFuZ2U6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCAwKSwgMSk7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLkF1ZGlvUmFuZ2U6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsLCAtMSksIDEpO1xuXHQgICAgICAgICAgICBjYXNlIFRvbmUuVHlwZS5Qb3NpdGl2ZTpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWwsIDApO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENvbnZlcnQgdGhlIHBhcmFtZXRlcnMgdmFsdWUgaW50byB0aGUgdW5pdHMgc3BlY2lmaWVkIGJ5IFRvbmUuUGFyYW0udW5pdHMuXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbCB0aGUgdmFsdWUgdG8gY29udmVydFxuXHRcdCAqIEByZXR1cm4ge251bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLl90b1VuaXRzID0gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnZlcnQgfHwgVG9uZS5pc1VuZGVmKHRoaXMuY29udmVydCkpIHtcblx0ICAgICAgICAgICAgc3dpdGNoICh0aGlzLnVuaXRzKSB7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5UeXBlLkRlY2liZWxzOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFRvbmUuZ2FpblRvRGIodmFsKTtcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIG1pbmltdW0gb3V0cHV0IHZhbHVlXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5fbWluT3V0cHV0ID0gMC4wMDAwMTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYSBwYXJhbWV0ZXIgdmFsdWUgY2hhbmdlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0geyp9XHR2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBzaWduYWwuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gIHRpbWUgVGhlIHRpbWUgd2hlbiB0aGUgY2hhbmdlIHNob3VsZCBvY2N1ci5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3NldCB0aGUgZnJlcXVlbmN5IHRvIFwiRzRcIiBpbiBleGFjdGx5IDEgc2Vjb25kIGZyb20gbm93LlxuXHRcdCAqIGZyZXEuc2V0VmFsdWVBdFRpbWUoXCJHNFwiLCBcIisxXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgVG9uZS5pc1Bhc3QodGltZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUodGhpcy5fZnJvbVVuaXRzKHZhbHVlKSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENyZWF0ZXMgYSBzY2hlZHVsZSBwb2ludCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGF0IHRoZSBjdXJyZW50IHRpbWUuXG5cdFx0ICogIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhbiBhdXRvbWF0aW9uIGFuY2hvciBwb2ludCBpbiBvcmRlciB0b1xuXHRcdCAqICBzY2hlZHVsZSBjaGFuZ2VzIGZyb20gdGhlIGN1cnJlbnQgdmFsdWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSBub3cgKE9wdGlvbmFsbHkpIHBhc3MgdGhlIG5vdyB2YWx1ZSBpbi5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLnNldFJhbXBQb2ludCA9IGZ1bmN0aW9uIChub3cpIHtcblx0ICAgICAgICBub3cgPSBUb25lLmRlZmF1bHRBcmcobm93LCB0aGlzLm5vdygpKTtcblx0ICAgICAgICB0aGlzLmNhbmNlbEFuZEhvbGRBdFRpbWUodGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lKTtcblx0ICAgICAgICB2YXIgY3VycmVudFZhbCA9IHRoaXMuX3BhcmFtLnZhbHVlO1xuXHQgICAgICAgIGlmIChjdXJyZW50VmFsID09PSAwKSB7XG5cdCAgICAgICAgICAgIGN1cnJlbnRWYWwgPSB0aGlzLl9taW5PdXRwdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGNhbmNlbCBhbmQgaG9sZCBhdCB0aGUgZ2l2ZW4gdGltZVxuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFZhbHVlQXRUaW1lKGN1cnJlbnRWYWwsIG5vdyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhIGxpbmVhciBjb250aW51b3VzIGNoYW5nZSBpbiBwYXJhbWV0ZXIgdmFsdWUgZnJvbSB0aGVcblx0XHQgKiAgcHJldmlvdXMgc2NoZWR1bGVkIHBhcmFtZXRlciB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBlbmRUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kVGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICBlbmRUaW1lID0gdGhpcy50b1NlY29uZHMoZW5kVGltZSk7XG5cdCAgICAgICAgVG9uZS5pc1Bhc3QoZW5kVGltZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwYXJhbWV0ZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kVGltZSkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHRoaXMuX21pbk91dHB1dCwgdmFsdWUpO1xuXHQgICAgICAgIGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0ICAgICAgICBUb25lLmlzUGFzdChlbmRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHZhbHVlLCBlbmRUaW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGFuIGV4cG9uZW50aWFsIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tXG5cdFx0ICogIHRoZSBjdXJyZW50IHRpbWUgYW5kIGN1cnJlbnQgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlIG92ZXIgdGhlXG5cdFx0ICogIGR1cmF0aW9uIG9mIHRoZSByYW1wVGltZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlICAgVGhlIHZhbHVlIHRvIHJhbXAgdG8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIHRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgdG8gcmFtcCBmcm9tIGl0J3MgY3VycmVudCB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9XHRbc3RhcnRUaW1lPW5vd10gXHRXaGVuIHRoZSByYW1wIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2V4cG9uZW50aWFsbHkgcmFtcCB0byB0aGUgdmFsdWUgMiBvdmVyIDQgc2Vjb25kcy5cblx0XHQgKiBzaWduYWwuZXhwb25lbnRpYWxSYW1wVG8oMiwgNCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSk7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSArIHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlcyBhbiBsaW5lYXIgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIGN1cnJlbnQgdGltZSBhbmQgY3VycmVudCB2YWx1ZSB0byB0aGUgZ2l2ZW4gdmFsdWUgb3ZlciB0aGVcblx0XHQgKiAgZHVyYXRpb24gb2YgdGhlIHJhbXBUaW1lLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gcmFtcFRpbWUgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSB0byByYW1wIGZyb20gaXQncyBjdXJyZW50IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZX1cdFtzdGFydFRpbWU9bm93XSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbGluZWFybHkgcmFtcCB0byB0aGUgdmFsdWUgNCBvdmVyIDMgc2Vjb25kcy5cblx0XHQgKiBzaWduYWwubGluZWFyUmFtcFRvKDQsIDMpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUubGluZWFyUmFtcFRvID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIHN0YXJ0VGltZSArIHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gU2luY2UgaXRcblx0XHQgKiAgaXMgYW4gZXhwb25lbnRpYWwgYXBwcm9hY2ggaXQgd2lsbCBjb250aW51ZSBhcHByb2FjaGluZyBhZnRlciB0aGUgcmFtcCBkdXJhdGlvbi4gVGhlXG5cdFx0ICogIHJhbXBUaW1lIGlzIHRoZSB0aW1lIHRoYXQgaXQgdGFrZXMgdG8gcmVhY2ggb3ZlciA5OSUgb2YgdGhlIHdheSB0b3dhcmRzIHRoZSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSAgIFRoZSB2YWx1ZSB0byByYW1wIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9leHBvbmVudGlhbGx5IHJhbXAgdG8gdGhlIHZhbHVlIDIgb3ZlciA0IHNlY29uZHMuXG5cdFx0ICogc2lnbmFsLmV4cG9uZW50aWFsUmFtcFRvKDIsIDQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUudGFyZ2V0UmFtcFRvID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuZXhwb25lbnRpYWxBcHByYW9jaFZhbHVlQXRUaW1lKHZhbHVlLCBzdGFydFRpbWUsIHJhbXBUaW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgZXhwb25lbnRpYWxseSBhcHByb2FjaGluZyB0aGUgdGFyZ2V0IHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBTaW5jZSBpdFxuXHRcdCAqICBpcyBhbiBleHBvbmVudGlhbCBhcHByb2FjaCBpdCB3aWxsIGNvbnRpbnVlIGFwcHJvYWNoaW5nIGFmdGVyIHRoZSByYW1wIGR1cmF0aW9uLiBUaGVcblx0XHQgKiAgcmFtcFRpbWUgaXMgdGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0byByZWFjaCBvdmVyIDk5JSBvZiB0aGUgd2F5IHRvd2FyZHMgdGhlIHZhbHVlLiBUaGlzIG1ldGhvZHNcblx0XHQgKiAgaXMgc2ltaWxhciB0byBzZXRUYXJnZXRBdFRpbWUgZXhjZXB0IHRoZSB0aGlyZCBhcmd1bWVudCBpcyBhIHRpbWUgaW5zdGVhZCBvZiBhICd0aW1lQ29uc3RhbnQnXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWUgICBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0dGltZSBcdFdoZW4gdGhlIHJhbXAgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSByYW1wVGltZSB0aGUgdGltZSB0aGF0IGl0IHRha2VzIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2V4cG9uZW50aWFsbHkgcmFtcCB0byB0aGUgdmFsdWUgMiBvdmVyIDQgc2Vjb25kcy5cblx0XHQgKiBzaWduYWwuZXhwb25lbnRpYWxSYW1wVG8oMiwgNCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5leHBvbmVudGlhbEFwcHJhb2NoVmFsdWVBdFRpbWUgPSBmdW5jdGlvbiAodmFsdWUsIHRpbWUsIHJhbXBUaW1lKSB7XG5cdCAgICAgICAgdmFyIHRpbWVDb25zdGFudCA9IE1hdGgubG9nKHRoaXMudG9TZWNvbmRzKHJhbXBUaW1lKSArIDEpIC8gTWF0aC5sb2coMjAwKTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgVG9uZS5pc1Bhc3QodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUsIHRpbWVDb25zdGFudCkge1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAvLyBUaGUgdmFsdWUgd2lsbCBuZXZlciBiZSBhYmxlIHRvIGFwcHJvYWNoIHdpdGhvdXQgdGltZUNvbnN0YW50ID4gMC5cblx0ICAgICAgICBpZiAodGltZUNvbnN0YW50IDw9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aW1lQ29uc3RhbnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wYXJhbS5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMudG9TZWNvbmRzKHN0YXJ0VGltZSksIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHBhcmFtZXRlciB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBkdXJhdGlvblxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuc2V0VmFsdWVDdXJ2ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZXMsIHN0YXJ0VGltZSwgZHVyYXRpb24pIHtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIHRoaXMuc2V0VmFsdWVBdFRpbWUodmFsdWVzWzBdLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIHZhciBzZWdUaW1lID0gZHVyYXRpb24gLyAodmFsdWVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuX2Zyb21Vbml0cyh2YWx1ZXNbaV0pLCBzdGFydFRpbWUgKyBpICogc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWxzIGFsbCBzY2hlZHVsZWQgcGFyYW1ldGVyIGNoYW5nZXMgd2l0aCB0aW1lcyBncmVhdGVyIHRoYW4gb3Jcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYXJhbX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzID0gZnVuY3Rpb24gKHN0YXJ0VGltZSkge1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhpcyBpcyBzaW1pbGFyIHRvIFtjYW5jZWxTY2hlZHVsZWRWYWx1ZXNdKCNjYW5jZWxTY2hlZHVsZWRWYWx1ZXMpIGV4Y2VwdFxuXHRcdCAqICBpdCBob2xkcyB0aGUgYXV0b21hdGVkIHZhbHVlIGF0IGNhbmNlbFRpbWUgdW50aWwgdGhlIG5leHQgYXV0b21hdGVkIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBjYW5jZWxUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcmFtLnByb3RvdHlwZS5jYW5jZWxBbmRIb2xkQXRUaW1lID0gZnVuY3Rpb24gKGNhbmNlbFRpbWUpIHtcblx0ICAgICAgICBjYW5jZWxUaW1lID0gdGhpcy50b1NlY29uZHMoY2FuY2VsVGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3BhcmFtLmNhbmNlbEFuZEhvbGRBdFRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0uY2FuY2VsQW5kSG9sZEF0VGltZShjYW5jZWxUaW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL2ZhbGxiYWNrIGZvciB1bnN1cHBvcnRlZCBicm93c2Vyc1xuXHQgICAgICAgICAgICAvL2Nhbid0IGNhbmNlbCBhbmQgaG9sZCBhdCBhbnkgdGltZSBpbiB0aGUgZnV0dXJlXG5cdCAgICAgICAgICAgIC8vanVzdCBkbyBpdCBpbW1lZGlhdGVseSBmb3IgZ2FwbGVzcyBhdXRvbWF0aW9uIGN1cnZlc1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJhbS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMobm93KTtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSB0aGlzLl9wYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWwgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnRWYWwgPSB0aGlzLl9taW5PdXRwdXQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0uc2V0VmFsdWVBdFRpbWUoY3VycmVudFZhbCwgbm93ICsgdGhpcy5zYW1wbGVUaW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJhbXBzIHRvIHRoZSBnaXZlbiB2YWx1ZSBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFtcFRpbWUuXG5cdFx0ICogIEF1dG9tYXRpY2FsbHkgc2VsZWN0cyB0aGUgYmVzdCByYW1wIHR5cGUgKGV4cG9uZW50aWFsIG9yIGxpbmVhcilcblx0XHQgKiAgZGVwZW5kaW5nIG9uIHRoZSBgdW5pdHNgIG9mIHRoZSBzaWduYWxcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHJhbXBUaW1lIFx0VGhlIHRpbWUgdGhhdCBpdCB0YWtlcyB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIHRvIHJhbXAgZnJvbSBpdCdzIGN1cnJlbnQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lfVx0W3N0YXJ0VGltZT1ub3ddIFx0V2hlbiB0aGUgcmFtcCBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcmFtfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yYW1wIHRvIHRoZSB2YWx1ZSBlaXRoZXIgbGluZWFybHkgb3IgZXhwb25lbnRpYWxseVxuXHRcdCAqIC8vZGVwZW5kaW5nIG9uIHRoZSBcInVuaXRzXCIgdmFsdWUgb2YgdGhlIHNpZ25hbFxuXHRcdCAqIHNpZ25hbC5yYW1wVG8oMCwgMTApO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc2NoZWR1bGUgaXQgdG8gcmFtcCBzdGFydGluZyBhdCBhIHNwZWNpZmljIHRpbWVcblx0XHQgKiBzaWduYWwucmFtcFRvKDAsIDEwLCA1KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJhbS5wcm90b3R5cGUucmFtcFRvID0gZnVuY3Rpb24gKHZhbHVlLCByYW1wVGltZSwgc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgcmFtcFRpbWUgPSBUb25lLmRlZmF1bHRBcmcocmFtcFRpbWUsIDAuMSk7XG5cdCAgICAgICAgaWYgKHRoaXMudW5pdHMgPT09IFRvbmUuVHlwZS5GcmVxdWVuY3kgfHwgdGhpcy51bml0cyA9PT0gVG9uZS5UeXBlLkJQTSB8fCB0aGlzLnVuaXRzID09PSBUb25lLlR5cGUuRGVjaWJlbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5leHBvbmVudGlhbFJhbXBUbyh2YWx1ZSwgcmFtcFRpbWUsIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5saW5lYXJSYW1wVG8odmFsdWUsIHJhbXBUaW1lLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFyYW07XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIGNyZWF0ZUdhaW4gc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKHdpbmRvdy5HYWluTm9kZSAmJiAhQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluKSB7XG5cdCAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluID0gQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVHYWluTm9kZTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQSB0aGluIHdyYXBwZXIgYXJvdW5kIHRoZSBOYXRpdmUgV2ViIEF1ZGlvIEdhaW5Ob2RlLlxuXHRcdCAqICAgICAgICAgVGhlIEdhaW5Ob2RlIGlzIGEgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgdGhlIFdlYiBBdWRpb1xuXHRcdCAqICAgICAgICAgQVBJIGFuZCBpcyB1c2VmdWwgZm9yIHJvdXRpbmcgYXVkaW8gYW5kIGFkanVzdGluZyBnYWlucy5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSAge051bWJlcj19ICBnYWluICBUaGUgaW5pdGlhbCBnYWluIG9mIHRoZSBHYWluTm9kZVxuXHRcdCAqICBAcGFyYW0ge1RvbmUuVHlwZT19IHVuaXRzIFRoZSB1bml0cyBvZiB0aGUgZ2FpbiBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdCAgICBUb25lLkdhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICd1bml0cydcblx0ICAgICAgICBdLCBUb25lLkdhaW4pO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIEdhaW5Ob2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIHBhcmFtZXRlciBvZiB0aGUgZ2FpbiBub2RlLlxuXHRcdFx0ICogIEB0eXBlIHtHYWlufVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fZ2Fpbk5vZGUuZ2Fpbixcblx0ICAgICAgICAgICAgJ3VuaXRzJzogb3B0aW9ucy51bml0cyxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5nYWluLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IG9wdGlvbnMuY29udmVydFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdnYWluJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYWluLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR2Fpbi5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZ2Fpbic6IDEsXG5cdCAgICAgICAgJ2NvbnZlcnQnOiB0cnVlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5HYWlufSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW5Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZ2FpbicpO1xuXHQgICAgICAgIHRoaXMuZ2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5nYWluID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HYWluO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc2lnbmFsIGlzIGFuIGF1ZGlvLXJhdGUgdmFsdWUuIFRvbmUuU2lnbmFsIGlzIGEgY29yZSBjb21wb25lbnQgb2YgdGhlIGxpYnJhcnkuXG5cdFx0ICogICAgICAgICAgVW5saWtlIGEgbnVtYmVyLCBTaWduYWxzIGNhbiBiZSBzY2hlZHVsZWQgd2l0aCBzYW1wbGUtbGV2ZWwgYWNjdXJhY3kuIFRvbmUuU2lnbmFsXG5cdFx0ICogICAgICAgICAgaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdG8gbmF0aXZlIFdlYiBBdWRpbyBcblx0XHQgKiAgICAgICAgICBbQXVkaW9QYXJhbV0oaHR0cDovL3dlYmF1ZGlvLmdpdGh1Yi5pby93ZWItYXVkaW8tYXBpLyN0aGUtYXVkaW9wYXJhbS1pbnRlcmZhY2UpXG5cdFx0ICogICAgICAgICAgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGNvbnZlbmllbmNlcy4gUmVhZCBtb3JlIGFib3V0IHdvcmtpbmcgd2l0aCBzaWduYWxzIFxuXHRcdCAqICAgICAgICAgIFtoZXJlXShodHRwczovL2dpdGh1Yi5jb20vVG9uZWpzL1RvbmUuanMvd2lraS9TaWduYWxzKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuUGFyYW19XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfEF1ZGlvUGFyYW19IFt2YWx1ZV0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2lnbmFsLiBJZiBhbiBBdWRpb1BhcmFtXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcGFzc2VkIGluLCB0aGF0IHBhcmFtZXRlciB3aWxsIGJlIHdyYXBwZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29udHJvbGxlZCBieSB0aGUgU2lnbmFsLiBcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1OdW1iZXJdIHVuaXQgVGhlIHVuaXRzIHRoZSBzaWduYWwgaXMgaW4uIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMTApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndmFsdWUnLFxuXHQgICAgICAgICAgICAndW5pdHMnXG5cdCAgICAgICAgXSwgVG9uZS5TaWduYWwpO1xuXHQgICAgICAgIHZhciBnYWluTm9kZSA9IFRvbmUuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgb3B0aW9ucy5wYXJhbSA9IGdhaW5Ob2RlLmdhaW47XG5cdCAgICAgICAgVG9uZS5QYXJhbS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIG5vZGUgd2hlcmUgdGhlIGNvbnN0YW50IHNpZ25hbCB2YWx1ZSBpcyBzY2FsZWQuXG5cdFx0XHQgKiBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSBnYWluTm9kZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBub2RlIHdoZXJlIHRoZSB2YWx1ZSBpcyBzZXQuXG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5QYXJhbX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5fcGFyYW0gPSB0aGlzLm91dHB1dC5nYWluO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgY29uc3Qgb3V0cHV0IHRvIHRoZSBub2RlIG91dHB1dFxuXHQgICAgICAgIHRoaXMuY29udGV4dC5nZXRDb25zdGFudCgxKS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNpZ25hbCwgVG9uZS5QYXJhbSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZhbHVlJzogMCxcblx0ICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRGVmYXVsdCxcblx0ICAgICAgICAnY29udmVydCc6IHRydWVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgV2hlbiBzaWduYWxzIGNvbm5lY3QgdG8gb3RoZXIgc2lnbmFscyBvciBBdWRpb1BhcmFtcywgXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS4gXG5cdFx0ICogIEZvciBhbGwgb3RoZXIgbm9kZXMsIHRoZSBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBhIGRlZmF1bHQgPGNvZGU+Y29ubmVjdDwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBvdmVycmlkZVxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvUGFyYW18QXVkaW9Ob2RlfFRvbmUuU2lnbmFsfFRvbmV9IG5vZGUgXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNpZ25hbEJhc2V9IHRoaXNcblx0XHQgKiAgQG1ldGhvZFxuXHRcdCAqL1xuXHQgICAgVG9uZS5TaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzcG9zZSBhbmQgZGlzY29ubmVjdFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuUGFyYW0ucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIHNpZ25hbCB3aGljaCBhZGRzIHRoZSBtZXRob2QgZ2V0VmFsdWVBdFRpbWUuXG5cdFx0ICogICAgICAgICBDb2RlIGFuZCBpbnNwaXJhdGlvbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2FudGVsbC93ZWItYXVkaW8tYXV0b21hdGlvbi10aW1lbGluZVxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyPX0gdmFsdWUgVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHNpZ25hbFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZz19IHVuaXRzIFRoZSBjb252ZXJzaW9uIHVuaXRzIG9mIHRoZSBzaWduYWwuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgJ3VuaXRzJ1xuXHQgICAgICAgIF0sIFRvbmUuU2lnbmFsKTtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzY2hlZHVsZWQgZXZlbnRzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKDEwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGluaXRpYWwgc2NoZWR1bGVkIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5pdGlhbCA9IHRoaXMuX2Zyb21Vbml0cyh0aGlzLl9wYXJhbS52YWx1ZSk7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgLy9kZWxldGUgdGhlIGlucHV0IG5vZGUgc28gdGhhdCBub3RoaW5nIGNhbiBvdmVyd3JpdGUgdGhlIHNpZ25hbCB2YWx1ZVxuXHQgICAgICAgIGRlbGV0ZSB0aGlzLmlucHV0O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVGltZWxpbmVTaWduYWwsIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZXZlbnQgdHlwZXMgb2YgYSBzY2hlZHVsYWJsZSBzaWduYWwuXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUgPSB7XG5cdCAgICAgICAgTGluZWFyOiAnbGluZWFyJyxcblx0ICAgICAgICBFeHBvbmVudGlhbDogJ2V4cG9uZW50aWFsJyxcblx0ICAgICAgICBUYXJnZXQ6ICd0YXJnZXQnLFxuXHQgICAgICAgIFNldDogJ3NldCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2lnbmFsLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlRpbWVsaW5lU2lnbmFsI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobm93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModmFsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0ZWRWYWwgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbCA9IGNvbnZlcnRlZFZhbDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbS52YWx1ZSA9IGNvbnZlcnRlZFZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0U0NIRURVTElOR1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtIHsqfVx0dmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgc2lnbmFsLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9ICB0aW1lIFRoZSB0aW1lIHdoZW4gdGhlIGNoYW5nZSBzaG91bGQgb2NjdXIuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgdGhlIGZyZXF1ZW5jeSB0byBcIkc0XCIgaW4gZXhhY3RseSAxIHNlY29uZCBmcm9tIG5vdy5cblx0XHQgKiBmcmVxLnNldFZhbHVlQXRUaW1lKFwiRzRcIiwgXCIrMVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydFRpbWUpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuU2V0LFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2ludm9rZSB0aGUgb3JpZ2luYWwgZXZlbnRcblx0ICAgICAgICB0aGlzLl9wYXJhbS5zZXRWYWx1ZUF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2NoZWR1bGVzIGEgbGluZWFyIGNvbnRpbnVvdXMgY2hhbmdlIGluIHBhcmFtZXRlciB2YWx1ZSBmcm9tIHRoZVxuXHRcdCAqICBwcmV2aW91cyBzY2hlZHVsZWQgcGFyYW1ldGVyIHZhbHVlIHRvIHRoZSBnaXZlbiB2YWx1ZS5cblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCBlbmRUaW1lKSB7XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyLFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBlbmRUaW1lXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwYXJhbWV0ZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZW5kVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5kVGltZSkge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBwcmV2aW91cyBldmVudCBhbmQgbWFrZSBzdXJlIGl0J3Mgbm90IHN0YXJ0aW5nIGZyb20gMFxuXHQgICAgICAgIGVuZFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhlbmRUaW1lKTtcblx0ICAgICAgICB2YXIgYmVmb3JlRXZlbnQgPSB0aGlzLl9zZWFyY2hCZWZvcmUoZW5kVGltZSk7XG5cdCAgICAgICAgaWYgKGJlZm9yZUV2ZW50ICYmIGJlZm9yZUV2ZW50LnZhbHVlID09PSAwKSB7XG5cdCAgICAgICAgICAgIC8vcmVzY2hlZHVsZSB0aGF0IGV2ZW50XG5cdCAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVBdFRpbWUodGhpcy5fbWluT3V0cHV0LCBiZWZvcmVFdmVudC50aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFsdWUgPSB0aGlzLl9mcm9tVW5pdHModmFsdWUpO1xuXHQgICAgICAgIHZhciBzZXRWYWx1ZSA9IE1hdGgubWF4KHZhbHVlLCB0aGlzLl9taW5PdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5hZGQoe1xuXHQgICAgICAgICAgICAndHlwZSc6IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbCxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogc2V0VmFsdWUsXG5cdCAgICAgICAgICAgICd0aW1lJzogZW5kVGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vaWYgdGhlIHJhbXBlZCB0byB2YWx1ZSBpcyAwLCBtYWtlIGl0IGdvIHRvIHRoZSBtaW4gb3V0cHV0LCBhbmQgdGhlbiBzZXQgdG8gMC5cblx0ICAgICAgICBpZiAodmFsdWUgPCB0aGlzLl9taW5PdXRwdXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyYW0uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLl9taW5PdXRwdXQsIGVuZFRpbWUgLSB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKDAsIGVuZFRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhcmFtLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGVuZFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgZXhwb25lbnRpYWxseSBhcHByb2FjaGluZyB0aGUgdGFyZ2V0IHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lIHdpdGhcblx0XHQgKiAgYSByYXRlIGhhdmluZyB0aGUgZ2l2ZW4gdGltZSBjb25zdGFudC5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB0aW1lQ29uc3RhbnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpIHtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHZhbHVlKTtcblx0ICAgICAgICB0aW1lQ29uc3RhbnQgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuYWRkKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuVGFyZ2V0LFxuXHQgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAgICAgJ3RpbWUnOiBzdGFydFRpbWUsXG5cdCAgICAgICAgICAgICdjb25zdGFudCc6IHRpbWVDb25zdGFudFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZSBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFsdWVzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3NjYWxpbmc9MV0gSWYgdGhlIHZhbHVlcyBpbiB0aGUgY3VydmUgc2hvdWxkIGJlIHNjYWxlZCBieSBzb21lIHZhbHVlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgc2NhbGluZykge1xuXHQgICAgICAgIHNjYWxpbmcgPSBUb25lLmRlZmF1bHRBcmcoc2NhbGluZywgMSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgc3RhcnRUaW1lID0gdGhpcy50b1NlY29uZHMoc3RhcnRUaW1lKTtcblx0ICAgICAgICB2YXIgc2VnVGltZSA9IGR1cmF0aW9uIC8gKHZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKHZhbHVlc1swXSAqIHNjYWxpbmcsIHN0YXJ0VGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZXNbaV0gKiBzY2FsaW5nLCBzdGFydFRpbWUgKyBpICogc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWxzIGFsbCBzY2hlZHVsZWQgcGFyYW1ldGVyIGNoYW5nZXMgd2l0aCB0aW1lcyBncmVhdGVyIHRoYW4gb3Jcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChhZnRlcikge1xuXHQgICAgICAgIGFmdGVyID0gdGhpcy50b1NlY29uZHMoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbHMgYWxsIHNjaGVkdWxlZCBwYXJhbWV0ZXIgY2hhbmdlcyB3aXRoIHRpbWVzIGdyZWF0ZXIgdGhhbiBvclxuXHRcdCAqICBlcXVhbCB0byBjYW5jZWxUaW1lIGFuZCBzZXRzIHRoZSBvdXRwdXQgb2YgdGhlIHNpZ25hbCB0byBiZSB0aGUgdmFsdWVcblx0XHQgKiAgYXQgY2FuY2VsVGltZS4gU2ltaWxhciB0byAoY2FuY2VsU2NoZWR1bGVkVmFsdWVzKVsjY2FuY2Vsc2NoZWR1bGVkdmFsdWVzXS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gY2FuY2VsVGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuY2FuY2VsQW5kSG9sZEF0VGltZSA9IGZ1bmN0aW9uIChjYW5jZWxUaW1lKSB7XG5cdCAgICAgICAgdGhpcy5zZXRSYW1wUG9pbnQodGhpcy50b1NlY29uZHMoY2FuY2VsVGltZSkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBjb21wdXRlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gVGhpcyBwcm92aWRlc1xuXHRcdCAqICBhIHBvaW50IGZyb20gd2hpY2ggYSBsaW5lYXIgb3IgZXhwb25lbnRpYWwgY3VydmVcblx0XHQgKiAgY2FuIGJlIHNjaGVkdWxlZCBhZnRlci4gV2lsbCBjYW5jZWwgZXZlbnRzIGFmdGVyXG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lIGFuZCBzaG9ydGVuIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkXG5cdFx0ICogIGxpbmVhciBvciBleHBvbmVudGlhbCByYW1wIHNvIHRoYXQgaXQgZW5kcyBhdCBgdGltZWAgLlxuXHRcdCAqICBUaGlzIGlzIHRvIGF2b2lkIGRpc2NvbnRpbnVpdGllcyBhbmQgY2xpY2tzIGluIGVudmVsb3Blcy5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFdoZW4gdG8gc2V0IHRoZSByYW1wIHBvaW50XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRSYW1wUG9pbnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAvL2dldCB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5fdG9Vbml0cyh0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpKTtcblx0ICAgICAgICAvL2lmIHRoZXJlIGlzIGFuIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lXG5cdCAgICAgICAgLy9hbmQgdGhhdCBldmVuIGlzIG5vdCBhIFwic2V0XCJcblx0ICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fc2VhcmNoQmVmb3JlKHRpbWUpO1xuXHQgICAgICAgIGlmIChiZWZvcmUgJiYgYmVmb3JlLnRpbWUgPT09IHRpbWUpIHtcblx0ICAgICAgICAgICAgLy9yZW1vdmUgZXZlcnl0aGluZyBhZnRlclxuXHQgICAgICAgICAgICB0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lICsgdGhpcy5zYW1wbGVUaW1lKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgdGhlIG5leHQgZXZlbnQgdG8gZW5kIGF0IHRoZSBnaXZlbiB0aW1lXG5cdCAgICAgICAgICAgIHZhciBhZnRlciA9IHRoaXMuX3NlYXJjaEFmdGVyKHRpbWUpO1xuXHQgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcblx0ICAgICAgICAgICAgICAgIC8vY2FuY2VsIHRoZSBuZXh0IGV2ZW50KHMpXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmIChhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuTGluZWFyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWwsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZnRlci50eXBlID09PSBUb25lLlRpbWVsaW5lU2lnbmFsLlR5cGUuRXhwb25lbnRpYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLnNldFZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIERvIGEgbGluZWFyIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBmaW5pc2ggdGltZXMuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmFtcCB0by5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBzdGFydCBUaGUgYmVnaW5uaW5nIGFuY2hvciBwb2ludCB0byBkbyB0aGUgbGluZWFyIHJhbXBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBmaW5pc2ggVGhlIGVuZGluZyBhbmNob3IgcG9pbnQgYnkgd2hpY2ggdGhlIHZhbHVlIG9mXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBzaWduYWwgd2lsbCBlcXVhbCB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUJldHdlZW4gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBmaW5pc2gpIHtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludChzdGFydCk7XG5cdCAgICAgICAgdGhpcy5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh2YWx1ZSwgZmluaXNoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRG8gYSBleHBvbmVudGlhbCByYW1wIHRvIHRoZSBnaXZlbiB2YWx1ZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZmluaXNoIHRpbWVzLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJhbXAgdG8uXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnQgVGhlIGJlZ2lubmluZyBhbmNob3IgcG9pbnQgdG8gZG8gdGhlIGV4cG9uZW50aWFsIHJhbXBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBmaW5pc2ggVGhlIGVuZGluZyBhbmNob3IgcG9pbnQgYnkgd2hpY2ggdGhlIHZhbHVlIG9mXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBzaWduYWwgd2lsbCBlcXVhbCB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQmV0d2VlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGZpbmlzaCkge1xuXHQgICAgICAgIHRoaXMuc2V0UmFtcFBvaW50KHN0YXJ0KTtcblx0ICAgICAgICB0aGlzLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodmFsdWUsIGZpbmlzaCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0R0VUVElORyBTQ0hFRFVMRUQgVkFMVUVTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSB2YWx1ZSBiZWZvcmUgb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnlcblx0XHQgKiAgQHJldHVybiAge09iamVjdH0gIFRoZSBldmVudCBhdCBvciBiZWZvcmUgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fc2VhcmNoQmVmb3JlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGV2ZW50IGFmdGVyIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIHRvIHF1ZXJ5LlxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgVGhlIG5leHQgZXZlbnQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9zZWFyY2hBZnRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5nZXRBZnRlcih0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFRoaXMgd2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIHVuY29udmVydGVkIChyYXcpIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSBpbiBzZWNvbmRzLlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIHNjaGVkdWxlZCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGFmdGVyID0gdGhpcy5fc2VhcmNoQWZ0ZXIodGltZSk7XG5cdCAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuX3NlYXJjaEJlZm9yZSh0aW1lKTtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIC8vaWYgaXQgd2FzIHNldCBieVxuXHQgICAgICAgIGlmIChiZWZvcmUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5UYXJnZXQpIHtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5fZXZlbnRzLmdldEJlZm9yZShiZWZvcmUudGltZSk7XG5cdCAgICAgICAgICAgIHZhciBwcmV2aW91c1ZhbDtcblx0ICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbCA9IHRoaXMuX2luaXRpYWw7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbCA9IHByZXZpb3VzLnZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZXhwb25lbnRpYWxBcHByb2FjaChiZWZvcmUudGltZSwgcHJldmlvdXNWYWwsIGJlZm9yZS52YWx1ZSwgYmVmb3JlLmNvbnN0YW50LCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGFmdGVyID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gYmVmb3JlLnZhbHVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIudHlwZSA9PT0gVG9uZS5UaW1lbGluZVNpZ25hbC5UeXBlLkxpbmVhcikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2xpbmVhckludGVycG9sYXRlKGJlZm9yZS50aW1lLCBiZWZvcmUudmFsdWUsIGFmdGVyLnRpbWUsIGFmdGVyLnZhbHVlLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5FeHBvbmVudGlhbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2V4cG9uZW50aWFsSW50ZXJwb2xhdGUoYmVmb3JlLnRpbWUsIGJlZm9yZS52YWx1ZSwgYWZ0ZXIudGltZSwgYWZ0ZXIudmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gYmVmb3JlLnZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFdoZW4gc2lnbmFscyBjb25uZWN0IHRvIG90aGVyIHNpZ25hbHMgb3IgQXVkaW9QYXJhbXMsXG5cdFx0ICogIHRoZXkgdGFrZSBvdmVyIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhhdCBzaWduYWwgb3IgQXVkaW9QYXJhbS5cblx0XHQgKiAgRm9yIGFsbCBvdGhlciBub2RlcywgdGhlIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGEgZGVmYXVsdCA8Y29kZT5jb25uZWN0PC9jb2RlPi5cblx0XHQgKlxuXHRcdCAqICBAb3ZlcnJpZGVcblx0XHQgKiAgQHBhcmFtIHtBdWRpb1BhcmFtfEF1ZGlvTm9kZXxUb25lLlNpZ25hbHxUb25lfSBub2RlXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtYmVyPTBdIFRoZSBvdXRwdXQgbnVtYmVyIHRvIGNvbm5lY3QgZnJvbS5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtpbnB1dE51bWJlcj0wXSBUaGUgaW5wdXQgbnVtYmVyIHRvIGNvbm5lY3QgdG8uXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICogIEBtZXRob2Rcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNvbm5lY3QgPSBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRBVVRPTUFUSU9OIENVUlZFIENBTENVTEFUSU9OU1xuXHQgICAgLy9cdE1JVCBMaWNlbnNlLCBjb3B5cmlnaHQgKGMpIDIwMTQgSm9yZGFuIFNhbnRlbGxcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIENhbGN1bGF0ZXMgdGhlIHRoZSB2YWx1ZSBhbG9uZyB0aGUgY3VydmUgcHJvZHVjZWQgYnkgc2V0VGFyZ2V0QXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fZXhwb25lbnRpYWxBcHByb2FjaCA9IGZ1bmN0aW9uICh0MCwgdjAsIHYxLCB0aW1lQ29uc3RhbnQsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjEgKyAodjAgLSB2MSkgKiBNYXRoLmV4cCgtKHQgLSB0MCkgLyB0aW1lQ29uc3RhbnQpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fbGluZWFySW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAodDAsIHYwLCB0MSwgdjEsIHQpIHtcblx0ICAgICAgICByZXR1cm4gdjAgKyAodjEgLSB2MCkgKiAoKHQgLSB0MCkgLyAodDEgLSB0MCkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYWxjdWxhdGVzIHRoZSB0aGUgdmFsdWUgYWxvbmcgdGhlIGN1cnZlIHByb2R1Y2VkIGJ5IGV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9leHBvbmVudGlhbEludGVycG9sYXRlID0gZnVuY3Rpb24gKHQwLCB2MCwgdDEsIHYxLCB0KSB7XG5cdCAgICAgICAgdjAgPSBNYXRoLm1heCh0aGlzLl9taW5PdXRwdXQsIHYwKTtcblx0ICAgICAgICByZXR1cm4gdjAgKiBNYXRoLnBvdyh2MSAvIHYwLCAodCAtIHQwKSAvICh0MSAtIHQwKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU2lnbmFsO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgUG93IGFwcGxpZXMgYW4gZXhwb25lbnQgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gVGhlIGluY29taW5nIHNpZ25hbFxuXHRcdCAqICAgICAgICAgbXVzdCBiZSBBdWRpb1JhbmdlLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge1Bvc2l0aXZlfSBleHAgVGhlIGV4cG9uZW50IHRvIGFwcGx5IHRvIHRoZSBpbmNvbWluZyBzaWduYWwsIG11c3QgYmUgYXQgbGVhc3QgMi4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBvdyA9IG5ldyBUb25lLlBvdygyKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChwb3cpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIHBvdyBpcyAwLjI1LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93ID0gZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIGV4cG9uZW50XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V4cCA9IFRvbmUuZGVmYXVsdEFyZyhleHAsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXhwU2NhbGVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcih0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCksIDgxOTIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUG93LCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHZhbHVlIG9mIHRoZSBleHBvbmVudC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Qb3cjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUG93LnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXhwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V4cCA9IGV4cDtcblx0ICAgICAgICAgICAgdGhpcy5fZXhwU2NhbGVyLnNldE1hcCh0aGlzLl9leHBGdW5jKHRoaXMuX2V4cCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBmdW5jdGlvbiB3aGljaCBtYXBzIHRoZSB3YXZlc2hhcGVyXG5cdFx0ICogIEBwYXJhbSAgIHtudW1iZXJ9IGV4cFxuXHRcdCAqICBAcmV0dXJuIHtmdW5jdGlvbn1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUG93LnByb3RvdHlwZS5fZXhwRnVuYyA9IGZ1bmN0aW9uIChleHApIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coTWF0aC5hYnModmFsKSwgZXhwKTtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG93fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBvdy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9leHBTY2FsZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2V4cFNjYWxlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUG93O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRW52ZWxvcGUgaXMgYW4gW0FEU1JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bnRoZXNpemVyI0FEU1JfZW52ZWxvcGUpXG5cdFx0ICogICAgICAgICAgZW52ZWxvcGUgZ2VuZXJhdG9yLiBUb25lLkVudmVsb3BlIG91dHB1dHMgYSBzaWduYWwgd2hpY2hcblx0XHQgKiAgICAgICAgICBjYW4gYmUgY29ubmVjdGVkIHRvIGFuIEF1ZGlvUGFyYW0gb3IgVG9uZS5TaWduYWwuXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL3VwbG9hZC53aWtpbWVkaWEub3JnL3dpa2lwZWRpYS9jb21tb25zL2UvZWEvQURTUl9wYXJhbWV0ZXIuc3ZnXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbYXR0YWNrXSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZSB0byBnbyBmcm9tXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgMCB0byBpdCdzIG1heGltdW0gdmFsdWUuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0VGhlIHBlcmlvZCBvZiB0aW1lIGFmdGVyIHRoZSBhdHRhY2sgdGhhdCBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIFx0dG8gZmFsbCB0byB0aGUgc3VzdGFpbiB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3N1c3RhaW5dXHRUaGUgcGVyY2VudCBvZiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IHRoZSBlbnZlbG9wZSByZXN0cyBhdCB1bnRpbFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbcmVsZWFzZV1cdFRoZSBhbW91bnQgb2YgdGltZSBhZnRlciB0aGUgcmVsZWFzZSBpcyB0cmlnZ2VyZWQgaXQgdGFrZXMgdG8gcmVhY2ggMC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2FuIGFtcGxpdHVkZSBlbnZlbG9wZVxuXHRcdCAqIHZhciBnYWluTm9kZSA9IFRvbmUuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0ICogdmFyIGVudiA9IG5ldyBUb25lLkVudmVsb3BlKHtcblx0XHQgKiBcdFwiYXR0YWNrXCIgOiAwLjEsXG5cdFx0ICogXHRcImRlY2F5XCIgOiAwLjIsXG5cdFx0ICogXHRcInN1c3RhaW5cIiA6IDEsXG5cdFx0ICogXHRcInJlbGVhc2VcIiA6IDAuOCxcblx0XHQgKiB9KTtcblx0XHQgKiBlbnYuY29ubmVjdChnYWluTm9kZS5nYWluKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy9nZXQgYWxsIG9mIHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdkZWNheScsXG5cdCAgICAgICAgICAgICdzdXN0YWluJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnXG5cdCAgICAgICAgXSwgVG9uZS5FbnZlbG9wZSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVuIHRyaWdnZXJBdHRhY2sgaXMgY2FsbGVkLCB0aGUgYXR0YWNrIHRpbWUgaXMgdGhlIGFtb3VudCBvZlxuXHRcdFx0ICogIHRpbWUgaXQgdGFrZXMgZm9yIHRoZSBlbnZlbG9wZSB0byByZWFjaCBpdCdzIG1heGltdW0gdmFsdWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG9wdGlvbnMuYXR0YWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFmdGVyIHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUsIHRoZSB2YWx1ZSB3aWxsIGZhbGxcblx0XHRcdCAqICBvdmVyIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGVjYXkgdGltZSB0byBpdCdzIHN1c3RhaW4gdmFsdWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlY2F5ID0gb3B0aW9ucy5kZWNheTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFx0VGhlIHN1c3RhaW4gdmFsdWUgaXMgdGhlIHZhbHVlXG5cdFx0XHQgKiBcdHdoaWNoIHRoZSBlbnZlbG9wZSByZXN0cyBhdCBhZnRlciB0cmlnZ2VyQXR0YWNrIGlzXG5cdFx0XHQgKiBcdGNhbGxlZCwgYnV0IGJlZm9yZSB0cmlnZ2VyUmVsZWFzZSBpcyBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc3VzdGFpbiA9IG9wdGlvbnMuc3VzdGFpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBZnRlciB0cmlnZ2VyUmVsZWFzZSBpcyBjYWxsZWQsIHRoZSBlbnZlbG9wZSdzXG5cdFx0XHQgKiAgdmFsdWUgd2lsbCBmYWxsIHRvIGl0J3MgbWltaW51bSB2YWx1ZSBvdmVyIHRoZVxuXHRcdFx0ICogIGR1cmF0aW9uIG9mIHRoZSByZWxlYXNlIHRpbWUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlbGVhc2UgPSBvcHRpb25zLnJlbGVhc2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5leHQgdGltZSB0aGUgZW52ZWxvcGUgaXMgYXQgc3RhbmRieVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gJ2xpbmVhcic7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5leHQgdGltZSB0aGUgZW52ZWxvcGUgaXMgYXQgc3RhbmRieVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9ICdleHBvbmVudGlhbCc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaWcgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlRpbWVsaW5lU2lnbmFsKCk7XG5cdCAgICAgICAgdGhpcy5fc2lnLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuXHQgICAgICAgIC8vc2V0IHRoZSBhdHRhY2tDdXJ2ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLmF0dGFja0N1cnZlID0gb3B0aW9ucy5hdHRhY2tDdXJ2ZTtcblx0ICAgICAgICB0aGlzLnJlbGVhc2VDdXJ2ZSA9IG9wdGlvbnMucmVsZWFzZUN1cnZlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRW52ZWxvcGUsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdhdHRhY2snOiAwLjAxLFxuXHQgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAnc3VzdGFpbic6IDAuNSxcblx0ICAgICAgICAncmVsZWFzZSc6IDEsXG5cdCAgICAgICAgJ2F0dGFja0N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgJ3JlbGVhc2VDdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZWFkIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbnZlbG9wZS4gVXNlZnVsIGZvclxuXHRcdCAqIHN5bmNyb25pemluZyB2aXN1YWwgb3V0cHV0IHRvIHRoZSBlbnZlbG9wZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5FbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIHZhbHVlXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUodGhpcy5ub3coKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2hhcGUgb2YgdGhlIGF0dGFjay5cblx0XHQgKiBDYW4gYmUgYW55IG9mIHRoZXNlIHN0cmluZ3M6XG5cdFx0ICogPHVsPlxuXHRcdCAqICAgPGxpPmxpbmVhcjwvbGk+XG5cdFx0ICogICA8bGk+ZXhwb25lbnRpYWw8L2xpPlxuXHRcdCAqICAgPGxpPnNpbmU8L2xpPlxuXHRcdCAqICAgPGxpPmNvc2luZTwvbGk+XG5cdFx0ICogICA8bGk+Ym91bmNlPC9saT5cblx0XHQgKiAgIDxsaT5yaXBwbGU8L2xpPlxuXHRcdCAqICAgPGxpPnN0ZXA8L2xpPlxuXHRcdCAqIDwvdWw+XG5cdFx0ICogQ2FuIGFsc28gYmUgYW4gYXJyYXkgd2hpY2ggZGVzY3JpYmVzIHRoZSBjdXJ2ZS4gVmFsdWVzXG5cdFx0ICogaW4gdGhlIGFycmF5IGFyZSBldmVubHkgc3ViZGl2aWRlZCBhbmQgbGluZWFybHlcblx0XHQgKiBpbnRlcnBvbGF0ZWQgb3ZlciB0aGUgZHVyYXRpb24gb2YgdGhlIGF0dGFjay5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5FbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfEFycmF5fVxuXHRcdCAqIEBuYW1lIGF0dGFja0N1cnZlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBlbnYuYXR0YWNrQ3VydmUgPSBcImxpbmVhclwiO1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9jYW4gYWxzbyBiZSBhbiBhcnJheVxuXHRcdCAqIGVudi5hdHRhY2tDdXJ2ZSA9IFswLCAwLjIsIDAuMywgMC40LCAxXVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLCAnYXR0YWNrQ3VydmUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzU3RyaW5nKHRoaXMuX2F0dGFja0N1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja0N1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheSh0aGlzLl9hdHRhY2tDdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIC8vbG9vayB1cCB0aGUgbmFtZSBpbiB0aGUgY3VydmVzIGFycmF5XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIFRvbmUuRW52ZWxvcGUuVHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLkVudmVsb3BlLlR5cGVbdHlwZV0uSW4gPT09IHRoaXMuX2F0dGFja0N1cnZlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgcmV0dXJuIHRoZSBhcnJheVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja0N1cnZlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjdXJ2ZSkge1xuXHQgICAgICAgICAgICAvL2NoZWNrIGlmIGl0J3MgYSB2YWxpZCB0eXBlXG5cdCAgICAgICAgICAgIGlmIChUb25lLkVudmVsb3BlLlR5cGUuaGFzT3duUHJvcGVydHkoY3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3VydmVEZWYgPSBUb25lLkVudmVsb3BlLlR5cGVbY3VydmVdO1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNPYmplY3QoY3VydmVEZWYpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBjdXJ2ZURlZi5Jbjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0YWNrQ3VydmUgPSBjdXJ2ZURlZjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzQXJyYXkoY3VydmUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2tDdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkVudmVsb3BlOiBpbnZhbGlkIGN1cnZlOiAnICsgY3VydmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2hhcGUgb2YgdGhlIHJlbGVhc2UuIFNlZSB0aGUgYXR0YWNrIGN1cnZlIHR5cGVzLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkVudmVsb3BlI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd8QXJyYXl9XG5cdFx0ICogQG5hbWUgcmVsZWFzZUN1cnZlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBlbnYucmVsZWFzZUN1cnZlID0gXCJsaW5lYXJcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkVudmVsb3BlLnByb3RvdHlwZSwgJ3JlbGVhc2VDdXJ2ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNTdHJpbmcodGhpcy5fcmVsZWFzZUN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2VDdXJ2ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzQXJyYXkodGhpcy5fcmVsZWFzZUN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgLy9sb29rIHVwIHRoZSBuYW1lIGluIHRoZSBjdXJ2ZXMgYXJyYXlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gVG9uZS5FbnZlbG9wZS5UeXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZVt0eXBlXS5PdXQgPT09IHRoaXMuX3JlbGVhc2VDdXJ2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgYXJyYXlcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxlYXNlQ3VydmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIC8vY2hlY2sgaWYgaXQncyBhIHZhbGlkIHR5cGVcblx0ICAgICAgICAgICAgaWYgKFRvbmUuRW52ZWxvcGUuVHlwZS5oYXNPd25Qcm9wZXJ0eShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJ2ZURlZiA9IFRvbmUuRW52ZWxvcGUuVHlwZVtjdXJ2ZV07XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc09iamVjdChjdXJ2ZURlZikpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWxlYXNlQ3VydmUgPSBjdXJ2ZURlZi5PdXQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlRGVmO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNBcnJheShjdXJ2ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbGVhc2VDdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkVudmVsb3BlOiBpbnZhbGlkIGN1cnZlOiAnICsgY3VydmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrL2RlY2F5IHBvcnRpb24gb2YgdGhlIEFEU1IgZW52ZWxvcGUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgZW52ZWxvcGUgc2NhbGVzIHRoZSB2YWxlcy5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgYmV0d2VlbiAwLTFcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRW52ZWxvcGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgLy90cmlnZ2VyIHRoZSBhdHRhY2sgMC41IHNlY29uZHMgZnJvbSBub3cgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqICBlbnYudHJpZ2dlckF0dGFjayhcIiswLjVcIiwgMC4yKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIG9yaWdpbmFsQXR0YWNrID0gdGhpcy50b1NlY29uZHModGhpcy5hdHRhY2spO1xuXHQgICAgICAgIHZhciBhdHRhY2sgPSBvcmlnaW5hbEF0dGFjaztcblx0ICAgICAgICB2YXIgZGVjYXkgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLmRlY2F5KTtcblx0ICAgICAgICB2ZWxvY2l0eSA9IFRvbmUuZGVmYXVsdEFyZyh2ZWxvY2l0eSwgMSk7XG5cdCAgICAgICAgLy9jaGVjayBpZiBpdCdzIG5vdCBhIGNvbXBsZXRlIGF0dGFja1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuXHQgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPiAwKSB7XG5cdCAgICAgICAgICAgIC8vc3VidHJhY3QgdGhlIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgYXR0YWNrIHRpbWVcblx0ICAgICAgICAgICAgdmFyIGF0dGFja1JhdGUgPSAxIC8gYXR0YWNrO1xuXHQgICAgICAgICAgICB2YXIgcmVtYWluaW5nRGlzdGFuY2UgPSAxIC0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICAvL3RoZSBhdHRhY2sgaXMgbm93IHRoZSByZW1haW5pbmcgdGltZVxuXHQgICAgICAgICAgICBhdHRhY2sgPSByZW1haW5pbmdEaXN0YW5jZSAvIGF0dGFja1JhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYXR0YWNrXG5cdCAgICAgICAgaWYgKHRoaXMuX2F0dGFja0N1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICB0aGlzLl9zaWcubGluZWFyUmFtcFRvKHZlbG9jaXR5LCBhdHRhY2ssIHRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXR0YWNrQ3VydmUgPT09ICdleHBvbmVudGlhbCcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2lnLnRhcmdldFJhbXBUbyh2ZWxvY2l0eSwgYXR0YWNrLCB0aW1lKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGF0dGFjayA+IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2lnLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5fYXR0YWNrQ3VydmU7XG5cdCAgICAgICAgICAgIC8vdGFrZSBvbmx5IGEgcG9ydGlvbiBvZiB0aGUgY3VydmVcblx0ICAgICAgICAgICAgaWYgKGF0dGFjayA8IG9yaWdpbmFsQXR0YWNrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGVyY2VudENvbXBsZXRlID0gMSAtIGF0dGFjayAvIG9yaWdpbmFsQXR0YWNrO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNsaWNlSW5kZXggPSBNYXRoLmZsb29yKHBlcmNlbnRDb21wbGV0ZSAqIHRoaXMuX2F0dGFja0N1cnZlLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBjdXJ2ZSA9IHRoaXMuX2F0dGFja0N1cnZlLnNsaWNlKHNsaWNlSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgLy90aGUgZmlyc3QgaW5kZXggaXMgdGhlIGN1cnJlbnQgdmFsdWVcblx0ICAgICAgICAgICAgICAgIGN1cnZlWzBdID0gY3VycmVudFZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRWYWx1ZUN1cnZlQXRUaW1lKGN1cnZlLCB0aW1lLCBhdHRhY2ssIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kZWNheVxuXHQgICAgICAgIHRoaXMuX3NpZy50YXJnZXRSYW1wVG8odmVsb2NpdHkgKiB0aGlzLnN1c3RhaW4sIGRlY2F5LCBhdHRhY2sgKyB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlcnMgdGhlIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGUgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL3RyaWdnZXIgcmVsZWFzZSBpbW1lZGlhdGVseVxuXHRcdCAqICBlbnYudHJpZ2dlclJlbGVhc2UoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRW52ZWxvcGUucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnRvU2Vjb25kcyh0aGlzLnJlbGVhc2UpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fcmVsZWFzZUN1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2lnLmxpbmVhclJhbXBUbygwLCByZWxlYXNlLCB0aW1lKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yZWxlYXNlQ3VydmUgPT09ICdleHBvbmVudGlhbCcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NpZy50YXJnZXRSYW1wVG8oMCwgcmVsZWFzZSwgdGltZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY3VydmUgPSB0aGlzLl9yZWxlYXNlQ3VydmU7XG5cdCAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc0FycmF5KGN1cnZlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZy5zZXRSYW1wUG9pbnQodGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnLnNldFZhbHVlQ3VydmVBdFRpbWUoY3VydmUsIHRpbWUsIHJlbGVhc2UsIGN1cnJlbnRWYWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCB0aGUgc2NoZWR1bGVkIHZhbHVlIGF0IHRoZSBnaXZlbiB0aW1lLiBUaGlzIHdpbGxcblx0XHQgKiAgcmV0dXJuIHRoZSB1bmNvbnZlcnRlZCAocmF3KSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3NpZy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdHJpZ2dlckF0dGFja1JlbGVhc2UgaXMgc2hvcnRoYW5kIGZvciB0cmlnZ2VyQXR0YWNrLCB0aGVuIHdhaXRpbmdcblx0XHQgKiAgc29tZSBkdXJhdGlvbiwgdGhlbiB0cmlnZ2VyUmVsZWFzZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gb2YgdGhlIHN1c3RhaW4uXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FbnZlbG9wZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlIGFmdGVyIDAuNiBzZWNvbmRzLlxuXHRcdCAqIGVudi50cmlnZ2VyQXR0YWNrUmVsZWFzZSgwLjYpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VscyBhbGwgc2NoZWR1bGVkIGVudmVsb3BlIGNoYW5nZXMgYWZ0ZXIgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGFmdGVyXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLl9zaWcuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGFmdGVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQm9ycm93cyB0aGUgY29ubmVjdCBtZXRob2QgZnJvbSBUb25lLlNpZ25hbC5cblx0XHQgKiAgQGZ1bmN0aW9uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5jb25uZWN0ID0gVG9uZS5TaWduYWwucHJvdG90eXBlLmNvbm5lY3Q7XG5cdCAgICAvKipcblx0IFx0ICogIEdlbmVyYXRlIHNvbWUgY29tcGxleCBlbnZlbG9wZSBjdXJ2ZXMuXG5cdCBcdCAqL1xuXHQgICAgKGZ1bmN0aW9uIF9jcmVhdGVDdXJ2ZXMoKSB7XG5cdCAgICAgICAgdmFyIGN1cnZlTGVuID0gMTI4O1xuXHQgICAgICAgIHZhciBpLCBrO1xuXHQgICAgICAgIC8vY29zaW5lIGN1cnZlXG5cdCAgICAgICAgdmFyIGNvc2luZUN1cnZlID0gW107XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgY29zaW5lQ3VydmVbaV0gPSBNYXRoLnNpbihpIC8gKGN1cnZlTGVuIC0gMSkgKiAoTWF0aC5QSSAvIDIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9yaXBwbGUgY3VydmVcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmUgPSBbXTtcblx0ICAgICAgICB2YXIgcmlwcGxlQ3VydmVGcmVxID0gNi40O1xuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjdXJ2ZUxlbiAtIDE7IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgc2luZVdhdmUgPSBNYXRoLnNpbihrICogKE1hdGguUEkgKiAyKSAqIHJpcHBsZUN1cnZlRnJlcSAtIE1hdGguUEkgLyAyKSArIDE7XG5cdCAgICAgICAgICAgIHJpcHBsZUN1cnZlW2ldID0gc2luZVdhdmUgLyAxMCArIGsgKiAwLjgzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByaXBwbGVDdXJ2ZVtjdXJ2ZUxlbiAtIDFdID0gMTtcblx0ICAgICAgICAvL3N0YWlycyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzdGFpcnNDdXJ2ZSA9IFtdO1xuXHQgICAgICAgIHZhciBzdGVwcyA9IDU7XG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnZlTGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgc3RhaXJzQ3VydmVbaV0gPSBNYXRoLmNlaWwoaSAvIChjdXJ2ZUxlbiAtIDEpICogc3RlcHMpIC8gc3RlcHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vaW4tb3V0IGVhc2luZyBjdXJ2ZVxuXHQgICAgICAgIHZhciBzaW5lQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICBzaW5lQ3VydmVbaV0gPSAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vYSBib3VuY2UgY3VydmVcblx0ICAgICAgICB2YXIgYm91bmNlQ3VydmUgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VydmVMZW47IGkrKykge1xuXHQgICAgICAgICAgICBrID0gaSAvIChjdXJ2ZUxlbiAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgZnJlcSA9IE1hdGgucG93KGssIDMpICogNCArIDAuMjtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IE1hdGguY29zKGZyZXEgKiBNYXRoLlBJICogMiAqIGspO1xuXHQgICAgICAgICAgICBib3VuY2VDdXJ2ZVtpXSA9IE1hdGguYWJzKHZhbCAqICgxIC0gaykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJbnZlcnQgYSB2YWx1ZSBjdXJ2ZSB0byBtYWtlIGl0IHdvcmsgZm9yIHRoZSByZWxlYXNlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIGludmVydEN1cnZlKGN1cnZlKSB7XG5cdCAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoY3VydmUubGVuZ3RoKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjdXJ2ZS5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgb3V0W2pdID0gMSAtIGN1cnZlW2pdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHJldmVyc2UgdGhlIGN1cnZlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIGZ1bmN0aW9uIHJldmVyc2VDdXJ2ZShjdXJ2ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gY3VydmUuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhdHRhY2sgYW5kIHJlbGVhc2UgY3VydmUgYXJyYXlzXG5cdFx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuVHlwZSA9IHtcblx0ICAgICAgICAgICAgJ2xpbmVhcic6ICdsaW5lYXInLFxuXHQgICAgICAgICAgICAnZXhwb25lbnRpYWwnOiAnZXhwb25lbnRpYWwnLFxuXHQgICAgICAgICAgICAnYm91bmNlJzoge1xuXHQgICAgICAgICAgICAgICAgSW46IGludmVydEN1cnZlKGJvdW5jZUN1cnZlKSxcblx0ICAgICAgICAgICAgICAgIE91dDogYm91bmNlQ3VydmVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2Nvc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBjb3NpbmVDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogcmV2ZXJzZUN1cnZlKGNvc2luZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc3RlcCc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzdGFpcnNDdXJ2ZSxcblx0ICAgICAgICAgICAgICAgIE91dDogaW52ZXJ0Q3VydmUoc3RhaXJzQ3VydmUpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdyaXBwbGUnOiB7XG5cdCAgICAgICAgICAgICAgICBJbjogcmlwcGxlQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHJpcHBsZUN1cnZlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc2luZSc6IHtcblx0ICAgICAgICAgICAgICAgIEluOiBzaW5lQ3VydmUsXG5cdCAgICAgICAgICAgICAgICBPdXQ6IGludmVydEN1cnZlKHNpbmVDdXJ2ZSlcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc2Nvbm5lY3QgYW5kIGRpc3Bvc2UuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVudmVsb3BlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2lnLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaWcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2F0dGFja0N1cnZlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZWxlYXNlQ3VydmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUgaXMgYSBUb25lLkVudmVsb3BlIGNvbm5lY3RlZCB0byBhIGdhaW4gbm9kZS5cblx0XHQgKiAgICAgICAgICBVbmxpa2UgVG9uZS5FbnZlbG9wZSwgd2hpY2ggb3V0cHV0cyB0aGUgZW52ZWxvcGUncyB2YWx1ZSwgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSBhY2NlcHRzXG5cdFx0ICogICAgICAgICAgYW4gYXVkaW8gc2lnbmFsIGFzIHRoZSBpbnB1dCBhbmQgd2lsbCBhcHBseSB0aGUgZW52ZWxvcGUgdG8gdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBzaWduYWwuIFJlYWQgbW9yZSBhYm91dCBBRFNSIEVudmVsb3BlcyBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW50aGVzaXplciNBRFNSX2VudmVsb3BlKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRW52ZWxvcGV9XG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFthdHRhY2tdIFRoZSBhbW91bnQgb2YgdGltZSBpdCB0YWtlcyBmb3IgdGhlIGVudmVsb3BlIHRvIGdvIGZyb21cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIHRvIGl0J3MgbWF4aW11bSB2YWx1ZS5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZGVjYXldXHRUaGUgcGVyaW9kIG9mIHRpbWUgYWZ0ZXIgdGhlIGF0dGFjayB0aGF0IGl0IHRha2VzIGZvciB0aGUgZW52ZWxvcGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgXHR0byBmYWxsIHRvIHRoZSBzdXN0YWluIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbc3VzdGFpbl1cdFRoZSBwZXJjZW50IG9mIHRoZSBtYXhpbXVtIHZhbHVlIHRoYXQgdGhlIGVudmVsb3BlIHJlc3RzIGF0IHVudGlsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dGhlIHJlbGVhc2UgaXMgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0VGhlIGFtb3VudCBvZiB0aW1lIGFmdGVyIHRoZSByZWxlYXNlIGlzIHRyaWdnZXJlZCBpdCB0YWtlcyB0byByZWFjaCAwLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBhbXBFbnYgPSBuZXcgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZSh7XG5cdFx0ICogXHRcImF0dGFja1wiOiAwLjEsXG5cdFx0ICogXHRcImRlY2F5XCI6IDAuMixcblx0XHQgKiBcdFwic3VzdGFpblwiOiAxLjAsXG5cdFx0ICogXHRcInJlbGVhc2VcIjogMC44XG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKiAvL2NyZWF0ZSBhbiBvc2NpbGxhdG9yIGFuZCBjb25uZWN0IGl0XG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KGFtcEVudikuc3RhcnQoKTtcblx0XHQgKiAvL3RyaWdnZXIgdGhlIGVudmVsb3BlcyBhdHRhY2sgYW5kIHJlbGVhc2UgXCI4dFwiIGFwYXJ0XG5cdFx0ICogYW1wRW52LnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiOHRcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkFtcGxpdHVkZUVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXQgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5jb25uZWN0KHRoaXMub3V0cHV0LmdhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUsIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVudmVsb3BlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQW1wbGl0dWRlRW52ZWxvcGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEFuYWx5c2VyTm9kZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhIHBvbHlmaWxsXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkFuYWx5c2VyTm9kZSAmJiAhQW5hbHlzZXJOb2RlLnByb3RvdHlwZS5nZXRGbG9hdFRpbWVEb21haW5EYXRhKSB7XG5cdCAgICAgICAgLy9yZWZlcmVuY2VkIGh0dHBzOi8vZ2l0aHViLmNvbS9tb2hheW9uYW8vZ2V0LWZsb2F0LXRpbWUtZG9tYWluLWRhdGFcblx0ICAgICAgICBBbmFseXNlck5vZGUucHJvdG90eXBlLmdldEZsb2F0VGltZURvbWFpbkRhdGEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgdmFyIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkubGVuZ3RoKTtcblx0ICAgICAgICAgICAgdGhpcy5nZXRCeXRlVGltZURvbWFpbkRhdGEodWludDgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVpbnQ4Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhcnJheVtpXSA9ICh1aW50OFtpXSAtIDEyOCkgLyAxMjg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgV3JhcHBlciBhcm91bmQgdGhlIG5hdGl2ZSBXZWIgQXVkaW8nc1xuXHRcdCAqICAgICAgICAgIFtBbmFseXNlck5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jaWRsLWRlZi1BbmFseXNlck5vZGUpLlxuXHRcdCAqICAgICAgICAgIEV4dHJhY3RzIEZGVCBvciBXYXZlZm9ybSBkYXRhIGZyb20gdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZz19IHR5cGUgVGhlIHJldHVybiB0eXBlIG9mIHRoZSBhbmFseXNpcywgZWl0aGVyIFwiZmZ0XCIsIG9yIFwid2F2ZWZvcm1cIi5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXI9fSBzaXplIFRoZSBzaXplIG9mIHRoZSBGRlQuIFZhbHVlIG11c3QgYmUgYSBwb3dlciBvZlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ3NpemUnXG5cdCAgICAgICAgXSwgVG9uZS5BbmFseXNlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW5hbHlzZXIgbm9kZS5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtBbmFseXNlck5vZGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbmFseXNpcyB0eXBlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYnVmZmVyIHRoYXQgdGhlIEZGVCBkYXRhIGlzIHdyaXR0ZW4gdG9cblx0XHRcdCAqICBAdHlwZSB7VHlwZWRBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICAvL3NldCB0aGUgdmFsdWVzIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BbmFseXNlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHZhbHVlcy5cblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdzaXplJzogMTAyNCxcblx0ICAgICAgICAndHlwZSc6ICdmZnQnLFxuXHQgICAgICAgICdzbW9vdGhpbmcnOiAwLjhcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUG9zc2libGUgcmV0dXJuIHR5cGVzIG9mIGFuYWx5c2VyLmdldFZhbHVlKClcblx0XHQgKiAgQGVudW0ge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuQW5hbHlzZXIuVHlwZSA9IHtcblx0ICAgICAgICBXYXZlZm9ybTogJ3dhdmVmb3JtJyxcblx0ICAgICAgICBGRlQ6ICdmZnQnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJ1biB0aGUgYW5hbHlzaXMgZ2l2ZW4gdGhlIGN1cnJlbnQgc2V0dGluZ3MgYW5kIHJldHVybiB0aGVcblx0XHQgKiAgcmVzdWx0IGFzIGEgVHlwZWRBcnJheS5cblx0XHQgKiAgQHJldHVybnMge1R5cGVkQXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkFuYWx5c2VyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5BbmFseXNlci5UeXBlLkZGVCkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodGhpcy5fYnVmZmVyKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQW5hbHlzZXIuVHlwZS5XYXZlZm9ybSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5nZXRGbG9hdFRpbWVEb21haW5EYXRhKHRoaXMuX2J1ZmZlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzaXplIG9mIGFuYWx5c2lzLiBUaGlzIG11c3QgYmUgYSBwb3dlciBvZiB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG5hbWUgc2l6ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQW5hbHlzZXIucHJvdG90eXBlLCAnc2l6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5mZnRTaXplID0gc2l6ZSAqIDI7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGFuYWx5c2lzIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGFuYWx5c2VyLmdldFZhbHVlKCksIGVpdGhlciBcImZmdFwiIG9yIFwid2F2ZWZvcm1cIi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuQW5hbHlzZXIjXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFuYWx5c2VyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZSAhPT0gVG9uZS5BbmFseXNlci5UeXBlLldhdmVmb3JtICYmIHR5cGUgIT09IFRvbmUuQW5hbHlzZXIuVHlwZS5GRlQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbmUuQW5hbHlzZXI6IGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIDAgcmVwcmVzZW50cyBubyB0aW1lIGF2ZXJhZ2luZyB3aXRoIHRoZSBsYXN0IGFuYWx5c2lzIGZyYW1lLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5BbmFseXNlciNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBzbW9vdGhpbmdcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFuYWx5c2VyLnByb3RvdHlwZSwgJ3Ntb290aGluZycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuYWx5c2VyLnNtb290aGluZ1RpbWVDb25zdGFudDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5zbW9vdGhpbmdUaW1lQ29uc3RhbnQgPSB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkFuYWx5c2VyfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BbmFseXNlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5BbmFseXNlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ29tcHJlc3NvciBpcyBhIHRoaW4gd3JhcHBlciBhcm91bmQgdGhlIFdlYiBBdWRpb1xuXHRcdCAqICAgICAgICAgW0R5bmFtaWNzQ29tcHJlc3Nvck5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLWR5bmFtaWNzY29tcHJlc3Nvcm5vZGUtaW50ZXJmYWNlKS5cblx0XHQgKiAgICAgICAgIENvbXByZXNzaW9uIHJlZHVjZXMgdGhlIHZvbHVtZSBvZiBsb3VkIHNvdW5kcyBvciBhbXBsaWZpZXMgcXVpZXQgc291bmRzXG5cdFx0ICogICAgICAgICBieSBuYXJyb3dpbmcgb3IgXCJjb21wcmVzc2luZ1wiIGFuIGF1ZGlvIHNpZ25hbCdzIGR5bmFtaWMgcmFuZ2UuXG5cdFx0ICogICAgICAgICBSZWFkIG1vcmUgb24gW1dpa2lwZWRpYV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRHluYW1pY19yYW5nZV9jb21wcmVzc2lvbikuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtEZWNpYmVsc3xPYmplY3R9IFt0aHJlc2hvbGRdIFRoZSB2YWx1ZSBhYm92ZSB3aGljaCB0aGUgY29tcHJlc3Npb24gc3RhcnRzIHRvIGJlIGFwcGxpZWQuXG5cdFx0ICogIEBwYXJhbSB7UG9zaXRpdmV9IFtyYXRpb10gVGhlIGdhaW4gcmVkdWN0aW9uIHJhdGlvLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjb21wID0gbmV3IFRvbmUuQ29tcHJlc3NvcigtMzAsIDMpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Db21wcmVzc29yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCcsXG5cdCAgICAgICAgICAgICdyYXRpbydcblx0ICAgICAgICBdLCBUb25lLkNvbXByZXNzb3IpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGNvbXByZXNzb3Igbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEeW5hbWljc0NvbXByZXNzb3JOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUR5bmFtaWNzQ29tcHJlc3NvcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0aHJlc2hvbGQgdmF1ZVxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnRocmVzaG9sZCA9IG5ldyBUb25lLlBhcmFtKHtcblx0ICAgICAgICAgICAgJ3BhcmFtJzogdGhpcy5fY29tcHJlc3Nvci50aHJlc2hvbGQsXG5cdCAgICAgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWNpYmVscyxcblx0ICAgICAgICAgICAgJ2NvbnZlcnQnOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhdHRhY2sgcGFyYW1ldGVyXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hdHRhY2sgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9jb21wcmVzc29yLmF0dGFjaywgVG9uZS5UeXBlLlRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByZWxlYXNlIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG5ldyBUb25lLlBhcmFtKHRoaXMuX2NvbXByZXNzb3IucmVsZWFzZSwgVG9uZS5UeXBlLlRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBrbmVlIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmtuZWUgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2NvbXByZXNzb3Iua25lZSxcblx0ICAgICAgICAgICAgJ3VuaXRzJzogVG9uZS5UeXBlLkRlY2liZWxzLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJhdGlvIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJhdGlvID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9jb21wcmVzc29yLnJhdGlvLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAna25lZScsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJyxcblx0ICAgICAgICAgICAgJ2F0dGFjaycsXG5cdCAgICAgICAgICAgICdyYXRpbycsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5zZXQob3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db21wcmVzc29yLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncmF0aW8nOiAxMixcblx0ICAgICAgICAndGhyZXNob2xkJzogLTI0LFxuXHQgICAgICAgICdyZWxlYXNlJzogMC4yNSxcblx0ICAgICAgICAnYXR0YWNrJzogMC4wMDMsXG5cdCAgICAgICAgJ2tuZWUnOiAzMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Db21wcmVzc29yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbXByZXNzb3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdrbmVlJyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnLFxuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ3JhdGlvJyxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmF0dGFjay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5hdHRhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVsZWFzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yZWxlYXNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnRocmVzaG9sZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmF0aW8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmF0aW8gPSBudWxsO1xuXHQgICAgICAgIHRoaXMua25lZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5rbmVlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Db21wcmVzc29yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQWRkIGEgc2lnbmFsIGFuZCBhIG51bWJlciBvciB0d28gc2lnbmFscy4gV2hlbiBubyB2YWx1ZSBpc1xuXHRcdCAqICAgICAgICAgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yLCBUb25lLkFkZCB3aWxsIHN1bSA8Y29kZT5pbnB1dFswXTwvY29kZT5cblx0XHQgKiAgICAgICAgIGFuZCA8Y29kZT5pbnB1dFsxXTwvY29kZT4uIElmIGEgdmFsdWUgaXMgcGFzc2VkIGludG8gdGhlIGNvbnN0cnVjdG9yLCBcblx0XHQgKiAgICAgICAgIHRoZSBpdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBpbnB1dC5cblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWUgSWYgbm8gdmFsdWUgaXMgcHJvdmlkZWQsIFRvbmUuQWRkIHdpbGwgc3VtIHRoZSBmaXJzdFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBzZWNvbmQgaW5wdXRzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDIpO1xuXHRcdCAqIHZhciBhZGQgPSBuZXcgVG9uZS5BZGQoMik7XG5cdFx0ICogc2lnbmFsLmNvbm5lY3QoYWRkKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgYWRkIGVxdWFscyA0XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pZiBjb25zdHJ1Y3RlZCB3aXRoIG5vIGFyZ3VtZW50c1xuXHRcdCAqIC8vaXQgd2lsbCBhZGQgdGhlIGZpcnN0IGFuZCBzZWNvbmQgaW5wdXRzXG5cdFx0ICogdmFyIGFkZCA9IG5ldyBUb25lLkFkZCgpO1xuXHRcdCAqIHZhciBzaWcwID0gbmV3IFRvbmUuU2lnbmFsKDMpLmNvbm5lY3QoYWRkLCAwLCAwKTtcblx0XHQgKiB2YXIgc2lnMSA9IG5ldyBUb25lLlNpZ25hbCg0KS5jb25uZWN0KGFkZCwgMCwgMSk7XG5cdFx0ICogLy90aGUgb3V0cHV0IG9mIGFkZCBlcXVhbHMgNy4gXG5cdFx0ICovXG5cdCAgICBUb25lLkFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDIsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBzdW1taW5nIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1bSA9IHRoaXMuaW5wdXRbMF0gPSB0aGlzLmlucHV0WzFdID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuaW5wdXRbMV0gPSBuZXcgVG9uZS5TaWduYWwodmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX3BhcmFtLmNvbm5lY3QodGhpcy5fc3VtKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkFkZCwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BZGR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQWRkLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc3VtLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdW0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFkZDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBNdWx0aXBseSB0d28gaW5jb21pbmcgc2lnbmFscy4gT3IsIGlmIGEgbnVtYmVyIGlzIGdpdmVuIGluIHRoZSBjb25zdHJ1Y3RvciwgXG5cdFx0ICogICAgICAgICAgbXVsdGlwbGllcyB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IHRoYXQgdmFsdWUuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWUgQ29uc3RhbnQgdmFsdWUgdG8gbXVsdGlwbGUuIElmIG5vIHZhbHVlIGlzIHByb3ZpZGVkLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgcmV0dXJuIHRoZSBwcm9kdWN0IG9mIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGlucHV0c1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBtdWx0ID0gbmV3IFRvbmUuTXVsdGlwbHkoKTtcblx0XHQgKiB2YXIgc2lnQSA9IG5ldyBUb25lLlNpZ25hbCgzKTtcblx0XHQgKiB2YXIgc2lnQiA9IG5ldyBUb25lLlNpZ25hbCg0KTtcblx0XHQgKiBzaWdBLmNvbm5lY3QobXVsdCwgMCwgMCk7XG5cdFx0ICogc2lnQi5jb25uZWN0KG11bHQsIDAsIDEpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIG11bHQgaXMgMTIuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG11bHQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMCk7XG5cdFx0ICogdmFyIHNpZyA9IG5ldyBUb25lLlNpZ25hbCgyKS5jb25uZWN0KG11bHQpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBtdWx0IGlzIDIwLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGlwbHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXQgbm9kZSBpcyB0aGUgc2FtZSBhcyB0aGUgb3V0cHV0IG5vZGVcblx0XHRcdCAqICBpdCBpcyBhbHNvIHRoZSBHYWluTm9kZSB3aGljaCBoYW5kbGVzIHRoZSBzY2FsaW5nIG9mIGluY29taW5nIHNpZ25hbFxuXHRcdFx0ICogIFxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IHRoaXMuaW5wdXRbMF0gPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2NhbGluZyBwYXJhbWV0ZXJcblx0XHRcdCAqICBAdHlwZSB7QXVkaW9QYXJhbX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0WzFdID0gdGhpcy5vdXRwdXQuZ2Fpbjtcblx0ICAgICAgICB0aGlzLl9wYXJhbS52YWx1ZSA9IFRvbmUuZGVmYXVsdEFyZyh2YWx1ZSwgMCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NdWx0aXBseSwgVG9uZS5TaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk11bHRpcGx5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpcGx5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbXVsdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpcGx5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTmVnYXRlIHRoZSBpbmNvbWluZyBzaWduYWwuIGkuZS4gYW4gaW5wdXQgc2lnbmFsIG9mIDEwIHdpbGwgb3V0cHV0IC0xMFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBuZWcgPSBuZXcgVG9uZS5OZWdhdGUoKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKC0yKS5jb25uZWN0KG5lZyk7XG5cdFx0ICogLy9vdXRwdXQgb2YgbmVnIGlzIHBvc2l0aXZlIDIuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5OZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbmVnYXRpb24gaXMgZG9uZSBieSBtdWx0aXBseWluZyBieSAtMVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tdWx0aXBseSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk11bHRpcGx5KC0xKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk5lZ2F0ZSwgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5OZWdhdGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTmVnYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0aXBseSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTmVnYXRlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgU3VidHJhY3QgdGhlIHNpZ25hbCBjb25uZWN0ZWQgdG8gPGNvZGU+aW5wdXRbMV08L2NvZGU+IGZyb20gdGhlIHNpZ25hbCBjb25uZWN0ZWQgXG5cdFx0ICogICAgICAgICB0byA8Y29kZT5pbnB1dFswXTwvY29kZT4uIElmIGFuIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGluIHRoZSBjb25zdHJ1Y3RvciwgdGhlIFxuXHRcdCAqICAgICAgICAgc2lnbmFscyA8Y29kZT4udmFsdWU8L2NvZGU+IHdpbGwgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSB2YWx1ZSBUaGUgdmFsdWUgdG8gc3VidHJhY3QgZnJvbSB0aGUgaW5jb21pbmcgc2lnbmFsLiBJZiB0aGUgdmFsdWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBpcyBvbWl0dGVkLCBpdCB3aWxsIHN1YnRyYWN0IHRoZSBzZWNvbmQgc2lnbmFsIGZyb20gdGhlIGZpcnN0LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzdWIgPSBuZXcgVG9uZS5TdWJ0cmFjdCgxKTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDQpLmNvbm5lY3Qoc3ViKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2Ygc3ViIGlzIDMuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzdWIgPSBuZXcgVG9uZS5TdWJ0cmFjdCgpO1xuXHRcdCAqIHZhciBzaWdBID0gbmV3IFRvbmUuU2lnbmFsKDEwKTtcblx0XHQgKiB2YXIgc2lnQiA9IG5ldyBUb25lLlNpZ25hbCgyLjUpO1xuXHRcdCAqIHNpZ0EuY29ubmVjdChzdWIsIDAsIDApO1xuXHRcdCAqIHNpZ0IuY29ubmVjdChzdWIsIDAsIDEpO1xuXHRcdCAqIC8vb3V0cHV0IG9mIHN1YiBpcyA3LjVcblx0XHQgKi9cblx0ICAgIFRvbmUuU3VidHJhY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc3VtbWluZyBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdW0gPSB0aGlzLmlucHV0WzBdID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgbmVnYXRlIHRoZSBpbnB1dCBvZiB0aGUgc2Vjb25kIGlucHV0IGJlZm9yZSBjb25uZWN0aW5nIGl0XG5cdFx0XHQgKiAgdG8gdGhlIHN1bW1pbmcgbm9kZS5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5OZWdhdGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX25lZyA9IG5ldyBUb25lLk5lZ2F0ZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSB2YWx1ZSBpcyBzZXRcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlNpZ25hbH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLlNpZ25hbCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uY2hhaW4odGhpcy5fbmVnLCB0aGlzLl9zdW0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3VidHJhY3QsIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2lnbmFsQmFzZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdWJ0cmFjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX25lZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbmVnID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdW0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX3N1bSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3VidHJhY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgR3JlYXRlclRoYW5aZXJvIG91dHB1dHMgMSB3aGVuIHRoZSBpbnB1dCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gemVyb1xuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGd0MCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuWmVybygpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoMC4wMSkuY29ubmVjdChndDApO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBndDAgaXMgMS4gXG5cdFx0ICogc2lnLnZhbHVlID0gMDtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2YgZ3QwIGlzIDAuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhblplcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuV2F2ZVNoYXBlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdGhyZXNoID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSwgMTI3KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgZmlyc3QgdGhyZXNob2xkZWQgc2lnbmFsIGJ5IGEgbGFyZ2UgdmFsdWUuXG5cdFx0XHQgKiAgdGhpcyB3aWxsIGhlbHAgd2l0aCB2YWx1ZXMgd2hpY2ggYXJlIHZlcnkgY2xvc2UgdG8gMFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxMDAwMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmNvbm5lY3QodGhpcy5fdGhyZXNoKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkdyZWF0ZXJUaGFuWmVybywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIG1ldGhvZFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HcmVhdGVyVGhhblplcm99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JlYXRlclRoYW5aZXJvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90aHJlc2ggPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkdyZWF0ZXJUaGFuWmVybztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBPdXRwdXQgMSBpZiB0aGUgc2lnbmFsIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUsIG90aGVyd2lzZSBvdXRwdXRzIDAuXG5cdFx0ICogICAgICAgICAgY2FuIGNvbXBhcmUgdHdvIHNpZ25hbHMgb3IgYSBzaWduYWwgYW5kIGEgbnVtYmVyLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWx9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MF0gdGhlIHZhbHVlIHRvIGNvbXBhcmUgdG8gdGhlIGluY29taW5nIHNpZ25hbFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBndCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuKDIpO1xuXHRcdCAqIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoNCkuY29ubmVjdChndCk7XG5cdFx0ICogLy9vdXRwdXQgb2YgZ3QgaXMgZXF1YWwgMS4gXG5cdFx0ICovXG5cdCAgICBUb25lLkdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWwuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc3VidHJhY3QgdGhlIGFtb3VudCBmcm9tIHRoZSBpbmNvbWluZyBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TdWJ0cmFjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFyYW0gPSB0aGlzLmlucHV0WzBdID0gbmV3IFRvbmUuU3VidHJhY3QodmFsdWUpO1xuXHQgICAgICAgIHRoaXMuaW5wdXRbMV0gPSB0aGlzLl9wYXJhbS5pbnB1dFsxXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb21wYXJlIHRoYXQgYW1vdW50IHRvIHplcm9cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HcmVhdGVyVGhhblplcm99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2d0eiA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR3JlYXRlclRoYW5aZXJvKCk7XG5cdCAgICAgICAgLy9jb25uZWN0XG5cdCAgICAgICAgdGhpcy5fcGFyYW0uY29ubmVjdCh0aGlzLl9ndHopO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR3JlYXRlclRoYW4sIFRvbmUuU2lnbmFsKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIG1ldGhvZFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HcmVhdGVyVGhhbn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmVhdGVyVGhhbi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2d0ei5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ3R6ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5HcmVhdGVyVGhhbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYW4gaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoLTEpO1xuXHRcdCAqIHZhciBhYnMgPSBuZXcgVG9uZS5BYnMoKTtcblx0XHQgKiBzaWduYWwuY29ubmVjdChhYnMpO1xuXHRcdCAqIC8vdGhlIG91dHB1dCBvZiBhYnMgaXMgMS4gXG5cdFx0ICovXG5cdCAgICBUb25lLkFicyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MZXNzVGhhbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWJzID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuV2F2ZVNoYXBlcihmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LCAxMjcpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQWJzLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgbWV0aG9kXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFic30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BYnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYWJzLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hYnMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFicztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFNpZ25hbC1yYXRlIG1vZHVsbyBvcGVyYXRvci4gT25seSB3b3JrcyBpbiBBdWRpb1JhbmdlIFstMSwgMV0gYW5kIGZvciBtb2R1bHVzXG5cdFx0ICogICAgICAgICB2YWx1ZXMgaW4gdGhlIE5vcm1hbFJhbmdlLiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU2lnbmFsQmFzZX1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gbW9kdWx1cyBUaGUgbW9kdWx1cyB0byBhcHBseS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbW9kID0gbmV3IFRvbmUuTW9kdWxvKDAuMilcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChtb2QpO1xuXHRcdCAqIC8vbW9kIG91dHB1dHMgMC4xXG5cdFx0ICovXG5cdCAgICBUb25lLk1vZHVsbyA9IGZ1bmN0aW9uIChtb2R1bHVzKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgd2F2ZXNoYXBlciBnZXRzIHRoZSBpbnRlZ2VyIG11bHRpcGxlIG9mIFxuXHRcdFx0ICogIHRoZSBpbnB1dCBzaWduYWwgYW5kIHRoZSBtb2R1bHVzLlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuV2F2ZVNoYXBlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG5ldyBUb25lLldhdmVTaGFwZXIoTWF0aC5wb3coMiwgMTYpKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW50ZWdlciBtdWx0aXBsZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBtb2R1bHVzXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tdWx0aXBseSA9IG5ldyBUb25lLk11bHRpcGx5KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgYW5kIHN1YnRyYWN0ZWQgZnJvbSB0aGUgaW5wdXQgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU3VidHJhY3QoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbW9kdWx1cyBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2RTaWduYWwgPSBuZXcgVG9uZS5TaWduYWwobW9kdWx1cyk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZmFuKHRoaXMuX3NoYXBlciwgdGhpcy5fc3VidHJhY3QpO1xuXHQgICAgICAgIHRoaXMuX21vZFNpZ25hbC5jb25uZWN0KHRoaXMuX211bHRpcGx5LCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuY29ubmVjdCh0aGlzLl9tdWx0aXBseSwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkuY29ubmVjdCh0aGlzLl9zdWJ0cmFjdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5fc2V0V2F2ZVNoYXBlcihtb2R1bHVzKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1vZHVsbywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9ICBtb2QgIHRoZSBtb2R1bHVzIHRvIGFwcGx5XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vZHVsby5wcm90b3R5cGUuX3NldFdhdmVTaGFwZXIgPSBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLnNldE1hcChmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGguZmxvb3IoKHZhbCArIDAuMDAwMSkgLyBtb2QpO1xuXHQgICAgICAgICAgICByZXR1cm4gbXVsdGlwbGU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1vZHVsdXMgdmFsdWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTW9kdWxvI1xuXHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTW9kdWxvLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kU2lnbmFsLnZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZFNpZ25hbC52YWx1ZSA9IG1vZDtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0V2F2ZVNoYXBlcihtb2QpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9kdWxvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1vZHVsby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbXVsdGlwbHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGx5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3VidHJhY3QgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZFNpZ25hbC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kU2lnbmFsID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb2R1bG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBdWRpb1RvR2FpbiBjb252ZXJ0cyBhbiBpbnB1dCBpbiBBdWRpb1JhbmdlIFstMSwxXSB0byBOb3JtYWxSYW5nZSBbMCwxXS4gXG5cdFx0ICogICAgICAgICBTZWUgVG9uZS5HYWluVG9BdWRpby5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIGEyZyA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkF1ZGlvVG9HYWluID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICh4ICsgMSkgLyAyO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXVkaW9Ub0dhaW4sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQXVkaW9Ub0dhaW59IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ub0dhaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9ybS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXVkaW9Ub0dhaW47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBFdmFsdWF0ZSBhbiBleHByZXNzaW9uIGF0IGF1ZGlvIHJhdGUuIDxicj48YnI+XG5cdFx0ICogICAgICAgICBQYXJzaW5nIGNvZGUgbW9kaWZpZWQgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3RhcGRpZ2l0L1xuXHRcdCAqICAgICAgICAgQ29weXJpZ2h0IDIwMTEgMjAxMiBBcml5YSBIaWRheWF0LCBOZXcgQlNEIExpY2Vuc2Vcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IGV4cHIgdGhlIGV4cHJlc3Npb24gdG8gZ2VuZXJhdGVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2FkZHMgdGhlIHNpZ25hbHMgZnJvbSBpbnB1dFswXSBhbmQgaW5wdXRbMV0uXG5cdFx0ICogdmFyIGV4cHIgPSBuZXcgVG9uZS5FeHByKFwiJDAgKyAkMVwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRXhwciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB2YXIgZXhwciA9IHRoaXMuX3JlcGxhY2VtZW50cyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblx0ICAgICAgICB2YXIgaW5wdXRDb3VudCA9IHRoaXMuX3BhcnNlSW5wdXRzKGV4cHIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGhvbGQgb250byBhbGwgb2YgdGhlIG5vZGVzIGZvciBkaXNwb3NhbFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgaW5wdXRzLiBUaGUgbGVuZ3RoIGlzIGRldGVybWluZWQgYnkgdGhlIGV4cHJlc3Npb24uIFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSBuZXcgQXJyYXkoaW5wdXRDb3VudCk7XG5cdCAgICAgICAgLy9jcmVhdGUgYSBnYWluIGZvciBlYWNoIGlucHV0XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dFtpXSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vcGFyc2UgdGhlIHN5bnRheCB0cmVlXG5cdCAgICAgICAgdmFyIHRyZWUgPSB0aGlzLl9wYXJzZVRyZWUoZXhwcik7XG5cdCAgICAgICAgLy9ldmFsdWF0ZSB0aGUgcmVzdWx0c1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZXZhbCh0cmVlKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VOb2RlcygpO1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbmUuRXhwcjogQ291bGQgZXZhbHVhdGUgZXhwcmVzc2lvbjogJyArIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IG5vZGUgaXMgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvblxuXHRcdFx0ICogIEB0eXBlIHtUb25lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FeHByLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLy9zb21lIGhlbHBlcnMgdG8gY3V0IGRvd24gdGhlIGFtb3VudCBvZiBjb2RlXG5cdCAgICBmdW5jdGlvbiBhcHBseUJpbmFyeShDb25zdHJ1Y3RvciwgYXJncywgc2VsZikge1xuXHQgICAgICAgIHZhciBvcCA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCwgMCwgMCk7XG5cdCAgICAgICAgc2VsZi5fZXZhbChhcmdzWzFdKS5jb25uZWN0KG9wLCAwLCAxKTtcblx0ICAgICAgICByZXR1cm4gb3A7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBhcHBseVVuYXJ5KENvbnN0cnVjdG9yLCBhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgdmFyIG9wID0gbmV3IENvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wLCAwLCAwKTtcblx0ICAgICAgICByZXR1cm4gb3A7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBnZXROdW1iZXIoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZyA/IHBhcnNlRmxvYXQoYXJnKSA6IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGxpdGVyYWxOdW1iZXIoYXJnKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyZyAmJiBhcmcuYXJncyA/IHBhcnNlRmxvYXQoYXJnLmFyZ3MpIDogdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgICAgLypcblx0XHQgKiAgdGhlIEV4cHJlc3Npb25zIHRoYXQgVG9uZS5FeHByIGNhbiBwYXJzZS5cblx0XHQgKlxuXHRcdCAqICBlYWNoIGV4cHJlc3Npb24gYmVsb25ncyB0byBhIGdyb3VwIGFuZCBjb250YWlucyBhIHJlZ2V4cCBcblx0XHQgKiAgZm9yIHNlbGVjdGluZyB0aGUgb3BlcmF0b3IgYXMgd2VsbCBhcyB0aGF0IG9wZXJhdG9ycyBtZXRob2Rcblx0XHQgKiAgXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIuX0V4cHJlc3Npb25zID0ge1xuXHQgICAgICAgIC8vdmFsdWVzXG5cdCAgICAgICAgJ3ZhbHVlJzoge1xuXHQgICAgICAgICAgICAnc2lnbmFsJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcZCtcXC5cXGQrfF5cXGQrLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzaWcgPSBuZXcgVG9uZS5TaWduYWwoZ2V0TnVtYmVyKGFyZykpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdpbnB1dCc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCRcXGQvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoYXJnLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuaW5wdXRbZ2V0TnVtYmVyKGFyZy5zdWJzdHIoMSkpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy9zeW50YWN0aWMgZ2x1ZVxuXHQgICAgICAgICdnbHVlJzoge1xuXHQgICAgICAgICAgICAnKCc6IHsgcmVnZXhwOiAvXlxcKC8gfSxcblx0ICAgICAgICAgICAgJyknOiB7IHJlZ2V4cDogL15cXCkvIH0sXG5cdCAgICAgICAgICAgICcsJzogeyByZWdleHA6IC9eLC8gfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy9mdW5jdGlvbnNcblx0ICAgICAgICAnZnVuYyc6IHtcblx0ICAgICAgICAgICAgJ2Ficyc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15hYnMvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseVVuYXJ5LmJpbmQodGhpcywgVG9uZS5BYnMpXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdtb2QnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9ebW9kLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWx1cyA9IGxpdGVyYWxOdW1iZXIoYXJnc1sxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IFRvbmUuTW9kdWxvKG1vZHVsdXMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAncG93Jzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXnBvdy8sXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChhcmdzLCBzZWxmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4cCA9IGxpdGVyYWxOdW1iZXIoYXJnc1sxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IFRvbmUuUG93KGV4cCk7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZi5fZXZhbChhcmdzWzBdKS5jb25uZWN0KG9wKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3A7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICdhMmcnOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eYTJnLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgVG9uZS5BdWRpb1RvR2FpbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbGYuX2V2YWwoYXJnc1swXSkuY29ubmVjdChvcCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvL2JpbmFyeSBleHByZXNzaW9uc1xuXHQgICAgICAgICdiaW5hcnknOiB7XG5cdCAgICAgICAgICAgICcrJzoge1xuXHQgICAgICAgICAgICAgICAgcmVnZXhwOiAvXlxcKy8sXG5cdCAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseUJpbmFyeS5iaW5kKHRoaXMsIFRvbmUuQWRkKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnLSc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXC0vLFxuXHQgICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKGFyZ3MsIHNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL2JvdGggdW5hcnkgYW5kIGJpbmFyeSBvcFxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlVbmFyeShUb25lLk5lZ2F0ZSwgYXJncywgc2VsZik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5QmluYXJ5KFRvbmUuU3VidHJhY3QsIGFyZ3MsIHNlbGYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJyonOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwqLyxcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDAsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGFwcGx5QmluYXJ5LmJpbmQodGhpcywgVG9uZS5NdWx0aXBseSlcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLy91bmFyeSBleHByZXNzaW9uc1xuXHQgICAgICAgICd1bmFyeSc6IHtcblx0ICAgICAgICAgICAgJy0nOiB7XG5cdCAgICAgICAgICAgICAgICByZWdleHA6IC9eXFwtLyxcblx0ICAgICAgICAgICAgICAgIG1ldGhvZDogYXBwbHlVbmFyeS5iaW5kKHRoaXMsIFRvbmUuTmVnYXRlKVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnISc6IHtcblx0ICAgICAgICAgICAgICAgIHJlZ2V4cDogL15cXCEvLFxuXHQgICAgICAgICAgICAgICAgbWV0aG9kOiBhcHBseVVuYXJ5LmJpbmQodGhpcywgVG9uZS5OT1QpXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBwYXJhbSAgIHtzdHJpbmd9IGV4cHIgdGhlIGV4cHJlc3Npb24gc3RyaW5nXG5cdFx0ICogIEByZXR1cm4gIHtudW1iZXJ9ICAgICAgdGhlIGlucHV0IGNvdW50XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl9wYXJzZUlucHV0cyA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIGlucHV0QXJyYXkgPSBleHByLm1hdGNoKC9cXCRcXGQvZyk7XG5cdCAgICAgICAgdmFyIGlucHV0TWF4ID0gMDtcblx0ICAgICAgICBpZiAoaW5wdXRBcnJheSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnB1dE51bSA9IHBhcnNlSW50KGlucHV0QXJyYXlbaV0uc3Vic3RyKDEpKSArIDE7XG5cdCAgICAgICAgICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dE51bSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGlucHV0TWF4O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBAcGFyYW0gICB7QXJyYXl9IGFyZ3MgXHRhbiBhcnJheSBvZiBhcmd1bWVudHNcblx0XHQgKiAgQHJldHVybiAge3N0cmluZ30gdGhlIHJlc3VsdHMgb2YgdGhlIHJlcGxhY2VtZW50cyBiZWluZyByZXBsYWNlZFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fcmVwbGFjZW1lbnRzID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0ICAgICAgICB2YXIgZXhwciA9IGFyZ3Muc2hpZnQoKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIucmVwbGFjZSgvXFwlL2ksIGFyZ3NbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZXhwcjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdG9rZW5pemUgdGhlIGV4cHJlc3Npb24gYmFzZWQgb24gdGhlIEV4cHJlc3Npb25zIG9iamVjdFxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fSAgICAgIHJldHVybnMgdHdvIG1ldGhvZHMgb24gdGhlIHRva2VuaXplZCBsaXN0LCBuZXh0IGFuZCBwZWVrXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV4cHIucHJvdG90eXBlLl90b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByKSB7XG5cdCAgICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG5cdCAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuXHQgICAgICAgIHdoaWxlIChleHByLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIudHJpbSgpO1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBnZXROZXh0VG9rZW4oZXhwcik7XG5cdCAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblx0ICAgICAgICAgICAgZXhwciA9IGV4cHIuc3Vic3RyKHRva2VuLnZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE5leHRUb2tlbihleHByKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gVG9uZS5FeHByLl9FeHByZXNzaW9ucykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gVG9uZS5FeHByLl9FeHByZXNzaW9uc1t0eXBlXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9wTmFtZSBpbiBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IGdyb3VwW29wTmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlZyA9IG9wLnJlZ2V4cDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBleHByLm1hdGNoKHJlZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoWzBdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcC5tZXRob2Rcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUb25lLkV4cHI6IFVuZXhwZWN0ZWQgdG9rZW4gJyArIGV4cHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zWysrcG9zaXRpb25dO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBwZWVrOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Bvc2l0aW9uICsgMV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICByZWN1cnNpdmVseSBwYXJzZSB0aGUgc3RyaW5nIGV4cHJlc3Npb24gaW50byBhIHN5bnRheCB0cmVlXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gICB7c3RyaW5nfSBleHByIFxuXHRcdCAqICBAcmV0dXJuICB7T2JqZWN0fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fcGFyc2VUcmVlID0gZnVuY3Rpb24gKGV4cHIpIHtcblx0ICAgICAgICB2YXIgbGV4ZXIgPSB0aGlzLl90b2tlbml6ZShleHByKTtcblx0ICAgICAgICB2YXIgaXNVbmRlZiA9IFRvbmUuaXNVbmRlZi5iaW5kKHRoaXMpO1xuXHQgICAgICAgIGZ1bmN0aW9uIG1hdGNoU3ludGF4KHRva2VuLCBzeW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICFpc1VuZGVmKHRva2VuKSAmJiB0b2tlbi50eXBlID09PSAnZ2x1ZScgJiYgdG9rZW4udmFsdWUgPT09IHN5bjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gbWF0Y2hHcm91cCh0b2tlbiwgZ3JvdXBOYW1lLCBwcmVjKSB7XG5cdCAgICAgICAgICAgIHZhciByZXQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwID0gVG9uZS5FeHByLl9FeHByZXNzaW9uc1tncm91cE5hbWVdO1xuXHQgICAgICAgICAgICBpZiAoIWlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvcE5hbWUgaW4gZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBncm91cFtvcE5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcC5yZWdleHAudGVzdCh0b2tlbi52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmKHByZWMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AucHJlY2VkZW5jZSA9PT0gcHJlYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKHByZWNlZGVuY2UpIHtcblx0ICAgICAgICAgICAgaWYgKGlzVW5kZWYocHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgICAgIHByZWNlZGVuY2UgPSA1O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBleHByO1xuXHQgICAgICAgICAgICBpZiAocHJlY2VkZW5jZSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5KCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKHByZWNlZGVuY2UgLSAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIHdoaWxlIChtYXRjaEdyb3VwKHRva2VuLCAnYmluYXJ5JywgcHJlY2VkZW5jZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogdG9rZW4udmFsdWUsXG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0b2tlbi5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHByLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUV4cHJlc3Npb24ocHJlY2VkZW5jZSAtIDEpXG5cdCAgICAgICAgICAgICAgICAgICAgXVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBwYXJzZVVuYXJ5KCkge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGV4cHI7XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICBpZiAobWF0Y2hHcm91cCh0b2tlbiwgJ3VuYXJ5JykpIHtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnkoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHRva2VuLnZhbHVlLFxuXHQgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogdG9rZW4ubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtleHByXVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VQcmltYXJ5KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeSgpIHtcblx0ICAgICAgICAgICAgdmFyIHRva2VuLCBleHByO1xuXHQgICAgICAgICAgICB0b2tlbiA9IGxleGVyLnBlZWsoKTtcblx0ICAgICAgICAgICAgaWYgKGlzVW5kZWYodG9rZW4pKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogVW5leHBlY3RlZCB0ZXJtaW5hdGlvbiBvZiBleHByZXNzaW9uJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdmdW5jJykge1xuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGdW5jdGlvbkNhbGwodG9rZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAndmFsdWUnKSB7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiB0b2tlbi5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogdG9rZW4udmFsdWVcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKG1hdGNoU3ludGF4KHRva2VuLCAnKCcpKSB7XG5cdCAgICAgICAgICAgICAgICBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICAgICAgICAgICAgICB0b2tlbiA9IGxleGVyLm5leHQoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcpJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0V4cGVjdGVkICknKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBleHByO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBQYXJzZSBlcnJvciwgY2Fubm90IHByb2Nlc3MgdG9rZW4gJyArIHRva2VuLnZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbkNhbGwoZnVuYykge1xuXHQgICAgICAgICAgICB2YXIgdG9rZW4sIGFyZ3MgPSBbXTtcblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5uZXh0KCk7XG5cdCAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcoJykpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVG9uZS5FeHByOiBFeHBlY3RlZCAoIGluIGEgZnVuY3Rpb24gY2FsbCBcIicgKyBmdW5jLnZhbHVlICsgJ1wiJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG9rZW4gPSBsZXhlci5wZWVrKCk7XG5cdCAgICAgICAgICAgIGlmICghbWF0Y2hTeW50YXgodG9rZW4sICcpJykpIHtcblx0ICAgICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50TGlzdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICBpZiAoIW1hdGNoU3ludGF4KHRva2VuLCAnKScpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RvbmUuRXhwcjogRXhwZWN0ZWQgKSBpbiBhIGZ1bmN0aW9uIGNhbGwgXCInICsgZnVuYy52YWx1ZSArICdcIicpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgYXJnczogYXJncyxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudExpc3QoKSB7XG5cdCAgICAgICAgICAgIHZhciB0b2tlbiwgZXhwciwgYXJncyA9IFtdO1xuXHQgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZXhwcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIHRocm93IGV4Y2VwdGlvbj9cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGFyZ3MucHVzaChleHByKTtcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gbGV4ZXIucGVlaygpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtYXRjaFN5bnRheCh0b2tlbiwgJywnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbGV4ZXIubmV4dCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhcmdzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHJlY3Vyc2l2ZWx5IGV2YWx1YXRlIHRoZSBleHByZXNzaW9uIHRyZWVcblx0XHQgKiAgQHBhcmFtICAge09iamVjdH0gdHJlZSBcblx0XHQgKiAgQHJldHVybiAge0F1ZGlvTm9kZX0gICAgICB0aGUgcmVzdWx0aW5nIGF1ZGlvIG5vZGUgZnJvbSB0aGUgZXhwcmVzc2lvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fZXZhbCA9IGZ1bmN0aW9uICh0cmVlKSB7XG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodHJlZSkpIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0cmVlLm1ldGhvZCh0cmVlLmFyZ3MsIHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2UgYWxsIHRoZSBub2Rlc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5fZGlzcG9zZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNGdW5jdGlvbihub2RlLmRpc3Bvc2UpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzRnVuY3Rpb24obm9kZS5kaXNjb25uZWN0KSkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbm9kZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX25vZGVzW2ldID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fbm9kZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqL1xuXHQgICAgVG9uZS5FeHByLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2Rpc3Bvc2VOb2RlcygpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkV4cHI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBDb252ZXJ0IGFuIGluY29taW5nIHNpZ25hbCBiZXR3ZWVuIDAsIDEgdG8gYW4gZXF1YWwgcG93ZXIgZ2FpbiBzY2FsZS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZXFQb3dHYWluID0gbmV3IFRvbmUuRXF1YWxQb3dlckdhaW4oKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRXF1YWxQb3dlckdhaW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuV2F2ZVNoYXBlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXFQb3dlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAoTWF0aC5hYnModmFsKSA8IDAuMDAxKSB7XG5cdCAgICAgICAgICAgICAgICAvL3Nob3VsZCBvdXRwdXQgMCB3aGVuIGlucHV0IGlzIDBcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFRvbmUuZXF1YWxQb3dlclNjYWxlKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcyksIDQwOTYpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRXF1YWxQb3dlckdhaW4sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRXF1YWxQb3dlckdhaW59IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXF1YWxQb3dlckdhaW4ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZXFQb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXFQb3dlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRXF1YWxQb3dlckdhaW47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzICBUb25lLkNyb3NzZmFkZSBwcm92aWRlcyBlcXVhbCBwb3dlciBmYWRpbmcgYmV0d2VlbiB0d28gaW5wdXRzLlxuXHRcdCAqICAgICAgICAgTW9yZSBvbiBjcm9zc2ZhZGluZyB0ZWNobmlxdWUgW2hlcmVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZhZGVfKGF1ZGlvX2VuZ2luZWVyaW5nKSNDcm9zc2ZhZGluZykuXG5cdFx0ICpcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKiBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogQHBhcmFtIHtOb3JtYWxSYW5nZX0gW2luaXRpYWxGYWRlPTAuNV1cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIHZhciBjcm9zc0ZhZGUgPSBuZXcgVG9uZS5Dcm9zc0ZhZGUoMC41KTtcblx0XHQgKiAvL2Nvbm5lY3QgZWZmZWN0IEEgdG8gY3Jvc3NmYWRlIGZyb21cblx0XHQgKiAvL2VmZmVjdCBvdXRwdXQgMCB0byBjcm9zc2ZhZGUgaW5wdXQgMFxuXHRcdCAqIGVmZmVjdEEuY29ubmVjdChjcm9zc0ZhZGUsIDAsIDApO1xuXHRcdCAqIC8vY29ubmVjdCBlZmZlY3QgQiB0byBjcm9zc2ZhZGUgZnJvbVxuXHRcdCAqIC8vZWZmZWN0IG91dHB1dCAwIHRvIGNyb3NzZmFkZSBpbnB1dCAxXG5cdFx0ICogZWZmZWN0Qi5jb25uZWN0KGNyb3NzRmFkZSwgMCwgMSk7XG5cdFx0ICogY3Jvc3NGYWRlLmZhZGUudmFsdWUgPSAwO1xuXHRcdCAqIC8vIF4gb25seSBlZmZlY3RBIGlzIG91dHB1dFxuXHRcdCAqIGNyb3NzRmFkZS5mYWRlLnZhbHVlID0gMTtcblx0XHQgKiAvLyBeIG9ubHkgZWZmZWN0QiBpcyBvdXRwdXRcblx0XHQgKiBjcm9zc0ZhZGUuZmFkZS52YWx1ZSA9IDAuNTtcblx0XHQgKiAvLyBeIHRoZSB0d28gc2lnbmFscyBhcmUgbWl4ZWQgZXF1YWxseS5cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3Jvc3NGYWRlID0gZnVuY3Rpb24gKGluaXRpYWxGYWRlKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQWxpYXMgZm9yIDxjb2RlPmlucHV0WzBdPC9jb2RlPi5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMV08L2NvZGU+LlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmIgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogXHRUaGUgbWl4IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuIEEgZmFkZSB2YWx1ZSBvZiAwXG5cdFx0XHQgKiBcdHdpbGwgb3V0cHV0IDEwMCUgPGNvZGU+aW5wdXRbMF08L2NvZGU+IGFuZFxuXHRcdFx0ICogXHRhIHZhbHVlIG9mIDEgd2lsbCBvdXRwdXQgMTAwJSA8Y29kZT5pbnB1dFsxXTwvY29kZT4uXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZSA9IG5ldyBUb25lLlNpZ25hbChUb25lLmRlZmF1bHRBcmcoaW5pdGlhbEZhZGUsIDAuNSksIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZXF1YWwgcG93ZXIgZ2FpbiBjcm9zcyBmYWRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FcXVhbFBvd2VyR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJBID0gbmV3IFRvbmUuRXF1YWxQb3dlckdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBlcXVhbCBwb3dlciBnYWluIGNyb3NzIGZhZGVcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkVxdWFsUG93ZXJHYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckIgPSBuZXcgVG9uZS5FcXVhbFBvd2VyR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGludmVydCB0aGUgaW5jb21pbmcgc2lnbmFsXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ludmVydCA9IG5ldyBUb25lLkV4cHIoJzEgLSAkMCcpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmEuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5iLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuZmFkZS5jaGFpbih0aGlzLl9lcXVhbFBvd2VyQiwgdGhpcy5iLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuZmFkZS5jaGFpbih0aGlzLl9pbnZlcnQsIHRoaXMuX2VxdWFsUG93ZXJBLCB0aGlzLmEuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2ZhZGUnKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkNyb3NzRmFkZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNyb3NzRmFkZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Dcm9zc0ZhZGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZmFkZScpO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJBLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9lcXVhbFBvd2VyQSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXF1YWxQb3dlckIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2VxdWFsUG93ZXJCID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZhZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZmFkZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5faW52ZXJ0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9pbnZlcnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5hID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ3Jvc3NGYWRlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRmlsdGVyIGlzIGEgZmlsdGVyIHdoaWNoIGFsbG93cyBmb3IgYWxsIG9mIHRoZSBzYW1lIG5hdGl2ZSBtZXRob2RzXG5cdFx0ICogICAgICAgICAgYXMgdGhlIFtCaXF1YWRGaWx0ZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1iaXF1YWRmaWx0ZXJub2RlLWludGVyZmFjZSkuXG5cdFx0ICogICAgICAgICAgVG9uZS5GaWx0ZXIgaGFzIHRoZSBhZGRlZCBhYmlsaXR5IHRvIHNldCB0aGUgZmlsdGVyIHJvbGxvZmYgYXQgLTEyXG5cdFx0ICogICAgICAgICAgKGRlZmF1bHQpLCAtMjQgYW5kIC00OC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIuXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSBUaGUgdHlwZSBvZiBmaWx0ZXIuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gcm9sbG9mZiBUaGUgZHJvcCBpbiBkZWNpYmVscyBwZXIgb2N0YXZlIGFmdGVyIHRoZSBjdXRvZmYgZnJlcXVlbmN5LlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMgY2hvaWNlczogLTEyLCAtMjQsIGFuZCAtNDhcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIGZpbHRlciA9IG5ldyBUb25lLkZpbHRlcigyMDAsIFwiaGlnaHBhc3NcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdyb2xsb2ZmJ1xuXHQgICAgICAgIF0sIFRvbmUuRmlsdGVyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZmlsdGVyKHMpXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgdGhlIGZpbHRlci5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIHBhcmFtZXRlclxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbCgwLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIG9mIHRoZSBmaWx0ZXIsIG9ubHkgdXNlZCBpbiBjZXJ0YWluIGZpbHRlciB0eXBlc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5nYWluID0gbmV3IFRvbmUuU2lnbmFsKHtcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5nYWluLFxuXHQgICAgICAgICAgICAnY29udmVydCc6IGZhbHNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIFEgb3IgUXVhbGl0eSBvZiB0aGUgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLlEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSB7c3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByb2xsb2ZmIHZhbHVlIG9mIHRoZSBmaWx0ZXJcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yb2xsb2ZmID0gb3B0aW9ucy5yb2xsb2ZmO1xuXHQgICAgICAgIC8vc2V0IHRoZSByb2xsb2ZmO1xuXHQgICAgICAgIHRoaXMucm9sbG9mZiA9IG9wdGlvbnMucm9sbG9mZjtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZpbHRlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndHlwZSc6ICdsb3dwYXNzJyxcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMzUwLFxuXHQgICAgICAgICdyb2xsb2ZmJzogLTEyLFxuXHQgICAgICAgICdRJzogMSxcblx0ICAgICAgICAnZ2Fpbic6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgZmlsdGVyLiBUeXBlczogXCJsb3dwYXNzXCIsIFwiaGlnaHBhc3NcIixcblx0XHQgKiBcImJhbmRwYXNzXCIsIFwibG93c2hlbGZcIiwgXCJoaWdoc2hlbGZcIiwgXCJub3RjaFwiLCBcImFsbHBhc3NcIiwgb3IgXCJwZWFraW5nXCIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmlsdGVyI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRmlsdGVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB2YXIgdHlwZXMgPSBbXG5cdCAgICAgICAgICAgICAgICAnbG93cGFzcycsXG5cdCAgICAgICAgICAgICAgICAnaGlnaHBhc3MnLFxuXHQgICAgICAgICAgICAgICAgJ2JhbmRwYXNzJyxcblx0ICAgICAgICAgICAgICAgICdsb3dzaGVsZicsXG5cdCAgICAgICAgICAgICAgICAnaGlnaHNoZWxmJyxcblx0ICAgICAgICAgICAgICAgICdub3RjaCcsXG5cdCAgICAgICAgICAgICAgICAnYWxscGFzcycsXG5cdCAgICAgICAgICAgICAgICAncGVha2luZydcblx0ICAgICAgICAgICAgXTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUb25lLkZpbHRlcjogaW52YWxpZCB0eXBlICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcm9sbG9mZiBvZiB0aGUgZmlsdGVyIHdoaWNoIGlzIHRoZSBkcm9wIGluIGRiXG5cdFx0ICogcGVyIG9jdGF2ZS4gSW1wbGVtZW50ZWQgaW50ZXJuYWxseSBieSBjYXNjYWRpbmcgZmlsdGVycy5cblx0XHQgKiBPbmx5IGFjY2VwdHMgdGhlIHZhbHVlcyAtMTIsIC0yNCwgLTQ4IGFuZCAtOTYuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmlsdGVyI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcm9sbG9mZlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRmlsdGVyLnByb3RvdHlwZSwgJ3JvbGxvZmYnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb2xsb2ZmO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocm9sbG9mZikge1xuXHQgICAgICAgICAgICByb2xsb2ZmID0gcGFyc2VJbnQocm9sbG9mZiwgMTApO1xuXHQgICAgICAgICAgICB2YXIgcG9zc2liaWxpdGllcyA9IFtcblx0ICAgICAgICAgICAgICAgIC0xMixcblx0ICAgICAgICAgICAgICAgIC0yNCxcblx0ICAgICAgICAgICAgICAgIC00OCxcblx0ICAgICAgICAgICAgICAgIC05NlxuXHQgICAgICAgICAgICBdO1xuXHQgICAgICAgICAgICB2YXIgY2FzY2FkaW5nQ291bnQgPSBwb3NzaWJpbGl0aWVzLmluZGV4T2Yocm9sbG9mZik7XG5cdCAgICAgICAgICAgIC8vY2hlY2sgdGhlIHJvbGxvZmYgaXMgdmFsaWRcblx0ICAgICAgICAgICAgaWYgKGNhc2NhZGluZ0NvdW50ID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RvbmUuRmlsdGVyOiByb2xsb2ZmIGNhbiBvbmx5IGJlIC0xMiwgLTI0LCAtNDggb3IgLTk2Jyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2FzY2FkaW5nQ291bnQgKz0gMTtcblx0ICAgICAgICAgICAgdGhpcy5fcm9sbG9mZiA9IHJvbGxvZmY7XG5cdCAgICAgICAgICAgIC8vZmlyc3QgZGlzY29ubmVjdCB0aGUgZmlsdGVycyBhbmQgdGhyb3cgdGhlbSBhd2F5XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2ZpbHRlcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tpXSA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVycyA9IG5ldyBBcnJheShjYXNjYWRpbmdDb3VudCk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNvdW50ID0gMDsgY291bnQgPCBjYXNjYWRpbmdDb3VudDsgY291bnQrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgICAgIGZpbHRlci50eXBlID0gdGhpcy5fdHlwZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QoZmlsdGVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KGZpbHRlci5kZXR1bmUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5RLmNvbm5lY3QoZmlsdGVyLlEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QoZmlsdGVyLmdhaW4pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1tjb3VudF0gPSBmaWx0ZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy9jb25uZWN0IHRoZW0gdXBcblx0ICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25DaGFpbiA9IFt0aGlzLmlucHV0XS5jb25jYXQodGhpcy5fZmlsdGVycykuY29uY2F0KFt0aGlzLm91dHB1dF0pO1xuXHQgICAgICAgICAgICBUb25lLmNvbm5lY3RTZXJpZXMuYXBwbHkoVG9uZSwgY29ubmVjdGlvbkNoYWluKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmlsdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNbaV0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzW2ldID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmlsdGVycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdnYWluJyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuUS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuUSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmdhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRmlsdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgU3BsaXQgdGhlIGluY29taW5nIHNpZ25hbCBpbnRvIHRocmVlIGJhbmRzIChsb3csIG1pZCwgaGlnaClcblx0XHQgKiAgICAgICAgIHdpdGggdHdvIGNyb3Nzb3ZlciBmcmVxdWVuY3kgY29udHJvbHMuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbbG93RnJlcXVlbmN5XSB0aGUgbG93L21pZCBjcm9zc292ZXIgZnJlcXVlbmN5XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbaGlnaEZyZXF1ZW5jeV0gdGhlIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3lcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kU3BsaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5NdWx0aWJhbmRTcGxpdCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmlucHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvdXRwdXRzXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBBcnJheSgzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbG93IGJhbmQuIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sb3cgPSB0aGlzLm91dHB1dFswXSA9IG5ldyBUb25lLkZpbHRlcigwLCAnbG93cGFzcycpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsb3dlciBmaWx0ZXIgb2YgdGhlIG1pZCBiYW5kXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb3dNaWRGaWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ2hpZ2hwYXNzJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCBiYW5kIG91dHB1dC4gQWxpYXMgZm9yIDxjb2RlPm91dHB1dFsxXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IHRoaXMub3V0cHV0WzFdID0gbmV3IFRvbmUuRmlsdGVyKDAsICdsb3dwYXNzJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGhpZ2ggYmFuZCBvdXRwdXQuIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMl08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoID0gdGhpcy5vdXRwdXRbMl0gPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ2hpZ2hwYXNzJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMubG93RnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkL2hpZ2ggY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmhpZ2hGcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBxdWFsaXR5IG9mIGFsbCB0aGUgZmlsdGVyc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuUSk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5mYW4odGhpcy5sb3csIHRoaXMuaGlnaCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jaGFpbih0aGlzLl9sb3dNaWRGaWx0ZXIsIHRoaXMubWlkKTtcblx0ICAgICAgICAvL3RoZSBmcmVxdWVuY3kgY29udHJvbCBzaWduYWxcblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeS5jb25uZWN0KHRoaXMubG93LmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5sb3dGcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9sb3dNaWRGaWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kuY29ubmVjdCh0aGlzLm1pZC5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuaGlnaEZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuaGlnaC5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vdGhlIFEgdmFsdWVcblx0ICAgICAgICB0aGlzLlEuY29ubmVjdCh0aGlzLmxvdy5RKTtcblx0ICAgICAgICB0aGlzLlEuY29ubmVjdCh0aGlzLl9sb3dNaWRGaWx0ZXIuUSk7XG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5taWQuUSk7XG5cdCAgICAgICAgdGhpcy5RLmNvbm5lY3QodGhpcy5oaWdoLlEpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpYmFuZFNwbGl0LCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRTcGxpdC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnbG93RnJlcXVlbmN5JzogNDAwLFxuXHQgICAgICAgICdoaWdoRnJlcXVlbmN5JzogMjUwMCxcblx0ICAgICAgICAnUSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk11bHRpYmFuZFNwbGl0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZFNwbGl0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubG93LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmxvdyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbG93TWlkRmlsdGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sb3dNaWRGaWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oaWdoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuUS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5RID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5NdWx0aWJhbmRTcGxpdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuRVEzIGlzIGEgdGhyZWUgYmFuZCBFUSB3aXRoIGNvbnRyb2wgb3ZlciBsb3csIG1pZCwgYW5kIGhpZ2ggZ2FpbiBhc1xuXHRcdCAqICAgICAgICAgd2VsbCBhcyB0aGUgbG93IGFuZCBoaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY2llcy5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN8T2JqZWN0fSBbbG93TGV2ZWxdIFRoZSBnYWluIGFwcGxpZWQgdG8gdGhlIGxvd3MuXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFttaWRMZXZlbF0gVGhlIGdhaW4gYXBwbGllZCB0byB0aGUgbWlkLlxuXHRcdCAqICBAcGFyYW0ge0RlY2liZWxzfSBbaGlnaExldmVsXSBUaGUgZ2FpbiBhcHBsaWVkIHRvIHRoZSBoaWdoLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBlcSA9IG5ldyBUb25lLkVRMygtMTAsIDMsIC0yMCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkVRMyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2hpZ2gnXG5cdCAgICAgICAgXSwgVG9uZS5FUTMpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG91dHB1dCBub2RlXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbXVsdGliYW5kIHNwbGl0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGliYW5kU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpYmFuZFNwbGl0KHtcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IG9wdGlvbnMubG93RnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IG9wdGlvbnMuaGlnaEZyZXF1ZW5jeVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBnYWluIGZvciB0aGUgbG93ZXIgc2lnbmFsc1xuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb3dHYWluID0gbmV3IFRvbmUuR2FpbihvcHRpb25zLmxvdywgVG9uZS5UeXBlLkRlY2liZWxzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZ2FpbiBmb3IgdGhlIG1pZCBzaWduYWxzXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZEdhaW4gPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMubWlkLCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIGhpZ2ggcGFydFxuXHRcdFx0ICogQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9oaWdoR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5oaWdoLCBUb25lLlR5cGUuRGVjaWJlbHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGdhaW4gaW4gZGVjaWJlbHMgb2YgdGhlIGxvdyBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmxvdyA9IHRoaXMuX2xvd0dhaW4uZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBnYWluIGluIGRlY2liZWxzIG9mIHRoZSBtaWQgcGFydFxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWQgPSB0aGlzLl9taWRHYWluLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBpbiBkZWNpYmVscyBvZiB0aGUgaGlnaCBwYXJ0XG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2ggPSB0aGlzLl9oaWdoR2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBRIHZhbHVlIGZvciBhbGwgb2YgdGhlIGZpbHRlcnMuXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuUSA9IHRoaXMuX211bHRpYmFuZFNwbGl0LlE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gdGhpcy5fbXVsdGliYW5kU3BsaXQubG93RnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvaGlnaCBjcm9zc292ZXIgZnJlcXVlbmN5LlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5ID0gdGhpcy5fbXVsdGliYW5kU3BsaXQuaGlnaEZyZXF1ZW5jeTtcblx0ICAgICAgICAvL3RoZSBmcmVxdWVuY3kgYmFuZHNcblx0ICAgICAgICB0aGlzLl9tdWx0aWJhbmRTcGxpdC5sb3cuY2hhaW4odGhpcy5fbG93R2FpbiwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0Lm1pZC5jaGFpbih0aGlzLl9taWRHYWluLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQuaGlnaC5jaGFpbih0aGlzLl9oaWdoR2FpbiwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdsb3dGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVRMywgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FUTMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2xvdyc6IDAsXG5cdCAgICAgICAgJ21pZCc6IDAsXG5cdCAgICAgICAgJ2hpZ2gnOiAwLFxuXHQgICAgICAgICdsb3dGcmVxdWVuY3knOiA0MDAsXG5cdCAgICAgICAgJ2hpZ2hGcmVxdWVuY3knOiAyNTAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkVRM30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FUTMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdsb3cnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fbXVsdGliYW5kU3BsaXQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX211bHRpYmFuZFNwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmxvd0ZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oaWdoRnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sb3dHYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sb3dHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9taWRHYWluLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9oaWdoR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faGlnaEdhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oaWdoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkVRMztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBQZXJmb3JtcyBhIGxpbmVhciBzY2FsaW5nIG9uIGFuIGlucHV0IHNpZ25hbC5cblx0XHQgKiAgICAgICAgICBTY2FsZXMgYSBOb3JtYWxSYW5nZSBpbnB1dCB0byBiZXR3ZWVuXG5cdFx0ICogICAgICAgICAgb3V0cHV0TWluIGFuZCBvdXRwdXRNYXguXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWluPTBdIFRoZSBvdXRwdXQgdmFsdWUgd2hlbiB0aGUgaW5wdXQgaXMgMC4gXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TWF4PTFdXHRUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDEuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzY2FsZSA9IG5ldyBUb25lLlNjYWxlKDUwLCAxMDApO1xuXHRcdCAqIHZhciBzaWduYWwgPSBuZXcgVG9uZS5TaWduYWwoMC41KS5jb25uZWN0KHNjYWxlKTtcblx0XHQgKiAvL3RoZSBvdXRwdXQgb2Ygc2NhbGUgZXF1YWxzIDc1XG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlID0gZnVuY3Rpb24gKG91dHB1dE1pbiwgb3V0cHV0TWF4KSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX291dHB1dE1pbiA9IFRvbmUuZGVmYXVsdEFyZyhvdXRwdXRNaW4sIDApO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vdXRwdXRNYXggPSBUb25lLmRlZmF1bHRBcmcob3V0cHV0TWF4LCAxKTtcblx0ICAgICAgICAvKiogXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTXVsdGlwbHkoMSk7XG5cdCAgICAgICAgLyoqIFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQWRkfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hZGQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkFkZCgwKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5jb25uZWN0KHRoaXMuX2FkZCk7XG5cdCAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNjYWxlLCBUb25lLlNpZ25hbEJhc2UpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGUjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtaW5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dE1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1pbikge1xuXHQgICAgICAgICAgICB0aGlzLl9vdXRwdXRNaW4gPSBtaW47XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSBvdXRwdXQgdmFsdWUuIFRoaXMgbnVtYmVyIGlzIG91dHB1dCB3aGVuIFxuXHRcdCAqIHRoZSB2YWx1ZSBpbnB1dCB2YWx1ZSBpcyAxLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0TWF4O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX291dHB1dE1heCA9IG1heDtcblx0ICAgICAgICAgICAgdGhpcy5fc2V0UmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBzZXQgdGhlIHZhbHVlc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TY2FsZS5wcm90b3R5cGUuX3NldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2FkZC52YWx1ZSA9IHRoaXMuX291dHB1dE1pbjtcblx0ICAgICAgICB0aGlzLl9zY2FsZS52YWx1ZSA9IHRoaXMuX291dHB1dE1heCAtIHRoaXMuX291dHB1dE1pbjtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNjYWxlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2FkZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYWRkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNjYWxlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBQZXJmb3JtcyBhbiBleHBvbmVudGlhbCBzY2FsaW5nIG9uIGFuIGlucHV0IHNpZ25hbC5cblx0XHQgKiAgICAgICAgICBTY2FsZXMgYSBOb3JtYWxSYW5nZSB2YWx1ZSBbMCwxXSBleHBvbmVudGlhbGx5XG5cdFx0ICogICAgICAgICAgdG8gdGhlIG91dHB1dCByYW5nZSBvZiBvdXRwdXRNaW4gdG8gb3V0cHV0TWF4LlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1pbj0wXSBUaGUgb3V0cHV0IHZhbHVlIHdoZW4gdGhlIGlucHV0IGlzIDAuIFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW291dHB1dE1heD0xXVx0VGhlIG91dHB1dCB2YWx1ZSB3aGVuIHRoZSBpbnB1dCBpcyAxLiBcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFtleHBvbmVudD0yXSBUaGUgZXhwb25lbnQgd2hpY2ggc2NhbGVzIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNjYWxlRXhwID0gbmV3IFRvbmUuU2NhbGVFeHAoMCwgMTAwLCAyKTtcblx0XHQgKiB2YXIgc2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAuNSkuY29ubmVjdChzY2FsZUV4cCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlRXhwID0gZnVuY3Rpb24gKG91dHB1dE1pbiwgb3V0cHV0TWF4LCBleHBvbmVudCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlIHRoZSBpbnB1dCB0byB0aGUgb3V0cHV0IHJhbmdlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TY2FsZShvdXRwdXRNaW4sIG91dHB1dE1heCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Qb3d9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V4cCA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5Qb3coVG9uZS5kZWZhdWx0QXJnKGV4cG9uZW50LCAyKSk7XG5cdCAgICAgICAgdGhpcy5fZXhwLmNvbm5lY3QodGhpcy5fc2NhbGUpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU2NhbGVFeHAsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBJbnN0ZWFkIG9mIGludGVycG9sYXRpbmcgbGluZWFybHkgYmV0d2VlbiB0aGUgPGNvZGU+bWluPC9jb2RlPiBhbmQgXG5cdFx0ICogPGNvZGU+bWF4PC9jb2RlPiB2YWx1ZXMsIHNldHRpbmcgdGhlIGV4cG9uZW50IHdpbGwgaW50ZXJwb2xhdGUgYmV0d2VlblxuXHRcdCAqIHRoZSB0d28gdmFsdWVzIHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlRXhwI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgZXhwb25lbnRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlRXhwLnByb3RvdHlwZSwgJ2V4cG9uZW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwLnZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXhwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V4cC52YWx1ZSA9IGV4cDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBtaW5pbXVtIG91dHB1dCB2YWx1ZS4gVGhpcyBudW1iZXIgaXMgb3V0cHV0IHdoZW4gXG5cdFx0ICogdGhlIHZhbHVlIGlucHV0IHZhbHVlIGlzIDAuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNjYWxlRXhwI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZUV4cC5wcm90b3R5cGUsICdtaW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZS5taW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2NhbGUubWluID0gbWluO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1heGltdW0gb3V0cHV0IHZhbHVlLiBUaGlzIG51bWJlciBpcyBvdXRwdXQgd2hlbiBcblx0XHQgKiB0aGUgdmFsdWUgaW5wdXQgdmFsdWUgaXMgMS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2NhbGVFeHAjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNjYWxlRXhwLnByb3RvdHlwZSwgJ21heCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlLm1heDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG1heCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNjYWxlRXhwfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlRXhwLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXhwLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9leHAgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNjYWxlRXhwO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBjcmVhdGVEZWxheSBzaGltXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBpZiAod2luZG93LkRlbGF5Tm9kZSAmJiAhQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVEZWxheSkge1xuXHQgICAgICAgIEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlRGVsYXkgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZURlbGF5Tm9kZTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgV3JhcHBlciBhcm91bmQgV2ViIEF1ZGlvJ3MgbmF0aXZlIFtEZWxheU5vZGVdKGh0dHA6Ly93ZWJhdWRpby5naXRodWIuaW8vd2ViLWF1ZGlvLWFwaS8jdGhlLWRlbGF5bm9kZS1pbnRlcmZhY2UpLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gZGVsYXlUaW1lIFRoZSBkZWxheSBhcHBsaWVkIHRvIHRoZSBpbmNvbWluZyBzaWduYWwuXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IG1heERlbGF5IFRoZSBtYXhpbXVtIGRlbGF5IHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkRlbGF5ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdtYXhEZWxheSdcblx0ICAgICAgICBdLCBUb25lLkRlbGF5KTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBuYXRpdmUgZGVsYXkgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtEZWxheU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVEZWxheSh0aGlzLnRvU2Vjb25kcyhvcHRpb25zLm1heERlbGF5KSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiB0aW1lIHRoZSBpbmNvbWluZyBzaWduYWwgaXNcblx0XHRcdCAqICBkZWxheWVkLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbmV3IFRvbmUuUGFyYW0oe1xuXHQgICAgICAgICAgICAncGFyYW0nOiB0aGlzLl9kZWxheU5vZGUuZGVsYXlUaW1lLFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuVGltZSxcblx0ICAgICAgICAgICAgJ3ZhbHVlJzogb3B0aW9ucy5kZWxheVRpbWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZGVsYXlUaW1lJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EZWxheSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkRlbGF5LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtYXhEZWxheSc6IDEsXG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkRlbGF5fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5EZWxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZGVsYXlUaW1lJyk7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkRlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQ29tYiBmaWx0ZXJzIGFyZSBiYXNpYyBidWlsZGluZyBibG9ja3MgZm9yIHBoeXNpY2FsIG1vZGVsaW5nLiBSZWFkIG1vcmVcblx0XHQgKiAgICAgICAgIGFib3V0IGNvbWIgZmlsdGVycyBvbiBbQ0NSTUEncyB3ZWJzaXRlXShodHRwczovL2Njcm1hLnN0YW5mb3JkLmVkdS9+am9zL3Bhc3AvRmVlZGJhY2tfQ29tYl9GaWx0ZXJzLmh0bWwpLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZXxPYmplY3R9IFtkZWxheVRpbWVdIFRoZSBkZWxheSB0aW1lIG9mIHRoZSBmaWx0ZXIuXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2U9fSByZXNvbmFuY2UgVGhlIGFtb3VudCBvZiBmZWVkYmFjayB0aGUgZmlsdGVyIGhhcy5cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2RlbGF5VGltZScsXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnXG5cdCAgICAgICAgXSwgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGRlbGF5IG9mIHRoZSBjb21iIGZpbHRlci5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2RlbGF5LmRlbGF5VGltZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZmVlZGJhY2sgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMucmVzb25hbmNlLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgb2YgdGhlIGRlbGF5ZWQgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IHRoaXMuX2ZlZWRiYWNrLmdhaW47XG5cdCAgICAgICAgdGhpcy5fZGVsYXkuY2hhaW4odGhpcy5fZmVlZGJhY2ssIHRoaXMuX2RlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmVlZGJhY2tDb21iRmlsdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMSxcblx0ICAgICAgICAncmVzb25hbmNlJzogMC41XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZlZWRiYWNrQ29tYkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZlZWRiYWNrQ29tYkZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgR2V0IHRoZSBjdXJyZW50IHdhdmVmb3JtIGRhdGEgb2YgdGhlIGNvbm5lY3RlZCBhdWRpbyBzb3VyY2UuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXI9fSBzaXplIFRoZSBzaXplIG9mIHRoZSBGRlQuIFZhbHVlIG11c3QgYmUgYSBwb3dlciBvZlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5GRlQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydzaXplJ10sIFRvbmUuRkZUKTtcblx0ICAgICAgICBvcHRpb25zLnR5cGUgPSBUb25lLkFuYWx5c2VyLlR5cGUuRkZUO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFuYWx5c2VyIG5vZGUuXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbmFseXNlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuQW5hbHlzZXIob3B0aW9ucyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GRlQsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GRlQuZGVmYXVsdHMgPSB7ICdzaXplJzogMTAyNCB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldHMgdGhlIHdhdmVmb3JtIG9mIHRoZSBhdWRpbyBzb3VyY2UuIFJldHVybnMgdGhlIHdhdmVmb3JtIGRhdGFcblx0XHQgKiAgb2YgbGVuZ3RoIFtzaXplXSgjc2l6ZSkgYXMgYSBGbG9hdDMyQXJyYXkgd2l0aCB2YWx1ZXMgYmV0d2VlbiAtMSBhbmQgMS5cblx0XHQgKiAgQHJldHVybnMge1R5cGVkQXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkZGVC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FuYWx5c2VyLmdldFZhbHVlKCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzaXplIG9mIGFuYWx5c2lzLiBUaGlzIG11c3QgYmUgYSBwb3dlciBvZiB0d28gaW4gdGhlIHJhbmdlIDMyIHRvIDMyNzY4LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5GRlQjXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIHNpemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZGVC5wcm90b3R5cGUsICdzaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5hbHlzZXIuc2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkZGVH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRkZULnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GRlQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Gb2xsb3dlciBpcyBhICBjcnVkZSBlbnZlbG9wZSBmb2xsb3dlciB3aGljaCB3aWxsIGZvbGxvd1xuXHRcdCAqICAgICAgICAgIHRoZSBhbXBsaXR1ZGUgb2YgYW4gaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgIFRha2UgY2FyZSB3aXRoIHNtYWxsICg8IDAuMDIpIGF0dGFjayBvciBkZWNheSB2YWx1ZXNcblx0XHQgKiAgICAgICAgICBhcyBmb2xsb3dlciBoYXMgc29tZSByaXBwbGUgd2hpY2ggaXMgZXhhZ2dlcmF0ZWRcblx0XHQgKiAgICAgICAgICBhdCB0aGVzZSB2YWx1ZXMuIFJlYWQgbW9yZSBhYm91dCBlbnZlbG9wZSBmb2xsb3dlcnMgKGFsc28ga25vd25cblx0XHQgKiAgICAgICAgICBhcyBlbnZlbG9wZSBkZXRlY3RvcnMpIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VudmVsb3BlX2RldGVjdG9yKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbYXR0YWNrXSBUaGUgcmF0ZSBhdCB3aGljaCB0aGUgZm9sbG93ZXIgcmlzZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIHJhdGUgYXQgd2hpY2ggdGhlIGZvbG93ZXIgZmFsbHMuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZvbGxvd2VyID0gbmV3IFRvbmUuRm9sbG93ZXIoMC4yLCAwLjQpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkZvbGxvd2VyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BYnN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FicyA9IG5ldyBUb25lLkFicygpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsb3dwYXNzIGZpbHRlciB3aGljaCBzbW9vdGhzIHRoZSBpbnB1dFxuXHRcdFx0ICogIEB0eXBlIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9maWx0ZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLnR5cGUgPSAnbG93cGFzcyc7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IDA7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyLlEudmFsdWUgPSAtMTAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtXYXZlU2hhcGVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5VmFsdWVzID0gbmV3IFRvbmUuV2F2ZVNoYXBlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWIgPSBuZXcgVG9uZS5TdWJ0cmFjdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG5ldyBUb25lLkRlbGF5KHRoaXMuYmxvY2tUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGlzIGtlZXBzIGl0IGZhciBmcm9tIDAsIGV2ZW4gZm9yIHZlcnkgc21hbGwgZGlmZmVyZW5jZXNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbXVsdCA9IG5ldyBUb25lLk11bHRpcGx5KDEwMDAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hdHRhY2sgPSBvcHRpb25zLmF0dGFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yZWxlYXNlID0gb3B0aW9ucy5yZWxlYXNlO1xuXHQgICAgICAgIC8vdGhlIHNtb290aGVkIHNpZ25hbCB0byBnZXQgdGhlIHZhbHVlc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4odGhpcy5fYWJzLCB0aGlzLl9maWx0ZXIsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAvL3RoZSBkaWZmZXJlbmNlIHBhdGhcblx0ICAgICAgICB0aGlzLl9hYnMuY29ubmVjdCh0aGlzLl9zdWIsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlci5jaGFpbih0aGlzLl9kZWxheSwgdGhpcy5fc3ViKTtcblx0ICAgICAgICAvL3RocmVzaG9sZCB0aGUgZGlmZmVyZW5jZSBhbmQgdXNlIHRoZSB0aHJlc2ggdG8gc2V0IHRoZSBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLl9zdWIuY2hhaW4odGhpcy5fbXVsdCwgdGhpcy5fZnJlcXVlbmN5VmFsdWVzLCB0aGlzLl9maWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3NldCB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIHZhbHVlcyBpbiB0aGUgdGFibGVcblx0ICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Gb2xsb3dlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2F0dGFjayc6IDAuMDUsXG5cdCAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc2V0cyB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIHRpbWVzIGluIHRoZSB3YXZlIHNoYXBlclxuXHRcdCAqICBAcGFyYW0gICB7VGltZX0gYXR0YWNrXG5cdFx0ICogIEBwYXJhbSAgIHtUaW1lfSByZWxlYXNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZvbGxvd2VyLnByb3RvdHlwZS5fc2V0QXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChhdHRhY2ssIHJlbGVhc2UpIHtcblx0ICAgICAgICB2YXIgbWluVGltZSA9IHRoaXMuYmxvY2tUaW1lO1xuXHQgICAgICAgIGF0dGFjayA9IFRvbmUuVGltZShhdHRhY2spLnRvRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmVsZWFzZSA9IFRvbmUuVGltZShyZWxlYXNlKS50b0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIGF0dGFjayA9IE1hdGgubWF4KGF0dGFjaywgbWluVGltZSk7XG5cdCAgICAgICAgcmVsZWFzZSA9IE1hdGgubWF4KHJlbGVhc2UsIG1pblRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeVZhbHVlcy5zZXRNYXAoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhdHRhY2s7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVsZWFzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBhdHRhY2sgdGltZS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Gb2xsb3dlciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBhdHRhY2tcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZvbGxvd2VyLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFjaykge1xuXHQgICAgICAgICAgICB0aGlzLl9hdHRhY2sgPSBhdHRhY2s7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEF0dGFja1JlbGVhc2UodGhpcy5fYXR0YWNrLCB0aGlzLl9yZWxlYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRm9sbG93ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLCAncmVsZWFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbGVhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZWxlYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlbGVhc2UgPSByZWxlYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBdHRhY2tSZWxlYXNlKHRoaXMuX2F0dGFjaywgdGhpcy5fcmVsZWFzZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQm9ycm93cyB0aGUgY29ubmVjdCBtZXRob2QgZnJvbSBTaWduYWwgc28gdGhhdCB0aGUgb3V0cHV0IGNhbiBiZSB1c2VkXG5cdFx0ICogIGFzIGEgVG9uZS5TaWduYWwgY29udHJvbCBzaWduYWwuXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5Gb2xsb3dlci5wcm90b3R5cGUuY29ubmVjdCA9IFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0O1xuXHQgICAgLyoqXG5cdFx0ICogIGRpc3Bvc2Vcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRm9sbG93ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRm9sbG93ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9maWx0ZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5VmFsdWVzLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3lWYWx1ZXMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3ViLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9zdWIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Ficy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYWJzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tdWx0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tdWx0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRm9sbG93ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlNjYWxlZEVudmVsb3AgaXMgYW4gZW52ZWxvcGUgd2hpY2ggY2FuIGJlIHNjYWxlZCBcblx0XHQgKiAgICAgICAgIHRvIGFueSByYW5nZS4gSXQncyB1c2VmdWwgZm9yIGFwcGx5aW5nIGFuIGVudmVsb3BlIFxuXHRcdCAqICAgICAgICAgdG8gYSBmcmVxdWVuY3kgb3IgYW55IG90aGVyIG5vbi1Ob3JtYWxSYW5nZSBzaWduYWwgXG5cdFx0ICogICAgICAgICBwYXJhbWV0ZXIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVudmVsb3BlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja11cdHRoZSBhdHRhY2sgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0dGhlIGRlY2F5IHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3N1c3RhaW5dIFx0YSBwZXJjZW50YWdlICgwLTEpIG9mIHRoZSBmdWxsIGFtcGxpdHVkZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0dGhlIHJlbGVhc2UgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBzY2FsZWRFbnYgPSBuZXcgVG9uZS5TY2FsZWRFbnZlbG9wZSh7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMixcblx0XHQgKiAgXHRcIm1pblwiIDogMjAwLFxuXHRcdCAqICBcdFwibWF4XCIgOiAyMDAwXG5cdFx0ICogIH0pO1xuXHRcdCAqICBzY2FsZWRFbnYuY29ubmVjdChvc2NpbGxhdG9yLmZyZXF1ZW5jeSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNjYWxlZEVudmVsb3BlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vZ2V0IGFsbCBvZiB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAnZGVjYXknLFxuXHQgICAgICAgICAgICAnc3VzdGFpbicsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJ1xuXHQgICAgICAgIF0sIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgICAgIFRvbmUuRW52ZWxvcGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU2NhbGVkRW52ZWxvcGUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKiBcblx0XHRcdCAqICBzY2FsZSB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IGFuIGV4cG9uZW50XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUG93fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9leHAgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlBvdyhvcHRpb25zLmV4cG9uZW50KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzY2FsZSB0aGUgc2lnbmFsIHRvIHRoZSBkZXNpcmVkIHJhbmdlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGlwbHl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLm1pbiwgb3B0aW9ucy5tYXgpO1xuXHQgICAgICAgIHRoaXMuX3NpZy5jaGFpbih0aGlzLl9leHAsIHRoaXMuX3NjYWxlKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNjYWxlZEVudmVsb3BlLCBUb25lLkVudmVsb3BlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgJ2V4cG9uZW50JzogMVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1pbiBvdXRwdXQgdmFsdWUuIFRoaXMgaXMgdGhlIHZhbHVlIHdoaWNoIGl0XG5cdFx0ICogc3RhcnRzIGF0LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1pbiA9IG1pbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1heCBvdXRwdXQgdmFsdWUuIEluIG90aGVyIHdvcmRzLCB0aGUgdmFsdWVcblx0XHQgKiBhdCB0aGUgcGVhayBvZiB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1heFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWF4O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1heCA9IG1heDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIGV4cG9uZW50IHZhbHVlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5TY2FsZWRFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGV4cG9uZW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TY2FsZWRFbnZlbG9wZS5wcm90b3R5cGUsICdleHBvbmVudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgICAgICB0aGlzLl9leHAudmFsdWUgPSBleHA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2NhbGVkRW52ZWxvcGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2NhbGVkRW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZXhwLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9leHAgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNjYWxlZEVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSBpcyBhIFRvbmUuU2NhbGVkRW52ZWxvcGUsIGJ1dCBpbnN0ZWFkIG9mIGBtaW5gIGFuZCBgbWF4YFxuXHRcdCAqICAgICAgICAgaXQncyBnb3QgYSBgYmFzZUZyZXF1ZW5jeWAgYW5kIGBvY3RhdmVzYCBwYXJhbWV0ZXIuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVudmVsb3BlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2F0dGFja11cdHRoZSBhdHRhY2sgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW2RlY2F5XVx0dGhlIGRlY2F5IHRpbWUgaW4gc2Vjb25kc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3N1c3RhaW5dIFx0YSBwZXJjZW50YWdlICgwLTEpIG9mIHRoZSBmdWxsIGFtcGxpdHVkZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFtyZWxlYXNlXVx0dGhlIHJlbGVhc2UgdGltZSBpbiBzZWNvbmRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBlbnYgPSBuZXcgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSh7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMixcblx0XHQgKiAgXHRcImJhc2VGcmVxdWVuY3lcIiA6IFwiQzJcIixcblx0XHQgKiAgXHRcIm9jdGF2ZXNcIiA6IDRcblx0XHQgKiAgfSk7XG5cdFx0ICogIHNjYWxlZEVudi5jb25uZWN0KG9zY2lsbGF0b3IuZnJlcXVlbmN5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYXR0YWNrJyxcblx0ICAgICAgICAgICAgJ2RlY2F5Jyxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkVudmVsb3BlKTtcblx0ICAgICAgICBUb25lLlNjYWxlZEVudmVsb3BlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLy9tZXJnZSBpdCB3aXRoIHRoZSBmcmVxdWVuY3kgZW52ZWxvcGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUuZGVmYXVsdHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFN0b3JlcyB0aGUgb2N0YXZlIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8vc2V0dXBcblx0ICAgICAgICB0aGlzLmJhc2VGcmVxdWVuY3kgPSBvcHRpb25zLmJhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUsIFRvbmUuRW52ZWxvcGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDQsXG5cdCAgICAgICAgJ2V4cG9uZW50JzogMlxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIG1pbmludW0gb3V0cHV0IHZhbHVlLiBUaGlzIGlzIHRoZSB2YWx1ZSB3aGljaCBpdFxuXHRcdCAqIHN0YXJ0cyBhdC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUjXG5cdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5wcm90b3R5cGUsICdiYXNlRnJlcXVlbmN5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGUubWluO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWluKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlLm1pbiA9IHRoaXMudG9GcmVxdWVuY3kobWluKTtcblx0ICAgICAgICAgICAgLy9hbHNvIHVwZGF0ZSB0aGUgb2N0YXZlc1xuXHQgICAgICAgICAgICB0aGlzLm9jdGF2ZXMgPSB0aGlzLl9vY3RhdmVzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBiYXNlRnJlcXVlbmN5IHRoYXQgdGhlXG5cdFx0ICogZW52ZWxvcGUgd2lsbCBzY2FsZSB0by5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZS5tYXggPSB0aGlzLmJhc2VGcmVxdWVuY3kgKiBNYXRoLnBvdygyLCBvY3RhdmVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBlbnZlbG9wZSdzIGV4cG9uZW50IHZhbHVlLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GcmVxdWVuY3lFbnZlbG9wZSNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGV4cG9uZW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GcmVxdWVuY3lFbnZlbG9wZS5wcm90b3R5cGUsICdleHBvbmVudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cC52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGV4cCkge1xuXHQgICAgICAgICAgICB0aGlzLl9leHAudmFsdWUgPSBleHA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRnJlcXVlbmN5RW52ZWxvcGV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlcXVlbmN5RW52ZWxvcGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TY2FsZWRFbnZlbG9wZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZXF1ZW5jeUVudmVsb3BlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuR2F0ZSBvbmx5IHBhc3NlcyBhIHNpZ25hbCB0aHJvdWdoIHdoZW4gdGhlIGluY29taW5nXG5cdFx0ICogICAgICAgICAgc2lnbmFsIGV4Y2VlZHMgYSBzcGVjaWZpZWQgdGhyZXNob2xkLiBUbyBkbyB0aGlzLCBHYXRlIHVzZXNcblx0XHQgKiAgICAgICAgICBhIFRvbmUuRm9sbG93ZXIgdG8gZm9sbG93IHRoZSBhbXBsaXR1ZGUgb2YgdGhlIGluY29taW5nIHNpZ25hbC5cblx0XHQgKiAgICAgICAgICBBIGNvbW1vbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNsYXNzIGlzIGEgW05vaXNlIEdhdGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05vaXNlX2dhdGUpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN8T2JqZWN0fSBbdGhyZXNob2xkXSBUaGUgdGhyZXNob2xkIGFib3ZlIHdoaWNoIHRoZSBnYXRlIHdpbGwgb3Blbi5cblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gYXR0YWNrIFRoZSBmb2xsb3dlcidzIGF0dGFjayB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJlbGVhc2UgVGhlIGZvbGxvd2VyJ3MgcmVsZWFzZSB0aW1lXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGdhdGUgPSBuZXcgVG9uZS5HYXRlKC0zMCwgMC4yLCAwLjMpLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIG1pYyA9IG5ldyBUb25lLlVzZXJNZWRpYSgpLmNvbm5lY3QoZ2F0ZSk7XG5cdFx0ICogLy90aGUgZ2F0ZSB3aWxsIG9ubHkgcGFzcyB0aHJvdWdoIHRoZSBpbmNvbWluZ1xuXHRcdCAqIC8vc2lnbmFsIHdoZW4gaXQncyBsb3VkZXIgdGhhbiAtMzBkYlxuXHRcdCAqL1xuXHQgICAgVG9uZS5HYXRlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCcsXG5cdCAgICAgICAgICAgICdhdHRhY2snLFxuXHQgICAgICAgICAgICAncmVsZWFzZSdcblx0ICAgICAgICBdLCBUb25lLkdhdGUpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZvbGxvd2VyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKG9wdGlvbnMuYXR0YWNrLCBvcHRpb25zLnJlbGVhc2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdyZWF0ZXJUaGFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ndCA9IG5ldyBUb25lLkdyZWF0ZXJUaGFuKFRvbmUuZGJUb0dhaW4ob3B0aW9ucy50aHJlc2hvbGQpKTtcblx0ICAgICAgICAvL3RoZSBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy90aGUgY29udHJvbCBzaWduYWxcblx0ICAgICAgICB0aGlzLmlucHV0LmNoYWluKHRoaXMuX2d0LCB0aGlzLl9mb2xsb3dlciwgdGhpcy5vdXRwdXQuZ2Fpbik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5HYXRlLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuR2F0ZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrJzogMC4xLFxuXHQgICAgICAgICdyZWxlYXNlJzogMC4xLFxuXHQgICAgICAgICd0aHJlc2hvbGQnOiAtNDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdGhyZXNob2xkIG9mIHRoZSBnYXRlIGluIGRlY2liZWxzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQG5hbWUgdGhyZXNob2xkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3RocmVzaG9sZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuZ2FpblRvRGIodGhpcy5fZ3QudmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhyZXNoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2d0LnZhbHVlID0gVG9uZS5kYlRvR2Fpbih0aHJlc2gpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGF0dGFjayBzcGVlZCBvZiB0aGUgZ2F0ZVxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdhdGUjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgYXR0YWNrXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ2F0dGFjaycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbGxvd2VyLmF0dGFjaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGF0dGFja1RpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIuYXR0YWNrID0gYXR0YWNrVGltZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByZWxlYXNlIHNwZWVkIG9mIHRoZSBnYXRlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR2F0ZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSByZWxlYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HYXRlLnByb3RvdHlwZSwgJ3JlbGVhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb2xsb3dlci5yZWxlYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmVsZWFzZVRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZm9sbG93ZXIucmVsZWFzZSA9IHJlbGVhc2VUaW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5HYXRlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9mb2xsb3dlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZvbGxvd2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9ndCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2F0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIFRvbmUuVGlja1NpZ25hbCBleHRlbmRzIFRvbmUuVGltZWxpbmVTaWduYWwsIGJ1dCBhZGRzIHRoZSBjYXBhYmlsaXR5XG5cdFx0ICogICAgICAgIHRvIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGVsYXBzZWQgdGlja3MuIGV4cG9uZW50aWFsIGFuZCB0YXJnZXQgY3VydmVzXG5cdFx0ICogICAgICAgIGFyZSBhcHByb3hpbWF0ZWQgd2l0aCBtdWx0aXBsZSBsaW5lYXIgcmFtcHMuXG5cdFx0ICpcblx0XHQgKiAgICAgICAgVGhhbmsgeW91IEJydW5vIERpYXMsIEguIFNvZmlhIFBpbnRvLCBhbmQgRGF2aWQgTS4gTWF0b3MsIGZvciB5b3VyIFtXQUMgcGFwZXJdKGh0dHBzOi8vc21hcnRlY2guZ2F0ZWNoLmVkdS9iaXRzdHJlYW0vaGFuZGxlLzE4NTMvNTQ1ODgvV0FDMjAxNi00OS5wZGYpXG5cdFx0ICogICAgICAgIGRlc2NyaWJpbmcgaW50ZWdyYXRpbmcgdGltaW5nIGZ1bmN0aW9ucyBmb3IgdGVtcG8gY2FsY3VsYXRpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzaWduYWxcblx0XHQgKiBAZXh0ZW5kcyB7VG9uZS5UaW1lbGluZVNpZ25hbH1cblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhbHVlID0gVG9uZS5kZWZhdWx0QXJnKHZhbHVlLCAxKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLmNhbGwodGhpcywge1xuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuVGlja3MsXG5cdCAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy9leHRlbmQgdGhlIG1lbW9yeVxuXHQgICAgICAgIHRoaXMuX2V2ZW50cy5tZW1vcnkgPSBJbmZpbml0eTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRpY2tTaWduYWwsIFRvbmUuVGltZWxpbmVTaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogV3JhcHMgVG9uZS5UaW1lbGluZVNpZ25hbCBtZXRob2RzIHNvIHRoYXQgdGhleSBhbHNvXG5cdFx0ICogcmVjb3JkIHRoZSB0aWNrcy5cblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbWV0aG9kXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGZ1bmN0aW9uIF93cmFwU2NoZWR1bGVNZXRob2RzKG1ldGhvZCkge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHRpbWUpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHByZXZpb3VzRXZlbnQgPSB0aGlzLl9ldmVudHMucHJldmlvdXNFdmVudChldmVudCk7XG5cdCAgICAgICAgICAgIHZhciB0aWNrc1VudGlsVGltZSA9IHRoaXMuX2dldFRpY2tVbnRpbEV2ZW50KHByZXZpb3VzRXZlbnQsIHRpbWUgLSB0aGlzLnNhbXBsZVRpbWUpO1xuXHQgICAgICAgICAgICBldmVudC50aWNrcyA9IE1hdGgubWF4KHRpY2tzVW50aWxUaW1lLCAwKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUgPSBfd3JhcFNjaGVkdWxlTWV0aG9kcyhUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSk7XG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gX3dyYXBTY2hlZHVsZU1ldGhvZHMoVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IGV4cG9uZW50aWFsbHkgYXBwcm9hY2hpbmcgdGhlIHRhcmdldCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gdGltZSB3aXRoXG5cdFx0ICogIGEgcmF0ZSBoYXZpbmcgdGhlIGdpdmVuIHRpbWUgY29uc3RhbnQuXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0VGltZVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdGltZUNvbnN0YW50XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpY2tTaWduYWx9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVGlja1NpZ25hbC5wcm90b3R5cGUuc2V0VGFyZ2V0QXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lLCBjb25zdGFudCkge1xuXHQgICAgICAgIC8vYXByb3hpbWF0ZSBpdCB3aXRoIG11bHRpcGxlIGxpbmVhciByYW1wc1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLnNldFJhbXBQb2ludCh0aW1lKTtcblx0ICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zyb21Vbml0cyh2YWx1ZSk7XG5cdCAgICAgICAgLy9zdGFydCBmcm9tIHByZXZpb3VzbHkgc2NoZWR1bGVkIHZhbHVlXG5cdCAgICAgICAgdmFyIHByZXZFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQodGltZSk7XG5cdCAgICAgICAgdmFyIHNlZ21lbnRzID0gNTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdtZW50czsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWdUaW1lID0gY29uc3RhbnQgKiBpICsgdGltZTtcblx0ICAgICAgICAgICAgdmFyIHJhbXBWYWwgPSB0aGlzLl9leHBvbmVudGlhbEFwcHJvYWNoKHByZXZFdmVudC50aW1lLCBwcmV2RXZlbnQudmFsdWUsIHZhbHVlLCBjb25zdGFudCwgc2VnVGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fdG9Vbml0cyhyYW1wVmFsKSwgc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZXMgYW4gZXhwb25lbnRpYWwgY29udGludW91cyBjaGFuZ2UgaW4gcGFyYW1ldGVyIHZhbHVlIGZyb21cblx0XHQgKiAgdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwYXJhbWV0ZXIgdmFsdWUgdG8gdGhlIGdpdmVuIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGVuZFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGlja1NpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgLy9hcHJveGltYXRlIGl0IHdpdGggbXVsdGlwbGUgbGluZWFyIHJhbXBzXG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhbHVlID0gdGhpcy5fZnJvbVVuaXRzKHZhbHVlKTtcblx0ICAgICAgICAvL3N0YXJ0IGZyb20gcHJldmlvdXNseSBzY2hlZHVsZWQgdmFsdWVcblx0ICAgICAgICB2YXIgcHJldkV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICBpZiAocHJldkV2ZW50ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHByZXZFdmVudCA9IHtcblx0ICAgICAgICAgICAgICAgICd2YWx1ZSc6IHRoaXMuX2luaXRpYWwsXG5cdCAgICAgICAgICAgICAgICAndGltZSc6IDBcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNlZ21lbnRzID0gNTtcblx0ICAgICAgICB2YXIgc2VnbWVudER1ciA9ICh0aW1lIC0gcHJldkV2ZW50LnRpbWUpIC8gc2VnbWVudHM7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgc2VnVGltZSA9IHNlZ21lbnREdXIgKiBpICsgcHJldkV2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgIHZhciByYW1wVmFsID0gdGhpcy5fZXhwb25lbnRpYWxJbnRlcnBvbGF0ZShwcmV2RXZlbnQudGltZSwgcHJldkV2ZW50LnZhbHVlLCB0aW1lLCB2YWx1ZSwgc2VnVGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fdG9Vbml0cyhyYW1wVmFsKSwgc2VnVGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHRpY2sgdmFsdWUgYXQgdGhlIHRpbWUuIFRha2VzIGludG8gYWNjb3VudFxuXHRcdCAqIGFueSBhdXRvbWF0aW9uIGN1cnZlcyBzY2hlZHVsZWQgb24gdGhlIHNpZ25hbC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSB0aWNrIGNvdW50IGF0XG5cdFx0ICogQHJldHVybiB7VGlja3N9ICAgICAgVGhlIG51bWJlciBvZiB0aWNrcyB3aGljaCBoYXZlIGVsYXBzZWQgYXQgdGhlIHRpbWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gYW55IGF1dG9tYXRpb25zLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5fZ2V0VGlja1VudGlsRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpIHtcblx0ICAgICAgICBpZiAoZXZlbnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgZXZlbnQgPSB7XG5cdCAgICAgICAgICAgICAgICAndGlja3MnOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3RpbWUnOiAwXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2YWwwID0gdGhpcy5nZXRWYWx1ZUF0VGltZShldmVudC50aW1lKTtcblx0ICAgICAgICB2YXIgdmFsMSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqICh0aW1lIC0gZXZlbnQudGltZSkgKiAodmFsMCArIHZhbDEpICsgZXZlbnQudGlja3M7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmV0dXJucyB0aGUgdGljayB2YWx1ZSBhdCB0aGUgdGltZS4gVGFrZXMgaW50byBhY2NvdW50XG5cdFx0ICogYW55IGF1dG9tYXRpb24gY3VydmVzIHNjaGVkdWxlZCBvbiB0aGUgc2lnbmFsLlxuXHRcdCAqIEBwYXJhbSAge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gZ2V0IHRoZSB0aWNrIGNvdW50IGF0XG5cdFx0ICogQHJldHVybiB7VGlja3N9ICAgICAgVGhlIG51bWJlciBvZiB0aWNrcyB3aGljaCBoYXZlIGVsYXBzZWQgYXQgdGhlIHRpbWVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW4gYW55IGF1dG9tYXRpb25zLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXRUaWNrQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLmdldCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VGlja1VudGlsRXZlbnQoZXZlbnQsIHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJldHVybiB0aGUgZWxhcHNlZCB0aW1lIG9mIHRoZSBudW1iZXIgb2YgdGlja3MgZnJvbSB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqIEBwYXJhbSB7VGlja3N9IHRpY2tzIFRoZSBudW1iZXIgb2YgdGlja3MgdG8gY2FsY3VsYXRlXG5cdFx0ICogQHBhcmFtICB7VGltZX0gdGltZSBUaGUgdGltZSB0byBnZXQgdGhlIG5leHQgdGljayBmcm9tXG5cdFx0ICogQHJldHVybiB7U2Vjb25kc30gVGhlIGR1cmF0aW9uIG9mIHRoZSBudW1iZXIgb2YgdGlja3MgZnJvbSB0aGUgZ2l2ZW4gdGltZSBpbiBzZWNvbmRzXG5cdFx0ICovXG5cdCAgICBUb25lLlRpY2tTaWduYWwucHJvdG90eXBlLmdldER1cmF0aW9uT2ZUaWNrcyA9IGZ1bmN0aW9uICh0aWNrcywgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB2YXIgY3VycmVudFRpY2sgPSB0aGlzLmdldFRpY2tBdFRpbWUodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGltZU9mVGljayhjdXJyZW50VGljayArIHRpY2tzKSAtIHRpbWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogR2l2ZW4gYSB0aWNrLCByZXR1cm5zIHRoZSB0aW1lIHRoYXQgdGljayBvY2N1cnMgYXQuXG5cdFx0ICogQHBhcmFtICB7VGlja3N9IHRpY2tcblx0XHQgKiBAcmV0dXJuIHtUaW1lfSAgICAgIFRoZSB0aW1lIHRoYXQgdGhlIHRpY2sgb2NjdXJzLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UaWNrU2lnbmFsLnByb3RvdHlwZS5nZXRUaW1lT2ZUaWNrID0gZnVuY3Rpb24gKHRpY2spIHtcblx0ICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5fZXZlbnRzLmdldCh0aWNrLCAndGlja3MnKTtcblx0ICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLl9ldmVudHMuZ2V0QWZ0ZXIodGljaywgJ3RpY2tzJyk7XG5cdCAgICAgICAgaWYgKGJlZm9yZSAmJiBiZWZvcmUudGlja3MgPT09IHRpY2spIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJlZm9yZS50aW1lO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlICYmIGFmdGVyICYmIGFmdGVyLnR5cGUgPT09IFRvbmUuVGltZWxpbmVTaWduYWwuVHlwZS5MaW5lYXIgJiYgYmVmb3JlLnZhbHVlICE9PSBhZnRlci52YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdmFsMCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoYmVmb3JlLnRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgdmFsMSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoYWZ0ZXIudGltZSk7XG5cdCAgICAgICAgICAgIHZhciBkZWx0YSA9ICh2YWwxIC0gdmFsMCkgLyAoYWZ0ZXIudGltZSAtIGJlZm9yZS50aW1lKTtcblx0ICAgICAgICAgICAgdmFyIGsgPSBNYXRoLnNxcnQoTWF0aC5wb3codmFsMCwgMikgLSAyICogZGVsdGEgKiAoYmVmb3JlLnRpY2tzIC0gdGljaykpO1xuXHQgICAgICAgICAgICB2YXIgc29sMSA9ICgtdmFsMCArIGspIC8gZGVsdGE7XG5cdCAgICAgICAgICAgIHZhciBzb2wyID0gKC12YWwwIC0gaykgLyBkZWx0YTtcblx0ICAgICAgICAgICAgcmV0dXJuIChzb2wxID4gMCA/IHNvbDEgOiBzb2wyKSArIGJlZm9yZS50aW1lO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlKSB7XG5cdCAgICAgICAgICAgIGlmIChiZWZvcmUudmFsdWUgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUudGltZSArICh0aWNrIC0gYmVmb3JlLnRpY2tzKSAvIGJlZm9yZS52YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aWNrIC8gdGhpcy5faW5pdGlhbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVGlja1NpZ25hbDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIFRpbWVsaW5lIFN0YXRlLiBQcm92aWRlcyB0aGUgbWV0aG9kczogPGNvZGU+c2V0U3RhdGVBdFRpbWUoXCJzdGF0ZVwiLCB0aW1lKTwvY29kZT5cblx0XHQgKiAgICAgICAgICBhbmQgPGNvZGU+Z2V0VmFsdWVBdFRpbWUodGltZSk8L2NvZGU+LlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lfVxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gaW5pdGlhbCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgVGltZWxpbmVTdGF0ZS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIDxjb2RlPnVuZGVmaW5lZDwvY29kZT5cblx0XHQgKi9cblx0ICAgIFRvbmUuVGltZWxpbmVTdGF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsKSB7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbml0aWFsIHN0YXRlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5pdGlhbCA9IGluaXRpYWw7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5UaW1lbGluZVN0YXRlLCBUb25lLlRpbWVsaW5lKTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBzY2hlZHVsZWQgc3RhdGUgc2NoZWR1bGVkIGJlZm9yZSBvciBhdFxuXHRcdCAqICB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRpbWVsaW5lU3RhdGUucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmdldCh0aW1lKTtcblx0ICAgICAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnN0YXRlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQWRkIGEgc3RhdGUgdG8gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd9ICBzdGF0ZSBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgdG8gc2V0LlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVGltZWxpbmVTdGF0ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UaW1lbGluZVN0YXRlLnByb3RvdHlwZS5zZXRTdGF0ZUF0VGltZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGltZSkge1xuXHQgICAgICAgIHRoaXMuYWRkKHtcblx0ICAgICAgICAgICAgJ3N0YXRlJzogc3RhdGUsXG5cdCAgICAgICAgICAgICd0aW1lJzogdGltZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRpbWVsaW5lU3RhdGU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQSBzYW1wbGUgYWNjdXJhdGUgY2xvY2sgd2hpY2ggcHJvdmlkZXMgYSBjYWxsYmFjayBhdCB0aGUgZ2l2ZW4gcmF0ZS4gXG5cdFx0ICogICAgICAgICAgV2hpbGUgdGhlIGNhbGxiYWNrIGlzIG5vdCBzYW1wbGUtYWNjdXJhdGUgKGl0IGlzIHN0aWxsIHN1c2NlcHRpYmxlIHRvXG5cdFx0ICogICAgICAgICAgbG9vc2UgSlMgdGltaW5nKSwgdGhlIHRpbWUgcGFzc2VkIGluIGFzIHRoZSBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2tcblx0XHQgKiAgICAgICAgICBpcyBwcmVjaXNlLiBGb3IgbW9zdCBhcHBsaWNhdGlvbnMsIGl0IGlzIGJldHRlciB0byB1c2UgVG9uZS5UcmFuc3BvcnRcblx0XHQgKiAgICAgICAgICBpbnN0ZWFkIG9mIHRoZSBDbG9jayBieSBpdHNlbGYgc2luY2UgeW91IGNhbiBzeW5jaHJvbml6ZSBtdWx0aXBsZSBjYWxsYmFja3MuXG5cdFx0ICpcblx0XHQgKiBcdEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqIFx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2l0aCB0aGUgdGltZSBvZiB0aGUgYXVkaW8gZXZlbnRcblx0XHQgKiBcdEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHJhdGUgb2YgdGhlIGNhbGxiYWNrXG5cdFx0ICogXHRAZXhhbXBsZVxuXHRcdCAqIC8vdGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBhcHByb3hpbWF0ZWx5IG9uY2UgYSBzZWNvbmRcblx0XHQgKiAvL2FuZCB3aWxsIHByaW50IHRoZSB0aW1lIGV4YWN0bHkgb25jZSBhIHNlY29uZCBhcGFydC5cblx0XHQgKiB2YXIgY2xvY2sgPSBuZXcgVG9uZS5DbG9jayhmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKHRpbWUpO1xuXHRcdCAqIH0sIDEpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5DbG9jayk7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhdCB0aGUgc2NoZWR1bGVkIHRpY2suXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBuZXh0IHRpbWUgdGhlIGNhbGxiYWNrIGlzIHNjaGVkdWxlZC5cblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxhc3Qgc3RhdGUgb2YgdGhlIGNsb2NrLlxuXHRcdFx0ICogIEB0eXBlICB7U3RhdGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xhc3RTdGF0ZSA9IFRvbmUuU3RhdGUuU3RvcHBlZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGJlIGludm9rZWQuIFxuXHRcdFx0ICogIEB0eXBlICB7QlBNfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuVGlja1NpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGNhbGxiYWNrIHdhcyBpbnZva2VkLiBTdGFydHMgY291bnRpbmcgYXQgMFxuXHRcdFx0ICogIGFuZCBpbmNyZW1lbnRzIGFmdGVyIHRoZSBjYWxsYmFjayB3YXMgaW52b2tlZC4gXG5cdFx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdFx0ICogIEByZWFkT25seVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50aWNrcyA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHN0YXRlIHRpbWVsaW5lXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmVTdGF0ZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVG9uZS5UaW1lbGluZVN0YXRlKFRvbmUuU3RhdGUuU3RvcHBlZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxvb3AgZnVuY3Rpb24gYm91bmQgdG8gaXRzIGNvbnRleHQuIFxuXHRcdFx0ICogIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSB0aGUgZXZlbnQgaW4gdGhlIGVuZC5cblx0XHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2JvdW5kTG9vcCA9IHRoaXMuX2xvb3AuYmluZCh0aGlzKTtcblx0ICAgICAgICAvL2JpbmQgYSBjYWxsYmFjayB0byB0aGUgd29ya2VyIHRocmVhZFxuXHQgICAgICAgIHRoaXMuY29udGV4dC5vbigndGljaycsIHRoaXMuX2JvdW5kTG9vcCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DbG9jaywgVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnY2FsbGJhY2snOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiLCBcInN0b3BwZWRcIiBvciBcInBhdXNlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkNsb2NrI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2xvY2sucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgY2xvY2sgYXQgdGhlIGdpdmVuIHRpbWUuIE9wdGlvbmFsbHkgcGFzcyBpbiBhbiBvZmZzZXRcblx0XHQgKiAgb2Ygd2hlcmUgdG8gc3RhcnQgdGhlIHRpY2sgY291bnRlciBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgVGhlIHRpbWUgdGhlIGNsb2NrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0gIHtUaWNrcz19ICBvZmZzZXQgIFdoZXJlIHRoZSB0aWNrIGNvdW50ZXIgc3RhcnRzIGNvdW50aW5nIGZyb20uXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkNsb2NrfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DbG9jay5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RhcnRlZCwgdGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmdldCh0aW1lKS5vZmZzZXQgPSBvZmZzZXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBjbG9jay4gU3RvcHBpbmcgdGhlIGNsb2NrIHJlc2V0cyB0aGUgdGljayBjb3VudGVyIHRvIDAuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSBjbG9jayBzaG91bGQgc3RvcC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2xvY2t9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBjbG9jay5zdG9wKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RvcHBlZCwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSBjbG9jay4gUGF1c2luZyBkb2VzIG5vdCByZXNldCB0aGUgdGljayBjb3VudGVyLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgY2xvY2sgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNsb2NrfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuUGF1c2VkLCB0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzY2hlZHVsaW5nIGxvb3AuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5fbG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL3RoZSBlbmQgb2YgdGhlIHVwZGF0ZSBpbnRlcnZhbFxuXHQgICAgICAgIHZhciBlbmRUaW1lID0gdGhpcy5ub3coKSArIHRoaXMuY29udGV4dC51cGRhdGVJbnRlcnZhbDtcblx0ICAgICAgICAvL3RoZSBjdXJyZW50IGV2ZW50IGF0IHRoZSB0aW1lIG9mIHRoZSBsb29wXG5cdCAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KGVuZFRpbWUpO1xuXHQgICAgICAgIGlmIChldmVudCkge1xuXHQgICAgICAgICAgICAvL3N0YXRlIGNoYW5nZSBldmVudHNcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlICE9PSB0aGlzLl9sYXN0U3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTdGF0ZSA9IGV2ZW50LnN0YXRlO1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5zdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBUb25lLlN0YXRlLlN0YXJ0ZWQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYoZXZlbnQub2Zmc2V0KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpY2tzID0gZXZlbnQub2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0VGljayA9IGV2ZW50LnRpbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIGV2ZW50LnRpbWUsIHRoaXMudGlja3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBUb25lLlN0YXRlLlN0b3BwZWQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgZXZlbnQudGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFRvbmUuU3RhdGUuUGF1c2VkOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGF1c2UnLCBldmVudC50aW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL2FsbCB0aGUgdGljayBldmVudHNcblx0ICAgICAgICAgICAgd2hpbGUgKGVuZFRpbWUgPiB0aGlzLl9uZXh0VGljayAmJiB0aGlzLl9zdGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpY2tUaW1lID0gdGhpcy5fbmV4dFRpY2s7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmVxdWVuY3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0VGljayArPSB0aGlzLmZyZXF1ZW5jeS5nZXREdXJhdGlvbk9mVGlja3MoMSwgdGhpcy5fbmV4dFRpY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHRpY2tUaW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGlja3MrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aWNrcysrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgc2NoZWR1bGVkIHN0YXRlIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgVGhlIHRpbWUgdG8gcXVlcnkuXG5cdFx0ICogIEByZXR1cm4gIHtTdHJpbmd9ICBUaGUgbmFtZSBvZiB0aGUgc3RhdGUgaW5wdXQgaW4gc2V0U3RhdGVBdFRpbWUuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogY2xvY2suc3RhcnQoXCIrMC4xXCIpO1xuXHRcdCAqIGNsb2NrLmdldFN0YXRlQXRUaW1lKFwiKzAuMVwiKTsgLy9yZXR1cm5zIFwic3RhcnRlZFwiXG5cdFx0ICovXG5cdCAgICBUb25lLkNsb2NrLnByb3RvdHlwZS5nZXRTdGF0ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ2xvY2t9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2xvY2sucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0Lm9mZigndGljaycsIHRoaXMuX2JvdW5kTG9vcCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2ZyZXF1ZW5jeScpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYm91bmRMb29wID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IEluZmluaXR5O1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ2xvY2s7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBTaW1pbGFyIHRvIFRvbmUuVGltZWxpbmUsIGJ1dCBhbGwgZXZlbnRzIHJlcHJlc2VudFxuXHRcdCAqICAgICAgICAgaW50ZXJ2YWxzIHdpdGggYm90aCBcInRpbWVcIiBhbmQgXCJkdXJhdGlvblwiIHRpbWVzLiBUaGUgXG5cdFx0ICogICAgICAgICBldmVudHMgYXJlIHBsYWNlZCBpbiBhIHRyZWUgc3RydWN0dXJlIG9wdGltaXplZFxuXHRcdCAqICAgICAgICAgZm9yIHF1ZXJ5aW5nIGFuIGludGVyc2VjdGlvbiBwb2ludCB3aXRoIHRoZSB0aW1lbGluZVxuXHRcdCAqICAgICAgICAgZXZlbnRzLiBJbnRlcm5hbGx5IHVzZXMgYW4gW0ludGVydmFsIFRyZWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludGVydmFsX3RyZWUpXG5cdFx0ICogICAgICAgICB0byByZXByZXNlbnQgdGhlIGRhdGEuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcm9vdCBub2RlIG9mIHRoZSBpbnRldmFsIHRyZWVcblx0XHRcdCAqICBAdHlwZSAge0ludGVydmFsTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgS2VlcCB0cmFjayBvZiB0aGUgbGVuZ3RoIG9mIHRoZSB0aW1lbGluZS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkludGVydmFsVGltZWxpbmUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lLiBBbGwgZXZlbnRzIG11c3QgXG5cdFx0ICogIGhhdmUgYSB0aW1lIGFuZCBkdXJhdGlvbiB2YWx1ZVxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IHRvIGFkZCB0byB0aGUgdGltZWxpbmVcblx0XHQgKiAgQHJldHVybiAge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihldmVudC50aW1lKSB8fCBUb25lLmlzVW5kZWYoZXZlbnQuZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5JbnRlcnZhbFRpbWVsaW5lOiBldmVudHMgbXVzdCBoYXZlIHRpbWUgYW5kIGR1cmF0aW9uIHBhcmFtZXRlcnMnKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxOb2RlKGV2ZW50LnRpbWUsIGV2ZW50LnRpbWUgKyBldmVudC5kdXJhdGlvbiwgZXZlbnQpO1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sZW5ndGgrKztcblx0ICAgICAgICAvLyBSZXN0cnVjdHVyZSB0cmVlIHRvIGJlIGJhbGFuY2VkXG5cdCAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgbm9kZS51cGRhdGVNYXgoKTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUpO1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge09iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgdG8gcmVtb3ZlIGZyb20gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkludGVydmFsVGltZWxpbmV9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKGV2ZW50LnRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmV2ZW50ID09PSBldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU5vZGUobm9kZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoLS07XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRpbWVsaW5lLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5JbnRlcnZhbFRpbWVsaW5lI1xuXHRcdCAqICBAbmFtZSBsZW5ndGhcblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgZXZlbnRzIHdob3NlIHRpbWUgdGltZSBpcyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0byBxdWVyeS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLmZvckVhY2hBZnRlcihhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHRoaXMucmVtb3ZlKGV2ZW50KTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIHJvb3Qgbm9kZSBhcyB0aGUgZ2l2ZW4gbm9kZVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsTm9kZX0gbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcm9vdC5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmVwbGFjZSB0aGUgcmVmZXJlbmNlcyB0byB0aGUgbm9kZSBpbiB0aGUgbm9kZSdzIHBhcmVudFxuXHRcdCAqICB3aXRoIHRoZSByZXBsYWNlbWVudCBub2RlLlxuXHRcdCAqICBAcGFyYW0gIHtJbnRlcnZhbE5vZGV9ICBub2RlICAgICAgICBcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgcmVwbGFjZW1lbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkludGVydmFsVGltZWxpbmUucHJvdG90eXBlLl9yZXBsYWNlTm9kZUluUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUsIHJlcGxhY2VtZW50KSB7XG5cdCAgICAgICAgaWYgKG5vZGUucGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmxlZnQgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCByZXBsYWNlIGl0IHdpdGggXG5cdFx0ICogIGEgc3VjY2Vzc29yIHdoaWNoIGZvbGxvd3MgdGhlIHNjaGVtYS5cblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCAmJiBub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChub2RlLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VOb2RlSW5QYXJlbnQobm9kZSwgbm9kZS5sZWZ0KTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIG5vZGUucmlnaHQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBiYWxhbmNlID0gbm9kZS5nZXRCYWxhbmNlKCk7XG5cdCAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCwgdGVtcDtcblx0ICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucmlnaHQgPSBub2RlLnJpZ2h0O1xuXHQgICAgICAgICAgICAgICAgICAgIHRlbXAgPSByZXBsYWNlbWVudDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBub2RlLmxlZnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlcGxhY2VtZW50LnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50LmxlZnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnJpZ2h0LmxlZnQgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQubGVmdCA9IG5vZGUubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gbm9kZS5yaWdodC5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZXBsYWNlbWVudC5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubGVmdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZW1lbnQucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQucmlnaHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcCA9IHJlcGxhY2VtZW50LnBhcmVudDtcblx0ICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5sZWZ0ID0gbm9kZS5sZWZ0O1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnJpZ2h0ID0gbm9kZS5yaWdodDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmlzTGVmdENoaWxkKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zZXRSb290KHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyB0aGlzLl9yZXBsYWNlTm9kZUluUGFyZW50KG5vZGUsIHJlcGxhY2VtZW50KTtcblx0ICAgICAgICAgICAgdGhpcy5fcmViYWxhbmNlKHRlbXApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmRpc3Bvc2UoKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUm90YXRlIHRoZSB0cmVlIHRvIHRoZSBsZWZ0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZUxlZnQgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcblx0ICAgICAgICB2YXIgaXNMZWZ0Q2hpbGQgPSBub2RlLmlzTGVmdENoaWxkKCk7XG5cdCAgICAgICAgLy8gTWFrZSBub2RlLnJpZ2h0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUucmlnaHQ7XG5cdCAgICAgICAgbm9kZS5yaWdodCA9IHBpdm90Tm9kZS5sZWZ0O1xuXHQgICAgICAgIHBpdm90Tm9kZS5sZWZ0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSb3RhdGUgdGhlIHRyZWUgdG8gdGhlIHJpZ2h0XG5cdFx0ICogIEBwYXJhbSAge0ludGVydmFsTm9kZX0gIG5vZGVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuX3JvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgdmFyIGlzTGVmdENoaWxkID0gbm9kZS5pc0xlZnRDaGlsZCgpO1xuXHQgICAgICAgIC8vIE1ha2Ugbm9kZS5sZWZ0IHRoZSBuZXcgcm9vdCBvZiB0aGlzIHN1YiB0cmVlIChpbnN0ZWFkIG9mIG5vZGUpXG5cdCAgICAgICAgdmFyIHBpdm90Tm9kZSA9IG5vZGUubGVmdDtcblx0ICAgICAgICBub2RlLmxlZnQgPSBwaXZvdE5vZGUucmlnaHQ7XG5cdCAgICAgICAgcGl2b3ROb2RlLnJpZ2h0ID0gbm9kZTtcblx0ICAgICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0xlZnRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSBwaXZvdE5vZGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRSb290KHBpdm90Tm9kZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBCYWxhbmNlIHRoZSBCU1Rcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5fcmViYWxhbmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICB2YXIgYmFsYW5jZSA9IG5vZGUuZ2V0QmFsYW5jZSgpO1xuXHQgICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xuXHQgICAgICAgICAgICBpZiAobm9kZS5sZWZ0LmdldEJhbGFuY2UoKSA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZUxlZnQobm9kZS5sZWZ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JvdGF0ZVJpZ2h0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmIChiYWxhbmNlIDwgLTEpIHtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQuZ2V0QmFsYW5jZSgpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRlUmlnaHQobm9kZS5yaWdodCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yb3RhdGVMZWZ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYW4gZXZlbnQgd2hvc2UgdGltZSBhbmQgZHVyYXRpb24gc3BhbiB0aGUgZ2l2ZSB0aW1lLiBXaWxsXG5cdFx0ICogIHJldHVybiB0aGUgbWF0Y2ggd2hvc2UgXCJ0aW1lXCIgdmFsdWUgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7T2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCB0byBhZGQgdG8gdGhlIHRpbWVsaW5lXG5cdFx0ICogIEByZXR1cm4gIHtPYmplY3R9ICBUaGUgZXZlbnQgd2hpY2ggc3BhbnMgdGhlIGRlc2lyZWQgdGltZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWF4ID0gcmVzdWx0c1swXTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldLmxvdyA+IG1heC5sb3cpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcmVzdWx0c1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWF4LmV2ZW50O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgZXZlcnl0aGluZyBpbiB0aGUgdGltZWxpbmUuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGFsbE5vZGVzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3QudHJhdmVyc2UoZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIGFsbE5vZGVzLnB1c2gobm9kZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXYgPSBhbGxOb2Rlc1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGlmIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGluIHdoaWNoIHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogIG92ZXJsYXBzIHdpdGggdGhlIHRpbWUgYW5kIGR1cmF0aW9uIHRpbWUgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lIFRoZSB0aW1lIHRvIGNoZWNrIGlmIGl0ZW1zIGFyZSBvdmVybGFwcGluZ1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBpdGVtXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkludGVydmFsVGltZWxpbmV9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZm9yRWFjaEF0VGltZSA9IGZ1bmN0aW9uICh0aW1lLCBjYWxsYmFjaykge1xuXHQgICAgICAgIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cdCAgICAgICAgICAgIHRoaXMuX3Jvb3Quc2VhcmNoKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGlmIChldikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGV2ZXJ5dGhpbmcgaW4gdGhlIGFycmF5IGluIHdoaWNoIHRoZSB0aW1lIGlzIGdyZWF0ZXJcblx0XHQgKiAgdGhhbiB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSBUaGUgdGltZSB0byBjaGVjayBpZiBpdGVtcyBhcmUgYmVmb3JlXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGV2ZXJ5IGl0ZW1cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnRlcnZhbFRpbWVsaW5lLnByb3RvdHlwZS5mb3JFYWNoQWZ0ZXIgPSBmdW5jdGlvbiAodGltZSwgY2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnNlYXJjaEFmdGVyKHRpbWUsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV2ID0gcmVzdWx0c1tpXS5ldmVudDtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuSW50ZXJ2YWxUaW1lbGluZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSW50ZXJ2YWxUaW1lbGluZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYWxsTm9kZXMgPSBbXTtcblx0ICAgICAgICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9yb290LnRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICBhbGxOb2Rlcy5wdXNoKG5vZGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBhbGxOb2Rlc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFsbE5vZGVzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRJTlRFUlZBTCBOT0RFIEhFTFBFUlxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIGJpbmFyeSBzZWFyY2ggdHJlZSwgd2l0aCB0aGUgYWRkaXRpb25cblx0XHQgKiAgb2YgYSBcImhpZ2hcIiB2YWx1ZSB3aGljaCBrZWVwcyB0cmFjayBvZiB0aGUgaGlnaGVzdCB2YWx1ZSBvZlxuXHRcdCAqICBpdHMgY2hpbGRyZW4uIFxuXHRcdCAqICBSZWZlcmVuY2VzOiBcblx0XHQgKiAgaHR0cHM6Ly9icm9va25vdmFrLndvcmRwcmVzcy5jb20vMjAxMy8xMi8wNy9hdWdtZW50ZWQtaW50ZXJ2YWwtdHJlZS1pbi1jL1xuXHRcdCAqICBodHRwOi8vd3d3Lm1pZi52dS5sdC9+dmFsZGFzL0FMR09SSVRNQUkvTElURVJBVFVSQS9Db3JtZW4vQ29ybWVuLnBkZlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gbG93XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICB2YXIgSW50ZXJ2YWxOb2RlID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZXZlbnQpIHtcblx0ICAgICAgICAvL3RoZSBldmVudCBjb250YWluZXJcblx0ICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdCAgICAgICAgLy90aGUgbG93IHZhbHVlXG5cdCAgICAgICAgdGhpcy5sb3cgPSBsb3c7XG5cdCAgICAgICAgLy90aGUgaGlnaCB2YWx1ZVxuXHQgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2g7XG5cdCAgICAgICAgLy90aGUgaGlnaCB2YWx1ZSBmb3IgdGhpcyBhbmQgYWxsIGNoaWxkIG5vZGVzXG5cdCAgICAgICAgdGhpcy5tYXggPSB0aGlzLmhpZ2g7XG5cdCAgICAgICAgLy90aGUgbm9kZXMgdG8gdGhlIGxlZnRcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICAvL3RoZSBub2RlcyB0byB0aGUgcmlnaHRcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgLy90aGUgcGFyZW50IG5vZGVcblx0ICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cdCAgICAgICAgLy90aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzXG5cdCAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuXHQgICAgfTtcblx0ICAgIC8qKiBcblx0XHQgKiAgSW5zZXJ0IGEgbm9kZSBpbnRvIHRoZSBjb3JyZWN0IHNwb3QgaW4gdGhlIHRyZWVcblx0XHQgKiAgQHBhcmFtICB7SW50ZXJ2YWxOb2RlfSAgbm9kZVxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgIGlmIChub2RlLmxvdyA8PSB0aGlzLmxvdykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBub2RlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbm9kZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZWFyY2ggdGhlIHRyZWUgZm9yIG5vZGVzIHdoaWNoIG92ZXJsYXAgXG5cdFx0ICogIHdpdGggdGhlIGdpdmVuIHBvaW50XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHBvaW50ICBUaGUgcG9pbnQgdG8gcXVlcnlcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICByZXN1bHRzICBUaGUgYXJyYXkgdG8gcHV0IHRoZSByZXN1bHRzXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChwb2ludCwgcmVzdWx0cykge1xuXHQgICAgICAgIC8vIElmIHAgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsXG5cdCAgICAgICAgLy8gaW4gdGhpcyBub2RlIGFuZCBhbGwgY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzLlxuXHQgICAgICAgIGlmIChwb2ludCA+IHRoaXMubWF4KSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubGVmdC5zZWFyY2gocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcblx0ICAgICAgICBpZiAodGhpcy5sb3cgPD0gcG9pbnQgJiYgdGhpcy5oaWdoID4gcG9pbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBJZiBwIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0aW1lIG9mIHRoaXMgaW50ZXJ2YWwsXG5cdCAgICAgICAgLy8gdGhlbiBpdCBjYW4ndCBiZSBpbiBhbnkgY2hpbGQgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgIGlmICh0aGlzLmxvdyA+IHBvaW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2VhcmNoIHJpZ2h0IGNoaWxkcmVuXG5cdCAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5yaWdodC5zZWFyY2gocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU2VhcmNoIHRoZSB0cmVlIGZvciBub2RlcyB3aGljaCBhcmUgbGVzcyBcblx0XHQgKiAgdGhhbiB0aGUgZ2l2ZW4gcG9pbnRcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgcG9pbnQgIFRoZSBwb2ludCB0byBxdWVyeVxuXHRcdCAqICBAcGFyYW0gIHtBcnJheX0gIHJlc3VsdHMgIFRoZSBhcnJheSB0byBwdXQgdGhlIHJlc3VsdHNcblx0XHQgKi9cblx0ICAgIEludGVydmFsTm9kZS5wcm90b3R5cGUuc2VhcmNoQWZ0ZXIgPSBmdW5jdGlvbiAocG9pbnQsIHJlc3VsdHMpIHtcblx0ICAgICAgICAvLyBDaGVjayB0aGlzIG5vZGVcblx0ICAgICAgICBpZiAodGhpcy5sb3cgPj0gcG9pbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmxlZnQuc2VhcmNoQWZ0ZXIocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHNlYXJjaCB0aGUgcmlnaHQgc2lkZVxuXHQgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMucmlnaHQuc2VhcmNoQWZ0ZXIocG9pbnQsIHJlc3VsdHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGlzIGVsZW1lbnQgYW5kIGJvdGggaXQncyBicmFuY2hlc1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmxlZnQudHJhdmVyc2UoY2FsbGJhY2spO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnJpZ2h0LnRyYXZlcnNlKGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh0aGlzLmxlZnQuaGVpZ2h0LCB0aGlzLnJpZ2h0LmhlaWdodCkgKyAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQuaGVpZ2h0ICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLm1heCA9IHRoaXMuaGlnaDtcblx0ICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIHRoaXMubGVmdC5tYXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCB0aGlzLnJpZ2h0Lm1heCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYmFsYW5jZSBpcyBob3cgdGhlIGxlYWZzIGFyZSBkaXN0cmlidXRlZCBvbiB0aGUgbm9kZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgTmVnYXRpdmUgbnVtYmVycyBhcmUgYmFsYW5jZWQgdG8gdGhlIHJpZ2h0XG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGJhbGFuY2UgPSAwO1xuXHQgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBiYWxhbmNlID0gdGhpcy5sZWZ0LmhlaWdodCAtIHRoaXMucmlnaHQuaGVpZ2h0O1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGJhbGFuY2UgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgYmFsYW5jZSA9IC0odGhpcy5yaWdodC5oZWlnaHQgKyAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGJhbGFuY2U7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgbm9kZSBpcyB0aGUgbGVmdCBjaGlsZFxuXHRcdCAqICBvZiBpdHMgcGFyZW50XG5cdFx0ICovXG5cdCAgICBJbnRlcnZhbE5vZGUucHJvdG90eXBlLmlzTGVmdENoaWxkID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCAhPT0gbnVsbCAmJiB0aGlzLnBhcmVudC5sZWZ0ID09PSB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBnZXQvc2V0IHRoZSBsZWZ0IG5vZGVcblx0XHQgKiAgQHR5cGUge0ludGVydmFsTm9kZX1cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbE5vZGUucHJvdG90eXBlLCAnbGVmdCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xlZnQgPSBub2RlO1xuXHQgICAgICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSB0aGlzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG5cdCAgICAgICAgICAgIHRoaXMudXBkYXRlTWF4KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgZ2V0L3NldCB0aGUgcmlnaHQgbm9kZVxuXHRcdCAqICBAdHlwZSB7SW50ZXJ2YWxOb2RlfVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludGVydmFsTm9kZS5wcm90b3R5cGUsICdyaWdodCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9yaWdodCA9IG5vZGU7XG5cdCAgICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHRoaXM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcblx0ICAgICAgICAgICAgdGhpcy51cGRhdGVNYXgoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBudWxsIG91dCByZWZlcmVuY2VzLlxuXHRcdCAqL1xuXHQgICAgSW50ZXJ2YWxOb2RlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0RU5EIElOVEVSVkFMIE5PREUgSEVMUEVSXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIHJldHVybiBUb25lLkludGVydmFsVGltZWxpbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5UcmFuc3BvcnRFdmVudCBpcyBhbiBpbnRlcm5hbCBjbGFzcyB1c2VkIGJ5IChUb25lLlRyYW5zcG9ydClbVHJhbnNwb3J0XVxuXHRcdCAqICAgICAgICAgdG8gc2NoZWR1bGUgZXZlbnRzLiBEbyBubyBpbnZva2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgaXQgaXNcblx0XHQgKiAgICAgICAgIGhhbmRsZWQgZnJvbSB3aXRoaW4gVG9uZS5UcmFuc3BvcnQuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRFdmVudCA9IGZ1bmN0aW9uIChUcmFuc3BvcnQsIG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuVHJhbnNwb3J0RXZlbnQuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgVHJhbnNwb3J0IHRoYXQgY3JlYXRlZCBpdFxuXHRcdFx0ICogQHR5cGUge1RvbmUuVHJhbnNwb3J0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdW5pcXVlIGlkIG9mIHRoZSBldmVudFxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaWQgPSBUb25lLlRyYW5zcG9ydEV2ZW50Ll9ldmVudElkKys7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdGltZSB0aGUgZXZlbnQgc3RhcnRzXG5cdFx0XHQgKiBAdHlwZSB7VGlja3N9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnRpbWUgPSBvcHRpb25zLnRpbWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqIElmIHRoZSBldmVudCBzaG91bGQgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBjcmVhdGVkLlxuXHRcdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb25jZSA9IG9wdGlvbnMub25jZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRyYW5zcG9ydEV2ZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0c1xuXHRcdCAqIEBzdGF0aWNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRFdmVudC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb25jZSc6IGZhbHNlLFxuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEN1cnJlbnQgSUQgY291bnRlclxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydEV2ZW50Ll9ldmVudElkID0gMDtcblx0ICAgIC8qKlxuXHRcdCAqIEludm9rZSB0aGUgY2FsbGJhY2sgZXZlbiBjYWxsYmFjay5cblx0XHQgKiBAcGFyYW0gIHtUaW1lfSB0aW1lICBUaGUgQXVkaW9Db250ZXh0IHRpbWUgaW4gc2Vjb25kcyBvZiB0aGUgZXZlbnRcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0RXZlbnQucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX29uY2UgJiYgdGhpcy5UcmFuc3BvcnQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuVHJhbnNwb3J0LmNsZWFyKHRoaXMuaWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIENsZWFuIHVwXG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRFdmVudH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRFdmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5UcmFuc3BvcnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRyYW5zcG9ydEV2ZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQgaXMgYW4gaW50ZXJuYWwgY2xhc3MgdXNlZCBieSBUb25lLlRyYW5zcG9ydFxuXHRcdCAqICAgICAgICAgdG8gc2NoZWR1bGUgcmVwZWF0IGV2ZW50cy4gVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuVHJhbnNwb3J0RXZlbnR9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50ID0gZnVuY3Rpb24gKFRyYW5zcG9ydCwgb3B0aW9ucykge1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0RXZlbnQuY2FsbCh0aGlzLCBUcmFuc3BvcnQsIG9wdGlvbnMpO1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5UcmFuc3BvcnRSZXBlYXRFdmVudC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBXaGVuIHRoZSBldmVudCBzaG91bGQgc3RvcCByZXBlYXRpbmdcblx0XHRcdCAqIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBpbnRlcnZhbCBvZiB0aGUgcmVwZWF0ZWQgZXZlbnRcblx0XHRcdCAqIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgSUQgb2YgdGhlIGN1cnJlbnQgdGltZWxpbmUgZXZlbnRcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY3VycmVudElkID0gLTE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgSUQgb2YgdGhlIG5leHQgdGltZWxpbmUgZXZlbnRcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbmV4dElkID0gLTE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgICogVGhlIHRpbWUgb2YgdGhlIG5leHQgZXZlbnRcblx0XHRcdCAgKiBAdHlwZSB7VGlja3N9XG5cdFx0XHQgICogQHByaXZhdGVcblx0XHRcdCAgKi9cblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IHRoaXMudGltZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIGEgcmVmZXJlbmNlIHRvIHRoZSBib3VuZCBzdGFydCBtZXRob2Rcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ib3VuZFJlc3RhcnQgPSB0aGlzLl9yZXN0YXJ0LmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5UcmFuc3BvcnQub24oJ3N0YXJ0IGxvb3BTdGFydCcsIHRoaXMuX2JvdW5kUmVzdGFydCk7XG5cdCAgICAgICAgdGhpcy5fcmVzdGFydCgpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQsIFRvbmUuVHJhbnNwb3J0RXZlbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRlZmF1bHRzXG5cdFx0ICogQHN0YXRpY1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdkdXJhdGlvbic6IEluZmluaXR5LFxuXHQgICAgICAgICdpbnRlcnZhbCc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJbnZva2UgdGhlIGNhbGxiYWNrLiBSZXR1cm5zIHRoZSB0aWNrIHRpbWUgd2hpY2hcblx0XHQgKiB0aGUgbmV4dCBldmVudCBzaG91bGQgYmUgc2NoZWR1bGVkIGF0LlxuXHRcdCAqIEBwYXJhbSAge051bWJlcn0gdGltZSAgVGhlIEF1ZGlvQ29udGV4dCB0aW1lIGluIHNlY29uZHMgb2YgdGhlIGV2ZW50XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50LnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIC8vY3JlYXRlIG1vcmUgZXZlbnRzIGlmIG5lY2Vzc2FyeVxuXHQgICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50cygpO1xuXHQgICAgICAgIC8vY2FsbCB0aGUgc3VwZXIgY2xhc3Ncblx0ICAgICAgICBUb25lLlRyYW5zcG9ydEV2ZW50LnByb3RvdHlwZS5pbnZva2UuY2FsbCh0aGlzLCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBQdXNoIG1vcmUgZXZlbnRzIG9udG8gdGhlIHRpbWVsaW5lIHRvIGtlZXAgdXAgd2l0aCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQucHJvdG90eXBlLl9jcmVhdGVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gc2NoZWR1bGUgdGhlIG5leHQgZXZlbnRcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLlRyYW5zcG9ydC50aWNrcztcblx0ICAgICAgICBpZiAodGlja3MgPj0gdGhpcy50aW1lICYmIHRpY2tzID49IHRoaXMuX25leHRUaWNrICYmIHRoaXMuX25leHRUaWNrICsgdGhpcy5faW50ZXJ2YWwgPCB0aGlzLnRpbWUgKyB0aGlzLmR1cmF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX25leHRUaWNrICs9IHRoaXMuX2ludGVydmFsO1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJyZW50SWQgPSB0aGlzLl9uZXh0SWQ7XG5cdCAgICAgICAgICAgIHRoaXMuX25leHRJZCA9IHRoaXMuVHJhbnNwb3J0LnNjaGVkdWxlT25jZSh0aGlzLmludm9rZS5iaW5kKHRoaXMpLCBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbmV4dFRpY2ssICdpJykpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBQdXNoIG1vcmUgZXZlbnRzIG9udG8gdGhlIHRpbWVsaW5lIHRvIGtlZXAgdXAgd2l0aCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQucHJvdG90eXBlLl9yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuVHJhbnNwb3J0LmNsZWFyKHRoaXMuX2N1cnJlbnRJZCk7XG5cdCAgICAgICAgdGhpcy5UcmFuc3BvcnQuY2xlYXIodGhpcy5fbmV4dElkKTtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLlRyYW5zcG9ydC50aWNrcztcblx0ICAgICAgICB0aGlzLl9uZXh0VGljayA9IHRoaXMudGltZTtcblx0ICAgICAgICBpZiAodGlja3MgPiB0aGlzLnRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbmV4dFRpY2sgPSB0aGlzLnRpbWUgKyBNYXRoLmNlaWwoKHRpY2tzIC0gdGhpcy50aW1lKSAvIHRoaXMuX2ludGVydmFsKSAqIHRoaXMuX2ludGVydmFsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jdXJyZW50SWQgPSB0aGlzLlRyYW5zcG9ydC5zY2hlZHVsZU9uY2UodGhpcy5pbnZva2UuYmluZCh0aGlzKSwgVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX25leHRUaWNrLCAnaScpKTtcblx0ICAgICAgICB0aGlzLl9uZXh0VGljayArPSB0aGlzLl9pbnRlcnZhbDtcblx0ICAgICAgICB0aGlzLl9uZXh0SWQgPSB0aGlzLlRyYW5zcG9ydC5zY2hlZHVsZU9uY2UodGhpcy5pbnZva2UuYmluZCh0aGlzKSwgVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX25leHRUaWNrLCAnaScpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0UmVwZWF0RXZlbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5UcmFuc3BvcnQuY2xlYXIodGhpcy5fY3VycmVudElkKTtcblx0ICAgICAgICB0aGlzLlRyYW5zcG9ydC5jbGVhcih0aGlzLl9uZXh0SWQpO1xuXHQgICAgICAgIHRoaXMuVHJhbnNwb3J0Lm9mZignc3RhcnQgbG9vcFN0YXJ0JywgdGhpcy5fYm91bmRSZXN0YXJ0KTtcblx0ICAgICAgICB0aGlzLl9ib3VuZENyZWF0ZUV2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnRFdmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRyYW5zcG9ydCBmb3IgdGltaW5nIG11c2ljYWwgZXZlbnRzLlxuXHRcdCAqICAgICAgICAgIFN1cHBvcnRzIHRlbXBvIGN1cnZlcyBhbmQgdGltZSBjaGFuZ2VzLiBVbmxpa2UgYnJvd3Nlci1iYXNlZCB0aW1pbmcgKHNldEludGVydmFsLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG5cdFx0ICogICAgICAgICAgVG9uZS5UcmFuc3BvcnQgdGltaW5nIGV2ZW50cyBwYXNzIGluIHRoZSBleGFjdCB0aW1lIG9mIHRoZSBzY2hlZHVsZWQgZXZlbnRcblx0XHQgKiAgICAgICAgICBpbiB0aGUgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLiBQYXNzIHRoYXQgdGltZSB2YWx1ZSB0byB0aGUgb2JqZWN0XG5cdFx0ICogICAgICAgICAgeW91J3JlIHNjaGVkdWxpbmcuIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgQSBzaW5nbGUgdHJhbnNwb3J0IGlzIGNyZWF0ZWQgZm9yIHlvdSB3aGVuIHRoZSBsaWJyYXJ5IGlzIGluaXRpYWxpemVkLlxuXHRcdCAqICAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICAgVGhlIHRyYW5zcG9ydCBlbWl0cyB0aGUgZXZlbnRzOiBcInN0YXJ0XCIsIFwic3RvcFwiLCBcInBhdXNlXCIsIGFuZCBcImxvb3BcIiB3aGljaCBhcmVcblx0XHQgKiAgICAgICAgICBjYWxsZWQgd2l0aCB0aGUgdGltZSBvZiB0aGF0IGV2ZW50IGFzIHRoZSBhcmd1bWVudC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FbWl0dGVyfVxuXHRcdCAqICBAc2luZ2xldG9uXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9yZXBlYXRlZCBldmVudCBldmVyeSA4dGggbm90ZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlUmVwZWF0KGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgdGltZVxuXHRcdCAqIH0sIFwiOG5cIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zY2hlZHVsZSBhbiBldmVudCBvbiB0aGUgMTZ0aCBtZWFzdXJlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGUoZnVuY3Rpb24odGltZSl7XG5cdFx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSB0aW1lXG5cdFx0ICogfSwgXCIxNjowOjBcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVtaXR0ZXIuY2FsbCh0aGlzKTtcblx0ICAgICAgICBUb25lLmdldENvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgICAgICAgICAvL1x0TE9PUElOR1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiBcdElmIHRoZSB0cmFuc3BvcnQgbG9vcHMgb3Igbm90LlxuXHRcdFx0XHQgKiAgQHR5cGUge2Jvb2xlYW59XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqIFx0VGhlIGxvb3Agc3RhcnQgcG9zaXRpb24gaW4gdGlja3Ncblx0XHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSAwO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogXHRUaGUgbG9vcCBlbmQgcG9zaXRpb24gaW4gdGlja3Ncblx0XHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gMDtcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLy9cdENMT0NLL1RFTVBPXG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBQdWxzZXMgcGVyIHF1YXJ0ZXIgaXMgdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgcXVhcnRlciBub3RlLlxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fcHBxID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuUFBRO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIHdhdGNoZXMgdGhlIG1haW4gb3NjaWxsYXRvciBmb3IgdGltaW5nIHRpY2tzXG5cdFx0XHRcdCAqICBpbml0aWFsbHkgc3RhcnRzIGF0IDEyMGJwbVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLkNsb2NrfVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fY2xvY2sgPSBuZXcgVG9uZS5DbG9jayh7XG5cdCAgICAgICAgICAgICAgICAnY2FsbGJhY2snOiB0aGlzLl9wcm9jZXNzVGljay5iaW5kKHRoaXMpLFxuXHQgICAgICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IDBcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2JpbmRDbG9ja0V2ZW50cygpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBCZWF0cyBQZXIgTWludXRlIG9mIHRoZSBUcmFuc3BvcnQuXG5cdFx0XHRcdCAqICBAdHlwZSB7QlBNfVxuXHRcdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gODA7XG5cdFx0XHRcdCAqIC8vcmFtcCB0aGUgYnBtIHRvIDEyMCBvdmVyIDEwIHNlY29uZHNcblx0XHRcdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnJhbXBUbygxMjAsIDEwKTtcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuYnBtID0gdGhpcy5fY2xvY2suZnJlcXVlbmN5O1xuXHQgICAgICAgICAgICB0aGlzLmJwbS5fdG9Vbml0cyA9IHRoaXMuX3RvVW5pdHMuYmluZCh0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5icG0uX2Zyb21Vbml0cyA9IHRoaXMuX2Zyb21Vbml0cy5iaW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB0aGlzLmJwbS51bml0cyA9IFRvbmUuVHlwZS5CUE07XG5cdCAgICAgICAgICAgIHRoaXMuYnBtLnZhbHVlID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuYnBtO1xuXHQgICAgICAgICAgICB0aGlzLl9yZWFkT25seSgnYnBtJyk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlLCBvciBtb3JlIGFjY3VyYXRlbHkgdGhlIG51bWVyYXRvclxuXHRcdFx0XHQgKiAgb2YgdGhlIHRpbWUgc2lnbmF0dXJlIG92ZXIgYSBkZW5vbWluYXRvciBvZiA0LlxuXHRcdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMudGltZVNpZ25hdHVyZTtcblx0ICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgICAgICAgICAgLy9cdFRJTUVMSU5FIEVWRU5UU1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQWxsIHRoZSBldmVudHMgaW4gYW4gb2JqZWN0IHRvIGtlZXAgdHJhY2sgYnkgSURcblx0XHRcdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkRXZlbnRzID0ge307XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiBcdFRoZSBzY2hlZHVsZWQgZXZlbnRzLlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuVGltZWxpbmV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fdGltZWxpbmUgPSBuZXcgVG9uZS5UaW1lbGluZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFJlcGVhdGVkIGV2ZW50c1xuXHRcdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzID0gbmV3IFRvbmUuSW50ZXJ2YWxUaW1lbGluZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEFsbCBvZiB0aGUgc3luY2VkIFNpZ25hbHNcblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzID0gW107XG5cdCAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8vXHRTV0lOR1xuXHQgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHN1YmRpdmlzaW9uIG9mIHRoZSBzd2luZ1xuXHRcdFx0XHQgKiAgQHR5cGUgIHtUaWNrc31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zd2luZ1RpY2tzID0gVHJhbnNwb3J0Q29uc3RydWN0b3IuZGVmYXVsdHMuUFBRIC8gMjtcblx0ICAgICAgICAgICAgLy84blxuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBzd2luZyBhbW91bnRcblx0XHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9zd2luZ0Ftb3VudCA9IDA7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlRyYW5zcG9ydCwgVG9uZS5FbWl0dGVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdicG0nOiAxMjAsXG5cdCAgICAgICAgJ3N3aW5nJzogMCxcblx0ICAgICAgICAnc3dpbmdTdWJkaXZpc2lvbic6ICc4bicsXG5cdCAgICAgICAgJ3RpbWVTaWduYXR1cmUnOiA0LFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogJzRtJyxcblx0ICAgICAgICAnUFBRJzogMTkyXG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFRJQ0tTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgY2FsbGVkIG9uIGV2ZXJ5IHRpY2tcblx0XHQgKiAgQHBhcmFtICAge251bWJlcn0gdGlja1RpbWUgY2xvY2sgcmVsYXRpdmUgdGljayB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX3Byb2Nlc3NUaWNrID0gZnVuY3Rpb24gKHRpY2tUaW1lKSB7XG5cdCAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5fY2xvY2sudGlja3M7XG5cdCAgICAgICAgLy9oYW5kbGUgc3dpbmdcblx0ICAgICAgICBpZiAodGhpcy5fc3dpbmdBbW91bnQgPiAwICYmIHRpY2tzICUgdGhpcy5fcHBxICE9PSAwICYmIC8vbm90IG9uIGEgZG93bmJlYXRcblx0ICAgICAgICAgICAgdGlja3MgJSAodGhpcy5fc3dpbmdUaWNrcyAqIDIpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIC8vYWRkIHNvbWUgc3dpbmdcblx0ICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gdGlja3MgJSAodGhpcy5fc3dpbmdUaWNrcyAqIDIpIC8gKHRoaXMuX3N3aW5nVGlja3MgKiAyKTtcblx0ICAgICAgICAgICAgdmFyIGFtb3VudCA9IE1hdGguc2luKHByb2dyZXNzICogTWF0aC5QSSkgKiB0aGlzLl9zd2luZ0Ftb3VudDtcblx0ICAgICAgICAgICAgdGlja1RpbWUgKz0gVG9uZS5UaW1lKHRoaXMuX3N3aW5nVGlja3MgKiAyIC8gMywgJ2knKSAqIGFtb3VudDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9kbyB0aGUgbG9vcCB0ZXN0XG5cdCAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICBpZiAodGlja3MgPj0gdGhpcy5fbG9vcEVuZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsb29wRW5kJywgdGlja1RpbWUpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xvY2sudGlja3MgPSB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9vcFN0YXJ0JywgdGlja1RpbWUsIHRoaXMuc2Vjb25kcyk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2xvb3AnLCB0aWNrVGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pbnZva2UgdGhlIHRpbWVsaW5lIGV2ZW50cyBzY2hlZHVsZWQgb24gdGhpcyB0aWNrXG5cdCAgICAgICAgdGhpcy5fdGltZWxpbmUuZm9yRWFjaEF0VGltZSh0aWNrcywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50Lmludm9rZSh0aWNrVGltZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNDSEVEVUxBQkxFIEVWRU5UU1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLyoqXG5cdFx0ICogIFNjaGVkdWxlIGFuIGV2ZW50IGFsb25nIHRoZSB0aW1lbGluZS5cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYXQgdGhlIHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gIHRpbWUgVGhlIHRpbWUgdG8gaW52b2tlIHRoZSBjYWxsYmFjayBhdC5cblx0XHQgKiAgQHJldHVybiB7TnVtYmVyfSBUaGUgaWQgb2YgdGhlIGV2ZW50IHdoaWNoIGNhbiBiZSB1c2VkIGZvciBjYW5jZWxpbmcgdGhlIGV2ZW50LlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciB0aGUgY2FsbGJhY2sgd2hlbiB0aGUgVHJhbnNwb3J0IHJlYWNoZXMgdGhlIGRlc2lyZWQgdGltZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0ZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0XHQgKiB9LCBcIjEyOGlcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRpbWUpIHtcblx0ICAgICAgICB2YXIgZXZlbnQgPSBuZXcgVG9uZS5UcmFuc3BvcnRFdmVudCh0aGlzLCB7XG5cdCAgICAgICAgICAgICd0aW1lJzogdGhpcy50b1RpY2tzKHRpbWUpLFxuXHQgICAgICAgICAgICAnY2FsbGJhY2snOiBjYWxsYmFja1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudChldmVudCwgdGhpcy5fdGltZWxpbmUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIHJlcGVhdGVkIGV2ZW50IGFsb25nIHRoZSB0aW1lbGluZS4gVGhlIGV2ZW50IHdpbGwgZmlyZVxuXHRcdCAqICBhdCB0aGUgYGludGVydmFsYCBzdGFydGluZyBhdCB0aGUgYHN0YXJ0VGltZWAgYW5kIGZvciB0aGUgc3BlY2lmaWVkXG5cdFx0ICogIGBkdXJhdGlvbmAuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgICBpbnRlcnZhbCAgIFRoZSBkdXJhdGlvbiBiZXR3ZWVuIHN1Y2Nlc3NpdmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MuIE11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIuXG5cdFx0ICogIEBwYXJhbSAge1RpbWVsaW5lUG9zaXRpb249fSAgICBzdGFydFRpbWUgIFdoZW4gYWxvbmcgdGhlIHRpbWVsaW5lIHRoZSBldmVudHMgc2hvdWxkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgYmVpbmcgaW52b2tlZC5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbZHVyYXRpb249SW5maW5pdHldIEhvdyBsb25nIHRoZSBldmVudCBzaG91bGQgcmVwZWF0LlxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgICBUaGUgSUQgb2YgdGhlIHNjaGVkdWxlZCBldmVudC4gVXNlIHRoaXMgdG8gY2FuY2VsXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZXZlbnQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIGNhbGxiYWNrIGludm9rZWQgZXZlcnkgZWlnaHRoIG5vdGUgYWZ0ZXIgdGhlIGZpcnN0IG1lYXN1cmVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdChjYWxsYmFjaywgXCI4blwiLCBcIjFtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlUmVwZWF0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBpbnRlcnZhbCwgc3RhcnRUaW1lLCBkdXJhdGlvbikge1xuXHQgICAgICAgIHZhciBldmVudCA9IG5ldyBUb25lLlRyYW5zcG9ydFJlcGVhdEV2ZW50KHRoaXMsIHtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJzogY2FsbGJhY2ssXG5cdCAgICAgICAgICAgICdpbnRlcnZhbCc6IHRoaXMudG9UaWNrcyhpbnRlcnZhbCksXG5cdCAgICAgICAgICAgICd0aW1lJzogdGhpcy50b1RpY2tzKHN0YXJ0VGltZSksXG5cdCAgICAgICAgICAgICdkdXJhdGlvbic6IHRoaXMudG9UaWNrcyhUb25lLmRlZmF1bHRBcmcoZHVyYXRpb24sIEluZmluaXR5KSlcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2tpY2sgaXQgb2ZmIGlmIHRoZSBUcmFuc3BvcnQgaXMgc3RhcnRlZFxuXHQgICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudChldmVudCwgdGhpcy5fcmVwZWF0ZWRFdmVudHMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhbiBldmVudCB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBpbnZva2VkLlxuXHRcdCAqICBOb3RlIHRoYXQgaWYgdGhlIGdpdmVuIHRpbWUgaXMgbGVzcyB0aGFuIHRoZSBjdXJyZW50IHRyYW5zcG9ydCB0aW1lLFxuXHRcdCAqICB0aGUgZXZlbnQgd2lsbCBiZSBpbnZva2VkIGltbWVkaWF0ZWx5LlxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UuXG5cdFx0ICogIEBwYXJhbSB7VHJhbnNwb3J0VGltZX0gdGltZSBUaGUgdGltZSB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIGludm9rZWQuXG5cdFx0ICogIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBJRCBvZiB0aGUgc2NoZWR1bGVkIGV2ZW50LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnNjaGVkdWxlT25jZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGltZSkge1xuXHQgICAgICAgIHZhciBldmVudCA9IG5ldyBUb25lLlRyYW5zcG9ydEV2ZW50KHRoaXMsIHtcblx0ICAgICAgICAgICAgJ3RpbWUnOiB0aGlzLnRvVGlja3ModGltZSksXG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IGNhbGxiYWNrLFxuXHQgICAgICAgICAgICAnb25jZSc6IHRydWVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnQoZXZlbnQsIHRoaXMuX3RpbWVsaW5lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYXIgdGhlIHBhc3NlZCBpbiBldmVudCBpZCBmcm9tIHRoZSB0aW1lbGluZVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gZXZlbnRJZCBUaGUgaWQgb2YgdGhlIGV2ZW50LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChldmVudElkKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NjaGVkdWxlZEV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudElkKSkge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX3NjaGVkdWxlZEV2ZW50c1tldmVudElkLnRvU3RyaW5nKCldO1xuXHQgICAgICAgICAgICBpdGVtLnRpbWVsaW5lLnJlbW92ZShpdGVtLmV2ZW50KTtcblx0ICAgICAgICAgICAgaXRlbS5ldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlZHVsZWRFdmVudHNbZXZlbnRJZC50b1N0cmluZygpXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQWRkIGFuIGV2ZW50IHRvIHRoZSBjb3JyZWN0IHRpbWVsaW5lLiBLZWVwIHRyYWNrIG9mIHRoZVxuXHRcdCAqIHRpbWVsaW5lIGl0IHdhcyBhZGRlZCB0by5cblx0XHQgKiBAcGFyYW0ge1RvbmUuVHJhbnNwb3J0RXZlbnR9XHRldmVudFxuXHRcdCAqIEBwYXJhbSB7VG9uZS5UaW1lbGluZX0gdGltZWxpbmVcblx0XHQgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZXZlbnQgaWQgd2hpY2ggd2FzIGp1c3QgYWRkZWRcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9hZGRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdGltZWxpbmUpIHtcblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWRFdmVudHNbZXZlbnQuaWQudG9TdHJpbmcoKV0gPSB7XG5cdCAgICAgICAgICAgICdldmVudCc6IGV2ZW50LFxuXHQgICAgICAgICAgICAndGltZWxpbmUnOiB0aW1lbGluZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGltZWxpbmUuYWRkKGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gZXZlbnQuaWQ7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSBzY2hlZHVsZWQgZXZlbnRzIGZyb20gdGhlIHRpbWVsaW5lIGFmdGVyXG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lLiBSZXBlYXRlZCBldmVudHMgd2lsbCBiZSByZW1vdmVkXG5cdFx0ICogIGlmIHRoZWlyIHN0YXJ0VGltZSBpcyBhZnRlciB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IFthZnRlcj0wXSBDbGVhciBhbGwgZXZlbnRzIGFmdGVyXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgdGltZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgYWZ0ZXIgPSBUb25lLmRlZmF1bHRBcmcoYWZ0ZXIsIDApO1xuXHQgICAgICAgIGFmdGVyID0gdGhpcy50b1RpY2tzKGFmdGVyKTtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZS5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzLmNhbmNlbChhZnRlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdFNUQVJUL1NUT1AvUEFVU0Vcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8qKlxuXHRcdCAqICBCaW5kIHN0YXJ0L3N0b3AvcGF1c2UgZXZlbnRzIGZyb20gdGhlIGNsb2NrIGFuZCBlbWl0IHRoZW0uXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuX2JpbmRDbG9ja0V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5vbignc3RhcnQnLCBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuVGltZSh0aGlzLl9jbG9jay50aWNrcywgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIHRpbWUsIG9mZnNldCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9jbG9jay5vbignc3RvcCcsIGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIHRpbWUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sub24oJ3BhdXNlJywgZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScsIHRpbWUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiwgXCJzdG9wcGVkXCIsIG9yIFwicGF1c2VkXCJcblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9jay5nZXRTdGF0ZUF0VGltZSh0aGlzLm5vdygpKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgdHJhbnNwb3J0IGFuZCBhbGwgc291cmNlcyBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBUaGUgdGltZSB3aGVuIHRoZSB0cmFuc3BvcnQgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lPX0gb2Zmc2V0IFRoZSB0aW1lbGluZSBvZmZzZXQgdG8gc3RhcnQgdGhlIHRyYW5zcG9ydC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0IGluIG9uZSBzZWNvbmQgc3RhcnRpbmcgYXQgYmVnaW5uaW5nIG9mIHRoZSA1dGggbWVhc3VyZS5cblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydChcIisxXCIsIFwiNDowOjBcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgY2xvY2tcblx0ICAgICAgICBpZiAoIVRvbmUuaXNVbmRlZihvZmZzZXQpKSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IHRoaXMudG9UaWNrcyhvZmZzZXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jbG9jay5zdGFydCh0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSB0cmFuc3BvcnQgYW5kIGFsbCBzb3VyY2VzIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIFRoZSB0aW1lIHdoZW4gdGhlIHRyYW5zcG9ydCBzaG91bGQgc3RvcC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVHJhbnNwb3J0fSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RvcCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBhdXNlIHRoZSB0cmFuc3BvcnQgYW5kIGFsbCBzb3VyY2VzIHN5bmNlZCB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9jbG9jay5wYXVzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUb2dnbGUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyYW5zcG9ydC4gSWYgaXQgaXNcblx0XHQgKiBzdGFydGVkLCBpdCB3aWxsIHN0b3AgaXQsIG90aGVyd2lzZSBpdCB3aWxsIHN0YXJ0IHRoZSBUcmFuc3BvcnQuXG5cdFx0ICogQHBhcmFtICB7VGltZT19IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnR9ICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9jbG9jay5nZXRTdGF0ZUF0VGltZSh0aW1lKSAhPT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnQodGltZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0U0VUVEVSUy9HRVRURVJTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgc2lnbmF0dXJlIGFzIGp1c3QgdGhlIG51bWVyYXRvciBvdmVyIDQuXG5cdFx0ICogIEZvciBleGFtcGxlIDQvNCB3b3VsZCBiZSBqdXN0IDQgYW5kIDYvOCB3b3VsZCBiZSAzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ8QXJyYXl9XG5cdFx0ICogIEBuYW1lIHRpbWVTaWduYXR1cmVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NvbW1vbiB0aW1lXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZSA9IDQ7XG5cdFx0ICogLy8gNy84XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQudGltZVNpZ25hdHVyZSA9IFs3LCA4XTtcblx0XHQgKiAvL3RoaXMgd2lsbCBiZSByZWR1Y2VkIHRvIGEgc2luZ2xlIG51bWJlclxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnRpbWVTaWduYXR1cmU7IC8vcmV0dXJucyAzLjVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICd0aW1lU2lnbmF0dXJlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZVNpZ25hdHVyZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWVTaWcpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aW1lU2lnKSkge1xuXHQgICAgICAgICAgICAgICAgdGltZVNpZyA9IHRpbWVTaWdbMF0gLyB0aW1lU2lnWzFdICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl90aW1lU2lnbmF0dXJlID0gdGltZVNpZztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFdoZW4gdGhlIFRvbmUuVHJhbnNwb3J0Lmxvb3AgPSB0cnVlLCB0aGlzIGlzIHRoZSBzdGFydGluZyBwb3NpdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BTdGFydCwgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1RpY2tzKHN0YXJ0UG9zaXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogV2hlbiB0aGUgVG9uZS5UcmFuc3BvcnQubG9vcCA9IHRydWUsIHRoaXMgaXMgdGhlIGVuZGluZyBwb3NpdGlvbiBvZiB0aGUgbG9vcC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbG9vcEVuZCwgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGVuZFBvc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3MoZW5kUG9zaXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgbG9vcCBzdGFydCBhbmQgc3RvcCBhdCB0aGUgc2FtZSB0aW1lLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHN0YXJ0UG9zaXRpb25cblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBlbmRQb3NpdGlvblxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5UcmFuc3BvcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvb3Agb3ZlciB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnNldExvb3BQb2ludHMoMCwgXCIxbVwiKTtcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5sb29wID0gdHJ1ZTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5zZXRMb29wUG9pbnRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uKSB7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBzdGFydFBvc2l0aW9uO1xuXHQgICAgICAgIHRoaXMubG9vcEVuZCA9IGVuZFBvc2l0aW9uO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3dpbmcgdmFsdWUuIEJldHdlZW4gMC0xIHdoZXJlIDEgZXF1YWwgdG9cblx0XHQgKiAgdGhlIG5vdGUgKyBoYWxmIHRoZSBzdWJkaXZpc2lvbi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHN3aW5nXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLCAnc3dpbmcnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zd2luZ0Ftb3VudDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGFtb3VudCkge1xuXHQgICAgICAgICAgICAvL3NjYWxlIHRoZSB2YWx1ZXMgdG8gYSBub3JtYWwgcmFuZ2Vcblx0ICAgICAgICAgICAgdGhpcy5fc3dpbmdBbW91bnQgPSBhbW91bnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU2V0IHRoZSBzdWJkaXZpc2lvbiB3aGljaCB0aGUgc3dpbmcgd2lsbCBiZSBhcHBsaWVkIHRvLlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhbiA4dGggbm90ZS4gVmFsdWUgbXVzdCBiZSBsZXNzXG5cdFx0ICogIHRoYW4gYSBxdWFydGVyIG5vdGUuXG5cdFx0ICpcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKiAgQG5hbWUgc3dpbmdTdWJkaXZpc2lvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3N3aW5nU3ViZGl2aXNpb24nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRpbWUodGhpcy5fc3dpbmdUaWNrcywgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzdWJkaXZpc2lvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9zd2luZ1RpY2tzID0gdGhpcy50b1RpY2tzKHN1YmRpdmlzaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgVHJhbnNwb3J0J3MgcG9zaXRpb24gaW4gQmFyczpCZWF0czpTaXh0ZWVudGhzLlxuXHRcdCAqICBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGp1bXAgdG8gdGhhdCBwb3NpdGlvbiByaWdodCBhd2F5LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtCYXJzQmVhdHNTaXh0ZWVudGhzfVxuXHRcdCAqICBAbmFtZSBwb3NpdGlvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3Bvc2l0aW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMudGlja3MsICdpJykudG9CYXJzQmVhdHNTaXh0ZWVudGhzKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3MocHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICB0aGlzLnRpY2tzID0gdGlja3M7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIFRyYW5zcG9ydCdzIHBvc2l0aW9uIGluIHNlY29uZHNcblx0XHQgKiAgU2V0dGluZyB0aGUgdmFsdWUgd2lsbCBqdW1wIHRvIHRoYXQgcG9zaXRpb24gcmlnaHQgYXdheS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVHJhbnNwb3J0I1xuXHRcdCAqICBAdHlwZSB7U2Vjb25kc31cblx0XHQgKiAgQG5hbWUgc2Vjb25kc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3NlY29uZHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy50aWNrcywgJ2knKS50b1NlY29uZHMoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2dyZXNzKSB7XG5cdCAgICAgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyhwcm9ncmVzcyk7XG5cdCAgICAgICAgICAgIHRoaXMudGlja3MgPSB0aWNrcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgVHJhbnNwb3J0J3MgbG9vcCBwb3NpdGlvbiBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUuIEFsd2F5c1xuXHRcdCAqICByZXR1cm5zIDAgaWYgdGhlIHRyYW5zcG9ydCBpZiBsb29wIGlzIG5vdCB0cnVlLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEBuYW1lIHByb2dyZXNzXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMubG9vcCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnRpY2tzIC0gdGhpcy5fbG9vcFN0YXJ0KSAvICh0aGlzLl9sb29wRW5kIC0gdGhpcy5fbG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRyYW5zcG9ydHMgY3VycmVudCB0aWNrIHBvc2l0aW9uLlxuXHRcdCAqXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlRyYW5zcG9ydCNcblx0XHQgKiAgQHR5cGUge1RpY2tzfVxuXHRcdCAqICBAbmFtZSB0aWNrc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ3RpY2tzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2sudGlja3M7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9jbG9jay50aWNrcyAhPT0gdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgICAgICAvL3N0b3AgZXZlcnl0aGluZyBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydFxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5vdyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvY2sudGlja3MgPSB0O1xuXHQgICAgICAgICAgICAgICAgICAgIC8vcmVzdGFydCBpdCB3aXRoIHRoZSBuZXcgdGltZVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBub3csIHRoaXMuc2Vjb25kcyk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb2NrLnRpY2tzID0gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFB1bHNlcyBQZXIgUXVhcnRlciBub3RlLiBUaGlzIGlzIHRoZSBzbWFsbGVzdCByZXNvbHV0aW9uXG5cdFx0ICogIHRoZSBUcmFuc3BvcnQgdGltaW5nIHN1cHBvcnRzLiBUaGlzIHNob3VsZCBiZSBzZXQgb25jZVxuXHRcdCAqICBvbiBpbml0aWFsaXphdGlvbiBhbmQgbm90IHNldCBhZ2Fpbi4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxuXHRcdCAqICBhZnRlciBvdGhlciBvYmplY3RzIGhhdmUgYmVlbiBjcmVhdGVkIGNhbiBjYXVzZSBwcm9ibGVtcy5cblx0XHQgKlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5UcmFuc3BvcnQjXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIFBQUVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZSwgJ1BQUScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BwcTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBwcSkge1xuXHQgICAgICAgICAgICB2YXIgYnBtID0gdGhpcy5icG0udmFsdWU7XG5cdCAgICAgICAgICAgIHRoaXMuX3BwcSA9IHBwcTtcblx0ICAgICAgICAgICAgdGhpcy5icG0udmFsdWUgPSBicG07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ29udmVydCBmcm9tIEJQTSB0byBmcmVxdWVuY3kgKGZhY3RvcmluZyBpbiBQUFEpXG5cdFx0ICogIEBwYXJhbSAge0JQTX0gIGJwbSBUaGUgQlBNIHZhbHVlIHRvIGNvbnZlcnQgdG8gZnJlcXVlbmN5XG5cdFx0ICogIEByZXR1cm4gIHtGcmVxdWVuY3l9ICBUaGUgQlBNIGFzIGEgZnJlcXVlbmN5IHdpdGggUFBRIGZhY3RvcmVkIGluLlxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLl9mcm9tVW5pdHMgPSBmdW5jdGlvbiAoYnBtKSB7XG5cdCAgICAgICAgcmV0dXJuIDEgLyAoNjAgLyBicG0gLyB0aGlzLlBQUSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZnJvbSBmcmVxdWVuY3kgKHdpdGggUFBRKSBpbnRvIEJQTVxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9ICBmcmVxIFRoZSBjbG9ja3MgZnJlcXVlbmN5IHRvIGNvbnZlcnQgdG8gQlBNXG5cdFx0ICogIEByZXR1cm4gIHtCUE19ICBUaGUgZnJlcXVlbmN5IHZhbHVlIGFzIEJQTS5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0LnByb3RvdHlwZS5fdG9Vbml0cyA9IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgcmV0dXJuIGZyZXEgLyB0aGlzLlBQUSAqIDYwO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vXHRTWU5DSU5HXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgdGltZSBhbGlnbmVkIHRvIHRoZSBuZXh0IHN1YmRpdmlzaW9uXG5cdFx0ICogIG9mIHRoZSBUcmFuc3BvcnQuIElmIHRoZSBUcmFuc3BvcnQgaXMgbm90IHN0YXJ0ZWQsXG5cdFx0ICogIGl0IHdpbGwgcmV0dXJuIDAuXG5cdFx0ICogIE5vdGU6IHRoaXMgd2lsbCBub3Qgd29yayBwcmVjaXNlbHkgZHVyaW5nIHRlbXBvIHJhbXBzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgc3ViZGl2aXNpb24gIFRoZSBzdWJkaXZpc2lvbiB0byBxdWFudGl6ZSB0b1xuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfSAgVGhlIGNvbnRleHQgdGltZSBvZiB0aGUgbmV4dCBzdWJkaXZpc2lvbi5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydCgpOyAvL3RoZSB0cmFuc3BvcnQgbXVzdCBiZSBzdGFydGVkXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQubmV4dFN1YmRpdmlzaW9uKFwiNG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydC5wcm90b3R5cGUubmV4dFN1YmRpdmlzaW9uID0gZnVuY3Rpb24gKHN1YmRpdmlzaW9uKSB7XG5cdCAgICAgICAgc3ViZGl2aXNpb24gPSB0aGlzLnRvU2Vjb25kcyhzdWJkaXZpc2lvbik7XG5cdCAgICAgICAgLy9pZiB0aGUgdHJhbnNwb3J0J3Mgbm90IHN0YXJ0ZWQsIHJldHVybiAwXG5cdCAgICAgICAgdmFyIG5vdztcblx0ICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgIG5vdyA9IHRoaXMuX2Nsb2NrLl9uZXh0VGljaztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHRyYW5zcG9ydFBvcyA9IFRvbmUuVGltZSh0aGlzLnRpY2tzLCAnaScpO1xuXHQgICAgICAgIHZhciByZW1haW5pbmdUaW1lID0gc3ViZGl2aXNpb24gLSB0cmFuc3BvcnRQb3MgJSBzdWJkaXZpc2lvbjtcblx0ICAgICAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gMCkge1xuXHQgICAgICAgICAgICByZW1haW5pbmdUaW1lID0gc3ViZGl2aXNpb247XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBub3cgKyByZW1haW5pbmdUaW1lO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBdHRhY2hlcyB0aGUgc2lnbmFsIHRvIHRoZSB0ZW1wbyBjb250cm9sIHNpZ25hbCBzbyB0aGF0XG5cdFx0ICogIGFueSBjaGFuZ2VzIGluIHRoZSB0ZW1wbyB3aWxsIGNoYW5nZSB0aGUgc2lnbmFsIGluIHRoZSBzYW1lXG5cdFx0ICogIHJhdGlvLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuU2lnbmFsfSBzaWduYWxcblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSByYXRpbyBPcHRpb25hbGx5IHBhc3MgaW4gdGhlIHJhdGlvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMuIE90aGVyd2lzZSBpdCB3aWxsIGJlIGNvbXB1dGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWQgb24gdGhlaXIgY3VycmVudCB2YWx1ZXMuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnN5bmNTaWduYWwgPSBmdW5jdGlvbiAoc2lnbmFsLCByYXRpbykge1xuXHQgICAgICAgIGlmICghcmF0aW8pIHtcblx0ICAgICAgICAgICAgLy9nZXQgdGhlIHN5bmMgcmF0aW9cblx0ICAgICAgICAgICAgaWYgKHNpZ25hbC5fcGFyYW0udmFsdWUgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJhdGlvID0gc2lnbmFsLl9wYXJhbS52YWx1ZSAvIHRoaXMuYnBtLl9wYXJhbS52YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJhdGlvID0gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmF0aW9TaWduYWwgPSBuZXcgVG9uZS5HYWluKHJhdGlvKTtcblx0ICAgICAgICB0aGlzLmJwbS5jaGFpbihyYXRpb1NpZ25hbCwgc2lnbmFsLl9wYXJhbSk7XG5cdCAgICAgICAgdGhpcy5fc3luY2VkU2lnbmFscy5wdXNoKHtcblx0ICAgICAgICAgICAgJ3JhdGlvJzogcmF0aW9TaWduYWwsXG5cdCAgICAgICAgICAgICdzaWduYWwnOiBzaWduYWwsXG5cdCAgICAgICAgICAgICdpbml0aWFsJzogc2lnbmFsLl9wYXJhbS52YWx1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHNpZ25hbC5fcGFyYW0udmFsdWUgPSAwO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBVbnN5bmNzIGEgcHJldmlvdXNseSBzeW5jZWQgc2lnbmFsIGZyb20gdGhlIHRyYW5zcG9ydCdzIGNvbnRyb2wuXG5cdFx0ICogIFNlZSBUb25lLlRyYW5zcG9ydC5zeW5jU2lnbmFsLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLlNpZ25hbH0gc2lnbmFsXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLnVuc3luY1NpZ25hbCA9IGZ1bmN0aW9uIChzaWduYWwpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fc3luY2VkU2lnbmFscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICAgICAgICB2YXIgc3luY2VkU2lnbmFsID0gdGhpcy5fc3luY2VkU2lnbmFsc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHN5bmNlZFNpZ25hbC5zaWduYWwgPT09IHNpZ25hbCkge1xuXHQgICAgICAgICAgICAgICAgc3luY2VkU2lnbmFsLnJhdGlvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgIHN5bmNlZFNpZ25hbC5zaWduYWwuX3BhcmFtLnZhbHVlID0gc3luY2VkU2lnbmFsLmluaXRpYWw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zeW5jZWRTaWduYWxzLnNwbGljZShpLCAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyYW5zcG9ydH0gdGhpc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FbWl0dGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2suZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnYnBtJyk7XG5cdCAgICAgICAgdGhpcy5icG0gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3RpbWVsaW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90aW1lbGluZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmVwZWF0ZWRFdmVudHMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3JlcGVhdGVkRXZlbnRzID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvL1x0SU5JVElBTElaQVRJT05cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIHZhciBUcmFuc3BvcnRDb25zdHJ1Y3RvciA9IFRvbmUuVHJhbnNwb3J0O1xuXHQgICAgVG9uZS5UcmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0Q29uc3RydWN0b3IoKTtcblx0ICAgIFRvbmUuQ29udGV4dC5vbignaW5pdCcsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNvbnRleHQuVHJhbnNwb3J0IGluc3RhbmNlb2YgVHJhbnNwb3J0Q29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQgPSBjb250ZXh0LlRyYW5zcG9ydDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydCA9IG5ldyBUcmFuc3BvcnRDb25zdHJ1Y3RvcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3N0b3JlIHRoZSBUcmFuc3BvcnQgb24gdGhlIGNvbnRleHQgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBsYXRlclxuXHQgICAgICAgIGNvbnRleHQuVHJhbnNwb3J0ID0gVG9uZS5UcmFuc3BvcnQ7XG5cdCAgICB9KTtcblx0ICAgIFRvbmUuQ29udGV4dC5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIGlmIChjb250ZXh0LlRyYW5zcG9ydCBpbnN0YW5jZW9mIFRyYW5zcG9ydENvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIGNvbnRleHQuVHJhbnNwb3J0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLlRyYW5zcG9ydDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVm9sdW1lIGlzIGEgc2ltcGxlIHZvbHVtZSBub2RlLCB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgdm9sdW1lIGZhZGVyLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFt2b2x1bWU9MF0gdGhlIGluaXRpYWwgdm9sdW1lXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHZvbCA9IG5ldyBUb25lLlZvbHVtZSgtMTIpO1xuXHRcdCAqIGluc3RydW1lbnQuY2hhaW4odm9sLCBUb25lLk1hc3Rlcik7XG5cdFx0ICovXG5cdCAgICBUb25lLlZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3ZvbHVtZSddLCBUb25lLlZvbHVtZSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHRoZSBvdXRwdXQgbm9kZVxuXHRcdFx0ICogQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy52b2x1bWUsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdW5tdXRlZCB2b2x1bWVcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91bm11dGVkVm9sdW1lID0gb3B0aW9ucy52b2x1bWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZvbHVtZSBjb250cm9sIGluIGRlY2liZWxzLlxuXHRcdFx0ICogIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMub3V0cHV0LmdhaW47XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBtdXRlIGluaXRpYWxseVxuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlZvbHVtZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Wb2x1bWUuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Wb2x1bWUjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiB2b2x1bWUubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Wb2x1bWUucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudm9sdW1lLnZhbHVlID09PSAtSW5maW5pdHk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5tdXRlICYmIG11dGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3VubXV0ZWRWb2x1bWUgPSB0aGlzLnZvbHVtZS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgIC8vbWF5YmUgaXQgc2hvdWxkIHJhbXAgaGVyZT9cblx0ICAgICAgICAgICAgICAgIHRoaXMudm9sdW1lLnZhbHVlID0gLUluZmluaXR5O1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubXV0ZSAmJiAhbXV0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy52b2x1bWUudmFsdWUgPSB0aGlzLl91bm11dGVkVm9sdW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuVm9sdW1lfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlZvbHVtZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmlucHV0LmRpc3Bvc2UoKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLnZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlZvbHVtZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBBIHNpbmdsZSBtYXN0ZXIgb3V0cHV0IHdoaWNoIGlzIGNvbm5lY3RlZCB0byB0aGVcblx0XHQgKiAgICAgICAgICBBdWRpb0Rlc3RpbmF0aW9uTm9kZSAoYWthIHlvdXIgc3BlYWtlcnMpLlxuXHRcdCAqICAgICAgICAgIEl0IHByb3ZpZGVzIHVzZWZ1bCBjb252ZW5pZW5jZXMgc3VjaCBhcyB0aGUgYWJpbGl0eVxuXHRcdCAqICAgICAgICAgIHRvIHNldCB0aGUgdm9sdW1lIGFuZCBtdXRlIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uXG5cdFx0ICogICAgICAgICAgSXQgYWxzbyBnaXZlcyB5b3UgdGhlIGFiaWxpdHkgdG8gYXBwbHkgbWFzdGVyIGVmZmVjdHMgdG8geW91ciBhcHBsaWNhdGlvbi5cblx0XHQgKiAgICAgICAgICA8YnI+PGJyPlxuXHRcdCAqICAgICAgICAgIExpa2UgVG9uZS5UcmFuc3BvcnQsIEEgc2luZ2xlIFRvbmUuTWFzdGVyIGlzIGNyZWF0ZWRcblx0XHQgKiAgICAgICAgICBvbiBpbml0aWFsaXphdGlvbiBhbmQgeW91IGRvIG5vdCBuZWVkIHRvIGV4cGxpY2l0bHkgY29uc3RydWN0IG9uZS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBzaW5nbGV0b25cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3RoZSBhdWRpbyB3aWxsIGdvIGZyb20gdGhlIG9zY2lsbGF0b3IgdG8gdGhlIHNwZWFrZXJzXG5cdFx0ICogb3NjaWxsYXRvci5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHQgKiAvL2EgY29udmVuaWVuY2UgZm9yIGNvbm5lY3RpbmcgdG8gdGhlIG1hc3RlciBvdXRwdXQgaXMgYWxzbyBwcm92aWRlZDpcblx0XHQgKiBvc2NpbGxhdG9yLnRvTWFzdGVyKCk7XG5cdFx0ICogLy90aGUgYWJvdmUgdHdvIGV4YW1wbGVzIGFyZSBlcXVpdmFsZW50LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5NYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBUb25lLmdldENvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHByaXZhdGUgdm9sdW1lIG5vZGVcblx0XHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUoKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG1hc3RlciBvdXRwdXQuXG5cdFx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICAgICAgdGhpcy5pbnB1dC5jaGFpbih0aGlzLm91dHB1dCwgdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWFzdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLk1hc3Rlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk1hc3RlciNcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAvL211dGUgdGhlIG91dHB1dFxuXHRcdCAqIFRvbmUuTWFzdGVyLm11dGUgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWFzdGVyLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIG1hc3RlciBlZmZlY3RzIGNoYWluLiBOT1RFOiB0aGlzIHdpbGwgZGlzY29ubmVjdCBhbnkgbm9kZXMgd2hpY2ggd2VyZSBwcmV2aW91c2x5XG5cdFx0ICogIGNoYWluZWQgaW4gdGhlIG1hc3RlciBlZmZlY3RzIGNoYWluLlxuXHRcdCAqICBAcGFyYW0ge0F1ZGlvTm9kZXxUb25lfSBhcmdzLi4uIEFsbCBhcmd1bWVudHMgd2lsbCBiZSBjb25uZWN0ZWQgaW4gYSByb3dcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIE1hc3RlciB3aWxsIGJlIHJvdXRlZCB0aHJvdWdoIGl0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NYXN0ZXJ9ICB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9zb21lIG92ZXJhbGwgY29tcHJlc3Npb24gdG8ga2VlcCB0aGUgbGV2ZWxzIGluIGNoZWNrXG5cdFx0ICogdmFyIG1hc3RlckNvbXByZXNzb3IgPSBuZXcgVG9uZS5Db21wcmVzc29yKHtcblx0XHQgKiBcdFwidGhyZXNob2xkXCIgOiAtNixcblx0XHQgKiBcdFwicmF0aW9cIiA6IDMsXG5cdFx0ICogXHRcImF0dGFja1wiIDogMC41LFxuXHRcdCAqIFx0XCJyZWxlYXNlXCIgOiAwLjFcblx0XHQgKiB9KTtcblx0XHQgKiAvL2dpdmUgYSBsaXR0bGUgYm9vc3QgdG8gdGhlIGxvd3Ncblx0XHQgKiB2YXIgbG93QnVtcCA9IG5ldyBUb25lLkZpbHRlcigyMDAsIFwibG93c2hlbGZcIik7XG5cdFx0ICogLy9yb3V0ZSBldmVyeXRoaW5nIHRocm91Z2ggdGhlIGZpbHRlclxuXHRcdCAqIC8vYW5kIGNvbXByZXNzb3IgYmVmb3JlIGdvaW5nIHRvIHRoZSBzcGVha2Vyc1xuXHRcdCAqIFRvbmUuTWFzdGVyLmNoYWluKGxvd0J1bXAsIG1hc3RlckNvbXByZXNzb3IpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NYXN0ZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY2hhaW4uYXBwbHkodGhpcy5pbnB1dCwgYXJndW1lbnRzKTtcblx0ICAgICAgICBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NYXN0ZXJ9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1hc3Rlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCd2b2x1bWUnKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9cdEFVR01FTlQgVE9ORSdzIFBST1RPVFlQRVxuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvKipcblx0XHQgKiAgQ29ubmVjdCAndGhpcycgdG8gdGhlIG1hc3RlciBvdXRwdXQuIFNob3J0aGFuZCBmb3IgdGhpcy5jb25uZWN0KFRvbmUuTWFzdGVyKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdWRpb05vZGV9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2Nvbm5lY3QgYW4gb3NjaWxsYXRvciB0byB0aGUgbWFzdGVyIG91dHB1dFxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS50b01hc3RlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIGlmICh3aW5kb3cuQXVkaW9Ob2RlKSB7XG5cdCAgICAgICAgLy8gQWxzbyBhdWdtZW50IEF1ZGlvTm9kZSdzIHByb3RvdHlwZSB0byBpbmNsdWRlIHRvTWFzdGVyIGFzIGEgY29udmVuaWVuY2Vcblx0ICAgICAgICBBdWRpb05vZGUucHJvdG90eXBlLnRvTWFzdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIGluaXRpYWxpemUgdGhlIG1vZHVsZSBhbmQgbGlzdGVuIGZvciBuZXcgYXVkaW8gY29udGV4dHNcblx0XHQgKi9cblx0ICAgIHZhciBNYXN0ZXJDb25zdHJ1Y3RvciA9IFRvbmUuTWFzdGVyO1xuXHQgICAgVG9uZS5NYXN0ZXIgPSBuZXcgTWFzdGVyQ29uc3RydWN0b3IoKTtcblx0ICAgIFRvbmUuQ29udGV4dC5vbignaW5pdCcsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgLy8gaWYgaXQgYWxyZWFkeSBleGlzdHMsIGp1c3QgcmVzdG9yZSBpdFxuXHQgICAgICAgIGlmIChjb250ZXh0Lk1hc3RlciBpbnN0YW5jZW9mIE1hc3RlckNvbnN0cnVjdG9yKSB7XG5cdCAgICAgICAgICAgIFRvbmUuTWFzdGVyID0gY29udGV4dC5NYXN0ZXI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgVG9uZS5NYXN0ZXIgPSBuZXcgTWFzdGVyQ29uc3RydWN0b3IoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29udGV4dC5NYXN0ZXIgPSBUb25lLk1hc3Rlcjtcblx0ICAgIH0pO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKGNvbnRleHQuTWFzdGVyIGluc3RhbmNlb2YgTWFzdGVyQ29uc3RydWN0b3IpIHtcblx0ICAgICAgICAgICAgY29udGV4dC5NYXN0ZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmUuTWFzdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMuIFNvdXJjZXMgaGF2ZSBzdGFydC9zdG9wIG1ldGhvZHNcblx0XHQgKiAgICAgICAgICBhbmQgdGhlIGFiaWxpdHkgdG8gYmUgc3luY2VkIHRvIHRoZVxuXHRcdCAqICAgICAgICAgIHN0YXJ0L3N0b3Agb2YgVG9uZS5UcmFuc3BvcnQuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL011bHRpcGxlIHN0YXRlIGNoYW5nZSBldmVudHMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIsXG5cdFx0ICogLy9idXQgbXVzdCBiZSBzZXQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIHdpdGggYXNjZW5kaW5nIHRpbWVzXG5cdFx0ICpcblx0XHQgKiAvLyBPS1xuXHRcdCAqIHN0YXRlLnN0YXJ0KCkuc3RvcChcIiswLjJcIik7XG5cdFx0ICogLy8gQU5EXG5cdFx0ICogc3RhdGUuc3RhcnQoKS5zdG9wKFwiKzAuMlwiKS5zdGFydChcIiswLjRcIikuc3RvcChcIiswLjdcIilcblx0XHQgKlxuXHRcdCAqIC8vIEJBRFxuXHRcdCAqIHN0YXRlLnN0b3AoXCIrMC4yXCIpLnN0YXJ0KCk7XG5cdFx0ICogLy8gT1Jcblx0XHQgKiBzdGF0ZS5zdGFydChcIiswLjNcIikuc3RvcChcIiswLjJcIik7XG5cdFx0ICpcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuU291cmNlLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogc291cmNlLnZvbHVtZS52YWx1ZSA9IC02O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCd2b2x1bWUnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFx0S2VlcCB0cmFjayBvZiB0aGUgc2NoZWR1bGVkIHN0YXRlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlRpbWVsaW5lU3RhdGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IFRvbmUuVGltZWxpbmVTdGF0ZShUb25lLlN0YXRlLlN0b3BwZWQpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLm1lbW9yeSA9IDEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzeW5jZWQgYHN0YXJ0YCBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHRcdCAqICBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEtlZXAgdHJhY2sgb2YgYWxsIG9mIHRoZSBzY2hlZHVsZWQgZXZlbnQgaWRzXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NoZWR1bGVkID0gW107XG5cdCAgICAgICAgLy9tYWtlIHRoZSBvdXRwdXQgZXhwbGljaXRseSBzdGVyZW9cblx0ICAgICAgICB0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnQgPSAyO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIC8vbXV0ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Tb3VyY2UsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBzb3VyY2UsIGVpdGhlciBcInN0YXJ0ZWRcIiBvciBcInN0b3BwZWRcIi5cblx0XHQgKiAgQHR5cGUge1RvbmUuU3RhdGV9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb3VyY2UucHJvdG90eXBlLCAnc3RhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChUb25lLlRyYW5zcG9ydC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKFRvbmUuVHJhbnNwb3J0LnNlY29uZHMpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5TdGF0ZS5TdG9wcGVkO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRoaXMubm93KCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBNdXRlIHRoZSBvdXRwdXQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU291cmNlI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIG11dGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vbXV0ZSB0aGUgb3V0cHV0XG5cdFx0ICogc291cmNlLm11dGUgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU291cmNlLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy9vdmVyd3JpdGUgdGhlc2UgZnVuY3Rpb25zXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuX3N0YXJ0ID0gVG9uZS5ub09wO1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLl9zdG9wID0gVG9uZS5ub09wO1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBzb3VyY2UgYXQgdGhlIHNwZWNpZmllZCB0aW1lLiBJZiBubyB0aW1lIGlzIGdpdmVuLFxuXHRcdCAqICBzdGFydCB0aGUgc291cmNlIG5vdy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBzb3VyY2Ugc2hvdWxkIGJlIHN0YXJ0ZWQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHNvdXJjZS5zdGFydChcIiswLjVcIik7IC8vc3RhcnRzIHRoZSBzb3VyY2UgMC41IHNlY29uZHMgZnJvbSBub3dcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih0aW1lKSAmJiB0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgdGltZSA9IFRvbmUuVHJhbnNwb3J0LnNlY29uZHM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2lmIGl0J3Mgc3RhcnRlZCwgc3RvcCBpdCBhbmQgcmVzdGFydCBpdFxuXHQgICAgICAgIGlmICghdGhpcy5yZXRyaWdnZXIgJiYgdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICB0aGlzLnN0b3AodGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3N0YXRlLnNldFN0YXRlQXRUaW1lKFRvbmUuU3RhdGUuU3RhcnRlZCwgdGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICAvLyBhZGQgdGhlIG9mZnNldCB0aW1lIHRvIHRoZSBldmVudFxuXHQgICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXQodGltZSk7XG5cdCAgICAgICAgICAgIGV2ZW50Lm9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIDApO1xuXHQgICAgICAgICAgICBldmVudC5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHQgICAgICAgICAgICB2YXIgc2NoZWQgPSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbiAodCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQodCwgb2Zmc2V0LCBkdXJhdGlvbik7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgdGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZC5wdXNoKHNjaGVkKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgc291cmNlIGF0IHRoZSBzcGVjaWZpZWQgdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbixcblx0XHQgKiAgc3RvcCB0aGUgc291cmNlIG5vdy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBzb3VyY2Ugc2hvdWxkIGJlIHN0b3BwZWQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHNvdXJjZS5zdG9wKCk7IC8vIHN0b3BzIHRoZSBzb3VyY2UgaW1tZWRpYXRlbHlcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc1VuZGVmKHRpbWUpICYmIHRoaXMuX3N5bmNlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnQuc2Vjb25kcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHQgICAgICAgIGlmICghdGhpcy5fc3luY2VkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgc2NoZWQgPSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSh0aGlzLl9zdG9wLmJpbmQodGhpcyksIHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWQucHVzaChzY2hlZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTeW5jIHRoZSBzb3VyY2UgdG8gdGhlIFRyYW5zcG9ydCBzbyB0aGF0IGFsbCBzdWJzZXF1ZW50XG5cdFx0ICogIGNhbGxzIHRvIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgc3luY2VkIHRvIHRoZSBUcmFuc3BvcnRUaW1lXG5cdFx0ICogIGluc3RlYWQgb2YgdGhlIEF1ZGlvQ29udGV4dCB0aW1lLlxuXHRcdCAqXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vc3luYyB0aGUgc291cmNlIHNvIHRoYXQgaXQgcGxheXMgYmV0d2VlbiAwIGFuZCAwLjMgb24gdGhlIFRyYW5zcG9ydCdzIHRpbWVsaW5lXG5cdFx0ICogc291cmNlLnN5bmMoKS5zdGFydCgwKS5zdG9wKDAuMyk7XG5cdFx0ICogLy9zdGFydCB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LnN0YXJ0KCk7XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3N0YXJ0IHRoZSB0cmFuc3BvcnQgd2l0aCBhbiBvZmZzZXQgYW5kIHRoZSBzeW5jJ2VkIHNvdXJjZXNcblx0XHQgKiAvL3dpbGwgc3RhcnQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cblx0XHQgKiBzb3VyY2Uuc3luYygpLnN0YXJ0KDAuMSk7XG5cdFx0ICogLy90aGUgc291cmNlIHdpbGwgYmUgaW52b2tlZCB3aXRoIGFuIG9mZnNldCBvZiAwLjRcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zdGFydChcIiswLjVcIiwgMC41KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZCA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5fc3luY2VkU3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHBsYXliYWNrIHN0YXRlIGF0IHRoYXQgdGltZVxuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXRlRXZlbnQgPSB0aGlzLl9zdGF0ZS5nZXQob2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIC8vIGxpc3RlbiBmb3Igc3RhcnQgZXZlbnRzIHdoaWNoIG1heSBvY2N1ciBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzeW5jJ2VkIHRpbWVcblx0ICAgICAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50ICYmIHN0YXRlRXZlbnQuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCAmJiBzdGF0ZUV2ZW50LnRpbWUgIT09IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgb2Zmc2V0XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0IC0gdGhpcy50b1NlY29uZHMoc3RhdGVFdmVudC50aW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlRXZlbnQuZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhzdGF0ZUV2ZW50LmR1cmF0aW9uKSAtIHN0YXJ0T2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCB0aGlzLnRvU2Vjb25kcyhzdGF0ZUV2ZW50Lm9mZnNldCkgKyBzdGFydE9mZnNldCwgZHVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N5bmNlZFN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQuc2Vjb25kcykgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RvcCh0aW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKTtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5vbignc3RhcnQgbG9vcFN0YXJ0JywgdGhpcy5fc3luY2VkU3RhcnQpO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9uKCdzdG9wIHBhdXNlIGxvb3BFbmQnLCB0aGlzLl9zeW5jZWRTdG9wKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVW5zeW5jIHRoZSBzb3VyY2UgdG8gdGhlIFRyYW5zcG9ydC4gU2VlIFRvbmUuU291cmNlLnN5bmNcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU291cmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQub2ZmKCdzdG9wIHBhdXNlIGxvb3BFbmQnLCB0aGlzLl9zeW5jZWRTdG9wKTtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQub2ZmKCdzdGFydCBsb29wU3RhcnQnLCB0aGlzLl9zeW5jZWRTdGFydCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlO1xuXHQgICAgICAgIC8vIGNsZWFyIGFsbCBvZiB0aGUgc2NoZWR1bGVkIGlkc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2NoZWR1bGVkLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX3NjaGVkdWxlZFtpXTtcblx0ICAgICAgICAgICAgVG9uZS5UcmFuc3BvcnQuY2xlYXIoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9zY2hlZHVsZWQgPSBbXTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5jYW5jZWwoMCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICpcdENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlNvdXJjZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Tb3VyY2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIE9zY2lsbGF0b3JOb2RlIHNoaW1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuT3NjaWxsYXRvck5vZGUgJiYgIU9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdGFydCkge1xuXHQgICAgICAgIE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zdGFydCA9IE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5ub3RlT247XG5cdCAgICAgICAgT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnN0b3AgPSBPc2NpbGxhdG9yTm9kZS5wcm90b3R5cGUubm90ZU9mZjtcblx0ICAgICAgICBpZiAoIU9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zZXRQZXJpb2RpY1dhdmUpIHtcblx0ICAgICAgICAgICAgT3NjaWxsYXRvck5vZGUucHJvdG90eXBlLnNldFBlcmlvZGljV2F2ZSA9IE9zY2lsbGF0b3JOb2RlLnByb3RvdHlwZS5zZXRXYXZlVGFibGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUpIHtcblx0ICAgICAgICAgICAgQXVkaW9Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVQZXJpb2RpY1dhdmUgPSBBdWRpb0NvbnRleHQucHJvdG90eXBlLmNyZWF0ZVdhdmVUYWJsZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuT3NjaWxsYXRvciBzdXBwb3J0cyBhIG51bWJlciBvZiBmZWF0dXJlcyBpbmNsdWRpbmdcblx0XHQgKiAgICAgICAgIHBoYXNlIHJvdGF0aW9uLCBtdWx0aXBsZSBvc2NpbGxhdG9yIHR5cGVzIChzZWUgVG9uZS5Pc2NpbGxhdG9yLnR5cGUpLFxuXHRcdCAqICAgICAgICAgYW5kIFRyYW5zcG9ydCBzeW5jaW5nIChzZWUgVG9uZS5Pc2NpbGxhdG9yLnN5bmNGcmVxdWVuY3kpLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZnJlcXVlbmN5XSBTdGFydGluZyBmcmVxdWVuY3lcblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSBUaGUgb3NjaWxsYXRvciB0eXBlLiBSZWFkIG1vcmUgYWJvdXQgdHlwZSBiZWxvdy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL21ha2UgYW5kIHN0YXJ0IGEgNDQwaHogc2luZSB0b25lXG5cdFx0ICogdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoNDQwLCBcInNpbmVcIikudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWFpbiBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge09zY2lsbGF0b3JOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBjb250cm9sIHNpZ25hbC5cblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBlcmlvZGljIHdhdmVcblx0XHRcdCAqICBAdHlwZSB7UGVyaW9kaWNXYXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl93YXZlID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFydGlhbHMgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMucGFydGlhbHMsIFsxXSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgYmV0d2VlbiAwIC0gMzYwXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge3N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG5cdCAgICAgICAgLy9zZXR1cFxuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnBoYXNlID0gdGhpcy5fcGhhc2U7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnc2luZScsXG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdwYXJ0aWFscyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBPc2NpbGxhdG9yIHR5cGVzXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IuVHlwZSA9IHtcblx0ICAgICAgICBTaW5lOiAnc2luZScsXG5cdCAgICAgICAgVHJpYW5nbGU6ICd0cmlhbmdsZScsXG5cdCAgICAgICAgU2F3dG9vdGg6ICdzYXd0b290aCcsXG5cdCAgICAgICAgU3F1YXJlOiAnc3F1YXJlJyxcblx0ICAgICAgICBDdXN0b206ICdjdXN0b20nXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAvL25ldyBvc2NpbGxhdG9yIHdpdGggcHJldmlvdXMgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IHRoaXMuY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5fd2F2ZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBjb250cm9sIHNpZ25hbCB0byB0aGUgb3NjaWxsYXRvciBmcmVxdWVuY3kgJiBkZXR1bmVcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgVG9uZS5pc1Bhc3QodGltZSk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvcikge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIFRvbmUuaXNQYXN0KHRpbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3luYyB0aGUgc2lnbmFsIHRvIHRoZSBUcmFuc3BvcnQncyBicG0uIEFueSBjaGFuZ2VzIHRvIHRoZSB0cmFuc3BvcnRzIGJwbSxcblx0XHQgKiAgd2lsbCBhbHNvIGFmZmVjdCB0aGUgb3NjaWxsYXRvcnMgZnJlcXVlbmN5LlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuYnBtLnZhbHVlID0gMTIwO1xuXHRcdCAqIG9zYy5mcmVxdWVuY3kudmFsdWUgPSA0NDA7XG5cdFx0ICogLy90aGUgcmF0aW9uIGJldHdlZW4gdGhlIGJwbSBhbmQgdGhlIGZyZXF1ZW5jeSB3aWxsIGJlIG1haW50YWluZWRcblx0XHQgKiBvc2Muc3luY0ZyZXF1ZW5jeSgpO1xuXHRcdCAqIFRvbmUuVHJhbnNwb3J0LmJwbS52YWx1ZSA9IDI0MDtcblx0XHQgKiAvLyB0aGUgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yIGlzIGRvdWJsZWQgdG8gODgwXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLnN5bmNGcmVxdWVuY3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5UcmFuc3BvcnQuc3luY1NpZ25hbCh0aGlzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFVuc3luYyB0aGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeSBmcm9tIHRoZSBUcmFuc3BvcnQuXG5cdFx0ICogIFNlZSBUb25lLk9zY2lsbGF0b3Iuc3luY0ZyZXF1ZW5jeVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLnVuc3luY0ZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC51bnN5bmNTaWduYWwodGhpcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yOiBlaXRoZXIgc2luZSwgc3F1YXJlLCB0cmlhbmdsZSwgb3Igc2F3dG9vdGguIEFsc28gY2FwYWJsZSBvZlxuXHRcdCAqIHNldHRpbmcgdGhlIGZpcnN0IHggbnVtYmVyIG9mIHBhcnRpYWxzIG9mIHRoZSBvc2NpbGxhdG9yLiBGb3IgZXhhbXBsZTogXCJzaW5lNFwiIHdvdWxkXG5cdFx0ICogc2V0IGJlIHRoZSBmaXJzdCA0IHBhcnRpYWxzIG9mIHRoZSBzaW5lIHdhdmUgYW5kIFwidHJpYW5nbGU4XCIgd291bGQgc2V0IHRoZSBmaXJzdFxuXHRcdCAqIDggcGFydGlhbHMgb2YgdGhlIHRyaWFuZ2xlIHdhdmUuXG5cdFx0ICogPGJyPjxicj5cblx0XHQgKiBVc2VzIFBlcmlvZGljV2F2ZSBpbnRlcm5hbGx5IGV2ZW4gZm9yIG5hdGl2ZSB0eXBlcyBzbyB0aGF0IGl0IGNhbiBzZXQgdGhlIHBoYXNlLlxuXHRcdCAqIFBlcmlvZGljV2F2ZSBlcXVhdGlvbnMgYXJlIGZyb20gdGhlXG5cdFx0ICogW1dlYmtpdCBXZWIgQXVkaW8gaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vY29kZXNlYXJjaCNjaHJvbWl1bS9zcmMvdGhpcmRfcGFydHkvV2ViS2l0L1NvdXJjZS9tb2R1bGVzL3dlYmF1ZGlvL1BlcmlvZGljV2F2ZS5jcHAmc3E9cGFja2FnZTpjaHJvbWl1bSkuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9zZXQgaXQgdG8gYSBzcXVhcmUgd2F2ZVxuXHRcdCAqIG9zYy50eXBlID0gXCJzcXVhcmVcIjtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vc2V0IHRoZSBmaXJzdCA2IHBhcnRpYWxzIG9mIGEgc2F3dG9vdGggd2F2ZVxuXHRcdCAqIG9zYy50eXBlID0gXCJzYXd0b290aDZcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHZhciBjb2VmcyA9IHRoaXMuX2dldFJlYWxJbWFnaW5hcnkodHlwZSwgdGhpcy5fcGhhc2UpO1xuXHQgICAgICAgICAgICB2YXIgcGVyaW9kaWNXYXZlID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBlcmlvZGljV2F2ZShjb2Vmc1swXSwgY29lZnNbMV0pO1xuXHQgICAgICAgICAgICB0aGlzLl93YXZlID0gcGVyaW9kaWNXYXZlO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zZXRQZXJpb2RpY1dhdmUodGhpcy5fd2F2ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgYmFzZWRcblx0XHQgKiAgb24gdGhlIG9zY2lsbGF0b3IgdHlwZS5cblx0XHQgKiAgQHJldHVybnMge0FycmF5fSBbcmVhbCwgaW1hZ2luYXJ5XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Pc2NpbGxhdG9yLnByb3RvdHlwZS5fZ2V0UmVhbEltYWdpbmFyeSA9IGZ1bmN0aW9uICh0eXBlLCBwaGFzZSkge1xuXHQgICAgICAgIHZhciBmZnRTaXplID0gNDA5Njtcblx0ICAgICAgICB2YXIgcGVyaW9kaWNXYXZlU2l6ZSA9IGZmdFNpemUgLyAyO1xuXHQgICAgICAgIHZhciByZWFsID0gbmV3IEZsb2F0MzJBcnJheShwZXJpb2RpY1dhdmVTaXplKTtcblx0ICAgICAgICB2YXIgaW1hZyA9IG5ldyBGbG9hdDMyQXJyYXkocGVyaW9kaWNXYXZlU2l6ZSk7XG5cdCAgICAgICAgdmFyIHBhcnRpYWxDb3VudCA9IDE7XG5cdCAgICAgICAgaWYgKHR5cGUgPT09IFRvbmUuT3NjaWxsYXRvci5UeXBlLkN1c3RvbSkge1xuXHQgICAgICAgICAgICBwYXJ0aWFsQ291bnQgPSB0aGlzLl9wYXJ0aWFscy5sZW5ndGggKyAxO1xuXHQgICAgICAgICAgICBwZXJpb2RpY1dhdmVTaXplID0gcGFydGlhbENvdW50O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gL14oc2luZXx0cmlhbmdsZXxzcXVhcmV8c2F3dG9vdGgpKFxcZCspJC8uZXhlYyh0eXBlKTtcblx0ICAgICAgICAgICAgaWYgKHBhcnRpYWwpIHtcblx0ICAgICAgICAgICAgICAgIHBhcnRpYWxDb3VudCA9IHBhcnNlSW50KHBhcnRpYWxbMl0pICsgMTtcblx0ICAgICAgICAgICAgICAgIHR5cGUgPSBwYXJ0aWFsWzFdO1xuXHQgICAgICAgICAgICAgICAgcGFydGlhbENvdW50ID0gTWF0aC5tYXgocGFydGlhbENvdW50LCAyKTtcblx0ICAgICAgICAgICAgICAgIHBlcmlvZGljV2F2ZVNpemUgPSBwYXJ0aWFsQ291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIgbiA9IDE7IG4gPCBwZXJpb2RpY1dhdmVTaXplOyArK24pIHtcblx0ICAgICAgICAgICAgdmFyIHBpRmFjdG9yID0gMiAvIChuICogTWF0aC5QSSk7XG5cdCAgICAgICAgICAgIHZhciBiO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5TaW5lOlxuXHQgICAgICAgICAgICAgICAgYiA9IG4gPD0gcGFydGlhbENvdW50ID8gMSA6IDA7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBUb25lLk9zY2lsbGF0b3IuVHlwZS5TcXVhcmU6XG5cdCAgICAgICAgICAgICAgICBiID0gbiAmIDEgPyAyICogcGlGYWN0b3IgOiAwO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5Pc2NpbGxhdG9yLlR5cGUuU2F3dG9vdGg6XG5cdCAgICAgICAgICAgICAgICBiID0gcGlGYWN0b3IgKiAobiAmIDEgPyAxIDogLTEpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5Pc2NpbGxhdG9yLlR5cGUuVHJpYW5nbGU6XG5cdCAgICAgICAgICAgICAgICBpZiAobiAmIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gMiAqIChwaUZhY3RvciAqIHBpRmFjdG9yKSAqIChuIC0gMSA+PiAxICYgMSA/IC0xIDogMSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGIgPSAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tOlxuXHQgICAgICAgICAgICAgICAgYiA9IHRoaXMuX3BhcnRpYWxzW24gLSAxXTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9uZS5Pc2NpbGxhdG9yOiBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYiAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgcmVhbFtuXSA9IC1iICogTWF0aC5zaW4ocGhhc2UgKiBuKTtcblx0ICAgICAgICAgICAgICAgIGltYWdbbl0gPSBiICogTWF0aC5jb3MocGhhc2UgKiBuKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJlYWxbbl0gPSAwO1xuXHQgICAgICAgICAgICAgICAgaW1hZ1tuXSA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgcmVhbCxcblx0ICAgICAgICAgICAgaW1hZ1xuXHQgICAgICAgIF07XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbXB1dGUgdGhlIGludmVyc2UgRkZUIGZvciBhIGdpdmVuIHBoYXNlLlxuXHRcdCAqICBAcGFyYW0gIHtGbG9hdDMyQXJyYXl9ICByZWFsXG5cdFx0ICogIEBwYXJhbSAge0Zsb2F0MzJBcnJheX0gIGltYWdcblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBwaGFzZVxuXHRcdCAqICBAcmV0dXJuICB7QXVkaW9SYW5nZX1cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuX2ludmVyc2VGRlQgPSBmdW5jdGlvbiAocmVhbCwgaW1hZywgcGhhc2UpIHtcblx0ICAgICAgICB2YXIgc3VtID0gMDtcblx0ICAgICAgICB2YXIgbGVuID0gcmVhbC5sZW5ndGg7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICBzdW0gKz0gcmVhbFtpXSAqIE1hdGguY29zKGkgKiBwaGFzZSkgKyBpbWFnW2ldICogTWF0aC5zaW4oaSAqIHBoYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHN1bTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgb3NjaWxsYXRvci5cblx0XHQgKiAgQHJldHVybiAge0F1ZGlvUmFuZ2V9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLl9nZXRJbml0aWFsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGNvZWZzID0gdGhpcy5fZ2V0UmVhbEltYWdpbmFyeSh0aGlzLl90eXBlLCAwKTtcblx0ICAgICAgICB2YXIgcmVhbCA9IGNvZWZzWzBdO1xuXHQgICAgICAgIHZhciBpbWFnID0gY29lZnNbMV07XG5cdCAgICAgICAgdmFyIG1heFZhbHVlID0gMDtcblx0ICAgICAgICB2YXIgdHdvUGkgPSBNYXRoLlBJICogMjtcblx0ICAgICAgICAvL2NoZWNrIGZvciBwZWFrcyBpbiA4IHBsYWNlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5faW52ZXJzZUZGVChyZWFsLCBpbWFnLCBpIC8gOCAqIHR3b1BpKSwgbWF4VmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gLXRoaXMuX2ludmVyc2VGRlQocmVhbCwgaW1hZywgdGhpcy5fcGhhc2UpIC8gbWF4VmFsdWU7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQSBwYXJ0aWFsIHJlcHJlc2VudHNcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGVcblx0XHQgKiBmdW5kYW1lbnRhbCBmcmVxdWVuY3ksIHRoZSBzZWNvbmQgaXMgdGhlIG9jdGF2ZSBhbmQgc28gb25cblx0XHQgKiBmb2xsb3dpbmcgdGhlIGhhcm1vbmljIHNlcmllcy5cblx0XHQgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IHNldCB0aGUgdHlwZSB0byBcImN1c3RvbVwiLlxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlICE9PSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b20pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFscztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBwYXJ0aWFscztcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBoYXNlID0gMTgwOyAvL2ZsaXBzIHRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BoYXNlICogKDE4MCAvIE1hdGguUEkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGhhc2UgPSBwaGFzZSAqIE1hdGguUEkgLyAxODA7XG5cdCAgICAgICAgICAgIC8vcmVzZXQgdGhlIHR5cGVcblx0ICAgICAgICAgICAgdGhpcy50eXBlID0gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBEaXNwb3NlIGFuZCBkaXNjb25uZWN0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9zY2lsbGF0b3J9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9yICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fd2F2ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5aZXJvIG91dHB1dHMgMCdzIGF0IGF1ZGlvLXJhdGUuIFRoZSByZWFzb24gdGhpcyBoYXMgdG8gYmVcblx0XHQgKiAgICAgICAgIGl0J3Mgb3duIGNsYXNzIGlzIHRoYXQgbWFueSBicm93c2VycyBvcHRpbWl6ZSBvdXQgVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgIHdpdGggYSB2YWx1ZSBvZiAwIGFuZCB3aWxsIG5vdCBwcm9jZXNzIG5vZGVzIGZ1cnRoZXIgZG93biB0aGUgZ3JhcGguXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLlplcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5nZXRDb25zdGFudCgwKS5jb25uZWN0KHRoaXMuX2dhaW4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuWmVybywgVG9uZS5TaWduYWxCYXNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5aZXJvfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5aZXJvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU2lnbmFsQmFzZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2dhaW4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlplcm87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgTEZPIHN0YW5kcyBmb3IgbG93IGZyZXF1ZW5jeSBvc2NpbGxhdG9yLiBUb25lLkxGTyBwcm9kdWNlcyBhbiBvdXRwdXQgc2lnbmFsXG5cdFx0ICogICAgICAgICAgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIGFuIEF1ZGlvUGFyYW0gb3IgVG9uZS5TaWduYWxcblx0XHQgKiAgICAgICAgICBpbiBvcmRlciB0byBtb2R1bGF0ZSB0aGF0IHBhcmFtZXRlciB3aXRoIGFuIG9zY2lsbGF0b3IuIFRoZSBMRk8gY2FuXG5cdFx0ICogICAgICAgICAgYWxzbyBiZSBzeW5jZWQgdG8gdGhlIHRyYW5zcG9ydCB0byBzdGFydC9zdG9wIGFuZCBjaGFuZ2Ugd2hlbiB0aGUgdGVtcG8gY2hhbmdlcy5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtmcmVxdWVuY3ldIFRoZSBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0aW9uLiBUeXBpY2FsbHksIExGT3Mgd2lsbCBiZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSBmcmVxdWVuY3kgcmFuZ2Ugb2YgMC4xIHRvIDEwIGhlcnR6LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IG1pbiBUaGUgbWluaW11bSBvdXRwdXQgdmFsdWUgb2YgdGhlIExGTy5cblx0XHQgKiAgQHBhcmFtIHtudW1iZXI9fSBtYXggVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIExGTy5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbGZvID0gbmV3IFRvbmUuTEZPKFwiNG5cIiwgNDAwLCA0MDAwKTtcblx0XHQgKiBsZm8uY29ubmVjdChmaWx0ZXIuZnJlcXVlbmN5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdtaW4nLFxuXHQgICAgICAgICAgICAnbWF4J1xuXHQgICAgICAgIF0sIFRvbmUuTEZPKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKHtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndHlwZSc6IG9wdGlvbnMudHlwZVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8ncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgYW1wbGl0dWRlIG9mIHRoZSBMRk8sIHdoaWNoIGNvbnRyb2xzIHRoZSBvdXRwdXQgcmFuZ2UgYmV0d2VlblxuXHRcdFx0ICogdGhlIG1pbiBhbmQgbWF4IG91dHB1dC4gRm9yIGV4YW1wbGUgaWYgdGhlIG1pbiBpcyAtMTAgYW5kIHRoZSBtYXhcblx0XHRcdCAqIGlzIDEwLCBzZXR0aW5nIHRoZSBhbXBsaXR1ZGUgdG8gMC41IHdvdWxkIG1ha2UgdGhlIExGTyBtb2R1bGF0ZVxuXHRcdFx0ICogYmV0d2VlbiAtNSBhbmQgNS5cblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmFtcGxpdHVkZSA9IHRoaXMuX29zY2lsbGF0b3Iudm9sdW1lO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnVuaXRzID0gVG9uZS5UeXBlLk5vcm1hbFJhbmdlO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlLnZhbHVlID0gb3B0aW9ucy5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZ25hbCB3aGljaCBpcyBvdXRwdXQgd2hlbiB0aGUgTEZPIGlzIHN0b3BwZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBKdXN0IG91dHB1dHMgemVyb3MuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5femVyb3MgPSBuZXcgVG9uZS5aZXJvKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlIHRoYXQgdGhlIExGTyBvdXRwdXRzIHdoZW4gaXQncyBzdG9wcGVkXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRWYWx1ZSA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2EyZyA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NjYWxlciA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuU2NhbGUob3B0aW9ucy5taW4sIG9wdGlvbnMubWF4KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgdW5pdHMgb2YgdGhlIExGTyAodXNlZCBmb3IgY29udmVydGluZylcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UeXBlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl91bml0cyA9IFRvbmUuVHlwZS5EZWZhdWx0O1xuXHQgICAgICAgIHRoaXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY2hhaW4odGhpcy5fYTJnLCB0aGlzLl9zY2FsZXIpO1xuXHQgICAgICAgIHRoaXMuX3plcm9zLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLmNvbm5lY3QodGhpcy5fYTJnKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdhbXBsaXR1ZGUnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTEZPLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAnbWF4JzogMSxcblx0ICAgICAgICAncGhhc2UnOiAwLFxuXHQgICAgICAgICdmcmVxdWVuY3knOiAnNG4nLFxuXHQgICAgICAgICdhbXBsaXR1ZGUnOiAxLFxuXHQgICAgICAgICd1bml0cyc6IFRvbmUuVHlwZS5EZWZhdWx0XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBMRk8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIExGTyB3aWxsIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBMRk8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIExGTyB3aWxsIHN0b3Bcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxGTy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0b3BwZWRTaWduYWwuc2V0VmFsdWVBdFRpbWUodGhpcy5fc3RvcHBlZFZhbHVlLCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN5bmMgdGhlIHN0YXJ0L3N0b3AvcGF1c2UgdG8gdGhlIHRyYW5zcG9ydFxuXHRcdCAqICBhbmQgdGhlIGZyZXF1ZW5jeSB0byB0aGUgYnBtIG9mIHRoZSB0cmFuc3BvcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTEZPfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIGxmby5mcmVxdWVuY3kudmFsdWUgPSBcIjhuXCI7XG5cdFx0ICogIGxmby5zeW5jKCkuc3RhcnQoMClcblx0XHQgKiAgLy90aGUgcmF0ZSBvZiB0aGUgTEZPIHdpbGwgYWx3YXlzIGJlIGFuIGVpZ2h0aCBub3RlLFxuXHRcdCAqICAvL2V2ZW4gYXMgdGhlIHRlbXBvIGNoYW5nZXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3luY0ZyZXF1ZW5jeSgpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICB1bnN5bmMgdGhlIExGTyBmcm9tIHRyYW5zcG9ydCBjb250cm9sXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkxGT30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudW5zeW5jRnJlcXVlbmN5KCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbml1bXVtIG91dHB1dCBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ21pbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvVW5pdHModGhpcy5fc2NhbGVyLm1pbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgbWluID0gdGhpcy5fZnJvbVVuaXRzKG1pbik7XG5cdCAgICAgICAgICAgIHRoaXMuX3NjYWxlci5taW4gPSBtaW47XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSBvdXRwdXQgb2YgdGhlIExGTy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBtYXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICdtYXgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b1VuaXRzKHRoaXMuX3NjYWxlci5tYXgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobWF4KSB7XG5cdCAgICAgICAgICAgIG1heCA9IHRoaXMuX2Zyb21Vbml0cyhtYXgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZXIubWF4ID0gbWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3I6IHNpbmUsIHNxdWFyZSwgc2F3dG9vdGgsIHRyaWFuZ2xlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxGTy5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci50eXBlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodHlwZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgTEZPLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgICAgICB0aGlzLl9zdG9wcGVkVmFsdWUgPSB0aGlzLl9vc2NpbGxhdG9yLl9nZXRJbml0aWFsVmFsdWUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcHBlZFNpZ25hbC52YWx1ZSA9IHRoaXMuX3N0b3BwZWRWYWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdXRwdXQgdW5pdHMgb2YgdGhlIExGTy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5MRk8jXG5cdFx0ICogQHR5cGUge1RvbmUuVHlwZX1cblx0XHQgKiBAbmFtZSB1bml0c1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3VuaXRzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5pdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNaW4gPSB0aGlzLm1pbjtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXggPSB0aGlzLm1heDtcblx0ICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBtaW4gYW5kIHRoZSBtYXhcblx0ICAgICAgICAgICAgdGhpcy5fdW5pdHMgPSB2YWw7XG5cdCAgICAgICAgICAgIHRoaXMubWluID0gY3VycmVudE1pbjtcblx0ICAgICAgICAgICAgdGhpcy5tYXggPSBjdXJyZW50TWF4O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogTXV0ZSB0aGUgb3V0cHV0LlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkxGTyNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBtdXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MRk8ucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5tdXRlID0gbXV0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTEZPI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTEZPLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5zdGF0ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDb25uZWN0IHRoZSBvdXRwdXQgb2YgdGhlIExGTyB0byBhbiBBdWRpb1BhcmFtLCBBdWRpb05vZGUsIG9yIFRvbmUgTm9kZS5cblx0XHQgKiAgVG9uZS5MRk8gd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgdG8gdGhlIGRlc3RpbmF0aW9uIHVuaXRzIG9mIHRoZVxuXHRcdCAqICB3aWxsIGdldCB0aGUgdW5pdHMgZnJvbSB0aGUgY29ubmVjdGVkIG5vZGUuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUgfCBBdWRpb1BhcmFtIHwgQXVkaW9Ob2RlfSBub2RlXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbb3V0cHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggb3V0cHV0IHRvIGNvbm5lY3QgZnJvbVxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW2lucHV0TnVtPTBdIG9wdGlvbmFsbHkgd2hpY2ggaW5wdXQgdG8gY29ubmVjdCB0b1xuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gVG9uZS5TaWduYWwgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gVG9uZS5QYXJhbSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBUb25lLlRpbWVsaW5lU2lnbmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udmVydCA9IG5vZGUuY29udmVydDtcblx0ICAgICAgICAgICAgdGhpcy51bml0cyA9IG5vZGUudW5pdHM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuU2lnbmFsLnByb3RvdHlwZS5jb25uZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHByaXZhdGUgbWV0aG9kIGJvcnJvd2VkIGZyb20gUGFyYW0gY29udmVydHNcblx0XHQgKiAgdW5pdHMgZnJvbSB0aGVpciBkZXN0aW5hdGlvbiB2YWx1ZVxuXHRcdCAqICBAZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5fZnJvbVVuaXRzID0gVG9uZS5QYXJhbS5wcm90b3R5cGUuX2Zyb21Vbml0cztcblx0ICAgIC8qKlxuXHRcdCAqICBwcml2YXRlIG1ldGhvZCBib3Jyb3dlZCBmcm9tIFBhcmFtIGNvbnZlcnRzXG5cdFx0ICogIHVuaXRzIHRvIHRoZWlyIGRlc3RpbmF0aW9uIHZhbHVlXG5cdFx0ICogIEBmdW5jdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MRk8ucHJvdG90eXBlLl90b1VuaXRzID0gVG9uZS5QYXJhbS5wcm90b3R5cGUuX3RvVW5pdHM7XG5cdCAgICAvKipcblx0XHQgKiAgZGlzY29ubmVjdCBhbmQgZGlzcG9zZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MRk99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTEZPLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnYW1wbGl0dWRlJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdG9wcGVkU2lnbmFsID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl96ZXJvcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5femVyb3MgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hMmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2EyZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuYW1wbGl0dWRlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5MRk87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkxpbWl0ZXIgd2lsbCBsaW1pdCB0aGUgbG91ZG5lc3Mgb2YgYW4gaW5jb21pbmcgc2lnbmFsLlxuXHRcdCAqICAgICAgICAgSXQgaXMgY29tcG9zZWQgb2YgYSBUb25lLkNvbXByZXNzb3Igd2l0aCBhIGZhc3QgYXR0YWNrXG5cdFx0ICogICAgICAgICBhbmQgcmVsZWFzZS4gTGltaXRlcnMgYXJlIGNvbW1vbmx5IHVzZWQgdG8gc2FmZWd1YXJkIGFnYWluc3Rcblx0XHQgKiAgICAgICAgIHNpZ25hbCBjbGlwcGluZy4gVW5saWtlIGEgY29tcHJlc3NvciwgbGltaXRlcnMgZG8gbm90IHByb3ZpZGVcblx0XHQgKiAgICAgICAgIHNtb290aCBnYWluIHJlZHVjdGlvbiBhbmQgYWxtb3N0IGNvbXBsZXRlbHkgcHJldmVudFxuXHRcdCAqICAgICAgICAgYWRkaXRpb25hbCBnYWluIGFib3ZlIHRoZSB0aHJlc2hvbGQuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBUaGUgdGhlc2hvbGQgYWJvdmUgd2hpY2ggdGhlIGxpbWl0aW5nIGlzIGFwcGxpZWQuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIHZhciBsaW1pdGVyID0gbmV3IFRvbmUuTGltaXRlcigtNik7XG5cdFx0ICovXG5cdCAgICBUb25lLkxpbWl0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd0aHJlc2hvbGQnXSwgVG9uZS5MaW1pdGVyKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb21wcmVzc29yXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Db21wcmVzc29yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29tcHJlc3NvciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkNvbXByZXNzb3Ioe1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDAxLFxuXHQgICAgICAgICAgICAndGhyZXNob2xkJzogb3B0aW9ucy50aHJlc2hvbGRcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB0aHJlc2hvbGQgb2Ygb2YgdGhlIGxpbWl0ZXJcblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aGlzLl9jb21wcmVzc29yLnRocmVzaG9sZDtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndGhyZXNob2xkJyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5MaW1pdGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGltaXRlci5kZWZhdWx0cyA9IHsgJ3RocmVzaG9sZCc6IC0xMiB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5MaW1pdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpbWl0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jb21wcmVzc29yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgndGhyZXNob2xkJyk7XG5cdCAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxpbWl0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkxvd3Bhc3MgaXMgYSBsb3dwYXNzIGZlZWRiYWNrIGNvbWIgZmlsdGVyLiBJdCBpcyBzaW1pbGFyIHRvXG5cdFx0ICogICAgICAgICBUb25lLkZlZWRiYWNrQ29tYkZpbHRlciwgYnV0IGluY2x1ZGVzIGEgbG93cGFzcyBmaWx0ZXIuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5IHRpbWUgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2U9fSByZXNvbmFuY2UgVGhlIHJlc29uYW5jZSAoZmVlZGJhY2spIG9mIHRoZSBjb21iIGZpbHRlclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IGRhbXBlbmluZyBUaGUgY3V0b2ZmIG9mIHRoZSBsb3dwYXNzIGZpbHRlciBkYW1wZW5zIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWwgYXMgaXQgaXMgZmVkYmFjay5cblx0XHQgKi9cblx0ICAgIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSwgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlcik7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7RGVsYXlOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheSA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5EZWxheShvcHRpb25zLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5VGltZSBvZiB0aGUgY29tYiBmaWx0ZXIuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSB0aGlzLl9kZWxheS5kZWxheVRpbWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxvd3Bhc3MgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUgIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb3dwYXNzID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG5cdCAgICAgICAgdGhpcy5fbG93cGFzcy5RLnZhbHVlID0gLTMuMDEwMjk5OTU2NjM5ODEyNTtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzLnR5cGUgPSAnbG93cGFzcyc7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRhbXBlbmluZyBjb250cm9sIG9mIHRoZSBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBuZXcgVG9uZS5QYXJhbSh7XG5cdCAgICAgICAgICAgICdwYXJhbSc6IHRoaXMuX2xvd3Bhc3MuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndW5pdHMnOiBUb25lLlR5cGUuRnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAndmFsdWUnOiBvcHRpb25zLmRhbXBlbmluZ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmZWVkYmFjayBnYWluXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBuZXcgVG9uZS5HYWluKG9wdGlvbnMucmVzb25hbmNlLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgZmVlZGJhY2sgb2YgdGhlIGRlbGF5ZWQgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnJlc29uYW5jZSA9IHRoaXMuX2ZlZWRiYWNrLmdhaW47XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX2RlbGF5LmNoYWluKHRoaXMuX2xvd3Bhc3MsIHRoaXMuX2ZlZWRiYWNrLCB0aGlzLl9kZWxheSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJyxcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Mb3dwYXNzQ29tYkZpbHRlciwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMSxcblx0ICAgICAgICAncmVzb25hbmNlJzogMC41LFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiAzMDAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Mb3dwYXNzQ29tYkZpbHRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Mb3dwYXNzQ29tYkZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZycsXG5cdCAgICAgICAgICAgICdyZXNvbmFuY2UnLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZGFtcGVuaW5nLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yZXNvbmFuY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9sb3dwYXNzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFjay5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxvd3Bhc3NDb21iRmlsdGVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTWVyZ2UgYnJpbmdzIHR3byBzaWduYWxzIGludG8gdGhlIGxlZnQgYW5kIHJpZ2h0XG5cdFx0ICogICAgICAgICAgY2hhbm5lbHMgb2YgYSBzaW5nbGUgc3RlcmVvIGNoYW5uZWwuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbWVyZ2UgPSBuZXcgVG9uZS5NZXJnZSgpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9yb3V0aW5nIGEgc2luZSB0b25lIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHQgKiAvL2FuZCBub2lzZSBpbiB0aGUgcmlnaHQgY2hhbm5lbFxuXHRcdCAqIHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkuY29ubmVjdChtZXJnZS5sZWZ0KTtcblx0XHQgKiB2YXIgbm9pc2UgPSBuZXcgVG9uZS5Ob2lzZSgpLmNvbm5lY3QobWVyZ2UucmlnaHQpO1xuXHRcdCAqIC8vc3RhcnRpbmcgb3VyIG9zY2lsbGF0b3JzXG5cdFx0ICogbm9pc2Uuc3RhcnQoKTtcblx0XHQgKiBvc2Muc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTWVyZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMiwgMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGxlZnQgaW5wdXQgY2hhbm5lbC5cblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5pbnB1dFswXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcmlnaHQgaW5wdXQgY2hhbm5lbC5cblx0XHRcdCAqICBBbGlhcyBmb3IgPGNvZGU+aW5wdXRbMV08L2NvZGU+LlxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLmlucHV0WzFdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBtZXJnZXIgbm9kZSBmb3IgdGhlIHR3byBjaGFubmVsc1xuXHRcdFx0ICogIEB0eXBlIHtDaGFubmVsTWVyZ2VyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2VyID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlQ2hhbm5lbE1lcmdlcigyKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5sZWZ0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblx0ICAgICAgICB0aGlzLmxlZnQuY2hhbm5lbENvdW50ID0gMTtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmNoYW5uZWxDb3VudCA9IDE7XG5cdCAgICAgICAgdGhpcy5sZWZ0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIHRoaXMucmlnaHQuY2hhbm5lbENvdW50TW9kZSA9ICdleHBsaWNpdCc7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXJnZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXJnZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXJnZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubGVmdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnJpZ2h0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXJnZXIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWVyZ2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZXRlciBnZXRzIHRoZSBbUk1TXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb290X21lYW5fc3F1YXJlKVxuXHRcdCAqICAgICAgICAgIG9mIGFuIGlucHV0IHNpZ25hbCB3aXRoIHNvbWUgYXZlcmFnaW5nIGFwcGxpZWQuIEl0IGNhbiBhbHNvIGdldCB0aGUgcmF3XG5cdFx0ICogICAgICAgICAgdmFsdWUgb2YgdGhlIGlucHV0IHNpZ25hbC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gc21vb3RoaW5nIFRoZSBhbW91bnQgb2Ygc21vb3RoaW5nIGFwcGxpZWQgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIG1ldGVyID0gbmV3IFRvbmUuTWV0ZXIoKTtcblx0XHQgKiB2YXIgbWljID0gbmV3IFRvbmUuVXNlck1lZGlhKCkub3BlbigpO1xuXHRcdCAqIC8vY29ubmVjdCBtaWMgdG8gdGhlIG1ldGVyXG5cdFx0ICogbWljLmNvbm5lY3QobWV0ZXIpO1xuXHRcdCAqIC8vdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIG1pYyBpbnB1dCBpbiBkZWNpYmVsc1xuXHRcdCAqIHZhciBsZXZlbCA9IG1ldGVyLmdldFZhbHVlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnc21vb3RoaW5nJ10sIFRvbmUuTWV0ZXIpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFuYWx5c2VyIG5vZGUgd2hpY2ggY29tcHV0ZXMgdGhlIGxldmVscy5cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5BbmFseXNlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IHRoaXMuX2FuYWx5c2VyID0gbmV3IFRvbmUuQW5hbHlzZXIoJ3dhdmVmb3JtJywgMTAyNCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBjYXJyeW92ZXIgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgbGFzdCBmcmFtZS5cblx0XHRcdCAqICBPbmx5IGFwcGxpZWQgbWV0ZXIgZm9yIFwibGV2ZWxcIiB0eXBlLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBvcHRpb25zLnNtb290aGluZztcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1ldGVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLmRlZmF1bHRzID0geyAnc21vb3RoaW5nJzogMC44IH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBjdXJyZW50IGRlY2liZWwgdmFsdWUgb2YgdGhlIGluY29taW5nIHNpZ25hbFxuXHRcdCAqICBAcmV0dXJucyB7RGVjaWJlbHN9XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLnByb3RvdHlwZS5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci50eXBlID0gJ2ZmdCc7XG5cdCAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2FuYWx5c2VyLmdldFZhbHVlKCk7XG5cdCAgICAgICAgdmFyIG9mZnNldCA9IDI4O1xuXHQgICAgICAgIC8vIG5vcm1hbGl6ZXMgbW9zdCBzaWduYWwgbGV2ZWxzXG5cdCAgICAgICAgLy8gVE9ETzogY29tcHV0ZSBsb3VkbmVzcyBmcm9tIEZGVFxuXHQgICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseSh0aGlzLCB2YWx1ZXMpICsgb2Zmc2V0O1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIHNpZ25hbCB2YWx1ZSBvZiB0aGUgaW5jb21pbmcgc2lnbmFsXG5cdFx0ICogIEByZXR1cm5zIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlci50eXBlID0gJ3dhdmVmb3JtJztcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9hbmFseXNlci5nZXRWYWx1ZSgpO1xuXHQgICAgICAgIHJldHVybiB2YWx1ZVswXTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBBIHZhbHVlIGZyb20gMCAtPiAxIHdoZXJlIDAgcmVwcmVzZW50cyBubyB0aW1lIGF2ZXJhZ2luZyB3aXRoIHRoZSBsYXN0IGFuYWx5c2lzIGZyYW1lLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk1ldGVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgc21vb3RoaW5nXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5NZXRlci5wcm90b3R5cGUsICdzbW9vdGhpbmcnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5zbW9vdGhpbmc7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYW5hbHlzZXIuc21vb3RoaW5nID0gdmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXRlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWV0ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICpcdEBjbGFzcyAgVG9uZS5TcGxpdCBzcGxpdHMgYW4gaW5jb21pbmcgc2lnbmFsIGludG8gbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3BsaXQgPSBuZXcgVG9uZS5TcGxpdCgpO1xuXHRcdCAqIHN0ZXJlb1NpZ25hbC5jb25uZWN0KHNwbGl0KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU3BsaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMCwgMik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge0NoYW5uZWxTcGxpdHRlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IHRoaXMuY29udGV4dC5jcmVhdGVDaGFubmVsU3BsaXR0ZXIoMik7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY2hhbm5lbENvdW50ID0gMjtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5jaGFubmVsQ291bnRNb2RlID0gJ2V4cGxpY2l0Jztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMZWZ0IGNoYW5uZWwgb3V0cHV0LlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubGVmdCA9IHRoaXMub3V0cHV0WzBdID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFJpZ2h0IGNoYW5uZWwgb3V0cHV0LlxuXHRcdFx0ICogIEFsaWFzIGZvciA8Y29kZT5vdXRwdXRbMV08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLm91dHB1dFsxXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLmxlZnQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmNvbm5lY3QodGhpcy5yaWdodCwgMSwgMCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TcGxpdCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TcGxpdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TcGxpdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLmxlZnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMubGVmdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5yaWdodC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWxcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKS4gPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTWlkID0gKExlZnQrUmlnaHQpL3NxcnQoMik7ICAgLy8gb2J0YWluIG1pZC1zaWduYWwgZnJvbSBsZWZ0IGFuZCByaWdodDxicj5cblx0XHQgKiAgICAgICAgIFNpZGUgPSAoTGVmdC1SaWdodCkvc3FydCgyKTsgICAvLyBvYnRhaW4gc2lkZS1zaWduYWwgZnJvbSBsZWZ0IGFuZCByaWdoPGJyPlxuXHRcdCAqICAgICAgICAgPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVTcGxpdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygwLCAyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzcGxpdCB0aGUgaW5jb21pbmcgc2lnbmFsIGludG8gbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHNcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCBzZW5kLiBDb25uZWN0IHRvIG1pZCBwcm9jZXNzaW5nLiBBbGlhcyBmb3Jcblx0XHRcdCAqICA8Y29kZT5vdXRwdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gdGhpcy5vdXRwdXRbMF0gPSBuZXcgVG9uZS5FeHByKCcoJDAgKyAkMSkgKiAkMicpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIG91dHB1dC4gQ29ubmVjdCB0byBzaWRlIHByb2Nlc3NpbmcuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPm91dHB1dFsxXTwvY29kZT5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5vdXRwdXRbMV0gPSBuZXcgVG9uZS5FeHByKCcoJDAgLSAkMSkgKiAkMicpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5taWQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5taWQsIDEsIDEpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmNvbm5lY3QodGhpcy5zaWRlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdC5jb25uZWN0KHRoaXMuc2lkZSwgMSwgMSk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLm1pZCwgMCwgMik7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLnNpZGUsIDAsIDIpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZVNwbGl0LCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWlkU2lkZVNwbGl0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVTcGxpdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZVNwbGl0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgTWlkL1NpZGUgcHJvY2Vzc2luZyBzZXBhcmF0ZXMgdGhlIHRoZSAnbWlkJyBzaWduYWxcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpXG5cdFx0ICogICAgICAgICBhbmQgdGhlICdzaWRlJyAod2hpY2ggb25seSBjb21lcyBvdXQgb2YgdGhlIHRoZSBzaWRlIGNoYW5uZWxzKS5cblx0XHQgKiAgICAgICAgIE1pZFNpZGVNZXJnZSBtZXJnZXMgdGhlIG1pZCBhbmQgc2lkZSBzaWduYWwgYWZ0ZXIgdGhleSd2ZSBiZWVuIHNlcGVyYXRlZFxuXHRcdCAqICAgICAgICAgYnkgVG9uZS5NaWRTaWRlU3BsaXQuPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTGVmdCA9IChNaWQrU2lkZSkvc3FydCgyKTsgICAvLyBvYnRhaW4gbGVmdCBzaWduYWwgZnJvbSBtaWQgYW5kIHNpZGU8YnI+XG5cdFx0ICogICAgICAgICBSaWdodCA9IChNaWQtU2lkZSkvc3FydCgyKTsgICAvLyBvYnRhaW4gcmlnaHQgc2lnbmFsIGZyb20gbWlkIGFuZCBzaWRlPGJyPlxuXHRcdCAqICAgICAgICAgPC9jb2RlPlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdCAgICBUb25lLk1pZFNpZGVNZXJnZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygyLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWlkIHNpZ25hbCBpbnB1dC4gQWxpYXMgZm9yXG5cdFx0XHQgKiAgPGNvZGU+aW5wdXRbMF08L2NvZGU+XG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IHRoaXMuaW5wdXRbMF0gPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgcmVjb21iaW5lIHRoZSBtaWQvc2lkZSBpbnRvIExlZnRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbmV3IFRvbmUuRXhwcignKCQwICsgJDEpICogJDInKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc2lkZSBzaWduYWwgaW5wdXQuIEFsaWFzIGZvclxuXHRcdFx0ICogIDxjb2RlPmlucHV0WzFdPC9jb2RlPlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5zaWRlID0gdGhpcy5pbnB1dFsxXSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICByZWNvbWJpbmUgdGhlIG1pZC9zaWRlIGludG8gUmlnaHRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yaWdodCA9IG5ldyBUb25lLkV4cHIoJygkMCAtICQxKSAqICQyJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgTWVyZ2UgdGhlIGxlZnQvcmlnaHQgc2lnbmFsIGJhY2sgaW50byBhIHN0ZXJlbyBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lcmdlID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgIHRoaXMubWlkLmNvbm5lY3QodGhpcy5fbGVmdCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5zaWRlLmNvbm5lY3QodGhpcy5fbGVmdCwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5taWQuY29ubmVjdCh0aGlzLl9yaWdodCwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5zaWRlLmNvbm5lY3QodGhpcy5fcmlnaHQsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2xlZnQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHQuY29ubmVjdCh0aGlzLl9tZXJnZSwgMCwgMSk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmdldENvbnN0YW50KE1hdGguU1FSVDFfMikuY29ubmVjdCh0aGlzLl9sZWZ0LCAwLCAyKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZ2V0Q29uc3RhbnQoTWF0aC5TUVJUMV8yKS5jb25uZWN0KHRoaXMuX3JpZ2h0LCAwLCAyKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVNZXJnZSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1pZFNpZGVNZXJnZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlTWVyZ2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5taWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5zaWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZWZ0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yaWdodC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZU1lcmdlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5NaWRTaWRlQ29tcHJlc3NvciBhcHBsaWVzIHR3byBkaWZmZXJlbnQgY29tcHJlc3NvcnMgdG8gdGhlIG1pZFxuXHRcdCAqICAgICAgICAgYW5kIHNpZGUgc2lnbmFsIGNvbXBvbmVudHMuIFNlZSBUb25lLk1pZFNpZGVTcGxpdC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgbWlkIGFuZCBzaWRlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzb3JzLlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1pZFNpZGVDb21wcmVzc29yLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWlkL3NpZGUgc3BsaXRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZVNwbGl0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSB0aGlzLmlucHV0ID0gbmV3IFRvbmUuTWlkU2lkZVNwbGl0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pZC9zaWRlIHJlY29tYmluYXRpb25cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTWlkU2lkZU1lcmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1pZFNpZGVNZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIG1pZCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLm1pZCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgc2lkZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuc2lkZSA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5zaWRlKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQubWlkLmNoYWluKHRoaXMubWlkLCB0aGlzLl9taWRTaWRlTWVyZ2UubWlkKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQuc2lkZS5jaGFpbih0aGlzLnNpZGUsIHRoaXMuX21pZFNpZGVNZXJnZS5zaWRlKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnc2lkZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1pZFNpZGVDb21wcmVzc29yLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUNvbXByZXNzb3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pZCc6IHtcblx0ICAgICAgICAgICAgJ3JhdGlvJzogMyxcblx0ICAgICAgICAgICAgJ3RocmVzaG9sZCc6IC0yNCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjAzLFxuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMixcblx0ICAgICAgICAgICAgJ2tuZWUnOiAxNlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3NpZGUnOiB7XG5cdCAgICAgICAgICAgICdyYXRpbyc6IDYsXG5cdCAgICAgICAgICAgICd0aHJlc2hvbGQnOiAtMzAsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMC4yNSxcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDMsXG5cdCAgICAgICAgICAgICdrbmVlJzogMTBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NaWRTaWRlQ29tcHJlc3Nvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlQ29tcHJlc3Nvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21pZCcsXG5cdCAgICAgICAgICAgICdzaWRlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubWlkLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5zaWRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnNpZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlTWVyZ2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTWlkU2lkZUNvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk1vbm8gY29lcmNlcyB0aGUgaW5jb21pbmcgbW9ubyBvciBzdGVyZW8gc2lnbmFsIGludG8gYSBtb25vIHNpZ25hbFxuXHRcdCAqICAgICAgICAgd2hlcmUgYm90aCBsZWZ0IGFuZCByaWdodCBjaGFubmVscyBoYXZlIHRoZSBzYW1lIHZhbHVlLiBUaGlzIGNhbiBiZSB1c2VmdWxcblx0XHQgKiAgICAgICAgIGZvciBbc3RlcmVvIGltYWdpbmddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N0ZXJlb19pbWFnaW5nKS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5jcmVhdGVJbnNPdXRzKDEsIDApO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG1lcmdlIHRoZSBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLk1lcmdlKCk7XG5cdCAgICAgICAgdGhpcy5pbnB1dC5jb25uZWN0KHRoaXMuX21lcmdlLCAwLCAwKTtcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fbWVyZ2UsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IFRvbmUuZGJUb0dhaW4oLTEwKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk1vbm8pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk1vbm99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9uby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9ubztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgY29tcHJlc3NvciB3aXRoIHNlcGVyYXRlIGNvbnRyb2xzIG92ZXIgbG93L21pZC9oaWdoIGR5bmFtaWNzXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuQXVkaW9Ob2RlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIGxvdy9taWQvaGlnaCBjb21wcmVzc29yIHNldHRpbmdzLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgbXVsdGliYW5kID0gbmV3IFRvbmUuTXVsdGliYW5kQ29tcHJlc3Nvcih7XG5cdFx0ICogIFx0XCJsb3dGcmVxdWVuY3lcIiA6IDIwMCxcblx0XHQgKiAgXHRcImhpZ2hGcmVxdWVuY3lcIiA6IDEzMDBcblx0XHQgKiAgXHRcImxvd1wiIDoge1xuXHRcdCAqICBcdFx0XCJ0aHJlc2hvbGRcIiA6IC0xMlxuXHRcdCAqICBcdH1cblx0XHQgKiAgfSlcblx0XHQgKi9cblx0ICAgIFRvbmUuTXVsdGliYW5kQ29tcHJlc3NvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKGFyZ3VtZW50cywgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yLmRlZmF1bHRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBzcGxpdCB0aGUgaW5jb21pbmcgc2lnbmFsIGludG8gaGlnaC9taWQvbG93XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTXVsdGliYW5kU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLk11bHRpYmFuZFNwbGl0KHtcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSc6IG9wdGlvbnMubG93RnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnaGlnaEZyZXF1ZW5jeSc6IG9wdGlvbnMuaGlnaEZyZXF1ZW5jeVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGxvdy9taWQgY3Jvc3NvdmVyIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gdGhpcy5fc3BsaXR0ZXIubG93RnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIG1pZC9oaWdoIGNyb3Nzb3ZlciBmcmVxdWVuY3kuXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSB0aGlzLl9zcGxpdHRlci5oaWdoRnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY29tcHJlc3NvciBhcHBsaWVkIHRvIHRoZSBsb3cgZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubG93ID0gbmV3IFRvbmUuQ29tcHJlc3NvcihvcHRpb25zLmxvdyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNvbXByZXNzb3IgYXBwbGllZCB0byB0aGUgbWlkIGZyZXF1ZW5jaWVzLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNvbXByZXNzb3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1pZCA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5taWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjb21wcmVzc29yIGFwcGxpZWQgdG8gdGhlIGhpZ2ggZnJlcXVlbmNpZXMuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ29tcHJlc3Nvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGlnaCA9IG5ldyBUb25lLkNvbXByZXNzb3Iob3B0aW9ucy5oaWdoKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGNvbXByZXNzb3Jcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5sb3cuY2hhaW4odGhpcy5sb3csIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5taWQuY2hhaW4odGhpcy5taWQsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5oaWdoLmNoYWluKHRoaXMuaGlnaCwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2hpZ2gnLFxuXHQgICAgICAgICAgICAnbWlkJyxcblx0ICAgICAgICAgICAgJ2xvdycsXG5cdCAgICAgICAgICAgICdoaWdoRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2xvd0ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk11bHRpYmFuZENvbXByZXNzb3IsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5NdWx0aWJhbmRDb21wcmVzc29yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdsb3cnOiBUb25lLkNvbXByZXNzb3IuZGVmYXVsdHMsXG5cdCAgICAgICAgJ21pZCc6IFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyxcblx0ICAgICAgICAnaGlnaCc6IFRvbmUuQ29tcHJlc3Nvci5kZWZhdWx0cyxcblx0ICAgICAgICAnbG93RnJlcXVlbmN5JzogMjUwLFxuXHQgICAgICAgICdoaWdoRnJlcXVlbmN5JzogMjAwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NdWx0aWJhbmRDb21wcmVzc29yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk11bHRpYmFuZENvbXByZXNzb3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnaGlnaCcsXG5cdCAgICAgICAgICAgICdtaWQnLFxuXHQgICAgICAgICAgICAnbG93Jyxcblx0ICAgICAgICAgICAgJ2hpZ2hGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnbG93RnJlcXVlbmN5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMubG93LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1pZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oaWdoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zcGxpdHRlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sb3cgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMubG93RnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhpZ2hGcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk11bHRpYmFuZENvbXByZXNzb3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QYW5uZXIgaXMgYW4gZXF1YWwgcG93ZXIgTGVmdC9SaWdodCBQYW5uZXIgYW5kIGRvZXMgbm90XG5cdFx0ICogICAgICAgICAgc3VwcG9ydCAzRC4gUGFubmVyIHVzZXMgdGhlIFN0ZXJlb1Bhbm5lck5vZGUgd2hlbiBhdmFpbGFibGUuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW2luaXRpYWxQYW49MF0gVGhlIGluaXRhaWwgcGFubmVyIHZhbHVlIChjZW50ZXIpLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAvL3BhbiB0aGUgaW5wdXQgc2lnbmFsIGhhcmQgcmlnaHQuXG5cdFx0ICogIHZhciBwYW5uZXIgPSBuZXcgVG9uZS5QYW5uZXIoMSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lciA9IGZ1bmN0aW9uIChpbml0aWFsUGFuKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICBpZiAoVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyKSB7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgdGhlIHBhbm5lciBub2RlXG5cdFx0XHRcdCAqICBAdHlwZSB7U3RlcmVvUGFubmVyTm9kZX1cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIgPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSB0aGlzLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHBhbiBjb250cm9sLiAtMSA9IGhhcmQgbGVmdCwgMSA9IGhhcmQgcmlnaHQuXG5cdFx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLnBhbiA9IHRoaXMuX3Bhbm5lci5wYW47XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICB0aGUgZHJ5L3dldCBrbm9iXG5cdFx0XHRcdCAqICBAdHlwZSB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuTWVyZ2V9XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fbWVyZ2VyID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIEB0eXBlIHtUb25lLlNwbGl0fVxuXHRcdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlNwbGl0KCk7XG5cdCAgICAgICAgICAgIC8qKlxuXHRcdFx0XHQgKiAgVGhlIHBhbiBjb250cm9sLiAtMSA9IGhhcmQgbGVmdCwgMSA9IGhhcmQgcmlnaHQuXG5cdFx0XHRcdCAqICBAdHlwZSB7QXVkaW9SYW5nZX1cblx0XHRcdFx0ICogIEBzaWduYWxcblx0XHRcdFx0ICovXG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbmV3IFRvbmUuU2lnbmFsKDAsIFRvbmUuVHlwZS5BdWRpb1JhbmdlKTtcblx0ICAgICAgICAgICAgLyoqXG5cdFx0XHRcdCAqICBhbHdheXMgc2VuZHMgMFxuXHRcdFx0XHQgKiAgQHR5cGUge1RvbmUuWmVyb31cblx0XHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHRcdCAqL1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvID0gbmV3IFRvbmUuWmVybygpO1xuXHQgICAgICAgICAgICAvKipcblx0XHRcdFx0ICogIFRoZSBhbmFsb2cgdG8gZ2FpbiBjb252ZXJzaW9uXG5cdFx0XHRcdCAqICBAdHlwZSAge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0XHQgKi9cblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAgICAgLy9DT05ORUNUSU9OUzpcblx0ICAgICAgICAgICAgdGhpcy5femVyby5jb25uZWN0KHRoaXMuX2EyZyk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuLmNoYWluKHRoaXMuX2EyZywgdGhpcy5fY3Jvc3NGYWRlLmZhZGUpO1xuXHQgICAgICAgICAgICAvL2xlZnQgY2hhbm5lbCBpcyBhLCByaWdodCBjaGFubmVsIGlzIGJcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUsIDAsIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9zcGxpdHRlci5jb25uZWN0KHRoaXMuX2Nyb3NzRmFkZSwgMSwgMSk7XG5cdCAgICAgICAgICAgIC8vbWVyZ2UgaXQgYmFjayB0b2dldGhlclxuXHQgICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuYS5jb25uZWN0KHRoaXMuX21lcmdlciwgMCwgMCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5iLmNvbm5lY3QodGhpcy5fbWVyZ2VyLCAwLCAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy5wYW4udmFsdWUgPSBUb25lLmRlZmF1bHRBcmcoaW5pdGlhbFBhbiwgMCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3BhbicpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFubmVyLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgSW5kaWNhdGVzIGlmIHRoZSBwYW5uZXIgaXMgdXNpbmcgdGhlIG5ldyBTdGVyZW9QYW5uZXJOb2RlIGludGVybmFsbHlcblx0XHQgKiAgQHR5cGUgIHtCb29sZWFufVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyID0gVG9uZS5jb250ZXh0ICYmIFRvbmUuaXNGdW5jdGlvbihUb25lLmNvbnRleHQuY3JlYXRlU3RlcmVvUGFubmVyKTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdwYW4nKTtcblx0ICAgICAgICBpZiAoVG9uZS5QYW5uZXIuaGFzU3RlcmVvUGFubmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lciA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl96ZXJvLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5femVybyA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG51bGw7XG5cdCAgICAgICAgICAgIHRoaXMuX3NwbGl0dGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3BsaXR0ZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9tZXJnZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLnBhbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMucGFuID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYTJnID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFubmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgc3BhdGlhbGl6ZWQgcGFubmVyIG5vZGUgd2hpY2ggc3VwcG9ydHMgZXF1YWxwb3dlciBvciBIUlRGIHBhbm5pbmcuXG5cdFx0ICogICAgICAgICAgVHJpZXMgdG8gbm9ybWFsaXplIHRoZSBBUEkgYWNyb3NzIHZhcmlvdXMgYnJvd3NlcnMuIFNlZSBUb25lLkxpc3RlbmVyXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uWCBUaGUgaW5pdGlhbCB4IHBvc2l0aW9uLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25ZIFRoZSBpbml0aWFsIHkgcG9zaXRpb24uXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblogVGhlIGluaXRpYWwgeiBwb3NpdGlvbi5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncG9zaXRpb25YJyxcblx0ICAgICAgICAgICAgJ3Bvc2l0aW9uWScsXG5cdCAgICAgICAgICAgICdwb3NpdGlvblonXG5cdCAgICAgICAgXSwgVG9uZS5QYW5uZXIzRCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFubmVyIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7UGFubmVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gdGhpcy5pbnB1dCA9IHRoaXMub3V0cHV0ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVBhbm5lcigpO1xuXHQgICAgICAgIC8vc2V0IHNvbWUgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5fcGFubmVyLnBhbm5pbmdNb2RlbCA9IG9wdGlvbnMucGFubmluZ01vZGVsO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5tYXhEaXN0YW5jZSA9IG9wdGlvbnMubWF4RGlzdGFuY2U7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3RhbmNlTW9kZWwgPSBvcHRpb25zLmRpc3RhbmNlTW9kZWw7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbmVPdXRlckdhaW4gPSBvcHRpb25zLmNvbmVPdXRlckdhaW47XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmNvbmVPdXRlckFuZ2xlID0gb3B0aW9ucy5jb25lT3V0ZXJBbmdsZTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29uZUlubmVyQW5nbGUgPSBvcHRpb25zLmNvbmVJbm5lckFuZ2xlO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5yZWZEaXN0YW5jZSA9IG9wdGlvbnMucmVmRGlzdGFuY2U7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLnJvbGxvZmZGYWN0b3IgPSBvcHRpb25zLnJvbGxvZmZGYWN0b3I7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgb3JpZW50YXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFtcblx0ICAgICAgICAgICAgb3B0aW9ucy5vcmllbnRhdGlvblgsXG5cdCAgICAgICAgICAgIG9wdGlvbnMub3JpZW50YXRpb25ZLFxuXHQgICAgICAgICAgICBvcHRpb25zLm9yaWVudGF0aW9uWlxuXHQgICAgICAgIF07XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IFtcblx0ICAgICAgICAgICAgb3B0aW9ucy5wb3NpdGlvblgsXG5cdCAgICAgICAgICAgIG9wdGlvbnMucG9zaXRpb25ZLFxuXHQgICAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uWlxuXHQgICAgICAgIF07XG5cdCAgICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IHBvc2l0aW9uL29yaWVudGF0aW9uXG5cdCAgICAgICAgdGhpcy5vcmllbnRhdGlvblggPSBvcHRpb25zLm9yaWVudGF0aW9uWDtcblx0ICAgICAgICB0aGlzLm9yaWVudGF0aW9uWSA9IG9wdGlvbnMub3JpZW50YXRpb25ZO1xuXHQgICAgICAgIHRoaXMub3JpZW50YXRpb25aID0gb3B0aW9ucy5vcmllbnRhdGlvblo7XG5cdCAgICAgICAgdGhpcy5wb3NpdGlvblggPSBvcHRpb25zLnBvc2l0aW9uWDtcblx0ICAgICAgICB0aGlzLnBvc2l0aW9uWSA9IG9wdGlvbnMucG9zaXRpb25ZO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb25aID0gb3B0aW9ucy5wb3NpdGlvblo7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYW5uZXIzRCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9zaXRpb25YJzogMCxcblx0ICAgICAgICAncG9zaXRpb25ZJzogMCxcblx0ICAgICAgICAncG9zaXRpb25aJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25YJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25ZJzogMCxcblx0ICAgICAgICAnb3JpZW50YXRpb25aJzogMCxcblx0ICAgICAgICAncGFubmluZ01vZGVsJzogJ2VxdWFscG93ZXInLFxuXHQgICAgICAgICdtYXhEaXN0YW5jZSc6IDEwMDAwLFxuXHQgICAgICAgICdkaXN0YW5jZU1vZGVsJzogJ2ludmVyc2UnLFxuXHQgICAgICAgICdjb25lT3V0ZXJHYWluJzogMCxcblx0ICAgICAgICAnY29uZU91dGVyQW5nbGUnOiAzNjAsXG5cdCAgICAgICAgJ2NvbmVJbm5lckFuZ2xlJzogMzYwLFxuXHQgICAgICAgICdyZWZEaXN0YW5jZSc6IDEsXG5cdCAgICAgICAgJ3JvbGxvZmZGYWN0b3InOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHJhbXAgdGltZSB3aGljaCBpcyBhcHBsaWVkIHRvIHRoZSBzZXRUYXJnZXRBdFRpbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5fcmFtcFRpbWVDb25zdGFudCA9IDAuMDE7XG5cdCAgICAvKipcblx0XHQgKiAgU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBpbiAzZCBzcGFjZS5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB5XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHpcblx0XHQgKiAgQHJldHVybiB7VG9uZS5QYW5uZXIzRH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuXHQgICAgICAgIGlmICh0aGlzLl9wYW5uZXIucG9zaXRpb25YKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25YLnNldFRhcmdldEF0VGltZSh4LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25ZLnNldFRhcmdldEF0VGltZSh5LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLl9wYW5uZXIucG9zaXRpb25aLnNldFRhcmdldEF0VGltZSh6LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5zZXRQb3NpdGlvbih4LCB5LCB6KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXRzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc291cmNlIGluIDNkIHNwYWNlLlxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBhbm5lcjNEfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELnByb3RvdHlwZS5zZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bhbm5lci5vcmllbnRhdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGFubmVyLnNldE9yaWVudGF0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdwb3NpdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ3Bvc2l0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAncG9zaXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB4IG9yaWVudGF0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgb3JpZW50YXRpb25YXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUsICdvcmllbnRhdGlvblgnLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzBdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHkgb3JpZW50YXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBvcmllbnRhdGlvbllcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgJ29yaWVudGF0aW9uWScsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsxXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeiBvcmllbnRhdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG9yaWVudGF0aW9uWlxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFubmVyM0QucHJvdG90eXBlLCAnb3JpZW50YXRpb25aJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblsyXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzJdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFByb3h5IGEgcHJvcGVydHkgb24gdGhlIHBhbm5lciB0byBhbiBleHBvc2VkIHB1YmxpYyBwcm9wZXJ5XG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIHByb3Bcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xuXHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhbm5lcjNELnByb3RvdHlwZSwgcHJvcCwge1xuXHQgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Bhbm5lcltwcm9wXSA9IHZhbDtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFubmVyW3Byb3BdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwYW5uaW5nIG1vZGVsLiBFaXRoZXIgXCJlcXVhbHBvd2VyXCIgb3IgXCJIUlRGXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBwYW5uaW5nTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3Bhbm5pbmdNb2RlbCcpO1xuXHQgICAgLyoqXG5cdFx0ICogIEEgcmVmZXJlbmNlIGRpc3RhbmNlIGZvciByZWR1Y2luZyB2b2x1bWUgYXMgc291cmNlIG1vdmUgZnVydGhlciBmcm9tIHRoZSBsaXN0ZW5lclxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcmVmRGlzdGFuY2Vcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ3JlZkRpc3RhbmNlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVzY3JpYmVzIGhvdyBxdWlja2x5IHRoZSB2b2x1bWUgaXMgcmVkdWNlZCBhcyBzb3VyY2UgbW92ZXMgYXdheSBmcm9tIGxpc3RlbmVyLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgcm9sbG9mZkZhY3RvclxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgncm9sbG9mZkZhY3RvcicpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkaXN0YW5jZSBtb2RlbCB1c2VkIGJ5LCAgXCJsaW5lYXJcIiwgXCJpbnZlcnNlXCIsIG9yIFwiZXhwb25lbnRpYWxcIi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIGRpc3RhbmNlTW9kZWxcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2Rpc3RhbmNlTW9kZWwnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIGluc2lkZSBvZiB3aGljaCB0aGVyZSB3aWxsIGJlIG5vIHZvbHVtZSByZWR1Y3Rpb25cblx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lSW5uZXJBbmdsZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5fYWxpYXNQcm9wZXJ0eSgnY29uZUlubmVyQW5nbGUnKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgYW5nbGUsIGluIGRlZ3JlZXMsIG91dHNpZGUgb2Ygd2hpY2ggdGhlIHZvbHVtZSB3aWxsIGJlIHJlZHVjZWRcblx0XHQgKiAgdG8gYSBjb25zdGFudCB2YWx1ZSBvZiBjb25lT3V0ZXJHYWluXG5cdFx0ICogIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYW5uZXIzRCNcblx0XHQgKiAgQG5hbWUgY29uZU91dGVyQW5nbGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFubmVyM0QuX2FsaWFzUHJvcGVydHkoJ2NvbmVPdXRlckFuZ2xlJyk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGdhaW4gb3V0c2lkZSBvZiB0aGUgY29uZU91dGVyQW5nbGVcblx0XHQgKiAgQHR5cGUge0dhaW59XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhbm5lcjNEI1xuXHRcdCAqICBAbmFtZSBjb25lT3V0ZXJHYWluXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdjb25lT3V0ZXJHYWluJyk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIG1heGltdW0gZGlzdGFuY2UgYmV0d2VlbiBzb3VyY2UgYW5kIGxpc3RlbmVyLFxuXHRcdCAqICBhZnRlciB3aGljaCB0aGUgdm9sdW1lIHdpbGwgbm90IGJlIHJlZHVjZWQgYW55IGZ1cnRoZXIuXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFubmVyM0QjXG5cdFx0ICogIEBuYW1lIG1heERpc3RhbmNlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhbm5lcjNELl9hbGlhc1Byb3BlcnR5KCdtYXhEaXN0YW5jZScpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QYW5uZXIzRH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5uZXIzRC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhbm5lcjNEO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QYW5Wb2wgaXMgYSBUb25lLlBhbm5lciBhbmQgVG9uZS5Wb2x1bWUgaW4gb25lLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9SYW5nZX0gcGFuIHRoZSBpbml0aWFsIHBhblxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdm9sdW1lIFRoZSBvdXRwdXQgdm9sdW1lLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vcGFuIHRoZSBpbmNvbWluZyBzaWduYWwgbGVmdCBhbmQgZHJvcCB0aGUgdm9sdW1lXG5cdFx0ICogdmFyIHBhblZvbCA9IG5ldyBUb25lLlBhblZvbCgtMC4yNSwgLTEyKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFuVm9sID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3BhbicsXG5cdCAgICAgICAgICAgICd2b2x1bWUnXG5cdCAgICAgICAgXSwgVG9uZS5QYW5Wb2wpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhbm5pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlBhbm5lcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gdGhpcy5pbnB1dCA9IG5ldyBUb25lLlBhbm5lcihvcHRpb25zLnBhbik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIEwvUiBwYW5uaW5nIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wYW4gPSB0aGlzLl9wYW5uZXIucGFuO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgbm9kZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2b2x1bWUgY29udHJvbCBpbiBkZWNpYmVscy5cblx0XHRcdCAqICBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWUudm9sdW1lO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9wYW5uZXIuY29ubmVjdCh0aGlzLl92b2x1bWUpO1xuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGFuVm9sLCBUb25lLkF1ZGlvTm9kZSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3Bhbic6IDAsXG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUvdW5tdXRlIHRoZSB2b2x1bWVcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QYW5Wb2wjXG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFuVm9sLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhblZvbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYW5Wb2wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdwYW4nLFxuXHQgICAgICAgICAgICAndm9sdW1lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuX3Bhbm5lci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnBhbiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QYW5Wb2w7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Tb2xvIGxldHMgeW91IGlzb2xhdGUgYSBzcGVjaWZpYyBhdWRpbyBzdHJlYW0uIFdoZW5cblx0XHQgKiAgICAgICAgIGFuIGluc3RhbmNlIGlzIHNldCB0byBgc29sbz10cnVlYCwgaXQgd2lsbCBtdXRlIGFsbCBvdGhlciBpbnN0YW5jZXMuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc29sb0EgPSBuZXcgVG9uZS5Tb2xvKClcblx0XHQgKiB2YXIgc29sb0IgPSBuZXcgVG9uZS5Tb2xvKClcblx0XHQgKiBzb2xvQS5zb2xvID0gdHJ1ZVxuXHRcdCAqIC8vbm8gYXVkaW8gd2lsbCBwYXNzIHRocm91Z2ggc29sb0Jcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3NvbG8nXSwgVG9uZS5Tb2xvKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBpbnB1dCBhbmQgb3V0cHV0IG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIGJvdW5kIF9zb2xvZWQgbWV0aG9kXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc29sb0JpbmQgPSB0aGlzLl9zb2xvZWQuYmluZCh0aGlzKTtcblx0ICAgICAgICAvL2xpc3RlbiBmb3Igc29sbyBldmVudHMgY2xhc3Mtd2lkZS5cblx0ICAgICAgICB0aGlzLmNvbnRleHQub24oJ3NvbG8nLCB0aGlzLl9zb2xvQmluZCk7XG5cdCAgICAgICAgLy9zZXQgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5zb2xvID0gb3B0aW9ucy5zb2xvO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU29sbywgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLmRlZmF1bHRzID0geyBzb2xvOiBmYWxzZSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElzb2xhdGVzIHRoaXMgaW5zdGFuY2UgYW5kIG11dGVzIGFsbCBvdGhlciBpbnN0YW5jZXMgb2YgVG9uZS5Tb2xvLlxuXHRcdCAqICBPbmx5IG9uZSBpbnN0YW5jZSBjYW4gYmUgc29sb2VkIGF0IGEgdGltZS4gQSBzb2xvZWRcblx0XHQgKiAgaW5zdGFuY2Ugd2lsbCByZXBvcnQgYHNvbG89ZmFsc2VgIHdoZW4gYW5vdGhlciBpbnN0YW5jZSBpcyBzb2xvZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlNvbG8jXG5cdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqICBAbmFtZSBzb2xvXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Tb2xvLnByb3RvdHlwZSwgJ3NvbG8nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1NvbG9lZCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc29sbykge1xuXHQgICAgICAgICAgICBpZiAoc29sbykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWRkU29sbygpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU29sbygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5lbWl0KCdzb2xvJywgdGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgSWYgdGhlIGN1cnJlbnQgaW5zdGFuY2UgaXMgbXV0ZWQsIGkuZS4gYW5vdGhlciBpbnN0YW5jZSBpcyBzb2xvZWRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuU29sbyNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIG11dGVkXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuU29sby5wcm90b3R5cGUsICdtdXRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9PT0gMDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIEFkZCB0aGlzIHRvIHRoZSBzb2xvZWQgYXJyYXlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5fYWRkU29sbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIVRvbmUuaXNBcnJheSh0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvKSkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghdGhpcy5faXNTb2xvZWQoKSkge1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvLnB1c2godGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlbW92ZSB0aGlzIGZyb20gdGhlIHNvbG9lZCBhcnJheVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNvbG8ucHJvdG90eXBlLl9yZW1vdmVTb2xvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9pc1NvbG9lZCgpKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5fY3VycmVudFNvbG8uaW5kZXhPZih0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBJcyB0aGlzIG9uIHRoZSBzb2xvZWQgYXJyYXlcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5faXNTb2xvZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheSh0aGlzLmNvbnRleHQuX2N1cnJlbnRTb2xvKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5sZW5ndGggIT09IDAgJiYgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5pbmRleE9mKHRoaXMpICE9PSAtMTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBubyBvbmUgaXMgc29sb2VkXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sby5wcm90b3R5cGUuX25vU29sb3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICFUb25lLmlzQXJyYXkodGhpcy5jb250ZXh0Ll9jdXJyZW50U29sbykgfHwgdGhpcy5jb250ZXh0Ll9jdXJyZW50U29sby5sZW5ndGggPT09IDA7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNvbG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UgYW5kIHVuc29sbyBhbGwgb3RoZXIgaW5zdGFuY2VzLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLlNvbG99ICBpbnN0YW5jZSAgVGhlIGluc3RhbmNlIHdoaWNoIGlzIGJlaW5nIHNvbG9lZC91bnNvbG9lZC5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU29sby5wcm90b3R5cGUuX3NvbG9lZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5faXNTb2xvZWQoKSkge1xuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbm9Tb2xvcygpKSB7XG5cdCAgICAgICAgICAgIC8vbm8gb25lIGlzIHNvbG9lZFxuXHQgICAgICAgICAgICB0aGlzLmlucHV0LmdhaW4udmFsdWUgPSAxO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2Fpbi52YWx1ZSA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5Tb2xvfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Tb2xvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuY29udGV4dC5vZmYoJ3NvbG8nLCB0aGlzLl9zb2xvQmluZCk7XG5cdCAgICAgICAgdGhpcy5fcmVtb3ZlU29sbygpO1xuXHQgICAgICAgIHRoaXMuX3NvbG9CaW5kID0gbnVsbDtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlNvbG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEdldCB0aGUgY3VycmVudCB3YXZlZm9ybSBkYXRhIG9mIHRoZSBjb25uZWN0ZWQgYXVkaW8gc291cmNlLlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyPX0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgRkZULiBWYWx1ZSBtdXN0IGJlIGEgcG93ZXIgb2Zcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgdHdvIGluIHRoZSByYW5nZSAzMiB0byAzMjc2OC5cblx0XHQgKi9cblx0ICAgIFRvbmUuV2F2ZWZvcm0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydzaXplJ10sIFRvbmUuV2F2ZWZvcm0pO1xuXHQgICAgICAgIG9wdGlvbnMudHlwZSA9IFRvbmUuQW5hbHlzZXIuVHlwZS5XYXZlZm9ybTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbmFseXNlciBub2RlLlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW5hbHlzZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9hbmFseXNlciA9IHRoaXMuaW5wdXQgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLkFuYWx5c2VyKG9wdGlvbnMpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuV2F2ZWZvcm0sIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5XYXZlZm9ybS5kZWZhdWx0cyA9IHsgJ3NpemUnOiAxMDI0IH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0cyB0aGUgd2F2ZWZvcm0gb2YgdGhlIGF1ZGlvIHNvdXJjZS4gUmV0dXJucyB0aGUgd2F2ZWZvcm0gZGF0YVxuXHRcdCAqICBvZiBsZW5ndGggW3NpemVdKCNzaXplKSBhcyBhIEZsb2F0MzJBcnJheSB3aXRoIHZhbHVlcyBiZXR3ZWVuIC0xIGFuZCAxLlxuXHRcdCAqICBAcmV0dXJucyB7VHlwZWRBcnJheX1cblx0XHQgKi9cblx0ICAgIFRvbmUuV2F2ZWZvcm0ucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5nZXRWYWx1ZSgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc2l6ZSBvZiBhbmFseXNpcy4gVGhpcyBtdXN0IGJlIGEgcG93ZXIgb2YgdHdvIGluIHRoZSByYW5nZSAzMiB0byAzMjc2OC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuV2F2ZWZvcm0jXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBuYW1lIHNpemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLldhdmVmb3JtLnByb3RvdHlwZSwgJ3NpemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmFseXNlci5zaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hbmFseXNlci5zaXplID0gc2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuV2F2ZWZvcm19ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLldhdmVmb3JtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fYW5hbHlzZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FuYWx5c2VyID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5XYXZlZm9ybTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ3RybEludGVycG9sYXRlIHdpbGwgaW50ZXJwb2xhdGUgYmV0d2VlbiBnaXZlbiB2YWx1ZXMgYmFzZWRcblx0XHQgKiAgICAgICAgIG9uIHRoZSBcImluZGV4XCIgcHJvcGVydHkuIFBhc3NpbmcgaW4gYW4gYXJyYXkgb3Igb2JqZWN0IGxpdGVyYWxcblx0XHQgKiAgICAgICAgIHdpbGwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgcGFyYW1ldGVycy4gTm90ZSAoaS5lLiBcIkMzXCIpXG5cdFx0ICogICAgICAgICBhbmQgVGltZSAoaS5lLiBcIjRuICsgMlwiKSBjYW4gYmUgaW50ZXJwb2xhdGVkLiBBbGwgb3RoZXIgdmFsdWVzIGFyZVxuXHRcdCAqICAgICAgICAgYXNzdW1lZCB0byBiZSBudW1iZXJzLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgaW50ZXJwID0gbmV3IFRvbmUuQ3RybEludGVycG9sYXRlKFswLCAyLCA5LCA0XSk7XG5cdFx0ICogaW50ZXJwLmluZGV4ID0gMC43NTtcblx0XHQgKiBpbnRlcnAudmFsdWU7IC8vcmV0dXJucyAxLjVcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBpbnRlcnAgPSBuZXcgVG9uZS5DdHJsSW50ZXJwb2xhdGUoW1xuXHRcdCAqIFx0WzIsIDQsIDVdLFxuXHRcdCAqIFx0WzksIDMsIDJdLFxuXHRcdCAqIF0pO1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIGludGVycG9sYXRlIG92ZXJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5pdGlhbCBpbnRlcnBvbGF0aW9uIGluZGV4LlxuXHRcdCAqIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndmFsdWVzJyxcblx0ICAgICAgICAgICAgJ2luZGV4J1xuXHQgICAgICAgIF0sIFRvbmUuQ3RybEludGVycG9sYXRlKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuXG5cdFx0XHQgKiAgQHR5cGUgIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGludGVycG9sYXRlZCBpbmRleCBiZXR3ZWVuIHZhbHVlcy4gRm9yIGV4YW1wbGU6IGEgdmFsdWUgb2YgMS41XG5cdFx0XHQgKiAgd291bGQgaW50ZXJwb2xhdGUgZXF1YWxseSBiZXR3ZWVuIHRoZSB2YWx1ZSBhdCBpbmRleCAxXG5cdFx0XHQgKiAgYW5kIHRoZSB2YWx1ZSBhdCBpbmRleCAyLiBcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogaW50ZXJwLmluZGV4ID0gMDsgXG5cdFx0XHQgKiBpbnRlcnAudmFsdWU7IC8vcmV0dXJucyB0aGUgdmFsdWUgYXQgMFxuXHRcdFx0ICogaW50ZXJwLmluZGV4ID0gMC41O1xuXHRcdFx0ICogaW50ZXJwLnZhbHVlOyAvL3JldHVybnMgdGhlIHZhbHVlIGJldHdlZW4gaW5kaWNlcyAwIGFuZCAxLiBcblx0XHRcdCAqICBAdHlwZSAge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsSW50ZXJwb2xhdGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxJbnRlcnBvbGF0ZS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaW5kZXgnOiAwLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBpbnRlcnBvbGF0ZWQgdmFsdWUgYmFzZWQgb24gdGhlIGluZGV4XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsSW50ZXJwb2xhdGUjXG5cdFx0ICogIEB0eXBlIHsqfVxuXHRcdCAqICBAbmFtZSB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXHQgICAgICAgICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyUG9zaXRpb24gPSBNYXRoLmZsb29yKGluZGV4KTtcblx0ICAgICAgICAgICAgdmFyIGxvd2VyID0gdGhpcy52YWx1ZXNbbG93ZXJQb3NpdGlvbl07XG5cdCAgICAgICAgICAgIHZhciB1cHBlciA9IHRoaXMudmFsdWVzW01hdGguY2VpbChpbmRleCldO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGUoaW5kZXggLSBsb3dlclBvc2l0aW9uLCBsb3dlciwgdXBwZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIGludGVycG9sYXRpb24gcm91dGluZVxuXHRcdCAqICBAcGFyYW0gIHtOb3JtYWxSYW5nZX0gIGluZGV4ICBUaGUgaW5kZXggYmV0d2VlbiB0aGUgbG93ZXIgYW5kIHVwcGVyXG5cdFx0ICogIEBwYXJhbSAgeyp9ICBsb3dlciBcblx0XHQgKiAgQHBhcmFtICB7Kn0gIHVwcGVyIFxuXHRcdCAqICBAcmV0dXJuICB7Kn0gIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybEludGVycG9sYXRlLnByb3RvdHlwZS5faW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoaW5kZXgsIGxvd2VyLCB1cHBlcikge1xuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkobG93ZXIpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXRBcnJheSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvd2VyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICByZXRBcnJheVtpXSA9IHRoaXMuX2ludGVycG9sYXRlKGluZGV4LCBsb3dlcltpXSwgdXBwZXJbaV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXRBcnJheTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNPYmplY3QobG93ZXIpKSB7XG5cdCAgICAgICAgICAgIHZhciByZXRPYmogPSB7fTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBsb3dlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0T2JqW2F0dHJdID0gdGhpcy5faW50ZXJwb2xhdGUoaW5kZXgsIGxvd2VyW2F0dHJdLCB1cHBlclthdHRyXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldE9iajtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBsb3dlciA9IHRoaXMuX3RvTnVtYmVyKGxvd2VyKTtcblx0ICAgICAgICAgICAgdXBwZXIgPSB0aGlzLl90b051bWJlcih1cHBlcik7XG5cdCAgICAgICAgICAgIHJldHVybiAoMSAtIGluZGV4KSAqIGxvd2VyICsgaW5kZXggKiB1cHBlcjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENvbnZlcnQgZnJvbSB0aGUgZ2l2ZW4gdHlwZSBpbnRvIGEgbnVtYmVyXG5cdFx0ICogIEBwYXJhbSAge051bWJlcnxTdHJpbmd9ICB2YWx1ZVxuXHRcdCAqICBAcmV0dXJuICB7TnVtYmVyfVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUucHJvdG90eXBlLl90b051bWJlciA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcih2YWwpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9vdGhlcndpc2UgYXNzdW1lIHRoYXQgaXQncyBUaW1lLi4uXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU2Vjb25kcyh2YWwpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuQ3RybEludGVycG9sYXRlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsSW50ZXJwb2xhdGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxJbnRlcnBvbGF0ZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQ3RybE1hcmtvdiByZXByZXNlbnRzIGEgTWFya292IENoYWluIHdoZXJlIGVhY2ggY2FsbFxuXHRcdCAqICAgICAgICAgdG8gVG9uZS5DdHJsTWFya292Lm5leHQgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHN0YXRlLiBJZiB0aGUgbmV4dFxuXHRcdCAqICAgICAgICAgc3RhdGUgY2hvaWNlIGlzIGFuIGFycmF5LCB0aGUgbmV4dCBzdGF0ZSBpcyBjaG9zZW4gcmFuZG9tbHkgd2l0aFxuXHRcdCAqICAgICAgICAgZXZlbiBwcm9iYWJpbGl0eSBmb3IgYWxsIG9mIHRoZSBjaG9pY2VzLiBGb3IgYSB3ZWlnaHRlZCBwcm9iYWJpbGl0eVxuXHRcdCAqICAgICAgICAgb2YgdGhlIG5leHQgY2hvaWNlcywgcGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBcInN0YXRlXCIgYW5kIFwicHJvYmFiaWxpdHlcIiBhdHRyaWJ1dGVzLiBcblx0XHQgKiAgICAgICAgIFRoZSBwcm9iYWJpbGl0aWVzIHdpbGwgYmUgbm9ybWFsaXplZCBhbmQgdGhlbiBjaG9zZW4uIElmIG5vIG5leHQgb3B0aW9uc1xuXHRcdCAqICAgICAgICAgYXJlIGdpdmVuIGZvciB0aGUgY3VycmVudCBzdGF0ZSwgdGhlIHN0YXRlIHdpbGwgc3RheSB0aGVyZS4gXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaGFpbiA9IG5ldyBUb25lLkN0cmxNYXJrb3Yoe1xuXHRcdCAqIFx0XCJiZWdpbm5pbmdcIiA6IFtcImVuZFwiLCBcIm1pZGRsZVwiXSxcblx0XHQgKiBcdFwibWlkZGxlXCIgOiBcImVuZFwiXG5cdFx0ICogfSk7XG5cdFx0ICogY2hhaW4udmFsdWUgPSBcImJlZ2lubmluZ1wiO1xuXHRcdCAqIGNoYWluLm5leHQoKTsgLy9yZXR1cm5zIFwiZW5kXCIgb3IgXCJtaWRkbGVcIiB3aXRoIDUwJSBwcm9iYWJpbGl0eVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGNoYWluID0gbmV3IFRvbmUuQ3RybE1hcmtvdih7XG5cdFx0ICogXHRcImJlZ2lubmluZ1wiIDogW3tcInZhbHVlXCIgOiBcImVuZFwiLCBcInByb2JhYmlsaXR5XCIgOiAwLjh9LCBcblx0XHQgKiBcdFx0XHRcdFx0e1widmFsdWVcIiA6IFwibWlkZGxlXCIsIFwicHJvYmFiaWxpdHlcIiA6IDAuMn1dLFxuXHRcdCAqIFx0XCJtaWRkbGVcIiA6IFwiZW5kXCJcblx0XHQgKiB9KTtcblx0XHQgKiBjaGFpbi52YWx1ZSA9IFwiYmVnaW5uaW5nXCI7XG5cdFx0ICogY2hhaW4ubmV4dCgpOyAvL3JldHVybnMgXCJlbmRcIiB3aXRoIDgwJSBwcm9iYWJpbGl0eSBvciBcIm1pZGRsZVwiIHdpdGggMjAlLlxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gdmFsdWVzIEFuIG9iamVjdCB3aXRoIHRoZSBzdGF0ZSBuYW1lcyBhcyB0aGUga2V5c1xuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB0aGUgbmV4dCBzdGF0ZShzKSBhcyB0aGUgdmFsdWVzLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdiA9IGZ1bmN0aW9uICh2YWx1ZXMsIGluaXRpYWwpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIE1hcmtvdiB2YWx1ZXMgd2l0aCBzdGF0ZXMgYXMgdGhlIGtleXNcblx0XHRcdCAqICBhbmQgbmV4dCBzdGF0ZShzKSBhcyB0aGUgdmFsdWVzLiBcblx0XHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBUb25lLmRlZmF1bHRBcmcodmFsdWVzLCB7fSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIE1hcmtvdiB2YWx1ZXMuIFRoZSBuZXh0XG5cdFx0XHQgKiAgc3RhdGUgd2lsbCBiZSBldmFsdWF0ZWQgYW5kIHJldHVybmVkIHdoZW4gVG9uZS5DdHJsTWFya292Lm5leHRcblx0XHRcdCAqICBpcyBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlID0gVG9uZS5kZWZhdWx0QXJnKGluaXRpYWwsIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKVswXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DdHJsTWFya292KTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSBNYXJrb3YgdmFsdWVzLiBcblx0XHQgKiAgQHJldHVybiAge1N0cmluZ31cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybE1hcmtvdi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy52YWx1ZXMuaGFzT3duUHJvcGVydHkodGhpcy52YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLnZhbHVlc1t0aGlzLnZhbHVlXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNBcnJheShuZXh0KSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpc3RyaWJ1dGlvbiA9IHRoaXMuX2dldFByb2JEaXN0cmlidXRpb24obmV4dCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRpb24ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RyaWJ1dGlvbltpXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmFuZCA+IHRvdGFsICYmIHJhbmQgPCB0b3RhbCArIGRpc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNob3NlbiA9IG5leHRbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUb25lLmlzT2JqZWN0KGNob3NlbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBjaG9zZW4udmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2hvc2VuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGRpc3Q7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2hvb3NlIHJhbmRvbWx5IGZyb20gYW4gYXJyYXkgd2VpZ2h0ZWQgb3B0aW9ucyBpbiB0aGUgZm9ybSBcblx0XHQgKiAge1wic3RhdGVcIiA6IHN0cmluZywgXCJwcm9iYWJpbGl0eVwiIDogbnVtYmVyfSBvciBhbiBhcnJheSBvZiB2YWx1ZXNcblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICBvcHRpb25zIFxuXHRcdCAqICBAcmV0dXJuICB7QXJyYXl9ICBUaGUgcmFuZG9tbHkgc2VsZWN0ZWQgY2hvaWNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxNYXJrb3YucHJvdG90eXBlLl9nZXRQcm9iRGlzdHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gW107XG5cdCAgICAgICAgdmFyIHRvdGFsID0gMDtcblx0ICAgICAgICB2YXIgbmVlZHNOb3JtYWxpemluZyA9IGZhbHNlO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tpXTtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNPYmplY3Qob3B0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgbmVlZHNOb3JtYWxpemluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSBvcHRpb24ucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25baV0gPSAxIC8gb3B0aW9ucy5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdG90YWwgKz0gZGlzdHJpYnV0aW9uW2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmVlZHNOb3JtYWxpemluZykge1xuXHQgICAgICAgICAgICAvL25vcm1hbGl6ZSB0aGUgdmFsdWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGlzdHJpYnV0aW9uLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBkaXN0cmlidXRpb25bal0gPSBkaXN0cmlidXRpb25bal0gLyB0b3RhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGlzdHJpYnV0aW9uO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5DdHJsTWFya292fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsTWFya292LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5DdHJsTWFya292O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgR2VuZXJhdGUgcGF0dGVybnMgZnJvbSBhbiBhcnJheSBvZiB2YWx1ZXMuXG5cdFx0ICogICAgICAgICBIYXMgYSBudW1iZXIgb2YgYXJwZWdnaWF0aW9uIGFuZCByYW5kb21pemVkXG5cdFx0ICogICAgICAgICBzZWxlY3Rpb24gcGF0dGVybnMuIFxuXHRcdCAqICAgICAgICAgICA8dWw+XG5cdFx0ICogIFx0ICAgICAgICA8bGk+XCJ1cFwiIC0gY3ljbGVzIHVwd2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25cIiAtIGN5Y2xlcyBkb3dud2FyZDwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cInVwRG93blwiIC0gdXAgdGhlbiBhbmQgZG93bjwvbGk+XG5cdFx0ICogIFx0XHRcdDxsaT5cImRvd25VcFwiIC0gY3ljbGVzIGRvd24gdGhlbiBhbmQgdXA8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJhbHRlcm5hdGVVcFwiIC0ganVtcCB1cCB0d28gYW5kIGRvd24gb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwiYWx0ZXJuYXRlRG93blwiIC0ganVtcCBkb3duIHR3byBhbmQgdXAgb25lPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tXCIgLSByYW5kb21seSBzZWxlY3QgYW4gaW5kZXg8L2xpPlxuXHRcdCAqICBcdFx0XHQ8bGk+XCJyYW5kb21XYWxrXCIgLSByYW5kb21seSBtb3ZlcyBvbmUgaW5kZXggYXdheSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uPC9saT5cblx0XHQgKiAgXHRcdFx0PGxpPlwicmFuZG9tT25jZVwiIC0gcmFuZG9tbHkgc2VsZWN0IGFuIGluZGV4IHdpdGhvdXQgcmVwZWF0aW5nIHVudGlsIGFsbCB2YWx1ZXMgaGF2ZSBiZWVuIGNob3Nlbi48L2xpPlxuXHRcdCAqICAgICBcdFx0PC91bD5cblx0XHQgKiAgQHBhcmFtICB7QXJyYXl9ICB2YWx1ZXMgICBBbiBhcnJheSBvZiBvcHRpb25zIHRvIGNob29zZSBmcm9tLlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkN0cmxQYXR0ZXJuLlR5cGU9fSAgdHlwZSAgVGhlIG5hbWUgb2YgdGhlIHBhdHRlcm4uXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICd2YWx1ZXMnLFxuXHQgICAgICAgICAgICAndHlwZSdcblx0ICAgICAgICBdLCBUb25lLkN0cmxQYXR0ZXJuKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIHZhbHVlcyB0byBhcnBlZ2dpYXRlIG92ZXJcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSB2YWx1ZXMgYXJyYXlcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0eXBlIHBsYWNlaG9sZGVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQ3RybFBhdHRlcm4uVHlwZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2h1ZmZsZWQgdmFsdWVzIGZvciB0aGUgUmFuZG9tT25jZSB0eXBlXG5cdFx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRpcmVjdGlvbiBvZiB0aGUgbW92ZW1lbnRcblx0XHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBudWxsO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkN0cmxQYXR0ZXJuKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgQ29udHJvbCBQYXR0ZXJuc1xuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5UeXBlID0ge1xuXHQgICAgICAgIFVwOiAndXAnLFxuXHQgICAgICAgIERvd246ICdkb3duJyxcblx0ICAgICAgICBVcERvd246ICd1cERvd24nLFxuXHQgICAgICAgIERvd25VcDogJ2Rvd25VcCcsXG5cdCAgICAgICAgQWx0ZXJuYXRlVXA6ICdhbHRlcm5hdGVVcCcsXG5cdCAgICAgICAgQWx0ZXJuYXRlRG93bjogJ2FsdGVybmF0ZURvd24nLFxuXHQgICAgICAgIFJhbmRvbTogJ3JhbmRvbScsXG5cdCAgICAgICAgUmFuZG9tV2FsazogJ3JhbmRvbVdhbGsnLFxuXHQgICAgICAgIFJhbmRvbU9uY2U6ICdyYW5kb21PbmNlJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuIFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ3RybFBhdHRlcm4uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAsXG5cdCAgICAgICAgJ3ZhbHVlcyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB2YWx1ZSBhdCB0aGUgY3VycmVudCBpbmRleCBvZiB0aGUgcGF0dGVybi5cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkN0cmxQYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZSwgJ3ZhbHVlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvL3NvbWUgc2FmZWd1YXJkc1xuXHQgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5pbmRleCA9IE1hdGgubWluKHRoaXMuaW5kZXgsIHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbdGhpcy5pbmRleF07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoICE9PSB0aGlzLl9zaHVmZmxlZC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlc1t0aGlzLl9zaHVmZmxlZFt0aGlzLmluZGV4XV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcGF0dGVybiB1c2VkIHRvIHNlbGVjdCB0aGUgbmV4dFxuXHRcdCAqICBpdGVtIGZyb20gdGhlIHZhbHVlcyBhcnJheVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge1RvbmUuQ3RybFBhdHRlcm4uVHlwZX1cblx0XHQgKiAgQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ3RybFBhdHRlcm4ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgICAgIC8vdGhlIGZpcnN0IGluZGV4XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tT25jZSB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duVXAgfHwgdGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkFsdGVybmF0ZURvd24pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vdGhlIGRpcmVjdGlvblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwRG93biB8fCB0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuQWx0ZXJuYXRlVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93blVwIHx8IHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3JhbmRvbXNcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5SYW5kb21PbmNlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5SYW5kb20pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnZhbHVlcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJuIHRoZSBuZXh0IHZhbHVlIGdpdmVuIHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cdFx0ICogIGFuZCBwYXR0ZXJuLlxuXHRcdCAqICBAcmV0dXJuIHsqfSBUaGUgbmV4dCB2YWx1ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblx0ICAgICAgICAvL2Nob29zZSB0aGUgbmV4dCBpbmRleFxuXHQgICAgICAgIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuRG93bikge1xuXHQgICAgICAgICAgICB0aGlzLmluZGV4LS07XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMudmFsdWVzLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcERvd24gfHwgdHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd25VcCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuUmFuZG9tKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnZhbHVlcy5sZW5ndGgpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbVdhbGspIHtcblx0ICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1heCh0aGlzLmluZGV4LCAwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBNYXRoLm1pbih0aGlzLmluZGV4LCB0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlJhbmRvbU9uY2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgLy9yZXNodWZmbGUgdGhlIHZhbHVlcyBmb3IgbmV4dCB0aW1lXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zaHVmZmxlVmFsdWVzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVVcCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gMjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLlVwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5BbHRlcm5hdGVEb3duKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5VcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gVG9uZS5DdHJsUGF0dGVybi5UeXBlLkRvd247XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4IC09IDI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IFRvbmUuQ3RybFBhdHRlcm4uVHlwZS5Eb3duO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTaHVmZmxlcyB0aGUgdmFsdWVzIGFuZCBwbGFjZXMgdGhlIHJlc3VsdHMgaW50byB0aGUgX3NodWZmbGVkXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxQYXR0ZXJuLnByb3RvdHlwZS5fc2h1ZmZsZVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY29weSA9IFtdO1xuXHQgICAgICAgIHRoaXMuX3NodWZmbGVkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb3B5W2ldID0gaTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgd2hpbGUgKGNvcHkubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZFZhbCA9IGNvcHkuc3BsaWNlKE1hdGguZmxvb3IoY29weS5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKSwgMSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NodWZmbGVkLnB1c2gocmFuZFZhbFswXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DdHJsUGF0dGVybn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUGF0dGVybi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zaHVmZmxlZCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52YWx1ZXMgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxQYXR0ZXJuO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIENob29zZSBhIHJhbmRvbSB2YWx1ZS5cblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHJhbmRvbVdhbGsgPSBuZXcgVG9uZS5DdHJsUmFuZG9tKHtcblx0XHQgKiBcdFwibWluXCIgOiAwLFxuXHRcdCAqIFx0XCJtYXhcIiA6IDEwLFxuXHRcdCAqIFx0XCJpbnRlZ2VyXCIgOiB0cnVlXG5cdFx0ICogfSk7XG5cdFx0ICogcmFuZG9tV2Fsay5ldmFsKCk7XG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8VGltZT19IG1pbiBUaGUgbWluaW11bSByZXR1cm4gdmFsdWUuXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfFRpbWU9fSBtYXggVGhlIG1heGltdW0gcmV0dXJuIHZhbHVlLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5DdHJsUmFuZG9tID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ21pbicsXG5cdCAgICAgICAgICAgICdtYXgnXG5cdCAgICAgICAgXSwgVG9uZS5DdHJsUmFuZG9tKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pbmltdW0gcmV0dXJuIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ8VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWluID0gb3B0aW9ucy5taW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1heGltdW0gcmV0dXJuIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ8VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWF4ID0gb3B0aW9ucy5tYXg7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgYmUgYW4gaW50ZWdlclxuXHRcdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaW50ZWdlciA9IG9wdGlvbnMuaW50ZWdlcjtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkN0cmxSYW5kb20pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkN0cmxSYW5kb20uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgJ21heCc6IDEsXG5cdCAgICAgICAgJ2ludGVnZXInOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm4gYSByYW5kb20gdmFsdWUgYmV0d2VlbiBtaW4gYW5kIG1heC4gXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5DdHJsUmFuZG9tI1xuXHRcdCAqICBAdHlwZSB7Kn1cblx0XHQgKiAgQG5hbWUgdmFsdWVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkN0cmxSYW5kb20ucHJvdG90eXBlLCAndmFsdWUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBtaW4gPSB0aGlzLnRvU2Vjb25kcyh0aGlzLm1pbik7XG5cdCAgICAgICAgICAgIHZhciBtYXggPSB0aGlzLnRvU2Vjb25kcyh0aGlzLm1heCk7XG5cdCAgICAgICAgICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IHJhbmQgKiBtaW4gKyAoMSAtIHJhbmQpICogbWF4O1xuXHQgICAgICAgICAgICBpZiAodGhpcy5pbnRlZ2VyKSB7XG5cdCAgICAgICAgICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLkN0cmxSYW5kb207XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEF1ZGlvQnVmZmVyLmNvcHlUb0NoYW5uZWwgcG9seWZpbGxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuQXVkaW9CdWZmZXIgJiYgIUF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5VG9DaGFubmVsKSB7XG5cdCAgICAgICAgQXVkaW9CdWZmZXIucHJvdG90eXBlLmNvcHlUb0NoYW5uZWwgPSBmdW5jdGlvbiAoc3JjLCBjaGFuTnVtLCBzdGFydCkge1xuXHQgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuZ2V0Q2hhbm5lbERhdGEoY2hhbk51bSk7XG5cdCAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFubmVsW2kgKyBzdGFydF0gPSBzcmNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIEF1ZGlvQnVmZmVyLnByb3RvdHlwZS5jb3B5RnJvbUNoYW5uZWwgPSBmdW5jdGlvbiAoZGVzdCwgY2hhbk51bSwgc3RhcnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmdldENoYW5uZWxEYXRhKGNoYW5OdW0pO1xuXHQgICAgICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgZGVzdFtpXSA9IGNoYW5uZWxbaSArIHN0YXJ0XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBCdWZmZXIgbG9hZGluZyBhbmQgc3RvcmFnZS4gVG9uZS5CdWZmZXIgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IGFsbCBcblx0XHQgKiAgICAgICAgICBjbGFzc2VzIHRoYXQgbWFrZSByZXF1ZXN0cyBmb3IgYXVkaW8gZmlsZXMgc3VjaCBhcyBUb25lLlBsYXllcixcblx0XHQgKiAgICAgICAgICBUb25lLlNhbXBsZXIgYW5kIFRvbmUuQ29udm9sdmVyLlxuXHRcdCAqICAgICAgICAgIFxuXHRcdCAqICAgICAgICAgIEFzaWRlIGZyb20gbG9hZCBjYWxsYmFja3MgZnJvbSBpbmRpdmlkdWFsIGJ1ZmZlcnMsIFRvbmUuQnVmZmVyIFxuXHRcdCAqICBcdFx0cHJvdmlkZXMgZXZlbnRzIHdoaWNoIGtlZXAgdHJhY2sgb2YgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgXG5cdFx0ICogIFx0XHRvZiBfYWxsXyBvZiB0aGUgYnVmZmVycy4gVGhlc2UgYXJlIFRvbmUuQnVmZmVyLm9uKFwibG9hZFwiIC8gXCJwcm9ncmVzc1wiIC8gXCJlcnJvclwiKVxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvciBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7QXVkaW9CdWZmZXJ8U3RyaW5nfSB1cmwgVGhlIHVybCB0byBsb2FkLCBvciB0aGUgYXVkaW8gYnVmZmVyIHRvIHNldC4gXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb249fSBvbmxvYWQgQSBjYWxsYmFjayB3aGljaCBpcyBpbnZva2VkIGFmdGVyIHRoZSBidWZmZXIgaXMgbG9hZGVkLiBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBgVG9uZS5CdWZmZXIub24oJ2xvYWQnLCBjYWxsYmFjaylgIGluc3RlYWQgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luY2UgaXQgd2lsbCBnaXZlIHlvdSBhIGNhbGxiYWNrIHdoZW4gX2FsbF8gYnVmZmVycyBhcmUgbG9hZGVkLlxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9uPX0gb25lcnJvciBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGlmIHRoZXJlIGlzIGFuIGVycm9yXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihcInBhdGgvdG8vc291bmQubXAzXCIsIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL3RoZSBidWZmZXIgaXMgbm93IGF2YWlsYWJsZS5cblx0XHQgKiBcdHZhciBidWZmID0gYnVmZmVyLmdldCgpO1xuXHRcdCAqIH0pO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGxvYWQgcHJvdmlkZSBmYWxsYmFjayBleHRlbnNpb24gdHlwZXMgaWYgdGhlIGZpcnN0IHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cblx0XHQgKiB2YXIgYnVmZmVyID0gbmV3IFRvbmUuQnVmZmVyKFwicGF0aC90by9zb3VuZC5bbXAzfG9nZ3x3YXZdXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAndXJsJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCcsXG5cdCAgICAgICAgICAgICdvbmVycm9yJ1xuXHQgICAgICAgIF0sIFRvbmUuQnVmZmVyKTtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgc3RvcmVzIHRoZSBsb2FkZWQgQXVkaW9CdWZmZXJcblx0XHRcdCAqICBAdHlwZSB7QXVkaW9CdWZmZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaW5kaWNhdGVzIGlmIHRoZSBidWZmZXIgc2hvdWxkIGJlIHJldmVyc2VkIG9yIG5vdFxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IG9wdGlvbnMucmV2ZXJzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgWEhSXG5cdFx0XHQgKiAgQHR5cGUgIHtYTUxIdHRwUmVxdWVzdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcblx0ICAgICAgICBpZiAob3B0aW9ucy51cmwgaW5zdGFuY2VvZiBBdWRpb0J1ZmZlciB8fCBvcHRpb25zLnVybCBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0KG9wdGlvbnMudXJsKTtcblx0ICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBvbmxvYWQgY2FsbGJhY2tcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMub25sb2FkKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm9ubG9hZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoVG9uZS5pc1N0cmluZyhvcHRpb25zLnVybCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5sb2FkKG9wdGlvbnMudXJsLCBvcHRpb25zLm9ubG9hZCwgb3B0aW9ucy5vbmVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5CdWZmZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICd1cmwnOiB1bmRlZmluZWQsXG5cdCAgICAgICAgJ3JldmVyc2UnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBQYXNzIGluIGFuIEF1ZGlvQnVmZmVyIG9yIFRvbmUuQnVmZmVyIHRvIHNldCB0aGUgdmFsdWVcblx0XHQgKiAgb2YgdGhpcyBidWZmZXIuXG5cdFx0ICogIEBwYXJhbSB7QXVkaW9CdWZmZXJ8VG9uZS5CdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVG9uZS5CdWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyID0gYnVmZmVyLmdldCgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEByZXR1cm4ge0F1ZGlvQnVmZmVyfSBUaGUgYXVkaW8gYnVmZmVyIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBNYWtlcyBhbiB4aHIgcmVxZXN0IGZvciB0aGUgc2VsZWN0ZWQgdXJsIHRoZW4gZGVjb2Rlc1xuXHRcdCAqICB0aGUgZmlsZSBhcyBhbiBhdWRpbyBidWZmZXIuIEludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHJldHVybnMge1Byb21pc2V9IHJldHVybnMgYSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggdGhlIFRvbmUuQnVmZmVyXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICh1cmwsIG9ubG9hZCwgb25lcnJvcikge1xuXHQgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKGxvYWQsIGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3hociA9IFRvbmUuQnVmZmVyLmxvYWQodXJsLCAvL3N1Y2Nlc3Ncblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGJ1ZmYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChidWZmKTtcblx0ICAgICAgICAgICAgICAgIGxvYWQodGhpcyk7XG5cdCAgICAgICAgICAgICAgICBpZiAob25sb2FkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb25sb2FkKHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyksIC8vZXJyb3Jcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5feGhyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICBpZiAob25lcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBkaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJ1ZmZlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMuX3hocikge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUodGhpcy5feGhyKTtcblx0ICAgICAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3hociA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgaXMgbG9hZGVkIG9yIG5vdFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gb2YgdGhlIGJ1ZmZlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgZHVyYXRpb25cblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdkdXJhdGlvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5kdXJhdGlvbjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaW4gc2FtcGxlc1xuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGxlbmd0aFxuXHRcdCAqIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5sZW5ndGg7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkaXNjcmV0ZSBhdWRpbyBjaGFubmVscy4gUmV0dXJucyAwIGlmIG5vIGJ1ZmZlclxuXHRcdCAqIGlzIGxvYWRlZC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5CdWZmZXIjXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAbmFtZSBudW1iZXJPZkNoYW5uZWxzXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXIucHJvdG90eXBlLCAnbnVtYmVyT2ZDaGFubmVscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgdGhlIGF1ZGlvIGJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHRcdCAqICBwYXNzIGluIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheS4gXG5cdFx0ICogIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbCB0aGUgYXVkaW8gYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG5cdCAgICAgICAgdmFyIGlzTXVsdGlkaW1lbnNpb25hbCA9IGFycmF5WzBdLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgdmFyIGNoYW5uZWxzID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXkubGVuZ3RoIDogMTtcblx0ICAgICAgICB2YXIgbGVuID0gaXNNdWx0aWRpbWVuc2lvbmFsID8gYXJyYXlbMF0ubGVuZ3RoIDogYXJyYXkubGVuZ3RoO1xuXHQgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyKGNoYW5uZWxzLCBsZW4sIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlKTtcblx0ICAgICAgICBpZiAoIWlzTXVsdGlkaW1lbnNpb25hbCAmJiBjaGFubmVscyA9PT0gMSkge1xuXHQgICAgICAgICAgICBhcnJheSA9IFthcnJheV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuXHQgICAgICAgICAgICBidWZmZXIuY29weVRvQ2hhbm5lbChhcnJheVtjXSwgYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IGJ1ZmZlcjtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdFN1bXMgbXVsaXBsZSBjaGFubmVscyBpbnRvIDEgY2hhbm5lbFxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9Nb25vID0gZnVuY3Rpb24gKGNoYW5OdW0pIHtcblx0ICAgICAgICBpZiAoVG9uZS5pc051bWJlcihjaGFuTnVtKSkge1xuXHQgICAgICAgICAgICB0aGlzLmZyb21BcnJheSh0aGlzLnRvQXJyYXkoY2hhbk51bSkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBvdXRwdXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YXIgbnVtQ2hhbm5lbHMgPSB0aGlzLm51bWJlck9mQ2hhbm5lbHM7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgbnVtQ2hhbm5lbHM7IGNoYW5uZWwrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxBcnJheSA9IHRoaXMudG9BcnJheShjaGFubmVsKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3V0cHV0QXJyYXlbaV0gKz0gY2hhbm5lbEFycmF5W2ldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vZGl2aWRlIGJ5IHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcblx0ICAgICAgICAgICAgb3V0cHV0QXJyYXkgPSBvdXRwdXRBcnJheS5tYXAoZnVuY3Rpb24gKHNhbXBsZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNhbXBsZSAvIG51bUNoYW5uZWxzO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgdGhpcy5mcm9tQXJyYXkob3V0cHV0QXJyYXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdEdldCB0aGUgYnVmZmVyIGFzIGFuIGFycmF5LiBTaW5nbGUgY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIGEgMS1kaW1lbnNpb25hbCBcblx0XHQgKiBcdEZsb2F0MzJBcnJheSwgYW5kIG11bHRpY2hhbm5lbCBidWZmZXJzIHdpbGwgcmV0dXJuIG11bHRpZGltZW5zaW9uYWwgYXJyYXlzLlxuXHRcdCAqICBAcGFyYW0ge051bWJlcj19IGNoYW5uZWwgT3B0aW9uYWxseSBvbmx5IGNvcHkgYSBzaW5nbGUgY2hhbm5lbCBmcm9tIHRoZSBhcnJheS5cblx0XHQgKiAgQHJldHVybiB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOdW1iZXIoY2hhbm5lbCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhbm5lbERhdGEoY2hhbm5lbCk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0aGlzLm51bWJlck9mQ2hhbm5lbHMgPT09IDEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgcmV0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGhpcy5udW1iZXJPZkNoYW5uZWxzOyBjKyspIHtcblx0ICAgICAgICAgICAgICAgIHJldFtjXSA9IHRoaXMuZ2V0Q2hhbm5lbERhdGEoYyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIEZsb2F0MzJBcnJheSByZXByZXNlbnRpbmcgdGhlIFBDTSBhdWRpbyBkYXRhIGZvciB0aGUgc3BlY2lmaWMgY2hhbm5lbC5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgY2hhbm5lbCAgVGhlIGNoYW5uZWwgbnVtYmVyIHRvIHJldHVyblxuXHRcdCAqICBAcmV0dXJuICB7RmxvYXQzMkFycmF5fSAgVGhlIGF1ZGlvIGFzIGEgVHlwZWRBcnJheVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIucHJvdG90eXBlLmdldENoYW5uZWxEYXRhID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWwpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDdXQgYSBzdWJzZWN0aW9uIG9mIHRoZSBhcnJheSBhbmQgcmV0dXJuIGEgYnVmZmVyIG9mIHRoZVxuXHRcdCAqICBzdWJzZWN0aW9uLiBEb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHN0YXJ0IFRoZSB0aW1lIHRvIHN0YXJ0IHRoZSBzbGljZVxuXHRcdCAqICBAcGFyYW0ge1RpbWU9fSBlbmQgVGhlIGVuZCB0aW1lIHRvIHNsaWNlLiBJZiBub25lIGlzIGdpdmVuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuXHQgICAgICAgIGVuZCA9IFRvbmUuZGVmYXVsdEFyZyhlbmQsIHRoaXMuZHVyYXRpb24pO1xuXHQgICAgICAgIHZhciBzdGFydFNhbXBsZXMgPSBNYXRoLmZsb29yKHRoaXMuY29udGV4dC5zYW1wbGVSYXRlICogdGhpcy50b1NlY29uZHMoc3RhcnQpKTtcblx0ICAgICAgICB2YXIgZW5kU2FtcGxlcyA9IE1hdGguZmxvb3IodGhpcy5jb250ZXh0LnNhbXBsZVJhdGUgKiB0aGlzLnRvU2Vjb25kcyhlbmQpKTtcblx0ICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtYmVyT2ZDaGFubmVsczsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlcGxhY2VtZW50W2ldID0gdGhpcy50b0FycmF5KGkpLnNsaWNlKHN0YXJ0U2FtcGxlcywgZW5kU2FtcGxlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXRCdWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkocmVwbGFjZW1lbnQpO1xuXHQgICAgICAgIHJldHVybiByZXRCdWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldmVyc2UgdGhlIGJ1ZmZlci5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybiB7VG9uZS5CdWZmZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnByb3RvdHlwZS5fcmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAodGhpcy5sb2FkZWQpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bWJlck9mQ2hhbm5lbHM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLmdldENoYW5uZWxEYXRhKGkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXZlcnNlIHRoZSBidWZmZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIHJldmVyc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlci5wcm90b3R5cGUsICdyZXZlcnNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyZXYpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JldmVyc2VkICE9PSByZXYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JldmVyc2VkID0gcmV2O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vIFNUQVRJQyBNRVRIT0RTXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0ICAgIC8vc3RhdGljYWxseSBpbmhlcml0cyBFbWl0dGVyIG1ldGhvZHNcblx0ICAgIFRvbmUuRW1pdHRlci5taXhpbihUb25lLkJ1ZmZlcik7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIHN0YXRpYyBxdWV1ZSBmb3IgYWxsIG9mIHRoZSB4aHIgcmVxdWVzdHNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUgPSBbXTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIHBhdGggd2hpY2ggaXMgcHJlZml4ZWQgYmVmb3JlIGV2ZXJ5IHVybC5cblx0XHQgKiAgQHR5cGUgIHtTdHJpbmd9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmJhc2VVcmwgPSAnJztcblx0ICAgIC8qKlxuXHRcdCAqICBDcmVhdGUgYSBUb25lLkJ1ZmZlciBmcm9tIHRoZSBhcnJheS4gVG8gY3JlYXRlIGEgbXVsdGljaGFubmVsIEF1ZGlvQnVmZmVyLFxuXHRcdCAqICBwYXNzIGluIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheS4gXG5cdFx0ICogIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbCB0aGUgYXVkaW8gYnVmZmVyXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQnVmZmVyfSBBIFRvbmUuQnVmZmVyIGNyZWF0ZWQgZnJvbSB0aGUgYXJyYXlcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkoYXJyYXkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFJlbW92ZSBhbiB4aHIgcmVxdWVzdCBmcm9tIHRoZSBkb3dubG9hZCBxdWV1ZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmluZGV4T2YocmVxdWVzdCk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fZG93bmxvYWRRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgTG9hZHMgYSB1cmwgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3Jcblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gb25wcm9ncmVzc1xuXHRcdCAqICBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBvbmxvYWQsIG9uZXJyb3IpIHtcblx0ICAgICAgICAvL2RlZmF1bHRcblx0ICAgICAgICBvbmxvYWQgPSBUb25lLmRlZmF1bHRBcmcob25sb2FkLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIC8vIHRlc3QgaWYgdGhlIHVybCBjb250YWlucyBtdWx0aXBsZSBleHRlbnNpb25zXG5cdCAgICAgICAgdmFyIG1hdGNoZXMgPSB1cmwubWF0Y2goL1xcWyguK1xcfD8pK1xcXSQvKTtcblx0ICAgICAgICBpZiAobWF0Y2hlcykge1xuXHQgICAgICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IG1hdGNoZXNbMV0uc3BsaXQoJ3wnKTtcblx0ICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbMF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZShleHRlbnNpb25zW2ldKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobWF0Y2hlc1swXSwgZXh0ZW5zaW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlKSB7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLl9yZW1vdmVGcm9tRG93bmxvYWRRdWV1ZShyZXF1ZXN0KTtcblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgnZXJyb3InLCBlKTtcblx0ICAgICAgICAgICAgaWYgKG9uZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIG9uZXJyb3IoZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG5cdCAgICAgICAgICAgIC8vY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuXHQgICAgICAgICAgICB2YXIgdG90YWxQcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsUHJvZ3Jlc3MgKz0gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWVbaV0ucHJvZ3Jlc3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgncHJvZ3Jlc3MnLCB0b3RhbFByb2dyZXNzIC8gVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUubGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0ICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIFRvbmUuQnVmZmVyLmJhc2VVcmwgKyB1cmwsIHRydWUpO1xuXHQgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0ICAgICAgICAvL3N0YXJ0IG91dCBhcyAwXG5cdCAgICAgICAgcmVxdWVzdC5wcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgVG9uZS5CdWZmZXIuX2Rvd25sb2FkUXVldWUucHVzaChyZXF1ZXN0KTtcblx0ICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG5cdCAgICAgICAgICAgICAgICBUb25lLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKHJlcXVlc3QucmVzcG9uc2UsIGZ1bmN0aW9uIChidWZmKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5wcm9ncmVzcyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9ubG9hZChidWZmKTtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2VtaXQgdGhlIGV2ZW50IGF0IHRoZSBlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgVG9uZS5CdWZmZXIuZW1pdCgnbG9hZCcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb25FcnJvcignVG9uZS5CdWZmZXI6IGNvdWxkIG5vdCBkZWNvZGUgYXVkaW8gZGF0YTogJyArIHVybCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1RvbmUuQnVmZmVyOiBjb3VsZCBub3QgbG9jYXRlIGZpbGU6ICcgKyB1cmwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuXHQgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcblx0ICAgICAgICAgICAgICAgIC8vb25seSBnbyB0byA5NSUsIHRoZSBsYXN0IDUlIGlzIHdoZW4gdGhlIGF1ZGlvIGlzIGRlY29kZWRcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3QucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCAqIDAuOTU7XG5cdCAgICAgICAgICAgICAgICBvblByb2dyZXNzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXF1ZXN0LnNlbmQoKTtcblx0ICAgICAgICByZXR1cm4gcmVxdWVzdDtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCBhbGwgb2YgdGhlIGRvd25sb2FkcyBpbiBwcm9ncmVzc1xuXHRcdCAqICBAcmV0dXJuIHtUb25lLkJ1ZmZlcn1cblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXIuY2FuY2VsRG93bmxvYWRzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQnVmZmVyLl9kb3dubG9hZFF1ZXVlLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCkge1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5fcmVtb3ZlRnJvbURvd25sb2FkUXVldWUocmVxdWVzdCk7XG5cdCAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gVG9uZS5CdWZmZXI7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENoZWNrcyBhIHVybCdzIGV4dGVuc2lvbiB0byBzZWUgaWYgdGhlIGN1cnJlbnQgYnJvd3NlciBjYW4gcGxheSB0aGF0IGZpbGUgdHlwZS5cblx0XHQgKiAgQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgdXJsL2V4dGVuc2lvbiB0byB0ZXN0XG5cdFx0ICogIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWxlIGV4dGVuc2lvbiBjYW4gYmUgcGxheWVkXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLkJ1ZmZlci5zdXBwb3J0c1R5cGUoXCJ3YXZcIik7IC8vcmV0dXJucyB0cnVlXG5cdFx0ICogVG9uZS5CdWZmZXIuc3VwcG9ydHNUeXBlKFwicGF0aC90by9maWxlLndhdlwiKTsgLy9yZXR1cm5zIHRydWVcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgICB2YXIgZXh0ZW5zaW9uID0gdXJsLnNwbGl0KCcuJyk7XG5cdCAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uW2V4dGVuc2lvbi5sZW5ndGggLSAxXTtcblx0ICAgICAgICB2YXIgcmVzcG9uc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpLmNhblBsYXlUeXBlKCdhdWRpby8nICsgZXh0ZW5zaW9uKTtcblx0ICAgICAgICByZXR1cm4gcmVzcG9uc2UgIT09ICcnO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBvZiB0aGUgYnVmZmVycyBoYXZlIGxvYWRlZFxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9ubG9hZCwgb25lcnJvcjtcblx0ICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudHMoKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBldmVudHMgd2hlbiBpdCdzIHJlc29sdmVkXG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9mZignbG9hZCcsIG9ubG9hZCk7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9mZignZXJyb3InLCBvbmVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBmYWlsKSB7XG5cdCAgICAgICAgICAgIG9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgb25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGZhaWwoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgLy9hZGQgdGhlIGV2ZW50IGxpc3RlbmVyc1xuXHQgICAgICAgICAgICBUb25lLkJ1ZmZlci5vbignbG9hZCcsIG9ubG9hZCk7XG5cdCAgICAgICAgICAgIFRvbmUuQnVmZmVyLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXHQgICAgICAgIH0pLnRoZW4ocmVtb3ZlRXZlbnRzKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICByZW1vdmVFdmVudHMoKTtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJ1ZmZlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIGRhdGEgc3RydWN0dXJlIGZvciBob2xkaW5nIG11bHRpcGxlIGJ1ZmZlcnMuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgIHVybHMgICAgICBBbiBvYmplY3QgbGl0ZXJhbCBvciBhcnJheVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB1cmxzIHRvIGxvYWQuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9uPX0gIGNhbGxiYWNrICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvYWQgYSB3aG9sZSBiYW5rIG9mIHBpYW5vIHNhbXBsZXNcblx0XHQgKiB2YXIgcGlhbm9TYW1wbGVzID0gbmV3IFRvbmUuQnVmZmVycyh7XG5cdFx0ICogXHRcIkM0XCIgOiBcInBhdGgvdG8vQzQubXAzXCJcblx0XHQgKiBcdFwiQyM0XCIgOiBcInBhdGgvdG8vQyM0Lm1wM1wiXG5cdFx0ICogXHRcIkQ0XCIgOiBcInBhdGgvdG8vRDQubXAzXCJcblx0XHQgKiBcdFwiRCM0XCIgOiBcInBhdGgvdG8vRCM0Lm1wM1wiXG5cdFx0ICogXHQuLi5cblx0XHQgKiB9LCBmdW5jdGlvbigpe1xuXHRcdCAqIFx0Ly9wbGF5IG9uZSBvZiB0aGUgc2FtcGxlcyB3aGVuIHRoZXkgYWxsIGxvYWRcblx0XHQgKiBcdHBsYXllci5idWZmZXIgPSBwaWFub1NhbXBsZXMuZ2V0KFwiQzRcIik7XG5cdFx0ICogXHRwbGF5ZXIuc3RhcnQoKTtcblx0XHQgKiB9KTtcblx0XHQgKiBcdEBleGFtcGxlXG5cdFx0ICogLy9UbyBwYXNzIGluIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlclxuXHRcdCAqIHZhciBidWZmZXJzID0gbmV3IFRvbmUuQnVmZmVycyh1cmxzLCB7XG5cdFx0ICogXHRcIm9ubG9hZFwiIDogY2FsbGJhY2ssXG5cdFx0ICogXHRcImJhc2VVcmxcIiA6IFwiLi4vcGF0aC90by9hdWRpby9cIlxuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIC8vcmVtb3ZlIHRoZSB1cmxzIGZyb20gdGhlIG9wdGlvbnNcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbXG5cdCAgICAgICAgICAgICdvbmxvYWQnLFxuXHQgICAgICAgICAgICAnYmFzZVVybCdcblx0ICAgICAgICBdLCBUb25lLkJ1ZmZlcnMpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGJ1ZmZlcnNcblx0XHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgcGF0aCB3aGljaCBpcyBwcmVmaXhlZCBiZWZvcmUgZXZlcnkgdXJsLlxuXHRcdFx0ICogIEB0eXBlICB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5iYXNlVXJsID0gb3B0aW9ucy5iYXNlVXJsO1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCA9IDA7XG5cdCAgICAgICAgLy9hZGQgZWFjaCBvbmVcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXJscykge1xuXHQgICAgICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQrKztcblx0ICAgICAgICAgICAgdGhpcy5hZGQoa2V5LCB1cmxzW2tleV0sIHRoaXMuX2J1ZmZlckxvYWRlZC5iaW5kKHRoaXMsIG9wdGlvbnMub25sb2FkKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQnVmZmVycyk7XG5cdCAgICAvKipcblx0XHQgKiAgRGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnYmFzZVVybCc6ICcnXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRydWUgaWYgdGhlIGJ1ZmZlcnMgb2JqZWN0IGhhcyBhIGJ1ZmZlciBieSB0aGF0IG5hbWUuXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xOdW1iZXJ9ICBuYW1lICBUaGUga2V5IG9yIGluZGV4IG9mIHRoZSBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5cblx0XHQgKiAgQHJldHVybiAge0Jvb2xlYW59XG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEdldCBhIGJ1ZmZlciBieSBuYW1lLiBJZiBhbiBhcnJheSB3YXMgbG9hZGVkLCBcblx0XHQgKiAgdGhlbiB1c2UgdGhlIGFycmF5IGluZGV4LlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8TnVtYmVyfSAgbmFtZSAgVGhlIGtleSBvciBpbmRleCBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICBpZiAodGhpcy5oYXMobmFtZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnNbbmFtZV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlcnM6IG5vIGJ1ZmZlciBuYW1lZCAnICsgbmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIGJ1ZmZlciB3YXMgbG9hZGVkLiBkZWNyZW1lbnQgdGhlIGNvdW50ZXIuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLl9idWZmZXJMb2FkZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQtLTtcblx0ICAgICAgICBpZiAodGhpcy5fbG9hZGluZ0NvdW50ID09PSAwICYmIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJZiB0aGUgYnVmZmVycyBhcmUgbG9hZGVkIG9yIG5vdFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlcnMjXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbG9hZGVkXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJzLnByb3RvdHlwZSwgJ2xvYWRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGlzTG9hZGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgYnVmZk5hbWUgaW4gdGhpcy5fYnVmZmVycykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ1ZmYgPSB0aGlzLmdldChidWZmTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpc0xvYWRlZCA9IGlzTG9hZGVkICYmIGJ1ZmYubG9hZGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBpc0xvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBidWZmZXIgYnkgbmFtZSBhbmQgdXJsIHRvIHRoZSBCdWZmZXJzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSAgICAgIEEgdW5pcXVlIG5hbWUgdG8gZ2l2ZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYnVmZmVyXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJ1ZmZlciB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2UgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIGNhbGxiYWNrID0gVG9uZS5kZWZhdWx0QXJnKGNhbGxiYWNrLCBUb25lLm5vT3ApO1xuXHQgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBUb25lLkJ1ZmZlcikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdID0gdXJsO1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKHVybCBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbbmFtZV0gPSBuZXcgVG9uZS5CdWZmZXIodXJsKTtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChUb25lLmlzU3RyaW5nKHVybCkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyc1tuYW1lXSA9IG5ldyBUb25lLkJ1ZmZlcih0aGlzLmJhc2VVcmwgKyB1cmwsIGNhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5CdWZmZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5fYnVmZmVycykge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzW25hbWVdLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQnVmZmVycztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgYnVzZXMgYXJlIGFub3RoZXIgd2F5IG9mIHJvdXRpbmcgYXVkaW9cblx0XHQgKlxuXHRcdCAqICBhdWdtZW50cyBUb25lLnByb3RvdHlwZSB0byBpbmNsdWRlIHNlbmQgYW5kIHJlY2lldmVcblx0XHQgKi9cblx0ICAgIC8qKlxuXHRcdCAgKiAgQWxsIG9mIHRoZSByb3V0ZXNcblx0XHQgICogIFxuXHRcdCAgKiAgQHR5cGUge09iamVjdH1cblx0XHQgICogIEBzdGF0aWNcblx0XHQgICogIEBwcml2YXRlXG5cdFx0ICAqL1xuXHQgICAgdmFyIEJ1c2VzID0ge307XG5cdCAgICAvKipcblx0XHQgKiAgU2VuZCB0aGlzIHNpZ25hbCB0byB0aGUgY2hhbm5lbCBuYW1lLiBcblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSBjaGFubmVsTmFtZSBBIG5hbWVkIGNoYW5uZWwgdG8gc2VuZCB0aGUgc2lnbmFsIHRvLlxuXHRcdCAqICBAcGFyYW0gIHtEZWNpYmVsc30gYW1vdW50IFRoZSBhbW91bnQgb2YgdGhlIHNvdXJjZSB0byBzZW5kIHRvIHRoZSBidXMuIFxuXHRcdCAqICBAcmV0dXJuIHtHYWluTm9kZX0gVGhlIGdhaW4gbm9kZSB3aGljaCBjb25uZWN0cyB0aGlzIG5vZGUgdG8gdGhlIGRlc2lyZWQgY2hhbm5lbC4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICBDYW4gYmUgdXNlZCB0byBhZGp1c3QgdGhlIGxldmVscyBvZiB0aGUgc2VuZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBzb3VyY2Uuc2VuZChcInJldmVyYlwiLCAtMTIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChjaGFubmVsTmFtZSwgYW1vdW50KSB7XG5cdCAgICAgICAgaWYgKCFCdXNlcy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcblx0ICAgICAgICAgICAgQnVzZXNbY2hhbm5lbE5hbWVdID0gdGhpcy5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYW1vdW50ID0gVG9uZS5kZWZhdWx0QXJnKGFtb3VudCwgMCk7XG5cdCAgICAgICAgdmFyIHNlbmRLbm9iID0gbmV3IFRvbmUuR2FpbihhbW91bnQsIFRvbmUuVHlwZS5EZWNpYmVscyk7XG5cdCAgICAgICAgdGhpcy5vdXRwdXQuY2hhaW4oc2VuZEtub2IsIEJ1c2VzW2NoYW5uZWxOYW1lXSk7XG5cdCAgICAgICAgcmV0dXJuIHNlbmRLbm9iO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZWNpZXZlIHRoZSBpbnB1dCBmcm9tIHRoZSBkZXNpcmVkIGNoYW5uZWxOYW1lIHRvIHRoZSBpbnB1dFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gY2hhbm5lbE5hbWUgQSBuYW1lZCBjaGFubmVsIHRvIHNlbmQgdGhlIHNpZ25hbCB0by5cblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyPX0gY2hhbm5lbE51bWJlciBUaGUgY2hhbm5lbCB0byBjb25uZWN0IHRvXG5cdFx0ICogIEByZXR1cm5zIHtUb25lfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcmV2ZXJiRWZmZWN0LnJlY2VpdmUoXCJyZXZlcmJcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLnByb3RvdHlwZS5yZWNlaXZlID0gZnVuY3Rpb24gKGNoYW5uZWxOYW1lLCBpbnB1dE51bSkge1xuXHQgICAgICAgIGlmICghQnVzZXMuaGFzT3duUHJvcGVydHkoY2hhbm5lbE5hbWUpKSB7XG5cdCAgICAgICAgICAgIEJ1c2VzW2NoYW5uZWxOYW1lXSA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIEJ1c2VzW2NoYW5uZWxOYW1lXS5jb25uZWN0KHRoaXMsIDAsIGlucHV0TnVtKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL3JlbW92ZSBhbGwgdGhlIHNlbmQvcmVjZWl2ZXMgd2hlbiBhIG5ldyBhdWRpbyBjb250ZXh0IGlzIHBhc3NlZCBpblxuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dC5CdXNlcykge1xuXHQgICAgICAgICAgICBCdXNlcyA9IGNvbnRleHQuQnVzZXM7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgQnVzZXMgPSB7fTtcblx0ICAgICAgICAgICAgY29udGV4dC5CdXNlcyA9IEJ1c2VzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIFRvbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkRyYXcgaXMgdXNlZnVsIGZvciBzeW5jaHJvbml6aW5nIHZpc3VhbHMgYW5kIGF1ZGlvIGV2ZW50cy5cblx0XHQgKiAgICAgICAgIENhbGxiYWNrcyBmcm9tIFRvbmUuVHJhbnNwb3J0IG9yIGFueSBvZiB0aGUgVG9uZS5FdmVudCBjbGFzc2VzXG5cdFx0ICogICAgICAgICBhbHdheXMgaGFwcGVuIF9iZWZvcmVfIHRoZSBzY2hlZHVsZWQgdGltZSBhbmQgYXJlIG5vdCBzeW5jaHJvbml6ZWRcblx0XHQgKiAgICAgICAgIHRvIHRoZSBhbmltYXRpb24gZnJhbWUgc28gdGhleSBhcmUgbm90IGdvb2QgZm9yIHRyaWdnZXJpbmcgdGlnaHRseVxuXHRcdCAqICAgICAgICAgc3luY2hyb25pemVkIHZpc3VhbHMgYW5kIHNvdW5kLiBUb25lLkRyYXcgbWFrZXMgaXQgZWFzeSB0byBzY2hlZHVsZVxuXHRcdCAqICAgICAgICAgY2FsbGJhY2tzIHVzaW5nIHRoZSBBdWRpb0NvbnRleHQgdGltZSBhbmQgdXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cdFx0ICogICAgICAgICBcblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZShmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vdXNlIHRoZSB0aW1lIGFyZ3VtZW50IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgd2l0aCBUb25lLkRyYXdcblx0XHQgKiBcdFRvbmUuRHJhdy5zY2hlZHVsZShmdW5jdGlvbigpe1xuXHRcdCAqIFx0XHQvL2RvIGRyYXdpbmcgb3IgRE9NIG1hbmlwdWxhdGlvbiBoZXJlXG5cdFx0ICogXHR9LCB0aW1lKVxuXHRcdCAqIH0sIFwiKzAuNVwiKVxuXHRcdCAqL1xuXHQgICAgVG9uZS5EcmF3ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbGwgb2YgdGhlIGV2ZW50cy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVGltZWxpbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBUb25lLlRpbWVsaW5lKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGR1cmF0aW9uIGFmdGVyIHdoaWNoIGV2ZW50cyBhcmUgbm90IGludm9rZWQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQGRlZmF1bHQgMC4yNVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gMC4yNTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHRpbWUgYmVmb3JlIHRoZSBzY2hlZHVsZWQgdGltZSBcblx0XHRcdCAqICB0aGF0IHRoZSBjYWxsYmFjayBjYW4gYmUgaW52b2tlZC4gRGVmYXVsdCBpc1xuXHRcdFx0ICogIGhhbGYgdGhlIHRpbWUgb2YgYW4gYW5pbWF0aW9uIGZyYW1lICgwLjAwOCBzZWNvbmRzKS5cblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAZGVmYXVsdCAwLjAwOFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hbnRpY2lwYXRpb24gPSAwLjAwODtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0XHQgKiAgQHR5cGUgIHtGdW5jdGlvbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYm91bmREcmF3TG9vcCA9IHRoaXMuX2RyYXdMb29wLmJpbmQodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5EcmF3KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTY2hlZHVsZSBhIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiB0aW1lIHRvIGJlIGludm9rZWRcblx0XHQgKiAgb24gdGhlIG5lYXJlc3QgYW5pbWF0aW9uIGZyYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBDYWxsYmFjayBpcyBpbnZva2VkIGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgICB0aW1lICAgICAgVGhlIHRpbWUgcmVsYXRpdmUgdG8gdGhlIEF1ZGlvQ29udGV4dCB0aW1lXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBpbnZva2UgdGhlIGNhbGxiYWNrLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5EcmF3fSAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmFkZCh7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcblx0ICAgICAgICAgICAgdGltZTogdGhpcy50b1NlY29uZHModGltZSlcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBkcmF3IGxvb3Agb24gdGhlIGZpcnN0IGV2ZW50XG5cdCAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kRHJhd0xvb3ApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGV2ZW50cyBzY2hlZHVsZWQgYWZ0ZXIgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBhZnRlciAgVGltZSBhZnRlciB3aGljaCBzY2hlZHVsZWQgZXZlbnRzIHdpbGwgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIGJlIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGluZyB0aW1lbGluZS5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRHJhd30gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRHJhdy5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLmNhbmNlbCh0aGlzLnRvU2Vjb25kcyhhZnRlcikpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZHJhdyBsb29wXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkRyYXcucHJvdG90eXBlLl9kcmF3TG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgbm93ID0gVG9uZS5ub3coKTtcblx0ICAgICAgICB3aGlsZSAodGhpcy5fZXZlbnRzLmxlbmd0aCAmJiB0aGlzLl9ldmVudHMucGVlaygpLnRpbWUgLSB0aGlzLmFudGljaXBhdGlvbiA8PSBub3cpIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5fZXZlbnRzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgIGlmIChub3cgLSBldmVudC50aW1lIDw9IHRoaXMuZXhwaXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kRHJhd0xvb3ApO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvL21ha2UgYSBzaW5nbGV0b25cblx0ICAgIFRvbmUuRHJhdyA9IG5ldyBUb25lLkRyYXcoKTtcblx0ICAgIHJldHVybiBUb25lLkRyYXc7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQm90aCBUb25lLlBhbm5lcjNEIGFuZCBUb25lLkxpc3RlbmVyIGhhdmUgYSBwb3NpdGlvbiBpbiAzRCBzcGFjZSBcblx0XHQgKiAgICAgICAgICB1c2luZyBhIHJpZ2h0LWhhbmRlZCBjYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW0uIFxuXHRcdCAqICAgICAgICAgIFRoZSB1bml0cyB1c2VkIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbSBhcmUgbm90IGRlZmluZWQ7IFxuXHRcdCAqICAgICAgICAgIHRoZXNlIGNvb3JkaW5hdGVzIGFyZSBpbmRlcGVuZGVudC9pbnZhcmlhbnQgb2YgYW55IHBhcnRpY3VsYXIgXG5cdFx0ICogICAgICAgICAgdW5pdHMgc3VjaCBhcyBtZXRlcnMgb3IgZmVldC4gVG9uZS5QYW5uZXIzRCBvYmplY3RzIGhhdmUgYW4gZm9yd2FyZCBcblx0XHQgKiAgICAgICAgICB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gdGhlIHNvdW5kIGlzIHByb2plY3RpbmcuIEFkZGl0aW9uYWxseSwgXG5cdFx0ICogICAgICAgICAgdGhleSBoYXZlIGEgc291bmQgY29uZSByZXByZXNlbnRpbmcgaG93IGRpcmVjdGlvbmFsIHRoZSBzb3VuZCBpcy4gXG5cdFx0ICogICAgICAgICAgRm9yIGV4YW1wbGUsIHRoZSBzb3VuZCBjb3VsZCBiZSBvbW5pZGlyZWN0aW9uYWwsIGluIHdoaWNoIGNhc2UgaXQgd291bGQgXG5cdFx0ICogICAgICAgICAgYmUgaGVhcmQgYW55d2hlcmUgcmVnYXJkbGVzcyBvZiBpdHMgZm9yd2FyZCwgb3IgaXQgY2FuIGJlIG1vcmUgZGlyZWN0aW9uYWwgXG5cdFx0ICogICAgICAgICAgYW5kIGhlYXJkIG9ubHkgaWYgaXQgaXMgZmFjaW5nIHRoZSBsaXN0ZW5lci4gVG9uZS5MaXN0ZW5lciBvYmplY3RzIFxuXHRcdCAqICAgICAgICAgIChyZXByZXNlbnRpbmcgYSBwZXJzb24ncyBlYXJzKSBoYXZlIGFuIGZvcndhcmQgYW5kIHVwIHZlY3RvciBcblx0XHQgKiAgICAgICAgICByZXByZXNlbnRpbmcgaW4gd2hpY2ggZGlyZWN0aW9uIHRoZSBwZXJzb24gaXMgZmFjaW5nLiBCZWNhdXNlIGJvdGggdGhlIFxuXHRcdCAqICAgICAgICAgIHNvdXJjZSBzdHJlYW0gYW5kIHRoZSBsaXN0ZW5lciBjYW4gYmUgbW92aW5nLCB0aGV5IGJvdGggaGF2ZSBhIHZlbG9jaXR5IFxuXHRcdCAqICAgICAgICAgIHZlY3RvciByZXByZXNlbnRpbmcgYm90aCB0aGUgc3BlZWQgYW5kIGRpcmVjdGlvbiBvZiBtb3ZlbWVudC4gVGFrZW4gdG9nZXRoZXIsIFxuXHRcdCAqICAgICAgICAgIHRoZXNlIHR3byB2ZWxvY2l0aWVzIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgZG9wcGxlciBzaGlmdCBlZmZlY3Qgd2hpY2ggY2hhbmdlcyB0aGUgcGl0Y2guXG5cdFx0ICogICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgICBOb3RlOiB0aGUgcG9zaXRpb24gb2YgdGhlIExpc3RlbmVyIHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gbm9kZXMgbm90IGNvbm5lY3RlZCB0byBhIFRvbmUuUGFubmVyM0Rcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZX1cblx0XHQgKiAgQHNpbmdsZXRvblxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSG9sZHMgdGhlIGN1cnJlbnQgZm9yd2FyZCBvcmllbnRhdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gW1xuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwXG5cdCAgICAgICAgXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkcyB0aGUgY3VycmVudCBwb3NpdGlvblxuXHRcdFx0ICogIEB0eXBlICB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gW1xuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICAwXG5cdCAgICAgICAgXTtcblx0ICAgICAgICBUb25lLmdldENvbnRleHQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBzZXQgdGhlIGRlZmF1bHQgcG9zaXRpb24vZm9yd2FyZFxuXHQgICAgICAgICAgICB0aGlzLnNldChMaXN0ZW5lckNvbnN0cnVjdG9yLmRlZmF1bHRzKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTGlzdGVuZXIpO1xuXHQgICAgLyoqXG5cdFx0ICogIERlZmF1bHRzIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9zaXRpb25YJzogMCxcblx0ICAgICAgICAncG9zaXRpb25ZJzogMCxcblx0ICAgICAgICAncG9zaXRpb25aJzogMCxcblx0ICAgICAgICAnZm9yd2FyZFgnOiAwLFxuXHQgICAgICAgICdmb3J3YXJkWSc6IDAsXG5cdCAgICAgICAgJ2ZvcndhcmRaJzogMSxcblx0ICAgICAgICAndXBYJzogMCxcblx0ICAgICAgICAndXBZJzogMSxcblx0ICAgICAgICAndXBaJzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSByYW1wIHRpbWUgd2hpY2ggaXMgYXBwbGllZCB0byB0aGUgc2V0VGFyZ2V0QXRUaW1lXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUuX3JhbXBUaW1lQ29uc3RhbnQgPSAwLjAxO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaXN0ZW5lciBpbiAzZCBzcGFjZS5cdFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB4XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgelxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkxpc3RlbmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxpc3RlbmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblkuc2V0VGFyZ2V0QXRUaW1lKHksIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5wb3NpdGlvblouc2V0VGFyZ2V0QXRUaW1lKHosIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLnNldFBvc2l0aW9uKHgsIHksIHopO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldHMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBsaXN0ZW5lciB1c2luZyB0d28gdmVjdG9ycywgdGhlIGZvcndhcmRcblx0XHQgKiAgdmVjdG9yICh3aGljaCBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIGZhY2luZykgYW5kIHRoZSB1cCB2ZWN0b3IgXG5cdFx0ICogICh3aGljaCB0aGUgdXAgZGlyZWN0aW9uIG9mIHRoZSBsaXN0ZW5lcikuIEFuIHVwIHZlY3RvclxuXHRcdCAqICBvZiAwLCAwLCAxIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGxpc3RlbmVyIHN0YW5kaW5nIHVwIGluIHRoZSBaIGRpcmVjdGlvbi4gXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHhcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgeVxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB6XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHVwWFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB1cFlcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdXBaXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuTGlzdGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLnNldE9yaWVudGF0aW9uID0gZnVuY3Rpb24gKHgsIHksIHosIHVwWCwgdXBZLCB1cFopIHtcblx0ICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRYKSB7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIuZm9yd2FyZFguc2V0VGFyZ2V0QXRUaW1lKHgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5mb3J3YXJkWS5zZXRUYXJnZXRBdFRpbWUoeSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRaLnNldFRhcmdldEF0VGltZSh6LCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubGlzdGVuZXIudXBYLnNldFRhcmdldEF0VGltZSh1cFgsIG5vdywgdGhpcy5fcmFtcFRpbWVDb25zdGFudCk7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci51cFkuc2V0VGFyZ2V0QXRUaW1lKHVwWSwgbm93LCB0aGlzLl9yYW1wVGltZUNvbnN0YW50KTtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZXh0Lmxpc3RlbmVyLnVwWi5zZXRUYXJnZXRBdFRpbWUodXBaLCBub3csIHRoaXMuX3JhbXBUaW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuY29udGV4dC5saXN0ZW5lci5zZXRPcmllbnRhdGlvbih4LCB5LCB6LCB1cFgsIHVwWSwgdXBaKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcGFubmVyIG9iamVjdC5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHBvc2l0aW9uWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAncG9zaXRpb25YJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwYW5uZXIgb2JqZWN0LlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgcG9zaXRpb25ZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdwb3NpdGlvblknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX3Bvc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogcG9zaXRpb24gb2YgdGhlIHBhbm5lciBvYmplY3QuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBwb3NpdGlvblpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3Bvc2l0aW9uWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgdGhpcy5fcG9zaXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcnMgZnJvbnQgZGlyZWN0aW9uLiBpLmUuIFxuXHRcdCAqICB3aGljaCB3YXkgdGhleSBhcmUgZmFjaW5nLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgZm9yd2FyZFhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ2ZvcndhcmRYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblswXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzBdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVycyBmcm9udCBkaXJlY3Rpb24uIGkuZS4gXG5cdFx0ICogIHdoaWNoIHdheSB0aGV5IGFyZSBmYWNpbmcuXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSBmb3J3YXJkWVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAnZm9yd2FyZFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzFdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bMV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXJzIGZyb250IGRpcmVjdGlvbi4gaS5lLiBcblx0XHQgKiAgd2hpY2ggd2F5IHRoZXkgYXJlIGZhY2luZy5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIGZvcndhcmRaXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICdmb3J3YXJkWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bMl0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvblsyXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsaXN0ZW5lcidzIHVwIGRpcmVjdGlvbi4gaS5lLlxuXHRcdCAqICB0aGUgZGlyZWN0aW9uIHRoZSBsaXN0ZW5lciBpcyBzdGFuZGluZyBpbi5cblx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTGlzdGVuZXIjXG5cdFx0ICogIEBuYW1lIHVwWFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLCAndXBYJywge1xuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBvcykge1xuXHQgICAgICAgICAgICB0aGlzLl9vcmllbnRhdGlvblszXSA9IHBvcztcblx0ICAgICAgICAgICAgdGhpcy5zZXRPcmllbnRhdGlvbi5hcHBseSh0aGlzLCB0aGlzLl9vcmllbnRhdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uWzNdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGxpc3RlbmVyJ3MgdXAgZGlyZWN0aW9uLiBpLmUuXG5cdFx0ICogIHRoZSBkaXJlY3Rpb24gdGhlIGxpc3RlbmVyIGlzIHN0YW5kaW5nIGluLlxuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5MaXN0ZW5lciNcblx0XHQgKiAgQG5hbWUgdXBZXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5MaXN0ZW5lci5wcm90b3R5cGUsICd1cFknLCB7XG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocG9zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yaWVudGF0aW9uWzRdID0gcG9zO1xuXHQgICAgICAgICAgICB0aGlzLnNldE9yaWVudGF0aW9uLmFwcGx5KHRoaXMsIHRoaXMuX29yaWVudGF0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb25bNF07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHogY29vcmRpbmF0ZSBvZiB0aGUgbGlzdGVuZXIncyB1cCBkaXJlY3Rpb24uIGkuZS5cblx0XHQgKiAgdGhlIGRpcmVjdGlvbiB0aGUgbGlzdGVuZXIgaXMgc3RhbmRpbmcgaW4uXG5cdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxpc3RlbmVyI1xuXHRcdCAqICBAbmFtZSB1cFpcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxpc3RlbmVyLnByb3RvdHlwZSwgJ3VwWicsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwb3MpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb25bNV0gPSBwb3M7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3JpZW50YXRpb24uYXBwbHkodGhpcywgdGhpcy5fb3JpZW50YXRpb24pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbls1XTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTGlzdGVuZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTGlzdGVuZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvL1NJTkdMRVRPTiBTRVRVUFxuXHQgICAgdmFyIExpc3RlbmVyQ29uc3RydWN0b3IgPSBUb25lLkxpc3RlbmVyO1xuXHQgICAgVG9uZS5MaXN0ZW5lciA9IG5ldyBMaXN0ZW5lckNvbnN0cnVjdG9yKCk7XG5cdCAgICBUb25lLkNvbnRleHQub24oJ2luaXQnLCBmdW5jdGlvbiAoY29udGV4dCkge1xuXHQgICAgICAgIGlmIChjb250ZXh0Lkxpc3RlbmVyIGluc3RhbmNlb2YgTGlzdGVuZXJDb25zdHJ1Y3Rvcikge1xuXHQgICAgICAgICAgICAvL2Egc2luZ2xlIGxpc3RlbmVyIG9iamVjdFxuXHQgICAgICAgICAgICBUb25lLkxpc3RlbmVyID0gY29udGV4dC5MaXN0ZW5lcjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL21ha2UgbmV3IExpc3RlbmVyIGluc2lkZXNcblx0ICAgICAgICAgICAgVG9uZS5MaXN0ZW5lciA9IG5ldyBMaXN0ZW5lckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbnRleHQuTGlzdGVuZXIgPSBUb25lLkxpc3RlbmVyO1xuXHQgICAgfSk7XG5cdCAgICAvL0VORCBTSU5HTEVUT04gU0VUVVBcblx0ICAgIHJldHVybiBUb25lLkxpc3RlbmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgc2hpbVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgaWYgKCF3aW5kb3cuaGFzT3duUHJvcGVydHkoJ09mZmxpbmVBdWRpb0NvbnRleHQnKSAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ3dlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQnKSkge1xuXHQgICAgICAgIHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0ID0gd2luZG93LndlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHQ7XG5cdCAgICB9XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFdyYXBwZXIgYXJvdW5kIHRoZSBPZmZsaW5lQXVkaW9Db250ZXh0XG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkNvbnRleHR9XG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIGNoYW5uZWxzICBUaGUgbnVtYmVyIG9mIGNoYW5uZWxzIHRvIHJlbmRlclxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBkdXJhdGlvbiAgVGhlIGR1cmF0aW9uIHRvIHJlbmRlciBpbiBzYW1wbGVzXG5cdFx0ICogIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIHRoZSBzYW1wbGUgcmF0ZSB0byByZW5kZXIgYXRcblx0XHQgKi9cblx0ICAgIFRvbmUuT2ZmbGluZUNvbnRleHQgPSBmdW5jdGlvbiAoY2hhbm5lbHMsIGR1cmF0aW9uLCBzYW1wbGVSYXRlKSB7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9mZmxpbmUgY29udGV4dFxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtPZmZsaW5lQXVkaW9Db250ZXh0fVxuXHRcdFx0ICovXG5cdCAgICAgICAgdmFyIG9mZmxpbmVDb250ZXh0ID0gbmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoY2hhbm5lbHMsIGR1cmF0aW9uICogc2FtcGxlUmF0ZSwgc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgLy93cmFwIHRoZSBtZXRob2RzL21lbWJlcnNcblx0ICAgICAgICBUb25lLkNvbnRleHQuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgICdjb250ZXh0Jzogb2ZmbGluZUNvbnRleHQsXG5cdCAgICAgICAgICAgICdjbG9ja1NvdXJjZSc6ICdvZmZsaW5lJyxcblx0ICAgICAgICAgICAgJ2xvb2tBaGVhZCc6IDAsXG5cdCAgICAgICAgICAgICd1cGRhdGVJbnRlcnZhbCc6IDEyOCAvIHNhbXBsZVJhdGVcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBIHByaXZhdGUgcmVmZXJlbmNlIHRvIHRoZSBkdXJhdGlvblxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEFuIGFydGlmaWNpYWwgY2xvY2sgc291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9mZmxpbmVDb250ZXh0LCBUb25lLkNvbnRleHQpO1xuXHQgICAgLyoqXG5cdFx0ICogIE92ZXJyaWRlIHRoZSBub3cgbWV0aG9kIHRvIHBvaW50IHRvIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lXG5cdFx0ICogIEByZXR1cm4gIHtOdW1iZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaW1lO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW5kZXIgdGhlIG91dHB1dCBvZiB0aGUgT2ZmbGluZUNvbnRleHRcblx0XHQgKiAgQHJldHVybiAge1Byb21pc2V9XG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmVDb250ZXh0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgd2hpbGUgKHRoaXMuX2R1cmF0aW9uIC0gdGhpcy5fY3VycmVudFRpbWUgPj0gMCkge1xuXHQgICAgICAgICAgICAvL2ludm9rZSBhbGwgdGhlIGNhbGxiYWNrcyBvbiB0aGF0IHRpbWVcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCd0aWNrJyk7XG5cdCAgICAgICAgICAgIC8vaW5jcmVtZW50IHRoZSBjbG9ja1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSB0aGlzLmJsb2NrVGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9wcm9taXNlIHJldHVybmVkIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gYWxsIGJyb3dzZXJzXG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChkb25lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NvbnRleHQub25jb21wbGV0ZSA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgICAgICBkb25lKGUucmVuZGVyZWRCdWZmZXIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0YXJ0UmVuZGVyaW5nKCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xvc2UgdGhlIGNvbnRleHRcblx0XHQgKiAgQHJldHVybiAge051bWJlcn1cblx0XHQgKi9cblx0ICAgIFRvbmUuT2ZmbGluZUNvbnRleHQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9mZmxpbmVDb250ZXh0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICAvKipcblx0XHQgKiAgR2VuZXJhdGUgYSBidWZmZXIgYnkgcmVuZGVyaW5nIGFsbCBvZiB0aGUgVG9uZS5qcyBjb2RlIHdpdGhpbiB0aGUgY2FsbGJhY2sgdXNpbmcgdGhlIE9mZmxpbmVBdWRpb0NvbnRleHQuIFxuXHRcdCAqICBUaGUgT2ZmbGluZUF1ZGlvQ29udGV4dCBpcyBjYXBhYmxlIG9mIHJlbmRlcmluZyBtdWNoIGZhc3RlciB0aGFuIHJlYWwgdGltZSBpbiBtYW55IGNhc2VzLiBcblx0XHQgKiAgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFsc28gcGFzc2VzIGluIGFuIG9mZmxpbmUgaW5zdGFuY2Ugb2YgVG9uZS5UcmFuc3BvcnQgd2hpY2ggY2FuIGJlIHVzZWRcblx0XHQgKiAgdG8gc2NoZWR1bGUgZXZlbnRzIGFsb25nIHRoZSBUcmFuc3BvcnQuIFxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGNhbGxiYWNrICBBbGwgVG9uZS5qcyBub2RlcyB3aGljaCBhcmUgY3JlYXRlZCBhbmQgc2NoZWR1bGVkIHdpdGhpbiB0aGlzIGNhbGxiYWNrIGFyZSByZWNvcmRlZCBpbnRvIHRoZSBvdXRwdXQgQnVmZmVyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgZHVyYXRpb24gICAgIHRoZSBhbW91bnQgb2YgdGltZSB0byByZWNvcmQgZm9yLlxuXHRcdCAqICBAcmV0dXJuICB7UHJvbWlzZX0gIFRoZSBwcm9taXNlIHdoaWNoIGlzIGludm9rZWQgd2l0aCB0aGUgVG9uZS5CdWZmZXIgb2YgdGhlIHJlY29yZGVkIG91dHB1dC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3JlbmRlciAyIHNlY29uZHMgb2YgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiBUb25lLk9mZmxpbmUoZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vb25seSBub2RlcyBjcmVhdGVkIGluIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSByZWNvcmRlZFxuXHRcdCAqIFx0dmFyIG9zY2lsbGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKS5zdGFydCgwKVxuXHRcdCAqIFx0Ly9zY2hlZHVsZSB0aGVpciBldmVudHNcblx0XHQgKiB9LCAyKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlcil7XG5cdFx0ICogXHQvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSBvdXRwdXQgYnVmZmVyXG5cdFx0ICogfSlcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2FuIGFsc28gc2NoZWR1bGUgZXZlbnRzIGFsb25nIHRoZSBUcmFuc3BvcnRcblx0XHQgKiAvL3VzaW5nIHRoZSBwYXNzZWQgaW4gT2ZmbGluZSBUcmFuc3BvcnRcblx0XHQgKiBUb25lLk9mZmxpbmUoZnVuY3Rpb24oVHJhbnNwb3J0KXtcblx0XHQgKiBcdHZhciBvc2MgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKCkudG9NYXN0ZXIoKVxuXHRcdCAqIFx0VHJhbnNwb3J0LnNjaGVkdWxlKGZ1bmN0aW9uKHRpbWUpe1xuXHRcdCAqIFx0XHRvc2Muc3RhcnQodGltZSkuc3RvcCh0aW1lICsgMC4xKVxuXHRcdCAqIFx0fSwgMSlcblx0XHQgKiBcdFRyYW5zcG9ydC5zdGFydCgwLjIpXG5cdFx0ICogfSwgNCkudGhlbihmdW5jdGlvbihidWZmZXIpe1xuXHRcdCAqIFx0Ly9kbyBzb21ldGhpbmcgd2l0aCB0aGUgb3V0cHV0IGJ1ZmZlclxuXHRcdCAqIH0pXG5cdFx0ICovXG5cdCAgICBUb25lLk9mZmxpbmUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgLy9zZXQgdGhlIE9mZmxpbmVBdWRpb0NvbnRleHRcblx0ICAgICAgICB2YXIgc2FtcGxlUmF0ZSA9IFRvbmUuY29udGV4dC5zYW1wbGVSYXRlO1xuXHQgICAgICAgIHZhciBvcmlnaW5hbENvbnRleHQgPSBUb25lLmNvbnRleHQ7XG5cdCAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgVG9uZS5PZmZsaW5lQ29udGV4dCgyLCBkdXJhdGlvbiwgc2FtcGxlUmF0ZSk7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gY29udGV4dDtcblx0ICAgICAgICAvL2ludm9rZSB0aGUgY2FsbGJhY2svc2NoZWR1bGluZ1xuXHQgICAgICAgIGNhbGxiYWNrKFRvbmUuVHJhbnNwb3J0KTtcblx0ICAgICAgICAvL3Byb2Nlc3MgdGhlIGF1ZGlvXG5cdCAgICAgICAgdmFyIHJlbmRlcmVkID0gY29udGV4dC5yZW5kZXIoKTtcblx0ICAgICAgICAvL3JldHVybiB0aGUgb3JpZ2luYWwgQXVkaW9Db250ZXh0XG5cdCAgICAgICAgVG9uZS5jb250ZXh0ID0gb3JpZ2luYWxDb250ZXh0O1xuXHQgICAgICAgIC8vcmV0dXJuIHRoZSBhdWRpb1xuXHQgICAgICAgIHJldHVybiByZW5kZXJlZC50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgLy93cmFwIGl0IGluIGEgVG9uZS5CdWZmZXJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBUb25lLkJ1ZmZlcihidWZmZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk9mZmxpbmU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogXHRAY2xhc3MgIFRvbmUuRWZmZWN0IGlzIHRoZSBiYXNlIGNsYXNzIGZvciBlZmZlY3RzLiBDb25uZWN0IHRoZSBlZmZlY3QgYmV0d2VlblxuXHRcdCAqIFx0ICAgICAgICB0aGUgZWZmZWN0U2VuZCBhbmQgZWZmZWN0UmV0dXJuIEdhaW5Ob2RlcywgdGhlbiBjb250cm9sIHRoZSBhbW91bnQgb2Zcblx0XHQgKiBcdCAgICAgICAgZWZmZWN0IHdoaWNoIGdvZXMgdG8gdGhlIG91dHB1dCB1c2luZyB0aGUgd2V0IGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFt3ZXRdIFRoZSBzdGFydGluZyB3ZXQgdmFsdWUuXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3dldCddLCBUb25lLkVmZmVjdCk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNyZWF0ZUluc091dHMoMSwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRyeXdldCBrbm9iIHRvIGNvbnRyb2wgdGhlIGFtb3VudCBvZiBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RyeVdldCA9IG5ldyBUb25lLkNyb3NzRmFkZShvcHRpb25zLndldCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdldCBjb250cm9sIGlzIGhvdyBtdWNoIG9mIHRoZSBlZmZlY3RlZFxuXHRcdFx0ICogIHdpbGwgcGFzcyB0aHJvdWdoIHRvIHRoZSBvdXRwdXQuIDEgPSAxMDAlIGVmZmVjdGVkXG5cdFx0XHQgKiAgc2lnbmFsLCAwID0gMTAwJSBkcnkgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLndldCA9IHRoaXMuX2RyeVdldC5mYWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbm5lY3QgdGhlIGVmZmVjdFNlbmQgdG8gdGhlIGlucHV0IG9mIGh0ZSBlZmZlY3Rcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29ubmVjdCB0aGUgb3V0cHV0IG9mIHRoZSBlZmZlY3QgdG8gdGhlIGVmZmVjdFJldHVyblxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fZHJ5V2V0LmEpO1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLmVmZmVjdFNlbmQpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuLmNvbm5lY3QodGhpcy5fZHJ5V2V0LmIpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3dldCddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkVmZmVjdCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRWZmZWN0LmRlZmF1bHRzID0geyAnd2V0JzogMSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNoYWlucyB0aGUgZWZmZWN0IGluIGJldHdlZW4gdGhlIGVmZmVjdFNlbmQgYW5kIGVmZmVjdFJldHVyblxuXHRcdCAqICBAcGFyYW0gIHtUb25lfSBlZmZlY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuY29ubmVjdEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3QpIHtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY2hhaW4oZWZmZWN0LCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5FZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVybi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2V0J10pO1xuXHQgICAgICAgIHRoaXMud2V0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5FZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkF1dG9GaWx0ZXIgaXMgYSBUb25lLkZpbHRlciB3aXRoIGEgVG9uZS5MRk8gY29ubmVjdGVkIHRvIHRoZSBmaWx0ZXIgY3V0b2ZmIGZyZXF1ZW5jeS5cblx0XHQgKiAgICAgICAgIFNldHRpbmcgdGhlIExGTyByYXRlIGFuZCBkZXB0aCBhbGxvd3MgZm9yIGNvbnRyb2wgb3ZlciB0aGUgZmlsdGVyIG1vZHVsYXRpb24gcmF0ZSBcblx0XHQgKiAgICAgICAgIGFuZCBkZXB0aC5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge1RpbWV8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgcmF0ZSBvZiB0aGUgTEZPLlxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IGJhc2VGcmVxdWVuY3kgVGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBMRk9zIG9zY2lsbGF0aW9uXG5cdCBcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeT19IG9jdGF2ZXMgVGhlIG51bWJlciBvZiBvY3RhdmVzIGFib3ZlIHRoZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9jcmVhdGUgYW4gYXV0b2ZpbHRlciBhbmQgc3RhcnQgaXQncyBMRk9cblx0XHQgKiB2YXIgYXV0b0ZpbHRlciA9IG5ldyBUb25lLkF1dG9GaWx0ZXIoXCI0blwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICogLy9yb3V0ZSBhbiBvc2NpbGxhdG9yIHRocm91Z2ggdGhlIGZpbHRlciBhbmQgc3RhcnQgaXRcblx0XHQgKiB2YXIgb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KGF1dG9GaWx0ZXIpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcydcblx0ICAgICAgICBdLCBUb25lLkF1dG9GaWx0ZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBkcml2ZXMgdGhlIGZpbHRlciBjdXRvZmZcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZSc6IG9wdGlvbnMuZGVwdGhcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSByYW5nZSBvZiB0aGUgZmlsdGVyIG1vZHVsYXRpbmcgYmV0d2VlbiB0aGUgbWluIGFuZCBtYXggZnJlcXVlbmN5LiBcblx0XHRcdCAqIDAgPSBubyBtb2R1bGF0aW9uLiAxID0gZnVsbCBtb2R1bGF0aW9uLlxuXHRcdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBIb3cgZmFzdCB0aGUgZmlsdGVyIG1vZHVsYXRlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LiBcblx0XHRcdCAqIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpbHRlciBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRmlsdGVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgVG9uZS5GaWx0ZXIob3B0aW9ucy5maWx0ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvY3RhdmVzIHBsYWNlaG9sZGVyXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gMDtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuZmlsdGVyKTtcblx0ICAgICAgICB0aGlzLl9sZm8uY29ubmVjdCh0aGlzLmZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIHRoaXMuYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgIH07XG5cdCAgICAvL2V4dGVuZCBFZmZlY3Rcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b0ZpbHRlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAxLFxuXHQgICAgICAgICdiYXNlRnJlcXVlbmN5JzogMjAwLFxuXHQgICAgICAgICdvY3RhdmVzJzogMi42LFxuXHQgICAgICAgICdmaWx0ZXInOiB7XG5cdCAgICAgICAgICAgICd0eXBlJzogJ2xvd3Bhc3MnLFxuXHQgICAgICAgICAgICAncm9sbG9mZic6IC0xMixcblx0ICAgICAgICAgICAgJ1EnOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN0YXJ0IHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0YXJ0LiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3RhcnQodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCB0aGUgZWZmZWN0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBMRk8gd2lsbCBzdG9wLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFN5bmMgdGhlIGZpbHRlciB0byB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW2RlbGF5PTBdIERlbGF5IHRpbWUgYmVmb3JlIHN0YXJ0aW5nIHRoZSBlZmZlY3QgYWZ0ZXIgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLiBcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvRmlsdGVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9GaWx0ZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9sZm8uc3luYyhkZWxheSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVW5zeW5jIHRoZSBmaWx0ZXIgZnJvbSB0aGUgdHJhbnNwb3J0LlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUudW5zeW5jID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2xmby51bnN5bmMoKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUeXBlIG9mIG9zY2lsbGF0b3IgYXR0YWNoZWQgdG8gdGhlIEF1dG9GaWx0ZXIuIFxuXHRcdCAqIFBvc3NpYmxlIHZhbHVlczogXCJzaW5lXCIsIFwic3F1YXJlXCIsIFwidHJpYW5nbGVcIiwgXCJzYXd0b290aFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkF1dG9GaWx0ZXIjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BdXRvRmlsdGVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm8udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIGZpbHRlcidzIGN1dG9mZiBmcmVxdWVuY3kuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBuYW1lIG1pblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdiYXNlRnJlcXVlbmN5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGZyZXEpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvLm1pbiA9IHRoaXMudG9GcmVxdWVuY3koZnJlcSk7XG5cdCAgICAgICAgICAgIC8vYW5kIHNldCB0aGUgbWF4XG5cdCAgICAgICAgICAgIHRoaXMub2N0YXZlcyA9IHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgZmlsdGVyJ3MgY3V0b2ZmIGZyZXF1ZW5jeS4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b0ZpbHRlciNcblx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdCkge1xuXHQgICAgICAgICAgICB0aGlzLl9vY3RhdmVzID0gb2N0O1xuXHQgICAgICAgICAgICB0aGlzLl9sZm8ubWF4ID0gdGhpcy5iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgb2N0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b0ZpbHRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b0ZpbHRlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQXV0b1Bhbm5lciBpcyBhIFRvbmUuUGFubmVyIHdpdGggYW4gTEZPIGNvbm5lY3RlZCB0byB0aGUgcGFuIGFtb3VudC4gXG5cdFx0ICogICAgICAgICBNb3JlIG9uIHVzaW5nIGF1dG9wYW5uZXJzIFtoZXJlXShodHRwczovL3d3dy5hYmxldG9uLmNvbS9lbi9ibG9nL2F1dG9wYW4tY2hvcHBlci1lZmZlY3QtYW5kLW1vcmUtbGl2ZXNjaG9vbC8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FZmZlY3R9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fE9iamVjdH0gW2ZyZXF1ZW5jeV0gUmF0ZSBvZiBsZWZ0LXJpZ2h0IG9zY2lsbGF0aW9uLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhbiBhdXRvcGFubmVyIGFuZCBzdGFydCBpdCdzIExGT1xuXHRcdCAqIHZhciBhdXRvUGFubmVyID0gbmV3IFRvbmUuQXV0b1Bhbm5lcihcIjRuXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKiAvL3JvdXRlIGFuIG9zY2lsbGF0b3IgdGhyb3VnaCB0aGUgcGFubmVyIGFuZCBzdGFydCBpdFxuXHRcdCAqIHZhciBvc2NpbGxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcigpLmNvbm5lY3QoYXV0b1Bhbm5lcikuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZyZXF1ZW5jeSddLCBUb25lLkF1dG9QYW5uZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBkcml2ZXMgdGhlIHBhbm5pbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2FtcGxpdHVkZSc6IG9wdGlvbnMuZGVwdGgsXG5cdCAgICAgICAgICAgICdtaW4nOiAtMSxcblx0ICAgICAgICAgICAgJ21heCc6IDFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBhbW91bnQgb2YgcGFubmluZyBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0LiBcblx0XHRcdCAqIDAgPSBhbHdheXMgY2VudGVyLiAxID0gZnVsbCByYW5nZSBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0LiBcblx0XHRcdCAqIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLl9sZm8uYW1wbGl0dWRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwYW5uZXIgbm9kZSB3aGljaCBkb2VzIHRoZSBwYW5uaW5nXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUGFubmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBuZXcgVG9uZS5QYW5uZXIoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIEhvdyBmYXN0IHRoZSBwYW5uZXIgbW9kdWxhdGVzIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQuIFxuXHRcdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX3Bhbm5lcik7XG5cdCAgICAgICAgdGhpcy5fbGZvLmNvbm5lY3QodGhpcy5fcGFubmVyLnBhbik7XG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2RlcHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICAvL2V4dGVuZCBFZmZlY3Rcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b1Bhbm5lciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHRzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnZGVwdGgnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RhcnQgdGhlIGVmZmVjdC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gV2hlbiB0aGUgTEZPIHdpbGwgc3RhcnQuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIHRoZSBlZmZlY3QuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIExGTyB3aWxsIHN0b3AuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvLnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3luYyB0aGUgcGFubmVyIHRvIHRoZSB0cmFuc3BvcnQuXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbZGVsYXk9MF0gRGVsYXkgdGltZSBiZWZvcmUgc3RhcnRpbmcgdGhlIGVmZmVjdCBhZnRlciB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc3BvcnQgaGFzIHN0YXJ0ZWQuIFxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9QYW5uZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChkZWxheSkge1xuXHQgICAgICAgIHRoaXMuX2xmby5zeW5jKGRlbGF5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBVbnN5bmMgdGhlIHBhbm5lciBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm8udW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVHlwZSBvZiBvc2NpbGxhdG9yIGF0dGFjaGVkIHRvIHRoZSBBdXRvRmlsdGVyLiBcblx0XHQgKiBQb3NzaWJsZSB2YWx1ZXM6IFwic2luZVwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlXCIsIFwic2F3dG9vdGhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdXRvRmlsdGVyI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b1Bhbm5lci5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdXRvUGFubmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9QYW5uZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZm8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmbyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFubmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9wYW5uZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2RlcHRoJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b1Bhbm5lcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkF1dG9XYWggY29ubmVjdHMgYSBUb25lLkZvbGxvd2VyIHRvIGEgYmFuZHBhc3MgZmlsdGVyIChUb25lLkZpbHRlcikuXG5cdFx0ICogICAgICAgICAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVyIGlzIGFkanVzdGVkIHByb3BvcnRpb25hbGx5IHRvIHRoZSBcblx0XHQgKiAgICAgICAgICBpbmNvbWluZyBzaWduYWwncyBhbXBsaXR1ZGUuIEluc3BpcmF0aW9uIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeXxPYmplY3R9IFtiYXNlRnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IHRoZSBmaWx0ZXIgaXMgc2V0IFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhdCB0aGUgbG93IHBvaW50IG9mIHRoZSB3YWhcblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZX0gW29jdGF2ZXNdIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyBhYm92ZSB0aGUgYmFzZUZyZXF1ZW5jeVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgZmlsdGVyIHdpbGwgc3dlZXAgdG8gd2hlbiBmdWxseSBvcGVuXG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHN9IFtzZW5zaXRpdml0eV0gVGhlIGRlY2liZWwgdGhyZXNob2xkIHNlbnNpdGl2aXR5IGZvciBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGluY29taW5nIHNpZ25hbC4gTm9ybWFsIHJhbmdlIG9mIC00MCB0byAwLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgYXV0b1dhaCA9IG5ldyBUb25lLkF1dG9XYWgoNTAsIDYsIC0zMCkudG9NYXN0ZXIoKTtcblx0XHQgKiAvL2luaXRpYWxpemUgdGhlIHN5bnRoIGFuZCBjb25uZWN0IHRvIGF1dG93YWhcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgU3ludGguY29ubmVjdChhdXRvV2FoKTtcblx0XHQgKiAvL1EgdmFsdWUgaW5mbHVlbmNlcyB0aGUgZWZmZWN0IG9mIHRoZSB3YWggLSBkZWZhdWx0IGlzIDJcblx0XHQgKiBhdXRvV2FoLlEudmFsdWUgPSA2O1xuXHRcdCAqIC8vbW9yZSBhdWRpYmxlIG9uIGhpZ2hlciBub3Rlc1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcycsXG5cdCAgICAgICAgICAgICdzZW5zaXRpdml0eSdcblx0ICAgICAgICBdLCBUb25lLkF1dG9XYWgpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGVudmVsb3BlIGZvbGxvd2VyLiBTZXQgdGhlIGF0dGFjay9yZWxlYXNlXG5cdFx0XHQgKiAgdGltaW5nIHRvIGFkanVzdCBob3cgdGhlIGVudmVsb3BlIGlzIGZvbGxvd2VkLiBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Gb2xsb3dlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mb2xsb3dlciA9IG5ldyBUb25lLkZvbGxvd2VyKG9wdGlvbnMuZm9sbG93ZXIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlcyB0aGUgZm9sbG93ZXIgdmFsdWUgdG8gdGhlIGZyZXF1ZW5jeSBkb21haW5cblx0XHRcdCAqICBAdHlwZSB7VG9uZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZSA9IG5ldyBUb25lLlNjYWxlRXhwKDAsIDEsIDAuNSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmFzZUZyZXF1ZW5jeSA9IG9wdGlvbnMuYmFzZUZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBpbnB1dCBnYWluIHRvIGFkanVzdCB0aGUgc2Vuc2l0aXZpdHlcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9pbnB1dEJvb3N0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtCaXF1YWRGaWx0ZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iYW5kcGFzcyA9IG5ldyBUb25lLkZpbHRlcih7XG5cdCAgICAgICAgICAgICdyb2xsb2ZmJzogLTQ4LFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5JzogMCxcblx0ICAgICAgICAgICAgJ1EnOiBvcHRpb25zLlFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcgPSBuZXcgVG9uZS5GaWx0ZXIoMCwgJ3BlYWtpbmcnKTtcblx0ICAgICAgICB0aGlzLl9wZWFraW5nLmdhaW4udmFsdWUgPSBvcHRpb25zLmdhaW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZ2FpbiBvZiB0aGUgZmlsdGVyLlxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZ2FpbiA9IHRoaXMuX3BlYWtpbmcuZ2Fpbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBxdWFsaXR5IG9mIHRoZSBmaWx0ZXIuXG5cdFx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLlEgPSB0aGlzLl9iYW5kcGFzcy5RO1xuXHQgICAgICAgIC8vdGhlIGNvbnRyb2wgc2lnbmFsIHBhdGhcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmQuY2hhaW4odGhpcy5faW5wdXRCb29zdCwgdGhpcy5mb2xsb3dlciwgdGhpcy5fc3dlZXBSYW5nZSk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5jb25uZWN0KHRoaXMuX2JhbmRwYXNzLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5jb25uZWN0KHRoaXMuX3BlYWtpbmcuZnJlcXVlbmN5KTtcblx0ICAgICAgICAvL3RoZSBmaWx0ZXJlZCBwYXRoXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmNoYWluKHRoaXMuX2JhbmRwYXNzLCB0aGlzLl9wZWFraW5nLCB0aGlzLmVmZmVjdFJldHVybik7XG5cdCAgICAgICAgLy9zZXQgdGhlIGluaXRpYWwgdmFsdWVcblx0ICAgICAgICB0aGlzLl9zZXRTd2VlcFJhbmdlKCk7XG5cdCAgICAgICAgdGhpcy5zZW5zaXRpdml0eSA9IG9wdGlvbnMuc2Vuc2l0aXZpdHk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZ2FpbicsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQXV0b1dhaCwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQXV0b1dhaC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYmFzZUZyZXF1ZW5jeSc6IDEwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDYsXG5cdCAgICAgICAgJ3NlbnNpdGl2aXR5JzogMCxcblx0ICAgICAgICAnUSc6IDIsXG5cdCAgICAgICAgJ2dhaW4nOiAyLFxuXHQgICAgICAgICdmb2xsb3dlcic6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMyxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBvY3RhdmVzIHRoYXQgdGhlIGZpbHRlciB3aWxsIHN3ZWVwIGFib3ZlIHRoZSBcblx0XHQgKiBiYXNlRnJlcXVlbmN5LiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BdXRvV2FoI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQXV0b1dhaC5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdGF2ZXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdGF2ZXM7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFN3ZWVwUmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBiYXNlIGZyZXF1ZW5jeSBmcm9tIHdoaWNoIHRoZSBzd2VlcCB3aWxsIHN0YXJ0IGZyb20uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBuYW1lIGJhc2VGcmVxdWVuY3lcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiYXNlRnJlcSkge1xuXHQgICAgICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gYmFzZUZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFN3ZWVwUmFuZ2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBzZW5zaXRpdml0eSB0byBjb250cm9sIGhvdyByZXNwb25zaXZlIHRvIHRoZSBpbnB1dCBzaWduYWwgdGhlIGZpbHRlciBpcy4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQXV0b1dhaCNcblx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0ICogQG5hbWUgc2Vuc2l0aXZpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkF1dG9XYWgucHJvdG90eXBlLCAnc2Vuc2l0aXZpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLmdhaW5Ub0RiKDEgLyB0aGlzLl9pbnB1dEJvb3N0LmdhaW4udmFsdWUpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc2Vuc2l0aXZ5KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QuZ2Fpbi52YWx1ZSA9IDEgLyBUb25lLmRiVG9HYWluKHNlbnNpdGl2eSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0cyB0aGUgc3dlZXAgcmFuZ2Ugb2YgdGhlIHNjYWxlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BdXRvV2FoLnByb3RvdHlwZS5fc2V0U3dlZXBSYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlLm1pbiA9IHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy5fc3dlZXBSYW5nZS5tYXggPSBNYXRoLm1pbih0aGlzLl9iYXNlRnJlcXVlbmN5ICogTWF0aC5wb3coMiwgdGhpcy5fb2N0YXZlcyksIHRoaXMuY29udGV4dC5zYW1wbGVSYXRlIC8gMik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BdXRvV2FofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkF1dG9XYWgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmZvbGxvd2VyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZvbGxvd2VyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zd2VlcFJhbmdlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9iYW5kcGFzcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYmFuZHBhc3MgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3BlYWtpbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2lucHV0Qm9vc3QgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2dhaW4nLFxuXHQgICAgICAgICAgICAnUSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmdhaW4gPSBudWxsO1xuXHQgICAgICAgIHRoaXMuUSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQXV0b1dhaDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuQml0Y3J1c2hlciBkb3duc2FtcGxlcyB0aGUgaW5jb21pbmcgc2lnbmFsIHRvIGEgZGlmZmVyZW50IGJpdGRlcHRoLiBcblx0XHQgKiAgICAgICAgIExvd2VyaW5nIHRoZSBiaXRkZXB0aCBvZiB0aGUgc2lnbmFsIGNyZWF0ZXMgZGlzdG9ydGlvbi4gUmVhZCBtb3JlIGFib3V0IEJpdGNydXNoaW5nXG5cdFx0ICogICAgICAgICBvbiBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CaXRjcnVzaGVyKS5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gZG93bnNhbXBsZSB0aGUgc2lnbmFsLiBOb21pbmFsIHJhbmdlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIG9mIDEgdG8gOC4gXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pbml0aWFsaXplIGNydXNoZXIgYW5kIHJvdXRlIGEgc3ludGggdGhyb3VnaCBpdFxuXHRcdCAqIHZhciBjcnVzaGVyID0gbmV3IFRvbmUuQml0Q3J1c2hlcig0KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLk1vbm9TeW50aCgpLmNvbm5lY3QoY3J1c2hlcik7XG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydiaXRzJ10sIFRvbmUuQml0Q3J1c2hlcik7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgb3B0aW9ucy5iaXRzIC0gMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU3VidHJhY3QgdGhlIGlucHV0IHNpZ25hbCBhbmQgdGhlIG1vZHVsdXMgb2YgdGhlIGlucHV0IHNpZ25hbFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN1YnRyYWN0fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG5ldyBUb25lLlN1YnRyYWN0KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZCBmdW5jdGlvblxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Nb2R1bG99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsbyA9IG5ldyBUb25lLk1vZHVsbyhpbnZTdGVwU2l6ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAga2VlcHMgdHJhY2sgb2YgdGhlIGJpdHNcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iaXRzID0gb3B0aW9ucy5iaXRzO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5mYW4odGhpcy5fc3VidHJhY3QsIHRoaXMuX21vZHVsbyk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmNvbm5lY3QodGhpcy5fc3VidHJhY3QsIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQml0Q3J1c2hlciwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkJpdENydXNoZXIuZGVmYXVsdHMgPSB7ICdiaXRzJzogNCB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGJpdCBkZXB0aCBvZiB0aGUgZWZmZWN0LiBOb21pbmFsIHJhbmdlIG9mIDEtOC4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQml0Q3J1c2hlciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIGJpdHNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJpdENydXNoZXIucHJvdG90eXBlLCAnYml0cycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpdHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaXRzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2JpdHMgPSBiaXRzO1xuXHQgICAgICAgICAgICB2YXIgaW52U3RlcFNpemUgPSAxIC8gTWF0aC5wb3coMiwgYml0cyAtIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9tb2R1bG8udmFsdWUgPSBpbnZTdGVwU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkJpdENydXNoZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQml0Q3J1c2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3N1YnRyYWN0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWJ0cmFjdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxvLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bG8gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkJpdENydXNoZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNoZWJ5U2hldiBpcyBhIENoZWJ5c2hldiB3YXZlc2hhcGVyLCBhbiBlZmZlY3Qgd2hpY2ggaXMgZ29vZCBcblx0XHQgKiAgICAgICAgIGZvciBtYWtpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGRpc3RvcnRpb24gc291bmRzLlxuXHRcdCAqICAgICAgICAgTm90ZSB0aGF0IG9kZCBvcmRlcnMgc291bmQgdmVyeSBkaWZmZXJlbnQgZnJvbSBldmVuIG9uZXMsIFxuXHRcdCAqICAgICAgICAgYW5kIG9yZGVyID0gMSBpcyBubyBjaGFuZ2UuIFxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIGF0IFttdXNpYy5jb2x1bWJpYS5lZHVdKGh0dHA6Ly9tdXNpYy5jb2x1bWJpYS5lZHUvY21jL211c2ljYW5kY29tcHV0ZXJzL2NoYXB0ZXI0LzA0XzA2LnBocCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtQb3NpdGl2ZXxPYmplY3R9IFtvcmRlcl0gVGhlIG9yZGVyIG9mIHRoZSBjaGVieXNoZXYgcG9seW5vbWlhbC4gTm9ybWFsIHJhbmdlIGJldHdlZW4gMS0xMDAuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vY3JlYXRlIGEgbmV3IGNoZWJ5XG5cdFx0ICogdmFyIGNoZWJ5ID0gbmV3IFRvbmUuQ2hlYnlzaGV2KDUwKTtcblx0XHQgKiAvL2NyZWF0ZSBhIG1vbm9zeW50aCBjb25uZWN0ZWQgdG8gb3VyIGNoZWJ5XG5cdFx0ICogc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoKS5jb25uZWN0KGNoZWJ5KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsnb3JkZXInXSwgVG9uZS5DaGVieXNoZXYpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUge1dhdmVTaGFwZXJOb2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKDQwOTYpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogaG9sZHMgb250byB0aGUgb3JkZXIgb2YgdGhlIGZpbHRlclxuXHRcdFx0ICogQHR5cGUge251bWJlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vcmRlciA9IG9wdGlvbnMub3JkZXI7XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX3NoYXBlcik7XG5cdCAgICAgICAgdGhpcy5vcmRlciA9IG9wdGlvbnMub3JkZXI7XG5cdCAgICAgICAgdGhpcy5vdmVyc2FtcGxlID0gb3B0aW9ucy5vdmVyc2FtcGxlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuQ2hlYnlzaGV2LCBUb25lLkVmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvcmRlcic6IDEsXG5cdCAgICAgICAgJ292ZXJzYW1wbGUnOiAnbm9uZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgZ2V0IHRoZSBjb2VmZmljaWVudCBmb3IgdGhhdCBkZWdyZWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggdmFsdWVcblx0XHQgKiAgQHBhcmFtICAge251bWJlcn0gZGVncmVlIFxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gbWVtbyBtZW1vaXplIHRoZSBjb21wdXRlZCB2YWx1ZS4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgIHRoaXMgc3BlZWRzIHVwIGNvbXB1dGF0aW9uIGdyZWF0bHkuIFxuXHRcdCAqICBAcmV0dXJuICB7bnVtYmVyfSAgICAgICB0aGUgY29lZmZpY2llbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUuX2dldENvZWZmaWNpZW50ID0gZnVuY3Rpb24gKHgsIGRlZ3JlZSwgbWVtbykge1xuXHQgICAgICAgIGlmIChtZW1vLmhhc093blByb3BlcnR5KGRlZ3JlZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG1lbW9bZGVncmVlXTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGRlZ3JlZSA9PT0gMCkge1xuXHQgICAgICAgICAgICBtZW1vW2RlZ3JlZV0gPSAwO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoZGVncmVlID09PSAxKSB7XG5cdCAgICAgICAgICAgIG1lbW9bZGVncmVlXSA9IHg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbWVtb1tkZWdyZWVdID0gMiAqIHggKiB0aGlzLl9nZXRDb2VmZmljaWVudCh4LCBkZWdyZWUgLSAxLCBtZW1vKSAtIHRoaXMuX2dldENvZWZmaWNpZW50KHgsIGRlZ3JlZSAtIDIsIG1lbW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbWVtb1tkZWdyZWVdO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvcmRlciBvZiB0aGUgQ2hlYnlzaGV2IHBvbHlub21pYWwgd2hpY2ggY3JlYXRlc1xuXHRcdCAqIHRoZSBlcXVhdGlvbiB3aGljaCBpcyBhcHBsaWVkIHRvIHRoZSBpbmNvbWluZyBcblx0XHQgKiBzaWduYWwgdGhyb3VnaCBhIFRvbmUuV2F2ZVNoYXBlci4gVGhlIGVxdWF0aW9uc1xuXHRcdCAqIGFyZSBpbiB0aGUgZm9ybTo8YnI+XG5cdFx0ICogb3JkZXIgMjogMnheMiArIDE8YnI+XG5cdFx0ICogb3JkZXIgMzogNHheMyArIDN4IDxicj5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaGVieXNoZXYjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIG9yZGVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaGVieXNoZXYucHJvdG90eXBlLCAnb3JkZXInLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmRlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9yZGVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG5cdCAgICAgICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBBcnJheSg0MDk2KTtcblx0ICAgICAgICAgICAgdmFyIGxlbiA9IGN1cnZlLmxlbmd0aDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHggPSBpICogMiAvIGxlbiAtIDE7XG5cdCAgICAgICAgICAgICAgICBpZiAoeCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIG91dHB1dCAwIHdoZW4gaW5wdXQgaXMgMFxuXHQgICAgICAgICAgICAgICAgICAgIGN1cnZlW2ldID0gMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VydmVbaV0gPSB0aGlzLl9nZXRDb2VmZmljaWVudCh4LCBvcmRlciwge30pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5jdXJ2ZSA9IGN1cnZlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG92ZXJzYW1wbGluZyBvZiB0aGUgZWZmZWN0LiBDYW4gZWl0aGVyIGJlIFwibm9uZVwiLCBcIjJ4XCIgb3IgXCI0eFwiLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkNoZWJ5c2hldiNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG92ZXJzYW1wbGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkNoZWJ5c2hldi5wcm90b3R5cGUsICdvdmVyc2FtcGxlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdmVyc2FtcGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5DaGVieXNoZXZ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQ2hlYnlzaGV2LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc2hhcGVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNoZWJ5c2hldjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEJhc2UgY2xhc3MgZm9yIFN0ZXJlbyBlZmZlY3RzLiBQcm92aWRlcyBlZmZlY3RTZW5kTC9SIGFuZCBlZmZlY3RSZXR1cm5ML1IuXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWyd3ZXQnXSwgVG9uZS5FZmZlY3QpO1xuXHQgICAgICAgIHRoaXMuY3JlYXRlSW5zT3V0cygxLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZHJ5d2V0IGtub2IgdG8gY29udHJvbCB0aGUgYW1vdW50IG9mIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkNyb3NzRmFkZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbmV3IFRvbmUuQ3Jvc3NGYWRlKG9wdGlvbnMud2V0KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2V0IGNvbnRyb2wsIGkuZS4gaG93IG11Y2ggb2YgdGhlIGVmZmVjdGVkXG5cdFx0XHQgKiAgd2lsbCBwYXNzIHRocm91Z2ggdG8gdGhlIG91dHB1dC5cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53ZXQgPSB0aGlzLl9kcnlXZXQuZmFkZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGVuIHNwbGl0IGl0XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwbGl0ID0gbmV3IFRvbmUuU3BsaXQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgZWZmZWN0cyBzZW5kIExFRlRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwgPSB0aGlzLl9zcGxpdC5sZWZ0O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3RzIHNlbmQgUklHSFRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIgPSB0aGlzLl9zcGxpdC5yaWdodDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc3RlcmVvIGVmZmVjdCBtZXJnZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NZXJnZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWVyZ2UgPSBuZXcgVG9uZS5NZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBlZmZlY3QgcmV0dXJuIExFRlRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTCA9IHRoaXMuX21lcmdlLmxlZnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGVmZmVjdCByZXR1cm4gUklHSFRcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuUiA9IHRoaXMuX21lcmdlLnJpZ2h0O1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLmlucHV0LmNvbm5lY3QodGhpcy5fc3BsaXQpO1xuXHQgICAgICAgIC8vZHJ5IHdldCBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuaW5wdXQuY29ubmVjdCh0aGlzLl9kcnlXZXQsIDAsIDApO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmNvbm5lY3QodGhpcy5fZHJ5V2V0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLl9kcnlXZXQuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWyd3ZXQnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9FZmZlY3QsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvRWZmZWN0fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2RyeVdldC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZHJ5V2V0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zcGxpdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21lcmdlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tZXJnZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2V0J10pO1xuXHQgICAgICAgIHRoaXMud2V0ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9FZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogXHRAY2xhc3MgIFRvbmUuRmVlZGJhY2tFZmZlY3QgcHJvdmlkZXMgYSBsb29wIGJldHdlZW4gYW4gXG5cdFx0ICogXHQgICAgICAgIGF1ZGlvIHNvdXJjZSBhbmQgaXRzIG93biBvdXRwdXQuIFRoaXMgaXMgYSBiYXNlLWNsYXNzXG5cdFx0ICogXHQgICAgICAgIGZvciBmZWVkYmFjayBlZmZlY3RzLiBcblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfE9iamVjdH0gW2ZlZWRiYWNrXSBUaGUgaW5pdGlhbCBmZWVkYmFjayB2YWx1ZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgWydmZWVkYmFjayddLCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBnYWluIHdoaWNoIGNvbnRyb2xzIHRoZSBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy5mZWVkYmFjaywgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIHNpZ25hbCB3aGljaCBpcyBmZWQgYmFjayBpbnRvIHRoZSBlZmZlY3QgaW5wdXQuIFxuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gdGhpcy5fZmVlZGJhY2tHYWluLmdhaW47XG5cdCAgICAgICAgLy90aGUgZmVlZGJhY2sgbG9vcFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuLmNoYWluKHRoaXMuX2ZlZWRiYWNrR2FpbiwgdGhpcy5lZmZlY3RTZW5kKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRmVlZGJhY2tFZmZlY3QsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRWZmZWN0LmRlZmF1bHRzID0geyAnZmVlZGJhY2snOiAwLjEyNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuRmVlZGJhY2tFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrR2Fpbi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tHYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GZWVkYmFja0VmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEp1c3QgbGlrZSBhIHN0ZXJlbyBmZWVkYmFjayBlZmZlY3QsIGJ1dCB0aGUgZmVlZGJhY2sgaXMgcm91dGVkIGZyb20gbGVmdCB0byByaWdodFxuXHRcdCAqICAgICAgICAgYW5kIHJpZ2h0IHRvIGxlZnQgaW5zdGVhZCBvZiBvbiB0aGUgc2FtZSBjaGFubmVsLlxuXHRcdCAqXG5cdFx0ICpcdEBjb25zdHJ1Y3RvclxuXHRcdCAqXHRAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBmZWVkYmFjayBmcm9tIHRoZSBvdXRwdXRcblx0XHRcdCAqICBiYWNrIGludG8gdGhlIGlucHV0IG9mIHRoZSBlZmZlY3QgKHJvdXRlZFxuXHRcdFx0ICogIGFjcm9zcyBsZWZ0IGFuZCByaWdodCBjaGFubmVscykuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmVlZGJhY2sgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mZWVkYmFjaywgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGVmdCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB1cFxuXHQgICAgICAgIHRoaXMuZWZmZWN0UmV0dXJuTC5jaGFpbih0aGlzLl9mZWVkYmFja0xSLCB0aGlzLmVmZmVjdFNlbmRSKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFJldHVyblIuY2hhaW4odGhpcy5fZmVlZGJhY2tSTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMUi5nYWluLCB0aGlzLl9mZWVkYmFja1JMLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZmVlZGJhY2snXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3R9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydmZWVkYmFjayddKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0xSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1JMID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkNob3J1cyBpcyBhIHN0ZXJlbyBjaG9ydXMgZWZmZWN0IHdpdGggZmVlZGJhY2sgY29tcG9zZWQgb2YgXG5cdFx0ICogICAgICAgICBhIGxlZnQgYW5kIHJpZ2h0IGRlbGF5IHdpdGggYSBUb25lLkxGTyBhcHBsaWVkIHRvIHRoZSBkZWxheVRpbWUgb2YgZWFjaCBjaGFubmVsLiBcblx0XHQgKiAgICAgICAgIEluc3BpcmF0aW9uIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hL2Jsb2IvbWFzdGVyL3R1bmEuanMpLlxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIHRoZSBjaG9ydXMgZWZmZWN0IG9uIFtTb3VuZE9uU291bmRdKGh0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvanVuMDQvYXJ0aWNsZXMvc3ludGhzZWNyZXRzLmh0bSkuXG5cdFx0ICpcblx0XHQgKlx0QGNvbnN0cnVjdG9yXG5cdFx0ICpcdEBleHRlbmRzIHtUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdH1cblx0XHQgKlx0QHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IG9mIHRoZSBMRk8uXG5cdFx0ICpcdEBwYXJhbSB7TWlsbGlzZWNvbmRzfSBbZGVsYXlUaW1lXSBUaGUgZGVsYXkgb2YgdGhlIGNob3J1cyBlZmZlY3QgaW4gbXMuIFxuXHRcdCAqXHRAcGFyYW0ge05vcm1hbFJhbmdlfSBbZGVwdGhdIFRoZSBkZXB0aCBvZiB0aGUgY2hvcnVzLlxuXHRcdCAqXHRAZXhhbXBsZVxuXHRcdCAqIHZhciBjaG9ydXMgPSBuZXcgVG9uZS5DaG9ydXMoNCwgMi41LCAwLjUpO1xuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLlBvbHlTeW50aCg0LCBUb25lLk1vbm9TeW50aCkuY29ubmVjdChjaG9ydXMpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFtcIkMzXCIsXCJFM1wiLFwiRzNcIl0sIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkNob3J1cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuQ2hvcnVzKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZXB0aCBvZiB0aGUgY2hvcnVzXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVwdGggPSBvcHRpb25zLmRlcHRoO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheVRpbWVcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheVRpbWUgPSBvcHRpb25zLmRlbGF5VGltZSAvIDEwMDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxmbyB3aGljaCBjb250cm9scyB0aGUgZGVsYXlUaW1lXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9MID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAnbWluJzogMCxcblx0ICAgICAgICAgICAgJ21heCc6IDFcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBhbm90aGVyIExGTyBmb3IgdGhlIHJpZ2h0IHNpZGUgd2l0aCBhIDE4MCBkZWdyZWUgcGhhc2UgZGlmZlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvUiA9IG5ldyBUb25lLkxGTyh7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICAgICAncGhhc2UnOiAxODBcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBkZWxheSBmb3IgbGVmdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMID0gbmV3IFRvbmUuRGVsYXkoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBkZWxheSBmb3IgcmlnaHRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlUiA9IG5ldyBUb25lLkRlbGF5KCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgZnJlcXVlbmN5IG9mIHRoZSBMRk8gd2hpY2ggbW9kdWxhdGVzIHRoZSBkZWxheVRpbWUuIFxuXHRcdFx0ICogQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbGZvTC5mcmVxdWVuY3k7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY2hhaW4odGhpcy5fZGVsYXlOb2RlTCwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX2RlbGF5Tm9kZVIsIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgLy9hbmQgcGFzcyB0aHJvdWdoIHRvIG1ha2UgdGhlIGRldHVuZSBhcHBhcmVudFxuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vbGZvIHNldHVwXG5cdCAgICAgICAgdGhpcy5fbGZvTC5jb25uZWN0KHRoaXMuX2RlbGF5Tm9kZUwuZGVsYXlUaW1lKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLmNvbm5lY3QodGhpcy5fZGVsYXlOb2RlUi5kZWxheVRpbWUpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIGxmb1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLnN0YXJ0KCk7XG5cdCAgICAgICAgLy9oYXZlIG9uZSBMRk8gZnJlcXVlbmN5IGNvbnRyb2wgdGhlIG90aGVyXG5cdCAgICAgICAgdGhpcy5fbGZvTC5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9sZm9SLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2RlcHRoO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LnZhbHVlID0gb3B0aW9ucy5mcmVxdWVuY3k7XG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnZnJlcXVlbmN5J10pO1xuXHQgICAgICAgIHRoaXMuc3ByZWFkID0gb3B0aW9ucy5zcHJlYWQ7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5DaG9ydXMsIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkNob3J1cy5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogMS41LFxuXHQgICAgICAgICdkZWxheVRpbWUnOiAzLjUsXG5cdCAgICAgICAgJ2RlcHRoJzogMC43LFxuXHQgICAgICAgICdmZWVkYmFjayc6IDAuMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAnc3ByZWFkJzogMTgwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuIEEgZGVwdGggb2YgMSBtYWtlcyB0aGUgZGVsYXlUaW1lXG5cdFx0ICogbW9kdWxhdGUgYmV0d2VlbiAwIGFuZCAyKmRlbGF5VGltZSAoY2VudGVyZWQgYXJvdW5kIHRoZSBkZWxheVRpbWUpLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBuYW1lIGRlcHRoXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAnZGVwdGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXB0aDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGRlcHRoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RlcHRoID0gZGVwdGg7XG5cdCAgICAgICAgICAgIHZhciBkZXZpYXRpb24gPSB0aGlzLl9kZWxheVRpbWUgKiBkZXB0aDtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5taW4gPSBNYXRoLm1heCh0aGlzLl9kZWxheVRpbWUgLSBkZXZpYXRpb24sIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1heCA9IHRoaXMuX2RlbGF5VGltZSArIGRldmlhdGlvbjtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5taW4gPSBNYXRoLm1heCh0aGlzLl9kZWxheVRpbWUgLSBkZXZpYXRpb24sIDApO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLm1heCA9IHRoaXMuX2RlbGF5VGltZSArIGRldmlhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZWxheVRpbWUgaW4gbWlsbGlzZWNvbmRzIG9mIHRoZSBjaG9ydXMuIEEgbGFyZ2VyIGRlbGF5VGltZVxuXHRcdCAqIHdpbGwgZ2l2ZSBhIG1vcmUgcHJvbm91bmNlZCBlZmZlY3QuIE5vbWluYWwgcmFuZ2UgYSBkZWxheVRpbWVcblx0XHQgKiBpcyBiZXR3ZWVuIDIgYW5kIDIwbXMuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkNob3J1cyNcblx0XHQgKiBAdHlwZSB7TWlsbGlzZWNvbmRzfVxuXHRcdCAqIEBuYW1lIGRlbGF5VGltZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQ2hvcnVzLnByb3RvdHlwZSwgJ2RlbGF5VGltZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5VGltZSAqIDEwMDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkZWxheVRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVsYXlUaW1lID0gZGVsYXlUaW1lIC8gMTAwMDtcblx0ICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2RlcHRoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG9zY2lsbGF0b3IgdHlwZSBvZiB0aGUgTEZPLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb0wudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKiBcblx0XHQgKiBBbW91bnQgb2Ygc3RlcmVvIHNwcmVhZC4gV2hlbiBzZXQgdG8gMCwgYm90aCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBjZW50cmFsbHkuXG5cdFx0ICogV2hlbiBzZXQgdG8gMTgwLCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBoYXJkIGxlZnQgYW5kIHJpZ2h0IHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5DaG9ydXMjXG5cdFx0ICogQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5DaG9ydXMucHJvdG90eXBlLCAnc3ByZWFkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvUi5waGFzZSAtIHRoaXMuX2xmb0wucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcHJlYWQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC5waGFzZSA9IDkwIC0gc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5waGFzZSA9IHNwcmVhZCAvIDIgKyA5MDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkNob3J1c30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5DaG9ydXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGVSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZSgnZnJlcXVlbmN5Jyk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkNob3J1cztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkNvbnZvbHZlciBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBOYXRpdmUgV2ViIEF1ZGlvIFxuXHRcdCAqICAgICAgICAgIFtDb252b2x2ZXJOb2RlXShodHRwOi8vd2ViYXVkaW8uZ2l0aHViLmlvL3dlYi1hdWRpby1hcGkvI3RoZS1jb252b2x2ZXJub2RlLWludGVyZmFjZSkuXG5cdFx0ICogICAgICAgICAgQ29udm9sdXRpb24gaXMgdXNlZnVsIGZvciByZXZlcmIgYW5kIGZpbHRlciBlbXVsYXRpb24uIFJlYWQgbW9yZSBhYm91dCBjb252b2x1dGlvbiByZXZlcmIgb25cblx0XHQgKiAgICAgICAgICBbV2lraXBlZGlhXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252b2x1dGlvbl9yZXZlcmIpLlxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd8VG9uZS5CdWZmZXJ8T2JqZWN0fSBbdXJsXSBUaGUgVVJMIG9mIHRoZSBpbXB1bHNlIHJlc3BvbnNlIG9yIHRoZSBUb25lLkJ1ZmZlclxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpYW5pbmcgdGhlIGltcHVsc2UgcmVzcG9uc2UuIFxuXHRcdCAqICBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIHRoZSB1cmwgaXMgbG9hZGVkLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vaW5pdGlhbGl6aW5nIHRoZSBjb252b2x2ZXIgd2l0aCBhbiBpbXB1bHNlIHJlc3BvbnNlXG5cdFx0ICogdmFyIGNvbnZvbHZlciA9IG5ldyBUb25lLkNvbnZvbHZlcihcIi4vcGF0aC90by9pci53YXZcIikudG9NYXN0ZXIoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5Db252b2x2ZXIpO1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udm9sdmVyIG5vZGVcblx0XHRcdCAqICBAdHlwZSB7Q29udm9sdmVyTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gdGhpcy5jb250ZXh0LmNyZWF0ZUNvbnZvbHZlcigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb252b2x1dGlvbiBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcigpO1xuXHQgICAgICAgIGlmIChUb25lLmlzU3RyaW5nKG9wdGlvbnMudXJsKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIubG9hZChvcHRpb25zLnVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLm9ubG9hZCgpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy51cmwpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBvcHRpb25zLnVybDtcblx0ICAgICAgICAgICAgb3B0aW9ucy5vbmxvYWQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX2NvbnZvbHZlcik7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Db252b2x2ZXIsIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLmRlZmF1bHRzID0geyAnb25sb2FkJzogVG9uZS5ub09wIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGNvbnZvbHZlcidzIGJ1ZmZlclxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Db252b2x2ZXIjXG5cdFx0ICogIEB0eXBlIHtBdWRpb0J1ZmZlcn1cblx0XHQgKiAgQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Db252b2x2ZXIucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmdldCgpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29udm9sdmVyLmJ1ZmZlciA9IHRoaXMuX2J1ZmZlci5nZXQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBMb2FkIGFuIGltcHVsc2UgcmVzcG9uc2UgdXJsIGFzIGFuIGF1ZGlvIGJ1ZmZlci5cblx0XHQgKiAgRGVjb2RlcyB0aGUgYXVkaW8gYXN5bmNocm9ub3VzbHkgYW5kIGludm9rZXNcblx0XHQgKiAgdGhlIGNhbGxiYWNrIG9uY2UgdGhlIGF1ZGlvIGJ1ZmZlciBsb2Fkcy5cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICBmaWxldHlwZSBzdXBwb3J0IGRlcGVuZHMgb24gdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5cblx0XHQgKiAgQHBhcmFtICB7ZnVuY3Rpb249fSBjYWxsYmFja1xuXHRcdCAqICBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuQ29udm9sdmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZikge1xuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmY7XG5cdCAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuQ29udm9sdmVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkNvbnZvbHZlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbnZvbHZlci5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fY29udm9sdmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQ29udm9sdmVyO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5EaXN0b3J0aW9uIGlzIGEgc2ltcGxlIGRpc3RvcnRpb24gZWZmZWN0IHVzaW5nIFRvbmUuV2F2ZVNoYXBlci5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmcm9tIFthIHN0YWNrb3ZlcmZsb3cgYW5zd2VyXShodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjMxMzQwOCkuXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGlzdG9ydGlvbl0gVGhlIGFtb3VudCBvZiBkaXN0b3J0aW9uIChub21pbmFsIHJhbmdlIG9mIDAtMSlcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgZGlzdCA9IG5ldyBUb25lLkRpc3RvcnRpb24oMC44KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciBmbSA9IG5ldyBUb25lLlNpbXBsZUZNKCkuY29ubmVjdChkaXN0KTtcblx0XHQgKiAvL3RoaXMgc291bmRzIGdvb2Qgb24gYmFzcyBub3Rlc1xuXHRcdCAqIGZtLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTFcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRGlzdG9ydGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2Rpc3RvcnRpb24nXSwgVG9uZS5EaXN0b3J0aW9uKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG5ldyBUb25lLldhdmVTaGFwZXIoNDA5Nik7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBob2xkcyB0aGUgZGlzdG9ydGlvbiBhbW91bnRcblx0XHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGlzdG9ydGlvbiA9IG9wdGlvbnMuZGlzdG9ydGlvbjtcblx0ICAgICAgICB0aGlzLmNvbm5lY3RFZmZlY3QodGhpcy5fc2hhcGVyKTtcblx0ICAgICAgICB0aGlzLmRpc3RvcnRpb24gPSBvcHRpb25zLmRpc3RvcnRpb247XG5cdCAgICAgICAgdGhpcy5vdmVyc2FtcGxlID0gb3B0aW9ucy5vdmVyc2FtcGxlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRGlzdG9ydGlvbiwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkRpc3RvcnRpb24uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2Rpc3RvcnRpb24nOiAwLjQsXG5cdCAgICAgICAgJ292ZXJzYW1wbGUnOiAnbm9uZSdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYW1vdW50IG9mIGRpc3RvcnRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRGlzdG9ydGlvbiNcblx0XHQgKiBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogQG5hbWUgZGlzdG9ydGlvblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRGlzdG9ydGlvbi5wcm90b3R5cGUsICdkaXN0b3J0aW9uJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzdG9ydGlvbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGFtb3VudCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kaXN0b3J0aW9uID0gYW1vdW50O1xuXHQgICAgICAgICAgICB2YXIgayA9IGFtb3VudCAqIDEwMDtcblx0ICAgICAgICAgICAgdmFyIGRlZyA9IE1hdGguUEkgLyAxODA7XG5cdCAgICAgICAgICAgIHRoaXMuX3NoYXBlci5zZXRNYXAoZnVuY3Rpb24gKHgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh4KSA8IDAuMDAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9zaG91bGQgb3V0cHV0IDAgd2hlbiBpbnB1dCBpcyAwXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMyArIGspICogeCAqIDIwICogZGVnIC8gKE1hdGguUEkgKyBrICogTWF0aC5hYnMoeCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBvdmVyc2FtcGxpbmcgb2YgdGhlIGVmZmVjdC4gQ2FuIGVpdGhlciBiZSBcIm5vbmVcIiwgXCIyeFwiIG9yIFwiNHhcIi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5EaXN0b3J0aW9uI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgb3ZlcnNhbXBsZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRGlzdG9ydGlvbi5wcm90b3R5cGUsICdvdmVyc2FtcGxlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvdmVyc2FtcGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2hhcGVyLm92ZXJzYW1wbGUgPSBvdmVyc2FtcGxpbmc7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5EaXN0b3J0aW9ufSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkRpc3RvcnRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9zaGFwZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NoYXBlciA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRGlzdG9ydGlvbjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLkZlZWRiYWNrRGVsYXkgaXMgYSBEZWxheU5vZGUgaW4gd2hpY2ggcGFydCBvZiBvdXRwdXRcblx0XHQgKiAgICAgICAgICBzaWduYWwgaXMgZmVkIGJhY2sgaW50byB0aGUgZGVsYXkuIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5GZWVkYmFja0VmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5IGFwcGxpZWQgdG8gdGhlIGluY29taW5nIHNpZ25hbC4gXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2U9fSBmZWVkYmFjayBUaGUgYW1vdW50IG9mIHRoZSBlZmZlY3RlZCBzaWduYWwgd2hpY2ggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZmVkIGJhY2sgdGhyb3VnaCB0aGUgZGVsYXkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZlZWRiYWNrRGVsYXkgPSBuZXcgVG9uZS5GZWVkYmFja0RlbGF5KFwiOG5cIiwgMC41KS50b01hc3RlcigpO1xuXHRcdCAqIHZhciB0b20gPSBuZXcgVG9uZS5EcnVtU3ludGgoe1xuXHRcdCAqIFx0XCJvY3RhdmVzXCIgOiA0LFxuXHRcdCAqIFx0XCJwaXRjaERlY2F5XCIgOiAwLjFcblx0XHQgKiB9KS5jb25uZWN0KGZlZWRiYWNrRGVsYXkpO1xuXHRcdCAqIHRvbS50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkEyXCIsXCIzMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkZlZWRiYWNrRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZGVsYXlUaW1lJyxcblx0ICAgICAgICAgICAgJ2ZlZWRiYWNrJ1xuXHQgICAgICAgIF0sIFRvbmUuRmVlZGJhY2tEZWxheSk7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2RlbGF5Tm9kZSA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGVsYXlUaW1lIG9mIHRoZSBEZWxheU5vZGUuIFxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gdGhpcy5fZGVsYXlOb2RlLmRlbGF5VGltZTtcblx0ICAgICAgICAvLyBjb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5jb25uZWN0RWZmZWN0KHRoaXMuX2RlbGF5Tm9kZSk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoWydkZWxheVRpbWUnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5GZWVkYmFja0RlbGF5LCBUb25lLkZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuIFxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GZWVkYmFja0RlbGF5LmRlZmF1bHRzID0geyAnZGVsYXlUaW1lJzogMC4yNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZlZWRiYWNrRGVsYXl9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRmVlZGJhY2tEZWxheS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkZlZWRiYWNrRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZGVsYXlUaW1lJ10pO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5GZWVkYmFja0RlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiBjb21iIGZpbHRlciBkZWxheSB2YWx1ZXMgZnJvbSBGcmVldmVyYiBpbXBsZW1lbnRhdGlvblxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBjb21iRmlsdGVyVHVuaW5ncyA9IFtcblx0ICAgICAgICAxNTU3IC8gNDQxMDAsXG5cdCAgICAgICAgMTYxNyAvIDQ0MTAwLFxuXHQgICAgICAgIDE0OTEgLyA0NDEwMCxcblx0ICAgICAgICAxNDIyIC8gNDQxMDAsXG5cdCAgICAgICAgMTI3NyAvIDQ0MTAwLFxuXHQgICAgICAgIDEzNTYgLyA0NDEwMCxcblx0ICAgICAgICAxMTg4IC8gNDQxMDAsXG5cdCAgICAgICAgMTExNiAvIDQ0MTAwXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIGFuIGFycmF5IG9mIGFsbHBhc3MgZmlsdGVyIGZyZXF1ZW5jeSB2YWx1ZXMgZnJvbSBGcmVldmVyYiBpbXBsZW1lbnRhdGlvblxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXMgPSBbXG5cdCAgICAgICAgMjI1LFxuXHQgICAgICAgIDU1Nixcblx0ICAgICAgICA0NDEsXG5cdCAgICAgICAgMzQxXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZyZWV2ZXJiIGlzIGEgcmV2ZXJiIGJhc2VkIG9uIFtGcmVldmVyYl0oaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvfmpvcy9wYXNwL0ZyZWV2ZXJiLmh0bWwpLlxuXHRcdCAqICAgICAgICAgUmVhZCBtb3JlIG9uIHJldmVyYiBvbiBbU291bmQgT24gU291bmRdKGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE2MDQwNDA4MzkwMi9odHRwOi8vd3d3LnNvdW5kb25zb3VuZC5jb206ODAvc29zL2ZlYjAxL2FydGljbGVzL3N5bnRoc2VjcmV0cy5hc3ApLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbcm9vbVNpemVdIENvcnJlbGF0ZWQgdG8gdGhlIGRlY2F5IHRpbWUuXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZGFtcGVuaW5nXSBUaGUgY3V0b2ZmIGZyZXF1ZW5jeSBvZiBhIGxvd3Bhc3MgZmlsdGVyIGFzIHBhcnRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSByZXZlcmIuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZyZWV2ZXJiID0gbmV3IFRvbmUuRnJlZXZlcmIoKS50b01hc3RlcigpO1xuXHRcdCAqIGZyZWV2ZXJiLmRhbXBlbmluZy52YWx1ZSA9IDEwMDA7XG5cdFx0ICogLy9yb3V0aW5nIHN5bnRoIHRocm91Z2ggdGhlIHJldmVyYlxuXHRcdCAqIHZhciBzeW50aCA9IG5ldyBUb25lLkFNU3ludGgoKS5jb25uZWN0KGZyZWV2ZXJiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncm9vbVNpemUnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0sIFRvbmUuRnJlZXZlcmIpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHJvb21TaXplIHZhbHVlIGJldHdlZW4uIEEgbGFyZ2VyIHJvb21TaXplXG5cdFx0XHQgKiAgd2lsbCByZXN1bHQgaW4gYSBsb25nZXIgZGVjYXkuXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucm9vbVNpemUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5yb29tU2l6ZSwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGRhbXBlbmluZyBvZiB0aGUgcmV2ZXJiZXJhbnQgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kYW1wZW5pbmcsIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBjb21iIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NvbWJGaWx0ZXJzID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgbGVmdFxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMID0gW107XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFsbHBhc3MgZmlsdGVycyBvbiB0aGUgcmlnaHRcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUiA9IFtdO1xuXHQgICAgICAgIC8vbWFrZSB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSByaWdodFxuXHQgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzLmxlbmd0aDsgbCsrKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxwYXNzTCA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgYWxscGFzc0wudHlwZSA9ICdhbGxwYXNzJztcblx0ICAgICAgICAgICAgYWxscGFzc0wuZnJlcXVlbmN5LnZhbHVlID0gYWxscGFzc0ZpbHRlckZyZXF1ZW5jaWVzW2xdO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0wucHVzaChhbGxwYXNzTCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vbWFrZSB0aGUgYWxscGFzcyBmaWx0ZXJzIG9uIHRoZSBsZWZ0XG5cdCAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXMubGVuZ3RoOyByKyspIHtcblx0ICAgICAgICAgICAgdmFyIGFsbHBhc3NSID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICBhbGxwYXNzUi50eXBlID0gJ2FsbHBhc3MnO1xuXHQgICAgICAgICAgICBhbGxwYXNzUi5mcmVxdWVuY3kudmFsdWUgPSBhbGxwYXNzRmlsdGVyRnJlcXVlbmNpZXNbcl07XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUi5wdXNoKGFsbHBhc3NSKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9tYWtlIHRoZSBjb21iIGZpbHRlcnNcblx0ICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbWJGaWx0ZXJUdW5pbmdzLmxlbmd0aDsgYysrKSB7XG5cdCAgICAgICAgICAgIHZhciBsZnBmID0gbmV3IFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIoY29tYkZpbHRlclR1bmluZ3NbY10pO1xuXHQgICAgICAgICAgICBpZiAoYyA8IGNvbWJGaWx0ZXJUdW5pbmdzLmxlbmd0aCAvIDIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY2hhaW4obGZwZiwgdGhpcy5fYWxscGFzc0ZpbHRlcnNMWzBdKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY2hhaW4obGZwZiwgdGhpcy5fYWxscGFzc0ZpbHRlcnNSWzBdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnJvb21TaXplLmNvbm5lY3QobGZwZi5yZXNvbmFuY2UpO1xuXHQgICAgICAgICAgICB0aGlzLmRhbXBlbmluZy5jb25uZWN0KGxmcGYuZGFtcGVuaW5nKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMucHVzaChsZnBmKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9jaGFpbiB0aGUgYWxscGFzcyBmaWx0ZXJzIHRvZ2V0ZWhyXG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCk7XG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUik7XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW3RoaXMuX2FsbHBhc3NGaWx0ZXJzTC5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSW3RoaXMuX2FsbHBhc3NGaWx0ZXJzUi5sZW5ndGggLSAxXS5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncm9vbVNpemUnLFxuXHQgICAgICAgICAgICAnZGFtcGVuaW5nJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRnJlZXZlcmIsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkZyZWV2ZXJiLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdyb29tU2l6ZSc6IDAuNyxcblx0ICAgICAgICAnZGFtcGVuaW5nJzogMzAwMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuRnJlZXZlcmJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRnJlZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBhbCA9IDA7IGFsIDwgdGhpcy5fYWxscGFzc0ZpbHRlcnNMLmxlbmd0aDsgYWwrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc0xbYWxdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNMW2FsXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzTCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIgYXIgPSAwOyBhciA8IHRoaXMuX2FsbHBhc3NGaWx0ZXJzUi5sZW5ndGg7IGFyKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNSW2FyXS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzUlthcl0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1IgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGNmID0gMDsgY2YgPCB0aGlzLl9jb21iRmlsdGVycy5sZW5ndGg7IGNmKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fY29tYkZpbHRlcnNbY2ZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fY29tYkZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jvb21TaXplJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLnJvb21TaXplID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRhbXBlbmluZy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZyZWV2ZXJiO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBhbiBhcnJheSBvZiB0aGUgY29tYiBmaWx0ZXIgZGVsYXkgdGltZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgY29tYkZpbHRlckRlbGF5VGltZXMgPSBbXG5cdCAgICAgICAgMTY4NyAvIDI1MDAwLFxuXHQgICAgICAgIDE2MDEgLyAyNTAwMCxcblx0ICAgICAgICAyMDUzIC8gMjUwMDAsXG5cdCAgICAgICAgMjI1MSAvIDI1MDAwXG5cdCAgICBdO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSByZXNvbmFuY2VzIG9mIGVhY2ggb2YgdGhlIGNvbWIgZmlsdGVyc1xuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBjb21iRmlsdGVyUmVzb25hbmNlcyA9IFtcblx0ICAgICAgICAwLjc3Myxcblx0ICAgICAgICAwLjgwMixcblx0ICAgICAgICAwLjc1Myxcblx0ICAgICAgICAwLjczM1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgYWxscGFzcyBmaWx0ZXIgZnJlcXVlbmNpZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgYWxscGFzc0ZpbHRlckZyZXFzID0gW1xuXHQgICAgICAgIDM0Nyxcblx0ICAgICAgICAxMTMsXG5cdCAgICAgICAgMzdcblx0ICAgIF07XG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuSkNSZXZlcmIgaXMgYSBzaW1wbGUgW1NjaHJvZWRlciBSZXZlcmJlcmF0b3JdKGh0dHBzOi8vY2NybWEuc3RhbmZvcmQuZWR1L35qb3MvcGFzcC9TY2hyb2VkZXJfUmV2ZXJiZXJhdG9ycy5odG1sKVxuXHRcdCAqICAgICAgICAgdHVuZWQgYnkgSm9obiBDaG93bmluZyBpbiAxOTcwLlxuXHRcdCAqICAgICAgICAgSXQgaXMgbWFkZSB1cCBvZiB0aHJlZSBhbGxwYXNzIGZpbHRlcnMgYW5kIGZvdXIgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZXxPYmplY3R9IFtyb29tU2l6ZV0gQ29vcmVsYXRlcyB0byB0aGUgZGVjYXkgdGltZS5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcmV2ZXJiID0gbmV3IFRvbmUuSkNSZXZlcmIoMC40KS5jb25uZWN0KFRvbmUuTWFzdGVyKTtcblx0XHQgKiB2YXIgZGVsYXkgPSBuZXcgVG9uZS5GZWVkYmFja0RlbGF5KDAuNSk7IFxuXHRcdCAqIC8vY29ubmVjdGluZyB0aGUgc3ludGggdG8gcmV2ZXJiIHRocm91Z2ggZGVsYXlcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5EdW9TeW50aCgpLmNoYWluKGRlbGF5LCByZXZlcmIpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQTRcIixcIjhuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5KQ1JldmVyYiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3Jvb21TaXplJ10sIFRvbmUuSkNSZXZlcmIpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgcm9vbSBzaXplIGNvbnRyb2wgdmFsdWVzIGJldHdlZW4gWzAsMV1cblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLnJvb21TaXplLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHNjYWxlIHRoZSByb29tIHNpemVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5TY2FsZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZSA9IG5ldyBUb25lLlNjYWxlKC0wLjczMywgMC4xOTcpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGEgc2VyaWVzIG9mIGFsbHBhc3MgZmlsdGVyc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBwYXJhbGxlbCBmZWVkYmFjayBjb21iIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAvL21ha2UgdGhlIGFsbHBhc3MgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGFmID0gMDsgYWYgPCBhbGxwYXNzRmlsdGVyRnJlcXMubGVuZ3RoOyBhZisrKSB7XG5cdCAgICAgICAgICAgIHZhciBhbGxwYXNzID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuXHQgICAgICAgICAgICBhbGxwYXNzLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIGFsbHBhc3MuZnJlcXVlbmN5LnZhbHVlID0gYWxscGFzc0ZpbHRlckZyZXFzW2FmXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMucHVzaChhbGxwYXNzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9hbmQgdGhlIGNvbWIgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGNmID0gMDsgY2YgPCBjb21iRmlsdGVyRGVsYXlUaW1lcy5sZW5ndGg7IGNmKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZiY2YgPSBuZXcgVG9uZS5GZWVkYmFja0NvbWJGaWx0ZXIoY29tYkZpbHRlckRlbGF5VGltZXNbY2ZdLCAwLjEpO1xuXHQgICAgICAgICAgICB0aGlzLl9zY2FsZVJvb21TaXplLmNvbm5lY3QoZmJjZi5yZXNvbmFuY2UpO1xuXHQgICAgICAgICAgICBmYmNmLnJlc29uYW5jZS52YWx1ZSA9IGNvbWJGaWx0ZXJSZXNvbmFuY2VzW2NmXTtcblx0ICAgICAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnNbdGhpcy5fYWxscGFzc0ZpbHRlcnMubGVuZ3RoIC0gMV0uY29ubmVjdChmYmNmKTtcblx0ICAgICAgICAgICAgaWYgKGNmIDwgY29tYkZpbHRlckRlbGF5VGltZXMubGVuZ3RoIC8gMikge1xuXHQgICAgICAgICAgICAgICAgZmJjZi5jb25uZWN0KHRoaXMuZWZmZWN0UmV0dXJuTCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmYmNmLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzLnB1c2goZmJjZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vY2hhaW4gdGhlIGFsbHBhc3MgZmlsdGVycyB0b2dldGhlclxuXHQgICAgICAgIHRoaXMucm9vbVNpemUuY29ubmVjdCh0aGlzLl9zY2FsZVJvb21TaXplKTtcblx0ICAgICAgICBUb25lLmNvbm5lY3RTZXJpZXMuYXBwbHkoVG9uZSwgdGhpcy5fYWxscGFzc0ZpbHRlcnMpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZEwuY29ubmVjdCh0aGlzLl9hbGxwYXNzRmlsdGVyc1swXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kUi5jb25uZWN0KHRoaXMuX2FsbHBhc3NGaWx0ZXJzWzBdKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ3Jvb21TaXplJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuSkNSZXZlcmIsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuSkNSZXZlcmIuZGVmYXVsdHMgPSB7ICdyb29tU2l6ZSc6IDAuNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuSkNSZXZlcmJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuSkNSZXZlcmIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICBmb3IgKHZhciBhcGYgPSAwOyBhcGYgPCB0aGlzLl9hbGxwYXNzRmlsdGVycy5sZW5ndGg7IGFwZisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FsbHBhc3NGaWx0ZXJzW2FwZl0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9hbGxwYXNzRmlsdGVyc1thcGZdID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWxscGFzc0ZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGZiY2YgPSAwOyBmYmNmIDwgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVycy5sZW5ndGg7IGZiY2YrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9mZWVkYmFja0NvbWJGaWx0ZXJzW2ZiY2ZdLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmVlZGJhY2tDb21iRmlsdGVyc1tmYmNmXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrQ29tYkZpbHRlcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsncm9vbVNpemUnXSk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5yb29tU2l6ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVSb29tU2l6ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuSkNSZXZlcmI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBNaWQvU2lkZSBwcm9jZXNzaW5nIHNlcGFyYXRlcyB0aGUgdGhlICdtaWQnIHNpZ25hbCBcblx0XHQgKiAgICAgICAgICh3aGljaCBjb21lcyBvdXQgb2YgYm90aCB0aGUgbGVmdCBhbmQgdGhlIHJpZ2h0IGNoYW5uZWwpIFxuXHRcdCAqICAgICAgICAgYW5kIHRoZSAnc2lkZScgKHdoaWNoIG9ubHkgY29tZXMgb3V0IG9mIHRoZSB0aGUgc2lkZSBjaGFubmVscykgXG5cdFx0ICogICAgICAgICBhbmQgZWZmZWN0cyB0aGVtIHNlcGFyYXRlbHkgYmVmb3JlIGJlaW5nIHJlY29tYmluZWQuXG5cdFx0ICogICAgICAgICBBcHBsaWVzIGEgTWlkL1NpZGUgc2VwZXJhdGlvbiBhbmQgcmVjb21iaW5hdGlvbi5cblx0XHQgKiAgICAgICAgIEFsZ29yaXRobSBmb3VuZCBpbiBba3ZyYXVkaW8gZm9ydW1zXShodHRwOi8vd3d3Lmt2cmF1ZGlvLmNvbS9mb3J1bS92aWV3dG9waWMucGhwP3Q9MjEyNTg3KS5cblx0XHQgKiAgICAgICAgIDxicj48YnI+XG5cdFx0ICogICAgICAgICBUaGlzIGlzIGEgYmFzZS1jbGFzcyBmb3IgTWlkL1NpZGUgRWZmZWN0cy4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0ICAgIFRvbmUuTWlkU2lkZUVmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkVmZmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvc2lkZSBzcGxpdFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlU3BsaXR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVTcGxpdCA9IG5ldyBUb25lLk1pZFNpZGVTcGxpdCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQvc2lkZSBtZXJnZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5NaWRTaWRlTWVyZ2V9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZSA9IG5ldyBUb25lLk1pZFNpZGVNZXJnZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtaWQgc2VuZC4gQ29ubmVjdCB0byBtaWQgcHJvY2Vzc2luZ1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkV4cHJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubWlkU2VuZCA9IHRoaXMuX21pZFNpZGVTcGxpdC5taWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNpZGUgc2VuZC4gQ29ubmVjdCB0byBzaWRlIHByb2Nlc3Npbmdcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5FeHByfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGVTZW5kID0gdGhpcy5fbWlkU2lkZVNwbGl0LnNpZGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1pZCByZXR1cm4gY29ubmVjdGlvblxuXHRcdFx0ICogIEB0eXBlIHtHYWluTm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5taWRSZXR1cm4gPSB0aGlzLl9taWRTaWRlTWVyZ2UubWlkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBzaWRlIHJldHVybiBjb25uZWN0aW9uXG5cdFx0XHQgKiAgQHR5cGUge0dhaW5Ob2RlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnNpZGVSZXR1cm4gPSB0aGlzLl9taWRTaWRlTWVyZ2Uuc2lkZTtcblx0ICAgICAgICAvL3RoZSBjb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jb25uZWN0KHRoaXMuX21pZFNpZGVTcGxpdCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlLmNvbm5lY3QodGhpcy5lZmZlY3RSZXR1cm4pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTWlkU2lkZUVmZmVjdCwgVG9uZS5FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWlkU2lkZUVmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NaWRTaWRlRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZVNwbGl0LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9taWRTaWRlU3BsaXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21pZFNpZGVNZXJnZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkU2lkZU1lcmdlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1pZFNlbmQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc2lkZVNlbmQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubWlkUmV0dXJuID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnNpZGVSZXR1cm4gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1pZFNpZGVFZmZlY3Q7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBoYXNlciBpcyBhIHBoYXNlciBlZmZlY3QuIFBoYXNlcnMgd29yayBieSBjaGFuZ2luZyB0aGUgcGhhc2Vcblx0XHQgKiAgICAgICAgIG9mIGRpZmZlcmVudCBmcmVxdWVuY3kgY29tcG9uZW50cyBvZiBhbiBpbmNvbWluZyBzaWduYWwuIFJlYWQgbW9yZSBvbiBcblx0XHQgKiAgICAgICAgIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BoYXNlcl8oZWZmZWN0KSkuIFxuXHRcdCAqICAgICAgICAgSW5zcGlyYXRpb24gZm9yIHRoaXMgcGhhc2VyIGNvbWVzIGZyb20gW1R1bmEuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9EaW5haG1vZS90dW5hLykuXG5cdFx0ICpcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QHBhcmFtIHtGcmVxdWVuY3l8T2JqZWN0fSBbZnJlcXVlbmN5XSBUaGUgc3BlZWQgb2YgdGhlIHBoYXNpbmcuIFxuXHRcdCAqXHRAcGFyYW0ge251bWJlcn0gW29jdGF2ZXNdIFRoZSBvY3RhdmVzIG9mIHRoZSBlZmZlY3QuIFxuXHRcdCAqXHRAcGFyYW0ge0ZyZXF1ZW5jeX0gW2Jhc2VGcmVxdWVuY3ldIFRoZSBiYXNlIGZyZXF1ZW5jeSBvZiB0aGUgZmlsdGVycy4gXG5cdFx0ICpcdEBleGFtcGxlXG5cdFx0ICogdmFyIHBoYXNlciA9IG5ldyBUb25lLlBoYXNlcih7XG5cdFx0ICogXHRcImZyZXF1ZW5jeVwiIDogMTUsIFxuXHRcdCAqIFx0XCJvY3RhdmVzXCIgOiA1LCBcblx0XHQgKiBcdFwiYmFzZUZyZXF1ZW5jeVwiIDogMTAwMFxuXHRcdCAqIH0pLnRvTWFzdGVyKCk7XG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuRk1TeW50aCgpLmNvbm5lY3QocGhhc2VyKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkUzXCIsIFwiMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvL3NldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnb2N0YXZlcycsXG5cdCAgICAgICAgICAgICdiYXNlRnJlcXVlbmN5J1xuXHQgICAgICAgIF0sIFRvbmUuUGhhc2VyKTtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBsZm8gd2hpY2ggY29udHJvbHMgdGhlIGZyZXF1ZW5jeSBvbiB0aGUgbGVmdCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9MID0gbmV3IFRvbmUuTEZPKG9wdGlvbnMuZnJlcXVlbmN5LCAwLCAxKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbGZvIHdoaWNoIGNvbnRyb2xzIHRoZSBmcmVxdWVuY3kgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBuZXcgVG9uZS5MRk8ob3B0aW9ucy5mcmVxdWVuY3ksIDAsIDEpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IucGhhc2UgPSAxODA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJhc2UgbW9kdWxhdGlvbiBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7bnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBvY3RhdmVzIG9mIHRoZSBwaGFzaW5nXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVhbGl0eSBmYWN0b3Igb2YgdGhlIGZpbHRlcnNcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5RID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuUSwgVG9uZS5UeXBlLlBvc2l0aXZlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYXJyYXkgb2YgZmlsdGVycyBmb3IgdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc0wgPSB0aGlzLl9tYWtlRmlsdGVycyhvcHRpb25zLnN0YWdlcywgdGhpcy5fbGZvTCwgdGhpcy5RKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYXJyYXkgb2YgZmlsdGVycyBmb3IgdGhlIGxlZnQgc2lkZVxuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmlsdGVyc1IgPSB0aGlzLl9tYWtlRmlsdGVycyhvcHRpb25zLnN0YWdlcywgdGhpcy5fbGZvUiwgdGhpcy5RKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHRoZSBmcmVxdWVuY3kgb2YgdGhlIGVmZmVjdFxuXHRcdFx0ICogQHR5cGUge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9sZm9MLmZyZXF1ZW5jeTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS52YWx1ZSA9IG9wdGlvbnMuZnJlcXVlbmN5O1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGVtIHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jb25uZWN0KHRoaXMuX2ZpbHRlcnNMWzBdKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNvbm5lY3QodGhpcy5fZmlsdGVyc1JbMF0pO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMW29wdGlvbnMuc3RhZ2VzIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNSW29wdGlvbnMuc3RhZ2VzIC0gMV0uY29ubmVjdCh0aGlzLmVmZmVjdFJldHVyblIpO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgZnJlcXVlbmN5IHdpdGggb25lIExGT1xuXHQgICAgICAgIHRoaXMuX2xmb0wuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fbGZvUi5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvcHRpb25zXG5cdCAgICAgICAgdGhpcy5iYXNlRnJlcXVlbmN5ID0gb3B0aW9ucy5iYXNlRnJlcXVlbmN5O1xuXHQgICAgICAgIHRoaXMub2N0YXZlcyA9IG9wdGlvbnMub2N0YXZlcztcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBsZm9cblx0ICAgICAgICB0aGlzLl9sZm9MLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCgpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdRJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGhhc2VyLCBUb25lLlN0ZXJlb0VmZmVjdCk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdHNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7b2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QaGFzZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDAuNSxcblx0ICAgICAgICAnb2N0YXZlcyc6IDMsXG5cdCAgICAgICAgJ3N0YWdlcyc6IDEwLFxuXHQgICAgICAgICdRJzogMTAsXG5cdCAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAzNTBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHN0YWdlc1xuXHRcdCAqICBAcmV0dXJucyB7QXJyYXl9IHRoZSBudW1iZXIgb2YgZmlsdGVycyBhbGwgY29ubmVjdGVkIHRvZ2V0aGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBoYXNlci5wcm90b3R5cGUuX21ha2VGaWx0ZXJzID0gZnVuY3Rpb24gKHN0YWdlcywgY29ubmVjdFRvRnJlcSwgUSkge1xuXHQgICAgICAgIHZhciBmaWx0ZXJzID0gbmV3IEFycmF5KHN0YWdlcyk7XG5cdCAgICAgICAgLy9tYWtlIGFsbCB0aGUgZmlsdGVyc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhZ2VzOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuY29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblx0ICAgICAgICAgICAgZmlsdGVyLnR5cGUgPSAnYWxscGFzcyc7XG5cdCAgICAgICAgICAgIFEuY29ubmVjdChmaWx0ZXIuUSk7XG5cdCAgICAgICAgICAgIGNvbm5lY3RUb0ZyZXEuY29ubmVjdChmaWx0ZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICAgICAgZmlsdGVyc1tpXSA9IGZpbHRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgVG9uZS5jb25uZWN0U2VyaWVzLmFwcGx5KFRvbmUsIGZpbHRlcnMpO1xuXHQgICAgICAgIHJldHVybiBmaWx0ZXJzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGUgcGhhc2UgZ29lcyBhYm92ZVxuXHRcdCAqIHRoZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGhhc2VyI1xuXHRcdCAqIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiBAbmFtZSBvY3RhdmVzXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaGFzZXIucHJvdG90eXBlLCAnb2N0YXZlcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29jdGF2ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChvY3RhdmVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvY3RhdmVzO1xuXHQgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5fYmFzZUZyZXF1ZW5jeSAqIE1hdGgucG93KDIsIG9jdGF2ZXMpO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1heCA9IG1heDtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi5tYXggPSBtYXg7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdGhlIGJhc2UgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXJzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QaGFzZXIjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBiYXNlRnJlcXVlbmN5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QaGFzZXIucHJvdG90eXBlLCAnYmFzZUZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VGcmVxdWVuY3k7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmcmVxKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Jhc2VGcmVxdWVuY3kgPSBmcmVxO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLm1pbiA9IGZyZXE7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmb1IubWluID0gZnJlcTtcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QaGFzZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGhhc2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ1EnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5RLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLlEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0wuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0wgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb1IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZmlsdGVyc0wubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc0xbaV0uZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJzTFtpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2ZpbHRlcnNMID0gbnVsbDtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2ZpbHRlcnNSLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlcnNSW2pdLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fZmlsdGVyc1Jbal0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maWx0ZXJzUiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBoYXNlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBpbmdQb25nRGVsYXkgaXMgYSBmZWVkYmFjayBkZWxheSBlZmZlY3Qgd2hlcmUgdGhlIGVjaG8gaXMgaGVhcmRcblx0XHQgKiAgICAgICAgICBmaXJzdCBpbiBvbmUgY2hhbm5lbCBhbmQgbmV4dCBpbiB0aGUgb3Bwb3NpdGUgY2hhbm5lbC4gSW4gYSBzdGVyZW9cblx0XHQgKiAgICAgICAgICBzeXN0ZW0gdGhlc2UgYXJlIHRoZSByaWdodCBhbmQgbGVmdCBjaGFubmVscy5cblx0XHQgKiAgICAgICAgICBQaW5nUG9uZ0RlbGF5IGluIG1vcmUgc2ltcGxpZmllZCB0ZXJtcyBpcyB0d28gVG9uZS5GZWVkYmFja0RlbGF5cyBcblx0XHQgKiAgICAgICAgICB3aXRoIGluZGVwZW5kZW50IGRlbGF5IHZhbHVlcy4gRWFjaCBkZWxheSBpcyByb3V0ZWQgdG8gb25lIGNoYW5uZWxcblx0XHQgKiAgICAgICAgICAobGVmdCBvciByaWdodCksIGFuZCB0aGUgY2hhbm5lbCB0cmlnZ2VyZWQgc2Vjb25kIHdpbGwgYWx3YXlzIFxuXHRcdCAqICAgICAgICAgIHRyaWdnZXIgYXQgdGhlIHNhbWUgaW50ZXJ2YWwgYWZ0ZXIgdGhlIGZpcnN0LlxuXHRcdCAqXG5cdFx0ICogXHRAY29uc3RydWN0b3Jcblx0XHQgKiBcdEBleHRlbmRzIHtUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdH1cblx0XHQgKiAgQHBhcmFtIHtUaW1lfE9iamVjdH0gW2RlbGF5VGltZV0gVGhlIGRlbGF5VGltZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGVjaG9zLlxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlPX0gZmVlZGJhY2sgVGhlIGFtb3VudCBvZiB0aGUgZWZmZWN0ZWQgc2lnbmFsIHdoaWNoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZmVkIGJhY2sgdGhyb3VnaCB0aGUgZGVsYXkuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBpbmdQb25nID0gbmV3IFRvbmUuUGluZ1BvbmdEZWxheShcIjRuXCIsIDAuMikudG9NYXN0ZXIoKTtcblx0XHQgKiB2YXIgZHJ1bSA9IG5ldyBUb25lLkRydW1TeW50aCgpLmNvbm5lY3QocGluZ1BvbmcpO1xuXHRcdCAqIGRydW0udHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjMyblwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGluZ1BvbmdEZWxheSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdkZWxheVRpbWUnLFxuXHQgICAgICAgICAgICAnZmVlZGJhY2snXG5cdCAgICAgICAgXSwgVG9uZS5QaW5nUG9uZ0RlbGF5KTtcblx0ICAgICAgICBUb25lLlN0ZXJlb1hGZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSBsZWZ0IHNpZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGVmdERlbGF5ID0gbmV3IFRvbmUuRGVsYXkoMCwgb3B0aW9ucy5tYXhEZWxheVRpbWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBkZWxheSBub2RlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0RGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHByZWRlbGF5IG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRGVsYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3JpZ2h0UHJlRGVsYXkgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGRlbGF5IHRpbWUgc2lnbmFsXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZWxheVRpbWUsIFRvbmUuVHlwZS5UaW1lKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgaXQgdXBcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRMLmNoYWluKHRoaXMuX2xlZnREZWxheSwgdGhpcy5lZmZlY3RSZXR1cm5MKTtcblx0ICAgICAgICB0aGlzLmVmZmVjdFNlbmRSLmNoYWluKHRoaXMuX3JpZ2h0UHJlRGVsYXksIHRoaXMuX3JpZ2h0RGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuUik7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZmFuKHRoaXMuX2xlZnREZWxheS5kZWxheVRpbWUsIHRoaXMuX3JpZ2h0RGVsYXkuZGVsYXlUaW1lLCB0aGlzLl9yaWdodFByZURlbGF5LmRlbGF5VGltZSk7XG5cdCAgICAgICAgLy9yZWFycmFuZ2VkIHRoZSBmZWVkYmFjayB0byBiZSBhZnRlciB0aGUgcmlnaHRQcmVEZWxheVxuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrTFIuY29ubmVjdCh0aGlzLl9yaWdodERlbGF5KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2RlbGF5VGltZSddKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBpbmdQb25nRGVsYXksIFRvbmUuU3RlcmVvWEZlZWRiYWNrRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2RlbGF5VGltZSc6IDAuMjUsXG5cdCAgICAgICAgJ21heERlbGF5VGltZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuIFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QaW5nUG9uZ0RlbGF5fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBpbmdQb25nRGVsYXkucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9YRmVlZGJhY2tFZmZlY3QucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9sZWZ0RGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xlZnREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHREZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fcmlnaHRQcmVEZWxheSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWydkZWxheVRpbWUnXSk7XG5cdCAgICAgICAgdGhpcy5kZWxheVRpbWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaW5nUG9uZ0RlbGF5O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QaXRjaFNoaWZ0IGRvZXMgbmVhci1yZWFsdGltZSBwaXRjaCBzaGlmdGluZyB0byB0aGUgaW5jb21pbmcgc2lnbmFsLiBcblx0XHQgKiAgICAgICAgIFRoZSBlZmZlY3QgaXMgYWNoaWV2ZWQgYnkgc3BlZWRpbmcgdXAgb3Igc2xvd2luZyBkb3duIHRoZSBkZWxheVRpbWVcblx0XHQgKiAgICAgICAgIG9mIGEgRGVsYXlOb2RlIHVzaW5nIGEgc2F3dG9vdGggd2F2ZS4gXG5cdFx0ICogICAgICAgICBBbGdvcml0aG0gZm91bmQgaW4gW3RoaXMgcGRmXShodHRwOi8vZHNwLWJvb2submFyb2QucnUvc291bmRwcm9jLnBkZikuXG5cdFx0ICogICAgICAgICBBZGRpdGlvbmFsIHJlZmVyZW5jZSBieSBbTWlsbGVyIFB1Y2tldF0oaHR0cDovL21zcC51Y3NkLmVkdS90ZWNobmlxdWVzL3YwLjExL2Jvb2staHRtbC9ub2RlMTE1Lmh0bWwpLlxuXHRcdCAqICAgICAgICAgXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkZlZWRiYWNrRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ludGVydmFsPX0gcGl0Y2ggVGhlIGludGVydmFsIHRvIHRyYW5zcG9zZSB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5LiBcblx0XHQgKi9cblx0ICAgIFRvbmUuUGl0Y2hTaGlmdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3BpdGNoJ10sIFRvbmUuUGl0Y2hTaGlmdCk7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBwaXRjaCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuU2lnbmFsfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwoMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVXNlcyB0d28gRGVsYXlOb2RlcyB0byBjb3ZlciB1cCB0aGUganVtcCBpblxuXHRcdFx0ICogIHRoZSBzYXd0b290aCB3YXZlLiBcblx0XHRcdCAqICBAdHlwZSAge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlBID0gbmV3IFRvbmUuRGVsYXkoMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpcnN0IExGTy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9BID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAwLjEsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ3Nhd3Rvb3RoJ1xuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5fZGVsYXlBLmRlbGF5VGltZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHNlY29uZCBEZWxheU5vZGVcblx0XHRcdCAqICBAdHlwZSAge0RlbGF5Tm9kZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGVsYXlCID0gbmV3IFRvbmUuRGVsYXkoMCwgMSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZpcnN0IExGTy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9CID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAwLjEsXG5cdCAgICAgICAgICAgICd0eXBlJzogJ3Nhd3Rvb3RoJyxcblx0ICAgICAgICAgICAgJ3BoYXNlJzogMTgwXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLl9kZWxheUIuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBDcm9zc2ZhZGUgcXVpY2tseSBiZXR3ZWVuIHRoZSB0d28gZGVsYXkgbGluZXNcblx0XHRcdCAqICB0byBjb3ZlciB1cCB0aGUganVtcCBpbiB0aGUgc2F3dG9vdGggd2F2ZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Dcm9zc0ZhZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZSA9IG5ldyBUb25lLkNyb3NzRmFkZSgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIExGTyB3aGljaCBhbHRlcm5hdGVzIGJldHdlZW4gdGhlIHR3b1xuXHRcdFx0ICogIGRlbGF5IGxpbmVzIHRvIGNvdmVyIHVwIHRoZSBkaXNwYXJpdHkgaW4gdGhlXG5cdFx0XHQgKiAgc2F3dG9vdGggd2F2ZS4gXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlTEZPID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ21pbic6IDAsXG5cdCAgICAgICAgICAgICdtYXgnOiAxLFxuXHQgICAgICAgICAgICAndHlwZSc6ICd0cmlhbmdsZScsXG5cdCAgICAgICAgICAgICdwaGFzZSc6IDkwXG5cdCAgICAgICAgfSkuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUuZmFkZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlbGF5IG5vZGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5EZWxheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tEZWxheSA9IG5ldyBUb25lLkRlbGF5KG9wdGlvbnMuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1vdW50IG9mIGRlbGF5IG9uIHRoZSBpbnB1dCBzaWduYWxcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRlbGF5VGltZSA9IHRoaXMuX2ZlZWRiYWNrRGVsYXkuZGVsYXlUaW1lO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KCdkZWxheVRpbWUnKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIb2xkIHRoZSBjdXJyZW50IHBpdGNoXG5cdFx0XHQgKiAgQHR5cGUge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fcGl0Y2ggPSBvcHRpb25zLnBpdGNoO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEhvbGQgdGhlIGN1cnJlbnQgd2luZG93U2l6ZVxuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dpbmRvd1NpemUgPSBvcHRpb25zLndpbmRvd1NpemU7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSB0d28gZGVsYXkgbGluZXMgdXBcblx0ICAgICAgICB0aGlzLl9kZWxheUEuY29ubmVjdCh0aGlzLl9jcm9zc0ZhZGUuYSk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlCLmNvbm5lY3QodGhpcy5fY3Jvc3NGYWRlLmIpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5LmZhbih0aGlzLl9sZm9BLmZyZXF1ZW5jeSwgdGhpcy5fbGZvQi5mcmVxdWVuY3ksIHRoaXMuX2Nyb3NzRmFkZUxGTy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vcm91dGUgdGhlIGlucHV0XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kLmZhbih0aGlzLl9kZWxheUEsIHRoaXMuX2RlbGF5Qik7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmNoYWluKHRoaXMuX2ZlZWRiYWNrRGVsYXksIHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgICAgICAvL3N0YXJ0IHRoZSBMRk9zIGF0IHRoZSBzYW1lIHRpbWVcblx0ICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3coKTtcblx0ICAgICAgICB0aGlzLl9sZm9BLnN0YXJ0KG5vdyk7XG5cdCAgICAgICAgdGhpcy5fbGZvQi5zdGFydChub3cpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTy5zdGFydChub3cpO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlXG5cdCAgICAgICAgdGhpcy53aW5kb3dTaXplID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBpdGNoU2hpZnQsIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKiAgQGNvbnN0XG5cdFx0ICovXG5cdCAgICBUb25lLlBpdGNoU2hpZnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3BpdGNoJzogMCxcblx0ICAgICAgICAnd2luZG93U2l6ZSc6IDAuMSxcblx0ICAgICAgICAnZGVsYXlUaW1lJzogMCxcblx0ICAgICAgICAnZmVlZGJhY2snOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogUmVwaXRjaCB0aGUgaW5jb21pbmcgc2lnbmFsIGJ5IHNvbWUgaW50ZXJ2YWwgKG1lYXN1cmVkXG5cdFx0ICogaW4gc2VtaS10b25lcykuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBpdGNoU2hpZnQjXG5cdFx0ICogQHR5cGUge0ludGVydmFsfVxuXHRcdCAqIEBuYW1lIHBpdGNoXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBwaXRjaFNoaWZ0LnBpdGNoID0gLTEyOyAvL2Rvd24gb25lIG9jdGF2ZVxuXHRcdCAqIHBpdGNoU2hpZnQucGl0Y2ggPSA3OyAvL3VwIGEgZmlmdGhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBpdGNoU2hpZnQucHJvdG90eXBlLCAncGl0Y2gnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9waXRjaDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BpdGNoID0gaW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIHZhciBmYWN0b3IgPSAwO1xuXHQgICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1pbiA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9BLm1heCA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1pbiA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sZm9CLm1heCA9IHRoaXMuX3dpbmRvd1NpemU7XG5cdCAgICAgICAgICAgICAgICBmYWN0b3IgPSBUb25lLmludGVydmFsVG9GcmVxdWVuY3lSYXRpbyhpbnRlcnZhbCAtIDEpICsgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWluID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0EubWF4ID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWluID0gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xmb0IubWF4ID0gMDtcblx0ICAgICAgICAgICAgICAgIGZhY3RvciA9IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKGludGVydmFsKSAtIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZnJlcXVlbmN5LnZhbHVlID0gZmFjdG9yICogKDEuMiAvIHRoaXMuX3dpbmRvd1NpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHdpbmRvdyBzaXplIGNvcnJlc3BvbmRzIHJvdWdobHkgdG8gdGhlIHNhbXBsZSBsZW5ndGggaW4gYSBsb29waW5nIHNhbXBsZXIuIFxuXHRcdCAqIFNtYWxsZXIgdmFsdWVzIGFyZSBkZXNpcmFibGUgZm9yIGEgbGVzcyBub3RpY2VhYmxlIGRlbGF5IHRpbWUgb2YgdGhlIHBpdGNoIHNoaWZ0ZWRcblx0XHQgKiBzaWduYWwsIGJ1dCBsYXJnZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIHNtb290aGVyIHBpdGNoIHNoaWZ0aW5nIGZvciBsYXJnZXIgaW50ZXJ2YWxzLiBcblx0XHQgKiBBIG5vbWluYWwgcmFuZ2Ugb2YgMC4wMyB0byAwLjEgaXMgcmVjb21tZW5kZWQuIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBpdGNoU2hpZnQjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgd2luZG93U2l6ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogcGl0Y2hTaGlmdC53aW5kb3dTaXplID0gMC4xO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGl0Y2hTaGlmdC5wcm90b3R5cGUsICd3aW5kb3dTaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93U2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNpemUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fd2luZG93U2l6ZSA9IHRoaXMudG9TZWNvbmRzKHNpemUpO1xuXHQgICAgICAgICAgICB0aGlzLnBpdGNoID0gdGhpcy5fcGl0Y2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBpdGNoU2hpZnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBpdGNoU2hpZnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2ZyZXF1ZW5jeS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9kZWxheUEuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgIHRoaXMuX2RlbGF5QSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlCLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheUIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0EuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0EgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmb0IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2xmb0IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY3Jvc3NGYWRlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jcm9zc0ZhZGVMRk8uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2Nyb3NzRmFkZUxGTyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ2RlbGF5VGltZScpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrRGVsYXkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrRGVsYXkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVsYXlUaW1lID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QaXRjaFNoaWZ0O1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgQmFzZSBjbGFzcyBmb3Igc3RlcmVvIGZlZWRiYWNrIGVmZmVjdHMgd2hlcmUgdGhlIGVmZmVjdFJldHVyblxuXHRcdCAqICAgICAgICAgaXMgZmVkIGJhY2sgaW50byB0aGUgc2FtZSBjaGFubmVsLiBcblx0XHQgKlxuXHRcdCAqXHRAY29uc3RydWN0b3Jcblx0XHQgKlx0QGV4dGVuZHMge1RvbmUuU3RlcmVvRWZmZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ2ZlZWRiYWNrJ10sIFRvbmUuRmVlZGJhY2tFZmZlY3QpO1xuXHQgICAgICAgIFRvbmUuU3RlcmVvRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udHJvbHMgdGhlIGFtb3VudCBvZiBmZWVkYmFja1xuXHRcdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZlZWRiYWNrID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZmVlZGJhY2ssIFRvbmUuVHlwZS5Ob3JtYWxSYW5nZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGxlZnQgc2lkZSBmZWViYWNrXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSByaWdodCBzaWRlIGZlZWJhY2tcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mZWVkYmFja1IgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLy9jb25uZWN0IGl0IHVwXG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5MLmNoYWluKHRoaXMuX2ZlZWRiYWNrTCwgdGhpcy5lZmZlY3RTZW5kTCk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RSZXR1cm5SLmNoYWluKHRoaXMuX2ZlZWRiYWNrUiwgdGhpcy5lZmZlY3RTZW5kUik7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5mYW4odGhpcy5fZmVlZGJhY2tMLmdhaW4sIHRoaXMuX2ZlZWRiYWNrUi5nYWluKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbJ2ZlZWRiYWNrJ10pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuU3RlcmVvRmVlZGJhY2tFZmZlY3QsIFRvbmUuU3RlcmVvRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnZmVlZGJhY2snXSk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5mZWVkYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9mZWVkYmFja0wgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2ZlZWRiYWNrUi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmVlZGJhY2tSID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5TdGVyZW9GZWVkYmFja0VmZmVjdDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEFwcGxpZXMgYSB3aWR0aCBmYWN0b3IgdG8gdGhlIG1pZC9zaWRlIHNlcGVyYXRpb24uIFxuXHRcdCAqICAgICAgICAgMCBpcyBhbGwgbWlkIGFuZCAxIGlzIGFsbCBzaWRlLlxuXHRcdCAqICAgICAgICAgQWxnb3JpdGhtIGZvdW5kIGluIFtrdnJhdWRpbyBmb3J1bXNdKGh0dHA6Ly93d3cua3ZyYXVkaW8uY29tL2ZvcnVtL3ZpZXd0b3BpYy5waHA/dD0yMTI1ODcpLlxuXHRcdCAqICAgICAgICAgPGJyPjxicj5cblx0XHQgKiAgICAgICAgIDxjb2RlPlxuXHRcdCAqICAgICAgICAgTWlkICo9IDIqKDEtd2lkdGgpPGJyPlxuXHRcdCAqICAgICAgICAgU2lkZSAqPSAyKndpZHRoXG5cdFx0ICogICAgICAgICA8L2NvZGU+XG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTWlkU2lkZUVmZmVjdH1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V8T2JqZWN0fSBbd2lkdGhdIFRoZSBzdGVyZW8gd2lkdGguIEEgd2lkdGggb2YgMCBpcyBtb25vIGFuZCAxIGlzIHN0ZXJlby4gMC41IGlzIG5vIGNoYW5nZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuU3RlcmVvV2lkZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbJ3dpZHRoJ10sIFRvbmUuU3RlcmVvV2lkZW5lcik7XG5cdCAgICAgICAgVG9uZS5NaWRTaWRlRWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHdpZHRoIGNvbnRyb2wuIDAgPSAxMDAlIG1pZC4gMSA9IDEwMCUgc2lkZS4gMC41ID0gbm8gY2hhbmdlLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLndpZHRoLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIE1pZCBtdWx0aXBsaWVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdCA9IG5ldyBUb25lLkV4cHIoJyQwICogKCQxICogKDEgLSAkMikpJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2lkZSBtdWx0aXBsaWVyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuRXhwcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc2lkZU11bHQgPSBuZXcgVG9uZS5FeHByKCckMCAqICgkMSAqICQyKScpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGNvbnN0YW50IG91dHB1dCBvZiAyXG5cdFx0XHQgKiAgQHR5cGUge1RvbmV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3R3byA9IG5ldyBUb25lLlNpZ25hbCgyKTtcblx0ICAgICAgICAvL3RoZSBtaWQgY2hhaW5cblx0ICAgICAgICB0aGlzLl90d28uY29ubmVjdCh0aGlzLl9taWRNdWx0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmNvbm5lY3QodGhpcy5fbWlkTXVsdCwgMCwgMik7XG5cdCAgICAgICAgLy90aGUgc2lkZSBjaGFpblxuXHQgICAgICAgIHRoaXMuX3R3by5jb25uZWN0KHRoaXMuX3NpZGVNdWx0LCAwLCAxKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmNvbm5lY3QodGhpcy5fc2lkZU11bHQsIDAsIDIpO1xuXHQgICAgICAgIC8vY29ubmVjdCBpdCB0byB0aGUgZWZmZWN0IHNlbmQvcmV0dXJuXG5cdCAgICAgICAgdGhpcy5taWRTZW5kLmNoYWluKHRoaXMuX21pZE11bHQsIHRoaXMubWlkUmV0dXJuKTtcblx0ICAgICAgICB0aGlzLnNpZGVTZW5kLmNoYWluKHRoaXMuX3NpZGVNdWx0LCB0aGlzLnNpZGVSZXR1cm4pO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFsnd2lkdGgnXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TdGVyZW9XaWRlbmVyLCBUb25lLk1pZFNpZGVFZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlN0ZXJlb1dpZGVuZXIuZGVmYXVsdHMgPSB7ICd3aWR0aCc6IDAuNSB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3RlcmVvV2lkZW5lcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TdGVyZW9XaWRlbmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTWlkU2lkZUVmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFsnd2lkdGgnXSk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbWlkTXVsdCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc2lkZU11bHQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3NpZGVNdWx0ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90d28uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3R3byA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU3RlcmVvV2lkZW5lcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIFRvbmUuVHJlbW9sbyBtb2R1bGF0ZXMgdGhlIGFtcGxpdHVkZSBvZiBhbiBpbmNvbWluZyBzaWduYWwgdXNpbmcgYSBUb25lLkxGTy5cblx0XHQgKiAgICAgICAgIFRoZSB0eXBlLCBmcmVxdWVuY3ksIGFuZCBkZXB0aCBvZiB0aGUgTEZPIGlzIGNvbnRyb2xsYWJsZS5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TdGVyZW9FZmZlY3R9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gW2ZyZXF1ZW5jeV0gVGhlIHJhdGUgb2YgdGhlIGVmZmVjdC5cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW2RlcHRoXSBUaGUgZGVwdGggb2YgdGhlIGVmZmVjdC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NyZWF0ZSBhIHRyZW1vbG8gYW5kIHN0YXJ0IGl0J3MgTEZPXG5cdFx0ICogdmFyIHRyZW1vbG8gPSBuZXcgVG9uZS5UcmVtb2xvKDksIDAuNzUpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKiAvL3JvdXRlIGFuIG9zY2lsbGF0b3IgdGhyb3VnaCB0aGUgdHJlbW9sbyBhbmQgc3RhcnQgaXRcblx0XHQgKiB2YXIgb3NjaWxsYXRvciA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKS5jb25uZWN0KHRyZW1vbG8pLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuVHJlbW9sbyk7XG5cdCAgICAgICAgVG9uZS5TdGVyZW9FZmZlY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdHJlbWVsbyBMRk8gaW4gdGhlIGxlZnQgY2hhbm5lbFxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xmb0wgPSBuZXcgVG9uZS5MRk8oe1xuXHQgICAgICAgICAgICAncGhhc2UnOiBvcHRpb25zLnNwcmVhZCxcblx0ICAgICAgICAgICAgJ21pbic6IDEsXG5cdCAgICAgICAgICAgICdtYXgnOiAwXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRyZW1lbG8gTEZPIGluIHRoZSBsZWZ0IGNoYW5uZWxcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuTEZPfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZm9SID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3BoYXNlJzogb3B0aW9ucy5zcHJlYWQsXG5cdCAgICAgICAgICAgICdtaW4nOiAxLFxuXHQgICAgICAgICAgICAnbWF4JzogMFxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFdoZXJlIHRoZSBnYWluIGlzIG11bHRpcGxpZWRcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWRlTCA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBXaGVyZSB0aGUgZ2FpbiBpcyBtdWx0aXBsaWVkXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVkZVIgPSBuZXcgVG9uZS5HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgdHJlbW9sby5cblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlcHRoIG9mIHRoZSBlZmZlY3QuIEEgZGVwdGggb2YgMCwgaGFzIG5vIGVmZmVjdFxuXHRcdFx0ICogIG9uIHRoZSBhbXBsaXR1ZGUsIGFuZCBhIGRlcHRoIG9mIDEgbWFrZXMgdGhlIGFtcGxpdHVkZVxuXHRcdFx0ICogIG1vZHVsYXRlIGZ1bGx5IGJldHdlZW4gMCBhbmQgMS5cblx0XHRcdCAqICBAdHlwZSAge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXB0aCwgVG9uZS5UeXBlLk5vcm1hbFJhbmdlKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5lZmZlY3RTZW5kTC5jaGFpbih0aGlzLl9hbXBsaXR1ZGVMLCB0aGlzLmVmZmVjdFJldHVybkwpO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZFIuY2hhaW4odGhpcy5fYW1wbGl0dWRlUiwgdGhpcy5lZmZlY3RSZXR1cm5SKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlTC5nYWluKTtcblx0ICAgICAgICB0aGlzLl9sZm9SLmNvbm5lY3QodGhpcy5fYW1wbGl0dWRlUi5nYWluKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5mYW4odGhpcy5fbGZvTC5mcmVxdWVuY3ksIHRoaXMuX2xmb1IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRlcHRoLmZhbih0aGlzLl9sZm9SLmFtcGxpdHVkZSwgdGhpcy5fbGZvTC5hbXBsaXR1ZGUpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICB0aGlzLnNwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJlbW9sbywgVG9uZS5TdGVyZW9FZmZlY3QpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDEwLFxuXHQgICAgICAgICd0eXBlJzogJ3NpbmUnLFxuXHQgICAgICAgICdkZXB0aCc6IDAuNSxcblx0ICAgICAgICAnc3ByZWFkJzogMTgwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RhcnQgdGhlIHRyZW1vbG8uXG5cdFx0ICogQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIHRyZW1vbG8gYmVnaW5zLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTdG9wIHRoZSB0cmVtb2xvLlxuXHRcdCAqIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSB0cmVtb2xvIHN0b3BzLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fbGZvTC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX2xmb1Iuc3RvcCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTeW5jIHRoZSBlZmZlY3QgdG8gdGhlIHRyYW5zcG9ydC5cblx0XHQgKiBAcGFyYW0ge1RpbWV9IFtkZWxheT0wXSBEZWxheSB0aW1lIGJlZm9yZSBzdGFydGluZyB0aGUgZWZmZWN0IGFmdGVyIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNwb3J0IGhhcyBzdGFydGVkLlxuXHRcdCAqIEByZXR1cm5zIHtUb25lLkF1dG9GaWx0ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChkZWxheSkge1xuXHQgICAgICAgIHRoaXMuX2xmb0wuc3luYyhkZWxheSk7XG5cdCAgICAgICAgdGhpcy5fbGZvUi5zeW5jKGRlbGF5KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBVbnN5bmMgdGhlIGZpbHRlciBmcm9tIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBAcmV0dXJucyB7VG9uZS5UcmVtb2xvfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyZW1vbG8ucHJvdG90eXBlLnVuc3luYyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9sZm9MLnVuc3luYygpO1xuXHQgICAgICAgIHRoaXMuX2xmb1IudW5zeW5jKCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIFRyZW1vbG8ncyBvc2NpbGxhdG9yIHR5cGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuVHJlbW9sbyNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlRyZW1vbG8ucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xmb0wudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvTC50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgdGhpcy5fbGZvUi50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKiBcblx0XHQgKiBBbW91bnQgb2Ygc3RlcmVvIHNwcmVhZC4gV2hlbiBzZXQgdG8gMCwgYm90aCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBjZW50cmFsbHkuXG5cdFx0ICogV2hlbiBzZXQgdG8gMTgwLCBMRk8ncyB3aWxsIGJlIHBhbm5lZCBoYXJkIGxlZnQgYW5kIHJpZ2h0IHJlc3BlY3RpdmVseS5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5UcmVtb2xvI1xuXHRcdCAqIEB0eXBlIHtEZWdyZWVzfVxuXHRcdCAqIEBuYW1lIHNwcmVhZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVHJlbW9sby5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZm9SLnBoYXNlIC0gdGhpcy5fbGZvTC5waGFzZTsgICAgLy8xODBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9MLnBoYXNlID0gOTAgLSBzcHJlYWQgLyAyO1xuXHQgICAgICAgICAgICB0aGlzLl9sZm9SLnBoYXNlID0gc3ByZWFkIC8gMiArIDkwO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRyZW1vbG99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJlbW9sby5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlN0ZXJlb0VmZmVjdC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXB0aCdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9sZm9MLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9MID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9sZm9SLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9sZm9SID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVMID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9hbXBsaXR1ZGVSID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJlbW9sbztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIEEgVmlicmF0byBlZmZlY3QgY29tcG9zZWQgb2YgYSBUb25lLkRlbGF5IGFuZCBhIFRvbmUuTEZPLiBUaGUgTEZPXG5cdFx0ICogICAgICAgICBtb2R1bGF0ZXMgdGhlIGRlbGF5VGltZSBvZiB0aGUgZGVsYXksIGNhdXNpbmcgdGhlIHBpdGNoIHRvIHJpc2Vcblx0XHQgKiAgICAgICAgIGFuZCBmYWxsLiBcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuRWZmZWN0fVxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBmcmVxdWVuY3kgb2YgdGhlIHZpYnJhdG8uXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IGRlcHRoIFRoZSBhbW91bnQgdGhlIHBpdGNoIGlzIG1vZHVsYXRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuVmlicmF0byA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSwgVG9uZS5WaWJyYXRvKTtcblx0ICAgICAgICBUb25lLkVmZmVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZWxheSBub2RlIHVzZWQgZm9yIHRoZSB2aWJyYXRvIGVmZmVjdFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkRlbGF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBuZXcgVG9uZS5EZWxheSgwLCBvcHRpb25zLm1heERlbGF5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgTEZPIHVzZWQgdG8gY29udHJvbCB0aGUgdmlicmF0b1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxGT31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbGZvID0gbmV3IFRvbmUuTEZPKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiBvcHRpb25zLnR5cGUsXG5cdCAgICAgICAgICAgICdtaW4nOiAwLFxuXHQgICAgICAgICAgICAnbWF4Jzogb3B0aW9ucy5tYXhEZWxheSxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeSc6IG9wdGlvbnMuZnJlcXVlbmN5LFxuXHQgICAgICAgICAgICAncGhhc2UnOiAtOTAgICAgLy9vZmZzZSB0aGUgcGhhc2Ugc28gdGhlIHJlc3RpbmcgcG9zaXRpb24gaXMgaW4gdGhlIGNlbnRlclxuXHQgICAgICAgIH0pLnN0YXJ0KCkuY29ubmVjdCh0aGlzLl9kZWxheU5vZGUuZGVsYXlUaW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSB2aWJyYXRvXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IHRoaXMuX2xmby5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRlcHRoIG9mIHRoZSB2aWJyYXRvLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXB0aCA9IHRoaXMuX2xmby5hbXBsaXR1ZGU7XG5cdCAgICAgICAgdGhpcy5kZXB0aC52YWx1ZSA9IG9wdGlvbnMuZGVwdGg7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RlcHRoJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZWZmZWN0U2VuZC5jaGFpbih0aGlzLl9kZWxheU5vZGUsIHRoaXMuZWZmZWN0UmV0dXJuKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlZpYnJhdG8sIFRvbmUuRWZmZWN0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5WaWJyYXRvLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdtYXhEZWxheSc6IDAuMDA1LFxuXHQgICAgICAgICdmcmVxdWVuY3knOiA1LFxuXHQgICAgICAgICdkZXB0aCc6IDAuMSxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJ1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFR5cGUgb2Ygb3NjaWxsYXRvciBhdHRhY2hlZCB0byB0aGUgVmlicmF0by5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5WaWJyYXRvI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVmlicmF0by5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGZvLnR5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xmby50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuVmlicmF0b30gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5WaWJyYXRvLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuRWZmZWN0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fZGVsYXlOb2RlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9kZWxheU5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmby5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGVwdGgnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGVwdGggPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlZpYnJhdG87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5FdmVudCBhYnN0cmFjdHMgYXdheSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZSBhbmQgcHJvdmlkZXMgYSBzY2hlZHVsYWJsZVxuXHRcdCAqICAgICAgICAgIGNhbGxiYWNrIGZvciBhIHNpbmdsZSBvciByZXBlYXRhYmxlIGV2ZW50cyBhbG9uZyB0aGUgdGltZWxpbmUuIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lfVxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGF0IHRoZSB0aW1lLiBcblx0XHQgKiAgQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb3IgdmFsdWVzIHdoaWNoIHNob3VsZCBiZSBwYXNzZWQgdG9cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb24gaW52b2NhdGlvbi4gIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBjaG9yZCA9IG5ldyBUb25lLkV2ZW50KGZ1bmN0aW9uKHRpbWUsIGNob3JkKXtcblx0XHQgKiBcdC8vdGhlIGNob3JkIGFzIHdlbGwgYXMgdGhlIGV4YWN0IHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogXHQvL2FyZSBwYXNzZWQgaW4gYXMgYXJndW1lbnRzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuXHRcdCAqIH0sIFtcIkQ0XCIsIFwiRTRcIiwgXCJGNFwiXSk7XG5cdFx0ICogLy9zdGFydCB0aGUgY2hvcmQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJhbnNwb3J0IHRpbWVsaW5lXG5cdFx0ICogY2hvcmQuc3RhcnQoKTtcblx0XHQgKiAvL2xvb3AgaXQgZXZlcnkgbWVhc3VyZSBmb3IgOCBtZWFzdXJlc1xuXHRcdCAqIGNob3JkLmxvb3AgPSA4O1xuXHRcdCAqIGNob3JkLmxvb3BFbmQgPSBcIjFtXCI7XG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ3ZhbHVlJ1xuXHQgICAgICAgIF0sIFRvbmUuRXZlbnQpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBMb29wIHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUgIHtCb29sZWFufFBvc2l0aXZlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayB0byBpbnZva2UuIFxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdmFsdWUgd2hpY2ggaXMgcGFzc2VkIHRvIHRoZVxuXHRcdFx0ICogIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHRcdFx0ICogIEB0eXBlICB7Kn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9UaWNrcyhvcHRpb25zLmxvb3BTdGFydCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgV2hlbiB0aGUgbm90ZSBpcyBzY2hlZHVsZWQgdG8gc3RhcnQuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvVGlja3Mob3B0aW9ucy5sb29wRW5kKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUcmFja3MgdGhlIHNjaGVkdWxlZCBldmVudHNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5UaW1lbGluZVN0YXRlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBUb25lLlRpbWVsaW5lU3RhdGUoVG9uZS5TdGF0ZS5TdG9wcGVkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG5vdGUuIEEgc3BlZWQgb2YgMVxuXHRcdFx0ICogIGlzIG5vIGNoYW5nZS4gXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSAxO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEEgZGVsYXkgdGltZSBmcm9tIHdoZW4gdGhlIGV2ZW50IGlzIHNjaGVkdWxlZCB0byBzdGFydFxuXHRcdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc3RhcnRPZmZzZXQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHByaXZhdGUgaG9sZGVyIG9mIHByb2JhYmlsaXR5IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IG9wdGlvbnMucHJvYmFiaWxpdHk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFtb3VudCBvZiB2YXJpYXRpb24gZnJvbSB0aGVcblx0XHRcdCAqICBnaXZlbiB0aW1lLiBcblx0XHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxUaW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9odW1hbml6ZSA9IG9wdGlvbnMuaHVtYW5pemU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgSWYgbXV0ZSBpcyB0cnVlLCB0aGUgY2FsbGJhY2sgd29uJ3QgYmVcblx0XHRcdCAqICBpbnZva2VkLlxuXHRcdFx0ICogIEB0eXBlIHtCb29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tdXRlID0gb3B0aW9ucy5tdXRlO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5FdmVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdsb29wJzogZmFsc2UsXG5cdCAgICAgICAgJ2xvb3BFbmQnOiAnMW0nLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxLFxuXHQgICAgICAgICd2YWx1ZSc6IG51bGwsXG5cdCAgICAgICAgJ3Byb2JhYmlsaXR5JzogMSxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlLFxuXHQgICAgICAgICdodW1hbml6ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlc2NoZWR1bGUgYWxsIG9mIHRoZSBldmVudHMgYWxvbmcgdGhlIHRpbWVsaW5lXG5cdFx0ICogIHdpdGggdGhlIHVwZGF0ZWQgdmFsdWVzLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IGFmdGVyIE9ubHkgcmVzY2hlZHVsZXMgZXZlbnRzIGFmdGVyIHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLl9yZXNjaGVkdWxlRXZlbnRzID0gZnVuY3Rpb24gKGFmdGVyKSB7XG5cdCAgICAgICAgLy9pZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgc2NoZWR1bGVzIGFsbCBvZiB0aGUgZXZlbnRzXG5cdCAgICAgICAgYWZ0ZXIgPSBUb25lLmRlZmF1bHRBcmcoYWZ0ZXIsIC0xKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoRnJvbShhZnRlciwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBkdXJhdGlvbjtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGV2ZW50LmlkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIFRvbmUuVHJhbnNwb3J0LmNsZWFyKGV2ZW50LmlkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydFRpY2sgPSBldmVudC50aW1lICsgTWF0aC5yb3VuZCh0aGlzLnN0YXJ0T2Zmc2V0IC8gdGhpcy5fcGxheWJhY2tSYXRlKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoVG9uZS5pc051bWJlcih0aGlzLl9sb29wKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuX2xvb3AgKiB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRFdmVudCA9IHRoaXMuX3N0YXRlLmdldEFmdGVyKHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFdmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE1hdGgubWluKGR1cmF0aW9uLCBuZXh0RXZlbnQudGltZSAtIHN0YXJ0VGljayk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9zY2hlZHVsZSBhIHN0b3Agc2luY2UgaXQncyBmaW5pdGUgZHVyYXRpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCBzdGFydFRpY2sgKyBkdXJhdGlvbiArIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IFRvbmUuVGltZShkdXJhdGlvbiwgJ2knKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gVG9uZS5UaW1lKHRoaXMuX2dldExvb3BEdXJhdGlvbigpLCAnaScpO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LmlkID0gVG9uZS5UcmFuc3BvcnQuc2NoZWR1bGVSZXBlYXQodGhpcy5fdGljay5iaW5kKHRoaXMpLCBpbnRlcnZhbCwgVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXJ0VGljaywgJ2knKSwgZHVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5pZCA9IFRvbmUuVHJhbnNwb3J0LnNjaGVkdWxlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgc3RhcnRUaWNrICsgJ2knKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJldHVybnMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBub3RlLCBlaXRoZXIgXCJzdGFydGVkXCIgb3IgXCJzdG9wcGVkXCIuXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdGFydCBmcm9tIHRoZSBzY2hlZHVsZWQgc3RhcnQgdGltZVxuXHRcdCAqICBAdHlwZSB7VGlja3N9XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkV2ZW50I1xuXHRcdCAqICBAbmFtZSBzdGFydE9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFiaWxpdHkgb2YgdGhlIG5vdGVzIGJlaW5nIHRyaWdnZXJlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvYmFiaWxpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3Byb2JhYmlsaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvYmFiaWxpdHk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9iKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2JhYmlsaXR5ID0gcHJvYjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCByYW5kb20gdmFyaWF0aW9uXG5cdFx0ICogIHRvIHRoZSBjYWxsYmFjayB0aW1lLiBJZiB0aGUgdmFsdWUgaXMgZ2l2ZW4gYXMgYSB0aW1lLCBpdCB3aWxsIHJhbmRvbWl6ZVxuXHRcdCAqICBieSB0aGF0IGFtb3VudC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBldmVudC5odW1hbml6ZSA9IHRydWU7XG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdodW1hbml6ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2h1bWFuaXplO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFyaWF0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2h1bWFuaXplID0gdmFyaWF0aW9uO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBub3RlIGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIHRpbWUgIFdoZW4gdGhlIG5vdGUgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5FdmVudH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZSh0aW1lKSA9PT0gVG9uZS5TdGF0ZS5TdG9wcGVkKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh7XG5cdCAgICAgICAgICAgICAgICAnc3RhdGUnOiBUb25lLlN0YXRlLlN0YXJ0ZWQsXG5cdCAgICAgICAgICAgICAgICAndGltZSc6IHRpbWUsXG5cdCAgICAgICAgICAgICAgICAnaWQnOiB1bmRlZmluZWRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jlc2NoZWR1bGVFdmVudHModGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBFdmVudCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIHRpbWUgIFdoZW4gdGhlIG5vdGUgc2hvdWxkIHN0b3AuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5jYW5jZWwodGltZSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGltZSkgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpbWUpO1xuXHQgICAgICAgICAgICB2YXIgcHJldmlvdXNFdmVudCA9IHRoaXMuX3N0YXRlLmdldEJlZm9yZSh0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHJlc2NoZWR1bFRpbWUgPSB0aW1lO1xuXHQgICAgICAgICAgICBpZiAocHJldmlvdXNFdmVudCAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmVzY2hlZHVsVGltZSA9IHByZXZpb3VzRXZlbnQudGltZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKHJlc2NoZWR1bFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIGFsbCBzY2hlZHVsZWQgZXZlbnRzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgZ2l2ZW4gdGltZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgW3RpbWU9MF0gIFRoZSB0aW1lIGFmdGVyIHdoaWNoIGV2ZW50cyB3aWxsIGJlIGNhbmNlbC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuRXZlbnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSBUb25lLmRlZmF1bHRBcmcodGltZSwgLUluZmluaXR5KTtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1RpY2tzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmZvckVhY2hGcm9tKHRpbWUsIGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcihldmVudC5pZCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlci4gQWxzbyBcblx0XHQgKiAgY2hlY2tzIGlmIHRoZSBFdmVudCBpcyBkb25lIHBsYXlpbmdcblx0XHQgKiAgQHBhcmFtICB7TnVtYmVyfSAgdGltZSAgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IGluIHNlY29uZHNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRXZlbnQucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMubXV0ZSAmJiB0aGlzLl9zdGF0ZS5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC50aWNrcykgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5wcm9iYWJpbGl0eSA8IDEgJiYgTWF0aC5yYW5kb20oKSA+IHRoaXMucHJvYmFiaWxpdHkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodGhpcy5odW1hbml6ZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhcmlhdGlvbiA9IDAuMDI7XG5cdCAgICAgICAgICAgICAgICBpZiAoIVRvbmUuaXNCb29sZWFuKHRoaXMuaHVtYW5pemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyaWF0aW9uID0gdGhpcy50b1NlY29uZHModGhpcy5odW1hbml6ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aW1lICs9IChNYXRoLnJhbmRvbSgpICogMiAtIDEpICogdmFyaWF0aW9uO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGltZSwgdGhpcy52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wLlxuXHRcdCAqICBAcmV0dXJuICB7VGlja3N9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkV2ZW50LnByb3RvdHlwZS5fZ2V0TG9vcER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aGlzLl9sb29wRW5kIC0gdGhpcy5fbG9vcFN0YXJ0KSAvIHRoaXMuX3BsYXliYWNrUmF0ZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBub3RlIHNob3VsZCBsb29wIG9yIG5vdFxuXHRcdCAqICBiZXR3ZWVuIFRvbmUuRXZlbnQubG9vcFN0YXJ0IGFuZCBcblx0XHQgKiAgVG9uZS5FdmVudC5sb29wRW5kLiBBbiBpbnRlZ2VyXG5cdFx0ICogIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBudW1iZXIgb2Zcblx0XHQgKiAgbG9vcHMgdGhlIEV2ZW50IGRvZXMgYWZ0ZXIgaXQgc3RhcnRzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW58UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ2xvb3AnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgbm90ZS4gRGVmYXVsdHMgdG8gMS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgcGxheWJhY2tSYXRlXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbm90ZS5sb29wID0gdHJ1ZTtcblx0XHQgKiAvL3JlcGVhdCB0aGUgbm90ZSB0d2ljZSBhcyBmYXN0XG5cdFx0ICogbm90ZS5wbGF5YmFja1JhdGUgPSAyO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGxvb3BFbmQgcG9pbnQgaXMgdGhlIHRpbWUgdGhlIGV2ZW50IHdpbGwgbG9vcFxuXHRcdCAqICBpZiBUb25lLkV2ZW50Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuRXZlbnQjXG5cdFx0ICogIEB0eXBlIHtUcmFuc3BvcnRUaW1lfVxuXHRcdCAqICBAbmFtZSBsb29wRW5kXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5FdmVudC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVzY2hlZHVsZUV2ZW50cygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHRpbWUgd2hlbiB0aGUgbG9vcCBzaG91bGQgc3RhcnQuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuRXZlbnQucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BTdGFydCwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gdGhpcy50b1RpY2tzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXNjaGVkdWxlRXZlbnRzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgbG9vcCBpbnRlcnZhbC5cblx0XHQgKiAgUmV0dXJucyAwIGlmIHRoZSBldmVudCBpcyBub3Qgc3RhcnRlZCB5ZXQgb3Jcblx0XHQgKiAgaXQgaXMgbm90IHNldCB0byBsb29wLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5FdmVudCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9ncmVzc1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkV2ZW50LnByb3RvdHlwZSwgJ3Byb2dyZXNzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpY2tzID0gVG9uZS5UcmFuc3BvcnQudGlja3M7XG5cdCAgICAgICAgICAgICAgICB2YXIgbGFzdEV2ZW50ID0gdGhpcy5fc3RhdGUuZ2V0KHRpY2tzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChsYXN0RXZlbnQgIT09IG51bGwgJiYgbGFzdEV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbG9vcER1cmF0aW9uID0gdGhpcy5fZ2V0TG9vcER1cmF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gKHRpY2tzIC0gbGFzdEV2ZW50LnRpbWUpICUgbG9vcER1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcyAvIGxvb3BEdXJhdGlvbjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkV2ZW50fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5FdmVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLmNhbmNlbCgpO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRXZlbnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5Mb29wIGNyZWF0ZXMgYSBsb29wZWQgY2FsbGJhY2sgYXQgdGhlIFxuXHRcdCAqICAgICAgICAgc3BlY2lmaWVkIGludGVydmFsLiBUaGUgY2FsbGJhY2sgY2FuIGJlIFxuXHRcdCAqICAgICAgICAgc3RhcnRlZCwgc3RvcHBlZCBhbmQgc2NoZWR1bGVkIGFsb25nXG5cdFx0ICogICAgICAgICB0aGUgVHJhbnNwb3J0J3MgdGltZWxpbmUuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBsb29wID0gbmV3IFRvbmUuTG9vcChmdW5jdGlvbih0aW1lKXtcblx0XHQgKiBcdC8vdHJpZ2dlcmVkIGV2ZXJ5IGVpZ2h0aCBub3RlLiBcblx0XHQgKiBcdGNvbnNvbGUubG9nKHRpbWUpO1xuXHRcdCAqIH0sIFwiOG5cIikuc3RhcnQoMCk7XG5cdFx0ICogVG9uZS5UcmFuc3BvcnQuc3RhcnQoKTtcblx0XHQgKiAgQGV4dGVuZHMge1RvbmV9XG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB0aGUgZXZlbnQuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gaW50ZXJ2YWwgVGhlIHRpbWUgYmV0d2VlbiBzdWNjZXNzaXZlIGNhbGxiYWNrIGNhbGxzLiBcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdjYWxsYmFjaycsXG5cdCAgICAgICAgICAgICdpbnRlcnZhbCdcblx0ICAgICAgICBdLCBUb25lLkxvb3ApO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZXZlbnQgd2hpY2ggcHJvZHVjZXMgdGhlIGNhbGxiYWNrc1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZXZlbnQgPSBuZXcgVG9uZS5FdmVudCh7XG5cdCAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgJ2xvb3AnOiB0cnVlLFxuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IG9wdGlvbnMuaW50ZXJ2YWwsXG5cdCAgICAgICAgICAgICdwbGF5YmFja1JhdGUnOiBvcHRpb25zLnBsYXliYWNrUmF0ZSxcblx0ICAgICAgICAgICAgJ3Byb2JhYmlsaXR5Jzogb3B0aW9ucy5wcm9iYWJpbGl0eVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCB0aGUgbmV4dCBldmVudCBpbiB0aGUgcGF0dGVyblxuXHRcdFx0ICogIEB0eXBlIHtGdW5jdGlvbn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuXHQgICAgICAgIC8vc2V0IHRoZSBpdGVyYXRpb25zXG5cdCAgICAgICAgdGhpcy5pdGVyYXRpb25zID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTG9vcCk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSAge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaW50ZXJ2YWwnOiAnNG4nLFxuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAnaXRlcmF0aW9ucyc6IEluZmluaXR5LFxuXHQgICAgICAgICdwcm9iYWJpbGl0eSc6IHRydWUsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgbG9vcCBhdCB0aGUgc3BlY2lmaWVkIHRpbWUgYWxvbmcgdGhlIFRyYW5zcG9ydCdzXG5cdFx0ICogIHRpbWVsaW5lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9uPX0gIHRpbWUgIFdoZW4gdG8gc3RhcnQgdGhlIExvb3AuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5zdGFydCh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgbG9vcCBhdCB0aGUgZ2l2ZW4gdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbj19ICB0aW1lICBXaGVuIHRvIHN0b3AgdGhlIEFycGVnZ2lvXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50LnN0b3AodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENhbmNlbCBhbGwgc2NoZWR1bGVkIGV2ZW50cyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGdpdmVuIHRpbWVcblx0XHQgKiAgQHBhcmFtICB7VGltZWxpbmVQb3NpdGlvbn0gIFt0aW1lPTBdICBUaGUgdGltZSBhZnRlciB3aGljaCBldmVudHMgd2lsbCBiZSBjYW5jZWwuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkxvb3B9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQuY2FuY2VsKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm90ZXMgc2hvdWxkIGJlIGNhbGxlZFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0aGUgZXZlbnQgb2NjdXJzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkxvb3AucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgc3RhdGUgb2YgdGhlIExvb3AsIGVpdGhlciBzdGFydGVkIG9yIHN0b3BwZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHN0YXRlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwcm9ncmVzcyBvZiB0aGUgbG9vcCBhcyBhIHZhbHVlIGJldHdlZW4gMC0xLiAwLCB3aGVuXG5cdFx0ICogIHRoZSBsb29wIGlzIHN0b3BwZWQgb3IgZG9uZSBpdGVyYXRpbmcuIFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0ICogIEBuYW1lIHByb2dyZXNzXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdwcm9ncmVzcycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50LnByb2dyZXNzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSB0aW1lIGJldHdlZW4gc3VjY2Vzc2l2ZSBjYWxsYmFja3MuIFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIGxvb3AuaW50ZXJ2YWwgPSBcIjhuXCI7IC8vbG9vcCBldmVyeSA4blxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Mb29wI1xuXHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHQgKiAgQG5hbWUgaW50ZXJ2YWxcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnaW50ZXJ2YWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQubG9vcEVuZCA9IGludGVydmFsO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBwbGF5YmFjayByYXRlIG9mIHRoZSBsb29wLiBUaGUgbm9ybWFsIHBsYXliYWNrIHJhdGUgaXMgMSAobm8gY2hhbmdlKS4gXG5cdFx0ICogIEEgYHBsYXliYWNrUmF0ZWAgb2YgMiB3b3VsZCBiZSB0d2ljZSBhcyBmYXN0LiBcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0ICogIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50LnBsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgUmFuZG9tIHZhcmlhdGlvbiArLy0wLjAxcyB0byB0aGUgc2NoZWR1bGVkIHRpbWUuIFxuXHRcdCAqICBPciBnaXZlIGl0IGEgdGltZSB2YWx1ZSB3aGljaCBpdCB3aWxsIHJhbmRvbWl6ZSBieS5cblx0XHQgKiAgQHR5cGUge0Jvb2xlYW58VGltZX1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQG5hbWUgaHVtYW5pemVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnaHVtYW5pemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5odW1hbml6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhcmlhdGlvbikge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudC5odW1hbml6ZSA9IHZhcmlhdGlvbjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFibHkgb2YgdGhlIGNhbGxiYWNrIGJlaW5nIGludm9rZWQuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtOb3JtYWxSYW5nZX1cblx0XHQgKiAgQG5hbWUgcHJvYmFiaWxpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAncHJvYmFiaWxpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudC5wcm9iYWJpbGl0eTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHByb2IpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnQucHJvYmFiaWxpdHkgPSBwcm9iO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIE11dGluZyB0aGUgTG9vcCBtZWFucyB0aGF0IG5vIGNhbGxiYWNrcyBhcmUgaW52b2tlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTG9vcCNcblx0XHQgKiAgQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogIEBuYW1lIG11dGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkxvb3AucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lm11dGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtdXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2V2ZW50Lm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgbG9vcC4gVGhlIGRlZmF1bHRcblx0XHQgKiAgdmFsdWUgaXMgSW5maW5pdHkgKGxvb3AgZm9yZXZlcikuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkxvb3AjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgaXRlcmF0aW9uc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTG9vcC5wcm90b3R5cGUsICdpdGVyYXRpb25zJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnQubG9vcCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50Lmxvb3A7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGl0ZXJzKSB7XG5cdCAgICAgICAgICAgIGlmIChpdGVycyA9PT0gSW5maW5pdHkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50Lmxvb3AgPSB0cnVlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnQubG9vcCA9IGl0ZXJzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuTG9vcH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudC5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkxvb3A7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhcnQgaXMgYSBjb2xsZWN0aW9uIFRvbmUuRXZlbnRzIHdoaWNoIGNhbiBiZVxuXHRcdCAqICAgICAgICAgc3RhcnRlZC9zdG9wcGVkIGFuZCBsb29wZWQgYXMgYSBzaW5nbGUgdW5pdC5cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5FdmVudH1cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGV2ZW50XG5cdFx0ICogIEBwYXJhbSB7QXJyYXl9IGV2ZW50cyB0aGUgYXJyYXkgb2YgZXZlbnRzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHBhcnQgPSBuZXcgVG9uZS5QYXJ0KGZ1bmN0aW9uKHRpbWUsIG5vdGUpe1xuXHRcdCAqIFx0Ly90aGUgbm90ZXMgZ2l2ZW4gYXMgdGhlIHNlY29uZCBlbGVtZW50IGluIHRoZSBhcnJheVxuXHRcdCAqIFx0Ly93aWxsIGJlIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ICogXHRzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShub3RlLCBcIjhuXCIsIHRpbWUpO1xuXHRcdCAqIH0sIFtbMCwgXCJDMlwiXSwgW1wiMDoyXCIsIFwiQzNcIl0sIFtcIjA6MzoyXCIsIFwiRzJcIl1dKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL3VzZSBhbiBhcnJheSBvZiBvYmplY3RzIGFzIGxvbmcgYXMgdGhlIG9iamVjdCBoYXMgYSBcInRpbWVcIiBhdHRyaWJ1dGVcblx0XHQgKiB2YXIgcGFydCA9IG5ldyBUb25lLlBhcnQoZnVuY3Rpb24odGltZSwgdmFsdWUpe1xuXHRcdCAqIFx0Ly90aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGJvdGggdGhlIG5vdGUgYW5kIHRoZSB2ZWxvY2l0eVxuXHRcdCAqIFx0c3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UodmFsdWUubm90ZSwgXCI4blwiLCB0aW1lLCB2YWx1ZS52ZWxvY2l0eSk7XG5cdFx0ICogfSwgW3tcInRpbWVcIiA6IDAsIFwibm90ZVwiIDogXCJDM1wiLCBcInZlbG9jaXR5XCI6IDAuOX0sIFxuXHRcdCAqIFx0ICAge1widGltZVwiIDogXCIwOjJcIiwgXCJub3RlXCIgOiBcIkM0XCIsIFwidmVsb2NpdHlcIjogMC41fVxuXHRcdCAqIF0pLnN0YXJ0KDApO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ2V2ZW50cydcblx0ICAgICAgICBdLCBUb25lLlBhcnQpO1xuXHQgICAgICAgIFRvbmUuRXZlbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBbiBhcnJheSBvZiBPYmplY3RzLiBcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICAvL2FkZCB0aGUgZXZlbnRzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmV2ZW50c1tpXSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKG9wdGlvbnMuZXZlbnRzW2ldWzBdLCBvcHRpb25zLmV2ZW50c1tpXVsxXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFkZChvcHRpb25zLmV2ZW50c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXJ0LCBUb25lLkV2ZW50KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdjYWxsYmFjayc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wRW5kJzogJzFtJyxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAncHJvYmFiaWxpdHknOiAxLFxuXHQgICAgICAgICdodW1hbml6ZSc6IGZhbHNlLFxuXHQgICAgICAgICdtdXRlJzogZmFsc2UsXG5cdCAgICAgICAgJ2V2ZW50cyc6IFtdXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLiBcblx0XHQgKiAgQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gIHRpbWUgICAgV2hlbiB0byBzdGFydCB0aGUgcGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19ICBvZmZzZXQgIFRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHBhcnRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlZ2luIHBsYXlpbmcgYXQuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHRpbWUsIG9mZnNldCkge1xuXHQgICAgICAgIHZhciB0aWNrcyA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBpZiAodGhpcy5fc3RhdGUuZ2V0VmFsdWVBdFRpbWUodGlja3MpICE9PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvVGlja3Mob2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuYWRkKHtcblx0ICAgICAgICAgICAgICAgICdzdGF0ZSc6IFRvbmUuU3RhdGUuU3RhcnRlZCxcblx0ICAgICAgICAgICAgICAgICd0aW1lJzogdGlja3MsXG5cdCAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnROb3RlKGV2ZW50LCB0aWNrcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGV2ZW50IGF0IHRoZSBjb3JyZWN0IHRpbWUgZ2l2ZW5cblx0XHQgKiAgdGhlIHRpY2tzIGFuZCBvZmZzZXQgYW5kIGxvb3BpbmcuXG5cdFx0ICogIEBwYXJhbSAge1RvbmUuRXZlbnR9ICBldmVudCBcblx0XHQgKiAgQHBhcmFtICB7VGlja3N9ICB0aWNrc1xuXHRcdCAqICBAcGFyYW0gIHtUaWNrc30gIG9mZnNldFxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5fc3RhcnROb3RlID0gZnVuY3Rpb24gKGV2ZW50LCB0aWNrcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgdGlja3MgLT0gb2Zmc2V0O1xuXHQgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IGl0IG9uIHRoZSBuZXh0IGxvb3Bcblx0ICAgICAgICAgICAgICAgICAgICB0aWNrcyArPSB0aGlzLl9nZXRMb29wRHVyYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0KFRvbmUuVHJhbnNwb3J0VGltZSh0aWNrcywgJ2knKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuc3RhcnRPZmZzZXQgPCB0aGlzLl9sb29wU3RhcnQgJiYgZXZlbnQuc3RhcnRPZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5sb29wID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zdGFydChUb25lLlRyYW5zcG9ydFRpbWUodGlja3MsICdpJykpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID49IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnQoVG9uZS5UcmFuc3BvcnRUaW1lKHRpY2tzLCAnaScpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHN0YXJ0IGZyb20gdGhlIHNjaGVkdWxlZCBzdGFydCB0aW1lXG5cdFx0ICogIEB0eXBlIHtUaWNrc31cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQG5hbWUgc3RhcnRPZmZzZXRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnc3RhcnRPZmZzZXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydE9mZnNldDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zdGFydE9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0YXJ0T2Zmc2V0ICs9IHRoaXMuX3N0YXJ0T2Zmc2V0O1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdG9wIHRoZSBwYXJ0IGF0IHRoZSBnaXZlbiB0aW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lbGluZVBvc2l0aW9ufSAgdGltZSAgV2hlbiB0byBzdG9wIHRoZSBwYXJ0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdGlja3MgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUuY2FuY2VsKHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5zZXRTdGF0ZUF0VGltZShUb25lLlN0YXRlLlN0b3BwZWQsIHRpY2tzKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQvU2V0IGFuIEV2ZW50J3MgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFxuXHRcdCAqICBJZiBhIHZhbHVlIGlzIHBhc3NlZCBpbiBhbmQgbm8gZXZlbnQgZXhpc3RzIGF0XG5cdFx0ICogIHRoZSBnaXZlbiB0aW1lLCBvbmUgd2lsbCBiZSBjcmVhdGVkIHdpdGggdGhhdCB2YWx1ZS4gXG5cdFx0ICogIElmIHR3byBldmVudHMgYXJlIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBmaXJzdCBvbmUgd2lsbFxuXHRcdCAqICBiZSByZXR1cm5lZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmF0KFwiMW1cIik7IC8vcmV0dXJucyB0aGUgcGFydCBhdCB0aGUgZmlyc3QgbWVhc3VyZVxuXHRcdCAqXG5cdFx0ICogcGFydC5hdChcIjJtXCIsIFwiQzJcIik7IC8vc2V0IHRoZSB2YWx1ZSBhdCBcIjJtXCIgdG8gQzIuIFxuXHRcdCAqIC8vaWYgYW4gZXZlbnQgZGlkbid0IGV4aXN0IGF0IHRoYXQgdGltZSwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuXHRcdCAqICBAcGFyYW0ge1RyYW5zcG9ydFRpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50IHRvIGdldCBvciBzZXQuXG5cdFx0ICogIEBwYXJhbSB7Kj19IHZhbHVlIElmIGEgdmFsdWUgaXMgcGFzc2VkIGluLCB0aGUgdmFsdWUgb2YgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgIGV2ZW50IGF0IHRoZSBnaXZlbiB0aW1lIHdpbGwgYmUgc2V0IHRvIGl0LlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLkV2ZW50fSB0aGUgZXZlbnQgYXQgdGhlIHRpbWVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAodGltZSwgdmFsdWUpIHtcblx0ICAgICAgICB0aW1lID0gVG9uZS5UcmFuc3BvcnRUaW1lKHRpbWUpO1xuXHQgICAgICAgIHZhciB0aWNrVGltZSA9IFRvbmUuVGltZSgxLCAnaScpLnRvU2Vjb25kcygpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRpbWUudG9UaWNrcygpIC0gZXZlbnQuc3RhcnRPZmZzZXQpIDwgdGlja1RpbWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9pZiB0aGVyZSB3YXMgbm8gZXZlbnQgYXQgdGhhdCB0aW1lLCBjcmVhdGUgb25lXG5cdCAgICAgICAgaWYgKCFUb25lLmlzVW5kZWYodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKHRpbWUsIHZhbHVlKTtcblx0ICAgICAgICAgICAgLy9yZXR1cm4gdGhlIG5ldyBldmVudFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzW3RoaXMuX2V2ZW50cy5sZW5ndGggLSAxXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIGFuIGV2ZW50IHRvIHRoZSBwYXJ0LiBcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lIFRoZSB0aW1lIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGluLCBpdCBzaG91bGRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXZlIGEgJ3RpbWUnIGF0dHJpYnV0ZSBhbmQgdGhlIHJlc3Rcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyB0aGUgJ3ZhbHVlJy5cblx0XHQgKiAgQHBhcmFtICB7VG9uZS5FdmVudHwqfSAgdmFsdWUgXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBhcnR9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBwYXJ0LmFkZChcIjFtXCIsIFwiQyMrMTFcIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICB2YXIgZXZlbnQ7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVG9uZS5FdmVudCkge1xuXHQgICAgICAgICAgICBldmVudCA9IHZhbHVlO1xuXHQgICAgICAgICAgICBldmVudC5jYWxsYmFjayA9IHRoaXMuX3RpY2suYmluZCh0aGlzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBldmVudCA9IG5ldyBUb25lLkV2ZW50KHtcblx0ICAgICAgICAgICAgICAgICdjYWxsYmFjayc6IHRoaXMuX3RpY2suYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL3RoZSBzdGFydCBvZmZzZXRcblx0ICAgICAgICBldmVudC5zdGFydE9mZnNldCA9IHRpbWU7XG5cdCAgICAgICAgLy9pbml0aWFsaXplIHRoZSB2YWx1ZXNcblx0ICAgICAgICBldmVudC5zZXQoe1xuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IHRoaXMubG9vcEVuZCxcblx0ICAgICAgICAgICAgJ2xvb3BTdGFydCc6IHRoaXMubG9vcFN0YXJ0LFxuXHQgICAgICAgICAgICAnbG9vcCc6IHRoaXMubG9vcCxcblx0ICAgICAgICAgICAgJ2h1bWFuaXplJzogdGhpcy5odW1hbml6ZSxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IHRoaXMucGxheWJhY2tSYXRlLFxuXHQgICAgICAgICAgICAncHJvYmFiaWxpdHknOiB0aGlzLnByb2JhYmlsaXR5XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuXHQgICAgICAgIC8vc3RhcnQgdGhlIG5vdGUgaWYgaXQgc2hvdWxkIGJlIHBsYXllZCByaWdodCBub3dcblx0ICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXN0YXJ0IHRoZSBnaXZlbiBldmVudFxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl9yZXN0YXJ0RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZUV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChzdGF0ZUV2ZW50LnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0Tm90ZShldmVudCwgc3RhdGVFdmVudC50aW1lLCBzdGF0ZUV2ZW50Lm9mZnNldCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvL3N0b3AgdGhlIG5vdGVcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnN0b3AoVG9uZS5UcmFuc3BvcnRUaW1lKHN0YXRlRXZlbnQudGltZSwgJ2knKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYW4gZXZlbnQgZnJvbSB0aGUgcGFydC4gV2lsbCByZWN1cnNpdmVseSBpdGVyYXRlXG5cdFx0ICogIGludG8gbmVzdGVkIHBhcnRzIHRvIGZpbmQgdGhlIGV2ZW50LlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBzZWxlY3Qgb25seSBhIHNwZWNpZmljIGV2ZW50IHZhbHVlXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vZXh0cmFjdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmICh0aW1lLmhhc093blByb3BlcnR5KCd0aW1lJykpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0aW1lO1xuXHQgICAgICAgICAgICB0aW1lID0gdmFsdWUudGltZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fZXZlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2V2ZW50c1tpXTtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgVG9uZS5QYXJ0KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5yZW1vdmUodGltZSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0YXJ0T2Zmc2V0ID09PSB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKFRvbmUuaXNVbmRlZih2YWx1ZSkgfHwgIVRvbmUuaXNVbmRlZih2YWx1ZSkgJiYgZXZlbnQudmFsdWUgPT09IHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFJlbW92ZSBhbGwgb2YgdGhlIG5vdGVzIGZyb20gdGhlIGdyb3VwLiBcblx0XHQgKiAgQHJldHVybiAge1RvbmUuUGFydH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2FuY2VsIHNjaGVkdWxlZCBzdGF0ZSBjaGFuZ2UgZXZlbnRzOiBpLmUuIFwic3RhcnRcIiBhbmQgXCJzdG9wXCIuXG5cdFx0ICogIEBwYXJhbSB7VGltZWxpbmVQb3NpdGlvbn0gYWZ0ZXIgVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggdG8gY2FuY2VsIHRoZSBzY2hlZHVsZWQgZXZlbnRzLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXJ0fSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYWZ0ZXIpIHtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICBldmVudC5jYW5jZWwoYWZ0ZXIpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuX3N0YXRlLmNhbmNlbCh0aGlzLnRvVGlja3MoYWZ0ZXIpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgZXZlbnRzXG5cdFx0ICogIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBjdHggVGhlIGNvbnRleHRcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9ldmVudHMpIHtcblx0ICAgICAgICAgICAgY3R4ID0gVG9uZS5kZWZhdWx0QXJnKGN0eCwgdGhpcyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9ldmVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5fZXZlbnRzW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBUb25lLlBhcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlLl9mb3JFYWNoKGNhbGxiYWNrLCBjdHgpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgYXR0cmlidXRlIG9mIGFsbCBvZiB0aGUgZXZlbnRzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gIGF0dHIgIHRoZSBhdHRyaWJ1dGUgdG8gc2V0XG5cdFx0ICogIEBwYXJhbSAgeyp9ICB2YWx1ZSAgICAgIFRoZSB2YWx1ZSB0byBzZXQgaXQgdG9cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGFydC5wcm90b3R5cGUuX3NldEFsbCA9IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGV2ZW50W2F0dHJdID0gdmFsdWU7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEludGVybmFsIHRpY2sgbWV0aG9kXG5cdFx0ICogIEBwYXJhbSAge051bWJlcn0gIHRpbWUgIFRoZSB0aW1lIG9mIHRoZSBldmVudCBpbiBzZWNvbmRzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLm11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aW1lLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBEZXRlcm1pbmUgaWYgdGhlIGV2ZW50IHNob3VsZCBiZSBjdXJyZW50bHkgbG9vcGluZ1xuXHRcdCAqICBnaXZlbiB0aGUgbG9vcCBib3VuZHJpZXMgb2YgdGhpcyBQYXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUb25lLkV2ZW50fSAgZXZlbnQgIFRoZSBldmVudCB0byB0ZXN0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLl90ZXN0TG9vcEJvdW5kcmllcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC5zdGFydE9mZnNldCA8IHRoaXMuX2xvb3BTdGFydCB8fCBldmVudC5zdGFydE9mZnNldCA+PSB0aGlzLl9sb29wRW5kKSB7XG5cdCAgICAgICAgICAgIGV2ZW50LmNhbmNlbCgwKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvL3Jlc2NoZWR1bGUgaXQgaWYgaXQncyBzdG9wcGVkXG5cdCAgICAgICAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdG9wcGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXN0YXJ0RXZlbnQoZXZlbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgcHJvYmFiaWxpdHkgb2YgdGhlIG5vdGVzIGJlaW5nIHRyaWdnZXJlZC5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqICBAbmFtZSBwcm9iYWJpbGl0eVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdwcm9iYWJpbGl0eScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2JhYmlsaXR5O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocHJvYikge1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9iYWJpbGl0eSA9IHByb2I7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgncHJvYmFiaWxpdHknLCBwcm9iKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCBhcHBseSBzbWFsbCByYW5kb20gdmFyaWF0aW9uXG5cdFx0ICogIHRvIHRoZSBjYWxsYmFjayB0aW1lLiBJZiB0aGUgdmFsdWUgaXMgZ2l2ZW4gYXMgYSB0aW1lLCBpdCB3aWxsIHJhbmRvbWl6ZVxuXHRcdCAqICBieSB0aGF0IGFtb3VudC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiBldmVudC5odW1hbml6ZSA9IHRydWU7XG5cdFx0ICogIEB0eXBlIHtCb29sZWFufFRpbWV9XG5cdFx0ICogIEBuYW1lIGh1bWFuaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXJ0LnByb3RvdHlwZSwgJ2h1bWFuaXplJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faHVtYW5pemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5faHVtYW5pemUgPSB2YXJpYXRpb247XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEFsbCgnaHVtYW5pemUnLCB2YXJpYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIElmIHRoZSBwYXJ0IHNob3VsZCBsb29wIG9yIG5vdFxuXHRcdCAqICBiZXR3ZWVuIFRvbmUuUGFydC5sb29wU3RhcnQgYW5kIFxuXHRcdCAqICBUb25lLlBhcnQubG9vcEVuZC4gQW4gaW50ZWdlclxuXHRcdCAqICB2YWx1ZSBjb3JyZXNwb25kcyB0byB0aGUgbnVtYmVyIG9mXG5cdFx0ICogIGxvb3BzIHRoZSBQYXJ0IGRvZXMgYWZ0ZXIgaXQgc3RhcnRzLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7Qm9vbGVhbnxQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbG9vcFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbG9vcCB0aGUgcGFydCA4IHRpbWVzXG5cdFx0ICogcGFydC5sb29wID0gODtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAnbG9vcCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuX2xvb3BTdGFydCA9IHRoaXMuX2xvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Ll9sb29wRW5kID0gdGhpcy5fbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Lmxvb3AgPSBsb29wO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbG9vcEVuZCBwb2ludCBkZXRlcm1pbmVzIHdoZW4gaXQgd2lsbCBcblx0XHQgKiAgbG9vcCBpZiBUb25lLlBhcnQubG9vcCBpcyB0cnVlLlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXJ0I1xuXHRcdCAqICBAdHlwZSB7VHJhbnNwb3J0VGltZX1cblx0XHQgKiAgQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKHRoaXMuX2xvb3BFbmQsICdpJykudG9Ob3RhdGlvbigpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gdGhpcy50b1RpY2tzKGxvb3BFbmQpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5sb29wRW5kID0gbG9vcEVuZDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXN0TG9vcEJvdW5kcmllcyhldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBsb29wU3RhcnQgcG9pbnQgZGV0ZXJtaW5lcyB3aGVuIGl0IHdpbGwgXG5cdFx0ICogIGxvb3AgaWYgVG9uZS5QYXJ0Lmxvb3AgaXMgdHJ1ZS5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1RyYW5zcG9ydFRpbWV9XG5cdFx0ICogIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBUb25lLlRyYW5zcG9ydFRpbWUodGhpcy5fbG9vcFN0YXJ0LCAnaScpLnRvTm90YXRpb24oKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3BTdGFydCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wU3RhcnQgPSB0aGlzLnRvVGlja3MobG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQubG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVzdExvb3BCb3VuZHJpZXMoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0VGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIHBhcnRcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGFydCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhcnQucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLl9zZXRBbGwoJ3BsYXliYWNrUmF0ZScsIHJhdGUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRUaGUgbnVtYmVyIG9mIHNjaGVkdWxlZCBub3RlcyBpbiB0aGUgcGFydC4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhcnQjXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgbGVuZ3RoXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGFydC5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLlBhcnR9ICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBhcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcblx0ICAgICAgICB0aGlzLl9zdGF0ZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGFydDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlBhdHRlcm4gYXJwZWdnaWF0ZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gbm90ZXNcblx0XHQgKiAgICAgICAgIGluIGEgbnVtYmVyIG9mIHBhdHRlcm5zLiBTZWUgVG9uZS5DdHJsUGF0dGVybiBmb3Jcblx0XHQgKiAgICAgICAgIGEgZnVsbCBsaXN0IG9mIHBhdHRlcm5zLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwYXR0ZXJuID0gbmV3IFRvbmUuUGF0dGVybihmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiAgIC8vdGhlIG9yZGVyIG9mIHRoZSBub3RlcyBwYXNzZWQgaW4gZGVwZW5kcyBvbiB0aGUgcGF0dGVyblxuXHRcdCAqIH0sIFtcIkMyXCIsIFwiRDRcIiwgXCJFNVwiLCBcIkE2XCJdLCBcInVwRG93blwiKTtcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTG9vcH1cblx0XHQgKiAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHRoZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5cblx0XHQgKiAgQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXJwZWdnaWF0ZSBvdmVyLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ3ZhbHVlcycsXG5cdCAgICAgICAgICAgICdwYXR0ZXJuJ1xuXHQgICAgICAgIF0sIFRvbmUuUGF0dGVybik7XG5cdCAgICAgICAgVG9uZS5Mb29wLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHBhdHRlcm4gbWFuYWdlclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkN0cmxQYXR0ZXJufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wYXR0ZXJuID0gbmV3IFRvbmUuQ3RybFBhdHRlcm4oe1xuXHQgICAgICAgICAgICAndmFsdWVzJzogb3B0aW9ucy52YWx1ZXMsXG5cdCAgICAgICAgICAgICd0eXBlJzogb3B0aW9ucy5wYXR0ZXJuLFxuXHQgICAgICAgICAgICAnaW5kZXgnOiBvcHRpb25zLmluZGV4XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5QYXR0ZXJuLCBUb25lLkxvb3ApO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0c1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUgIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBhdHRlcm4uZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3BhdHRlcm4nOiBUb25lLkN0cmxQYXR0ZXJuLlR5cGUuVXAsXG5cdCAgICAgICAgJ2NhbGxiYWNrJzogVG9uZS5ub09wLFxuXHQgICAgICAgICd2YWx1ZXMnOiBbXVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgbm90ZXMgc2hvdWxkIGJlIGNhbGxlZFxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICB0aW1lICBUaGUgdGltZSB0aGUgZXZlbnQgb2NjdXJzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBhdHRlcm4ucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmNhbGxiYWNrKHRpbWUsIHRoaXMuX3BhdHRlcm4udmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4ubmV4dCgpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgdmFsdWVzIGFycmF5LlxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QYXR0ZXJuI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lIGluZGV4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QYXR0ZXJuLnByb3RvdHlwZSwgJ2luZGV4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybi5pbmRleDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGF0dGVybi5pbmRleCA9IGk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIGFycmF5IG9mIGV2ZW50cy5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUge0FycmF5fVxuXHRcdCAqICBAbmFtZSB2YWx1ZXNcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAndmFsdWVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGF0dGVybi52YWx1ZXM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4udmFsdWVzID0gdmFscztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcGF0dGVybi5cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuUGF0dGVybiNcblx0XHQgKiAgQHR5cGUgeyp9XG5cdFx0ICogIEBuYW1lIHZhbHVlXG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGF0dGVybi5wcm90b3R5cGUsICd2YWx1ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBhdHRlcm4gdHlwZS4gU2VlIFRvbmUuQ3RybFBhdHRlcm4gZm9yIHRoZSBmdWxsIGxpc3Qgb2YgcGF0dGVybnMuXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlBhdHRlcm4jXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEBuYW1lIHBhdHRlcm5cblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBhdHRlcm4ucHJvdG90eXBlLCAncGF0dGVybicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdHRlcm4udHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGF0dGVybi50eXBlID0gcGF0dGVybjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QYXR0ZXJufSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QYXR0ZXJuLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTG9vcC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBhdHRlcm47XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBBIHNlcXVlbmNlIGlzIGFuIGFsdGVybmF0ZSBub3RhdGlvbiBvZiBhIHBhcnQuIEluc3RlYWRcblx0XHQgKiAgICAgICAgIG9mIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2YgW3RpbWUsIGV2ZW50XSBwYWlycywgcGFzc1xuXHRcdCAqICAgICAgICAgaW4gYW4gYXJyYXkgb2YgZXZlbnRzIHdoaWNoIHdpbGwgYmUgc3BhY2VkIGF0IHRoZVxuXHRcdCAqICAgICAgICAgZ2l2ZW4gc3ViZGl2aXNpb24uIFN1Yi1hcnJheXMgd2lsbCBzdWJkaXZpZGUgdGhhdCBiZWF0XG5cdFx0ICogICAgICAgICBieSB0aGUgbnVtYmVyIG9mIGl0ZW1zIGFyZSBpbiB0aGUgYXJyYXkuIFxuXHRcdCAqICAgICAgICAgU2VxdWVuY2Ugbm90YXRpb24gaW5zcGlyYXRpb24gZnJvbSBbVGlkYWxdKGh0dHA6Ly95YXh1Lm9yZy90aWRhbC8pXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2l0aCBldmVyeSBub3RlXG5cdFx0ICogIEBwYXJhbSAge0FycmF5fSAgICBldmVudHMgIFRoZSBzZXF1ZW5jZVxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBzdWJkaXZpc2lvbiAgVGhlIHN1YmRpdmlzaW9uIGJldHdlZW4gd2hpY2ggZXZlbnRzIGFyZSBwbGFjZWQuIFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5QYXJ0fVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBzZXEgPSBuZXcgVG9uZS5TZXF1ZW5jZShmdW5jdGlvbih0aW1lLCBub3RlKXtcblx0XHQgKiBcdGNvbnNvbGUubG9nKG5vdGUpO1xuXHRcdCAqIC8vc3RyYWlnaHQgcXVhdGVyIG5vdGVzXG5cdFx0ICogfSwgW1wiQzRcIiwgXCJFNFwiLCBcIkc0XCIsIFwiQTRcIl0sIFwiNG5cIik7XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHNlcSA9IG5ldyBUb25lLlNlcXVlbmNlKGZ1bmN0aW9uKHRpbWUsIG5vdGUpe1xuXHRcdCAqIFx0Y29uc29sZS5sb2cobm90ZSk7XG5cdFx0ICogLy9zdWJkaXZpc2lvbnMgYXJlIGdpdmVuIGFzIHN1YmFycmF5c1xuXHRcdCAqIH0sIFtcIkM0XCIsIFtcIkU0XCIsIFwiRDRcIiwgXCJFNFwiXSwgXCJHNFwiLCBbXCJBNFwiLCBcIkc0XCJdXSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2NhbGxiYWNrJyxcblx0ICAgICAgICAgICAgJ2V2ZW50cycsXG5cdCAgICAgICAgICAgICdzdWJkaXZpc2lvbidcblx0ICAgICAgICBdLCBUb25lLlNlcXVlbmNlKTtcblx0ICAgICAgICAvL3JlbW92ZSB0aGUgZXZlbnRzXG5cdCAgICAgICAgdmFyIGV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuXHQgICAgICAgIGRlbGV0ZSBvcHRpb25zLmV2ZW50cztcblx0ICAgICAgICBUb25lLlBhcnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgc3ViZGl2aXNvbiBvZiBlYWNoIG5vdGVcblx0XHRcdCAqICBAdHlwZSAge1RpY2tzfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdWJkaXZpc2lvbiA9IHRoaXMudG9UaWNrcyhvcHRpb25zLnN1YmRpdmlzaW9uKTtcblx0ICAgICAgICAvL2lmIG5vIHRpbWUgd2FzIHBhc3NlZCBpbiwgdGhlIGxvb3AgZW5kIGlzIHRoZSBlbmQgb2YgdGhlIGN5Y2xlXG5cdCAgICAgICAgaWYgKFRvbmUuaXNVbmRlZihvcHRpb25zLmxvb3BFbmQpICYmICFUb25lLmlzVW5kZWYoZXZlbnRzKSkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gZXZlbnRzLmxlbmd0aCAqIHRoaXMuX3N1YmRpdmlzaW9uO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2RlZmF1bHRzIHRvIGxvb3Bpbmdcblx0ICAgICAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblx0ICAgICAgICAvL2FkZCBhbGwgb2YgdGhlIGV2ZW50c1xuXHQgICAgICAgIGlmICghVG9uZS5pc1VuZGVmKGV2ZW50cykpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGksIGV2ZW50c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TZXF1ZW5jZSwgVG9uZS5QYXJ0KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdCB2YWx1ZXMuXG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5kZWZhdWx0cyA9IHsgJ3N1YmRpdmlzaW9uJzogJzRuJyB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBzdWJkaXZpc2lvbiBvZiB0aGUgc2VxdWVuY2UuIFRoaXMgY2FuIG9ubHkgYmUgXG5cdFx0ICogIHNldCBpbiB0aGUgY29uc3RydWN0b3IuIFRoZSBzdWJkaXZpc2lvbiBpcyB0aGUgXG5cdFx0ICogIGludGVydmFsIGJldHdlZW4gc3VjY2Vzc2l2ZSBzdGVwcy4gXG5cdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5TZXF1ZW5jZSNcblx0XHQgKiAgQG5hbWUgc3ViZGl2aXNpb25cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUsICdzdWJkaXZpc2lvbicsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFRvbmUuVGltZSh0aGlzLl9zdWJkaXZpc2lvbiwgJ2knKS50b05vdGF0aW9uKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgR2V0L1NldCBhbiBpbmRleCBvZiB0aGUgc2VxdWVuY2UuIElmIHRoZSBpbmRleCBjb250YWlucyBhIHN1YmFycmF5LCBcblx0XHQgKiAgYSBUb25lLlNlcXVlbmNlIHJlcHJlc2VudGluZyB0aGF0IHN1Yi1hcnJheSB3aWxsIGJlIHJldHVybmVkLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc2VxdWVuY2UgPSBuZXcgVG9uZS5TZXF1ZW5jZShwbGF5Tm90ZSwgW1wiRTRcIiwgXCJDNFwiLCBcIkYjNFwiLCBbXCJBNFwiLCBcIkJiM1wiXV0pXG5cdFx0ICogc2VxdWVuY2UuYXQoMCkvLyA9PiByZXR1cm5zIFwiRTRcIlxuXHRcdCAqIC8vc2V0IGEgdmFsdWVcblx0XHQgKiBzZXF1ZW5jZS5hdCgwLCBcIkczXCIpO1xuXHRcdCAqIC8vZ2V0IGEgbmVzdGVkIHNlcXVlbmNlXG5cdFx0ICogc2VxdWVuY2UuYXQoMykuYXQoMSkvLyA9PiByZXR1cm5zIFwiQmIzXCJcblx0XHQgKiBAcGFyYW0ge1Bvc2l0aXZlfSBpbmRleCBUaGUgaW5kZXggdG8gZ2V0IG9yIHNldFxuXHRcdCAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uYWxseSBwYXNzIGluIHRoZSB2YWx1ZSB0byBzZXQgYXQgdGhlIGdpdmVuIGluZGV4LlxuXHRcdCAqL1xuXHQgICAgVG9uZS5TZXF1ZW5jZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgLy9pZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIFxuXHQgICAgICAgIGlmIChUb25lLmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBjdXJyZW50IGV2ZW50IGF0IHRoYXQgaW5kZXhcblx0ICAgICAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL2NhbGwgdGhlIHBhcmVudCdzIG1ldGhvZFxuXHQgICAgICAgIHJldHVybiBUb25lLlBhcnQucHJvdG90eXBlLmF0LmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYW4gZXZlbnQgYXQgYW4gaW5kZXgsIGlmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmdcblx0XHQgKiAgYXQgdGhhdCBpbmRleCwgb3ZlcndyaXRlIGl0LiBJZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBcblx0XHQgKiAgaXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdWJzZXF1ZW5jZS5cblx0XHQgKiAgQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhZGQgdGhlIGV2ZW50IHRvXG5cdFx0ICogIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCBhdCB0aGF0IGluZGV4XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlNlcXVlbmNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoVG9uZS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgICAgICAvL21ha2UgYSBzdWJzZXF1ZW5jZSBhbmQgYWRkIHRoYXQgdG8gdGhlIHNlcXVlbmNlXG5cdCAgICAgICAgICAgIHZhciBzdWJTdWJkaXZpc2lvbiA9IE1hdGgucm91bmQodGhpcy5fc3ViZGl2aXNpb24gLyB2YWx1ZS5sZW5ndGgpO1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG5ldyBUb25lLlNlcXVlbmNlKHRoaXMuX3RpY2suYmluZCh0aGlzKSwgdmFsdWUsIFRvbmUuVGltZShzdWJTdWJkaXZpc2lvbiwgJ2knKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuUGFydC5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdGhpcy5faW5kZXhUaW1lKGluZGV4KSwgdmFsdWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZW1vdmUgYSB2YWx1ZSBmcm9tIHRoZSBzZXF1ZW5jZSBieSBpbmRleFxuXHRcdCAqICBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBldmVudCB0byByZW1vdmVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcblx0ICAgICAgICBUb25lLlBhcnQucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIHRoaXMuX2luZGV4VGltZShpbmRleCksIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSB0aW1lIG9mIHRoZSBpbmRleCBnaXZlbiB0aGUgU2VxdWVuY2UncyBzdWJkaXZpc2lvblxuXHRcdCAqICBAcGFyYW0gIHtOdW1iZXJ9ICBpbmRleCBcblx0XHQgKiAgQHJldHVybiAge1RpbWV9ICBUaGUgdGltZSBvZiB0aGF0IGluZGV4XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNlcXVlbmNlLnByb3RvdHlwZS5faW5kZXhUaW1lID0gZnVuY3Rpb24gKGluZGV4KSB7XG5cdCAgICAgICAgaWYgKGluZGV4IGluc3RhbmNlb2YgVG9uZS5UcmFuc3BvcnRUaW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRleDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICByZXR1cm4gVG9uZS5UcmFuc3BvcnRUaW1lKGluZGV4ICogdGhpcy5fc3ViZGl2aXNpb24gKyB0aGlzLnN0YXJ0T2Zmc2V0LCAnaScpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuU2VxdWVuY2V9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU2VxdWVuY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5QYXJ0LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2VxdWVuY2U7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLlB1bHNlT3NjaWxsYXRvciBpcyBhIHB1bHNlIG9zY2lsbGF0b3Igd2l0aCBjb250cm9sIG92ZXIgcHVsc2Ugd2lkdGgsXG5cdFx0ICogICAgICAgICBhbHNvIGtub3duIGFzIHRoZSBkdXR5IGN5Y2xlLiBBdCA1MCUgZHV0eSBjeWNsZSAod2lkdGggPSAwLjUpIHRoZSB3YXZlIGlzIFxuXHRcdCAqICAgICAgICAgYSBzcXVhcmUgYW5kIG9ubHkgb2RkLW51bWJlcmVkIGhhcm1vbmljcyBhcmUgcHJlc2VudC4gQXQgYWxsIG90aGVyIHdpZHRocyBcblx0XHQgKiAgICAgICAgIGV2ZW4tbnVtYmVyZWQgaGFybW9uaWNzIGFyZSBwcmVzZW50LiBSZWFkIG1vcmUgXG5cdFx0ICogICAgICAgICBbaGVyZV0oaHR0cHM6Ly93aWdnbGV3YXZlLndvcmRwcmVzcy5jb20vMjAxNC8wOC8xNi9wdWxzZS13YXZlZm9ybXMtYW5kLWhhcm1vbmljcy8pLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBbZnJlcXVlbmN5XSBUaGUgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7Tm9ybWFsUmFuZ2V9IFt3aWR0aF0gVGhlIHdpZHRoIG9mIHRoZSBwdWxzZVxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBwdWxzZSA9IG5ldyBUb25lLlB1bHNlT3NjaWxsYXRvcihcIkU1XCIsIDAuNCkudG9NYXN0ZXIoKS5zdGFydCgpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QdWxzZU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3dpZHRoJ1xuXHQgICAgICAgIF0sIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgd2lkdGggb2YgdGhlIHB1bHNlLiBcblx0XHRcdCAqICBAdHlwZSB7Tm9ybWFsUmFuZ2V9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy53aWR0aCA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLndpZHRoLCBUb25lLlR5cGUuTm9ybWFsUmFuZ2UpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGdhdGUgdGhlIHdpZHRoIGFtb3VudFxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZSA9IG5ldyBUb25lLkdhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgc2F3dG9vdGggb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgIGZyZXF1ZW5jeTogb3B0aW9ucy5mcmVxdWVuY3ksXG5cdCAgICAgICAgICAgIGRldHVuZTogb3B0aW9ucy5kZXR1bmUsXG5cdCAgICAgICAgICAgIHR5cGU6ICdzYXd0b290aCcsXG5cdCAgICAgICAgICAgIHBoYXNlOiBvcHRpb25zLnBoYXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeSBjb250cm9sLlxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9zYXd0b290aC5mcmVxdWVuY3k7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50cy4gXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5fc2F3dG9vdGguZGV0dW5lO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRocmVzaG9sZCB0aGUgc2lnbmFsIHRvIHR1cm4gaXQgaW50byBhIHNxdWFyZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLldhdmVTaGFwZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3RocmVzaCA9IG5ldyBUb25lLldhdmVTaGFwZXIoZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvL2Nvbm5lY3Rpb25zXG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGguY2hhaW4odGhpcy5fdGhyZXNoLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy53aWR0aC5jaGFpbih0aGlzLl93aWR0aEdhdGUsIHRoaXMuX3RocmVzaCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnd2lkdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlB1bHNlT3NjaWxsYXRvciwgVG9uZS5Tb3VyY2UpO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBkZWZhdWx0IHBhcmFtZXRlcnMuXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnZnJlcXVlbmN5JzogNDQwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdwaGFzZSc6IDAsXG5cdCAgICAgICAgJ3dpZHRoJzogMC4yXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fc2F3dG9vdGguc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fd2lkdGhHYXRlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMSwgdGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0b3AgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gdGltZSBcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLnN0b3AodGltZSk7XG5cdCAgICAgICAgLy90aGUgd2lkdGggaXMgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBvdXRwdXQuIFxuXHQgICAgICAgIC8vdGhhdCBuZWVkcyB0byBiZSBzdG9wcGVkIGFsc29cblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QdWxzZU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0RlZ3JlZXN9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nhd3Rvb3RoLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc2F3dG9vdGgucGhhc2UgPSBwaGFzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yLiBBbHdheXMgcmV0dXJucyBcInB1bHNlXCIuXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQG5hbWUgdHlwZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUHVsc2VPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAncHVsc2UnO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQ2Fubm90IHNldCBwYXJ0aWFscyBmb3IgdGhpcyB3YXZlZm9ybSB0eXBlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUHVsc2VPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QdWxzZU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cCBtZXRob2QuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUHVsc2VPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlB1bHNlT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3Nhd3Rvb3RoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zYXd0b290aCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnd2lkdGgnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLndpZHRoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLndpZHRoID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93aWR0aEdhdGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3dpZHRoR2F0ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdGhyZXNoLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl90aHJlc2ggPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUHVsc2VPc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5QV01Pc2NpbGxhdG9yIG1vZHVsYXRlcyB0aGUgd2lkdGggb2YgYSBUb25lLlB1bHNlT3NjaWxsYXRvciBcblx0XHQgKiAgICAgICAgIGF0IHRoZSBtb2R1bGF0aW9uRnJlcXVlbmN5LiBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mIGNvbnRpbnVvdXNseVxuXHRcdCAqICAgICAgICAgY2hhbmdpbmcgdGhlIHRpbWJyZSBvZiB0aGUgb3NjaWxsYXRvciBieSBhbHRlcmluZyB0aGUgaGFybW9uaWNzIFxuXHRcdCAqICAgICAgICAgZ2VuZXJhdGVkLlxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBtb2R1bGF0aW9uRnJlcXVlbmN5IFRoZSBtb2R1bGF0aW9uIGZyZXF1ZW5jeSBvZiB0aGUgd2lkdGggb2YgdGhlIHB1bHNlLiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgdmFyIHB3bSA9IG5ldyBUb25lLlBXTU9zY2lsbGF0b3IoXCJBYjNcIiwgMC4zKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knXG5cdCAgICAgICAgXSwgVG9uZS5QV01Pc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBwdWxzZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuUHVsc2VPc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wdWxzZSA9IG5ldyBUb25lLlB1bHNlT3NjaWxsYXRvcihvcHRpb25zLm1vZHVsYXRpb25GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8vY2hhbmdlIHRoZSBwdWxzZSBvc2NpbGxhdG9yIHR5cGVcblx0ICAgICAgICB0aGlzLl9wdWxzZS5fc2F3dG9vdGgudHlwZSA9ICdzaW5lJztcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbW9kdWxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbmV3IFRvbmUuT3NjaWxsYXRvcih7XG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knOiBvcHRpb25zLmZyZXF1ZW5jeSxcblx0ICAgICAgICAgICAgJ2RldHVuZSc6IG9wdGlvbnMuZGV0dW5lLFxuXHQgICAgICAgICAgICAncGhhc2UnOiBvcHRpb25zLnBoYXNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2NhbGUgdGhlIG9zY2lsbGF0b3Igc28gaXQgZG9lc24ndCBnbyBzaWxlbnQgXG5cdFx0XHQgKiAgYXQgdGhlIGV4dHJlbWUgdmFsdWVzLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk11bHRpcGx5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zY2FsZSA9IG5ldyBUb25lLk11bHRpcGx5KDIpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX21vZHVsYXRvci5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gcmF0ZSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25GcmVxdWVuY3kgPSB0aGlzLl9wdWxzZS5mcmVxdWVuY3k7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jaGFpbih0aGlzLl9zY2FsZSwgdGhpcy5fcHVsc2Uud2lkdGgpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25GcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBXTU9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvbkZyZXF1ZW5jeSc6IDAuNFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9wdWxzZS5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5zdG9wKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3IuIEFsd2F5cyByZXR1cm5zIFwicHdtXCIuXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBXTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICdwd20nO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSB3YXZlZm9ybS4gQ2Fubm90IHNldCBwYXJ0aWFscyBmb3IgdGhpcyB3YXZlZm9ybSB0eXBlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUFdNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUFdNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqIEBuYW1lIHBoYXNlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BoYXNlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9kdWxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUFdNT3NjaWxsYXRvcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QV01Pc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fcHVsc2UuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3B1bHNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zY2FsZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fc2NhbGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uRnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25GcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBXTU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLkZNT3NjaWxsYXRvciBcblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Tb3VyY2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gZnJlcXVlbmN5IFRoZSBzdGFydGluZyBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAcGFyYW0ge1N0cmluZ30gbW9kdWxhdGlvblR5cGUgVGhlIHR5cGUgb2YgdGhlIG1vZHVsYXRvciBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vYSBzaW5lIG9zY2lsbGF0b3IgZnJlcXVlbmN5LW1vZHVsYXRlZCBieSBhIHNxdWFyZSB3YXZlXG5cdFx0ICogdmFyIGZtT3NjID0gbmV3IFRvbmUuRk1Pc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uVHlwZSdcblx0ICAgICAgICBdLCBUb25lLkZNT3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG5ldyBUb25lLk9zY2lsbGF0b3Iob3B0aW9ucy5mcmVxdWVuY3ksIG9wdGlvbnMudHlwZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IncyBmcmVxdWVuY3lcblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX2NhcnJpZXIuZGV0dW5lO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLnZhbHVlID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggaXMgaW4gZXNzZW5jZSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJbiBvdGhlciB0ZXJtcyBpdCBpcyB0aGUgXG5cdFx0XHQgKiAgcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHRcdCAqICBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHRcdCAqXHRAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKlx0QHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXggPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLm1vZHVsYXRpb25JbmRleCk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uSW5kZXgudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpbmcgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLm1vZHVsYXRpb25UeXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdFx0ICogIEEgaGFybW9uaWNpdHkgb2YgMSBnaXZlcyBib3RoIG9zY2lsbGF0b3JzIHRoZSBzYW1lIGZyZXF1ZW5jeS4gXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB0aGUgbW9kdWxhdG9yIGFuIG9jdGF2ZSBiZWxvdyBjYXJyaWVyXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMubW9kdWxhdGlvbkluZGV4LCB0aGlzLl9tb2R1bGF0aW9uTm9kZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmNvbm5lY3QodGhpcy5fbW9kdWxhdGlvbk5vZGUuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuRk1Pc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvbkluZGV4JzogMixcblx0ICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkZNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GTU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRk1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuRk1Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5J1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRk1Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5BTU9zY2lsbGF0b3IgXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuT3NjaWxsYXRvcn1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5BTU9zY2lsbGF0b3IoXCJBYjNcIiwgXCJzaW5lXCIsIFwic3F1YXJlXCIpLnRvTWFzdGVyKCkuc3RhcnQoKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICd0eXBlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25UeXBlJ1xuXHQgICAgICAgIF0sIFRvbmUuQU1Pc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuT3NjaWxsYXRvcihvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy50eXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSB0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wgc2lnbmFsLlxuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IHRoaXMuX2NhcnJpZXIuZGV0dW5lO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLnZhbHVlID0gb3B0aW9ucy5kZXR1bmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpbmcgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBuZXcgVG9uZS5Pc2NpbGxhdG9yKG9wdGlvbnMuZnJlcXVlbmN5LCBvcHRpb25zLm1vZHVsYXRpb25UeXBlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBjb252ZXJ0IHRoZSAtMSwxIG91dHB1dCB0byAwLDFcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BdWRpb1RvR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvblNjYWxlID0gbmV3IFRvbmUuQXVkaW9Ub0dhaW4oKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdFx0ICogIEEgaGFybW9uaWNpdHkgb2YgMSBnaXZlcyBib3RoIG9zY2lsbGF0b3JzIHRoZSBzYW1lIGZyZXF1ZW5jeS4gXG5cdFx0XHQgKiAgSGFybW9uaWNpdHkgPSAyIG1lYW5zIGEgY2hhbmdlIG9mIGFuIG9jdGF2ZS4gXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqICBAZXhhbXBsZVxuXHRcdFx0ICogLy9waXRjaCB0aGUgbW9kdWxhdG9yIGFuIG9jdGF2ZSBiZWxvdyBjYXJyaWVyXG5cdFx0XHQgKiBzeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uTm9kZSA9IG5ldyBUb25lLkdhaW4oMCk7XG5cdCAgICAgICAgLy9jb25uZWN0aW9uc1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNoYWluKHRoaXMuaGFybW9uaWNpdHksIHRoaXMuX21vZHVsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3QodGhpcy5fbW9kdWxhdG9yLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmNoYWluKHRoaXMuX21vZHVsYXRpb25TY2FsZSwgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZ2Fpbik7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5jaGFpbih0aGlzLl9tb2R1bGF0aW9uTm9kZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMucGhhc2UgPSBvcHRpb25zLnBoYXNlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BTU9zY2lsbGF0b3IsIFRvbmUuT3NjaWxsYXRvcik7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd11cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1Pc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdGFydCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RvcCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSB0aW1lIChvcHRpb25hbCkgdGltaW5nIHBhcmFtZXRlclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnN0b3AodGltZSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5zdG9wKHRpbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3Jcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2Fycmllci50eXBlID0gdHlwZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvclxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkFNT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIG1vZHVsYXRpb25UeXBlXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5BTU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvblR5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnR5cGUgPSB0eXBlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBoYXNlIG9mIHRoZSBvc2NpbGxhdG9yIGluIGRlZ3JlZXMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQU1Pc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwaGFzZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGhhc2U7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwaGFzZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZHVsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5BTU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBuYW1lIHBhcnRpYWxzXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvc2MucGFydGlhbHMgPSBbMSwgMC4yLCAwLjAxXTtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUsICdwYXJ0aWFscycsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhcnJpZXIucGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9jYXJyaWVyLnBhcnRpYWxzID0gcGFydGlhbHM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuQU1Pc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNT3NjaWxsYXRvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQU1Pc2NpbGxhdG9yO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgVG9uZS5GYXRPc2NpbGxhdG9yIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBmcmVxdWVuY3kgVGhlIHN0YXJ0aW5nIGZyZXF1ZW5jeSBvZiB0aGUgb3NjaWxsYXRvci4gXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBjYXJyaWVyIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSBtb2R1bGF0aW9uVHlwZSBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9hIHNpbmUgb3NjaWxsYXRvciBmcmVxdWVuY3ktbW9kdWxhdGVkIGJ5IGEgc3F1YXJlIHdhdmVcblx0XHQgKiB2YXIgZm1Pc2MgPSBuZXcgVG9uZS5GYXRPc2NpbGxhdG9yKFwiQWIzXCIsIFwic2luZVwiLCBcInNxdWFyZVwiKS50b01hc3RlcigpLnN0YXJ0KCk7XG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3R5cGUnLFxuXHQgICAgICAgICAgICAnc3ByZWFkJ1xuXHQgICAgICAgIF0sIFRvbmUuRmF0T3NjaWxsYXRvcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvcidzIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5mcmVxdWVuY3ksIFRvbmUuVHlwZS5GcmVxdWVuY3kpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBkZXR1bmUgY29udHJvbCBzaWduYWwuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZGV0dW5lLCBUb25lLlR5cGUuQ2VudHMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhcnJheSBvZiBvc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvcnMgPSBbXTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdG90YWwgc3ByZWFkIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdFx0ICogIEB0eXBlICB7Q2VudHN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NwcmVhZCA9IG9wdGlvbnMuc3ByZWFkO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3JzXG5cdFx0XHQgKiAgQHR5cGUge0RlZ3JlZXN9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BoYXNlID0gb3B0aW9ucy5waGFzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGFydGlhbHMgYXJyYXlcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BhcnRpYWxzID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMucGFydGlhbHMsIFtdKTtcblx0ICAgICAgICAvL3NldCB0aGUgY291bnQgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5jb3VudCA9IG9wdGlvbnMuY291bnQ7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZhdE9zY2lsbGF0b3IsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogIEBjb25zdFxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiA0NDAsXG5cdCAgICAgICAgJ2RldHVuZSc6IDAsXG5cdCAgICAgICAgJ3BoYXNlJzogMCxcblx0ICAgICAgICAnc3ByZWFkJzogMjAsXG5cdCAgICAgICAgJ2NvdW50JzogMyxcblx0ICAgICAgICAndHlwZSc6ICdzYXd0b290aCdcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLnN0YXJ0KHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdG9wIHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IHRpbWUgKG9wdGlvbmFsKSB0aW1pbmcgcGFyYW1ldGVyXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgIG9zYy5zdG9wKHRpbWUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBvc2NpbGxhdG9yc1xuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGl0ZXJhdG9yICBUaGUgaXRlcmF0b3IgZnVuY3Rpb25cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRmF0T3NjaWxsYXRvci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwodGhpcywgdGhpcy5fb3NjaWxsYXRvcnNbaV0sIGkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgY2FycmllciBvc2NpbGxhdG9yXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAndHlwZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy50eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGV0dW5lIHNwcmVhZCBiZXR3ZWVuIHRoZSBvc2NpbGxhdG9ycy4gSWYgXCJjb3VudFwiIGlzXG5cdFx0ICogc2V0IHRvIDMgb3NjaWxsYXRvcnMgYW5kIHRoZSBcInNwcmVhZFwiIGlzIHNldCB0byA0MCxcblx0XHQgKiB0aGUgdGhyZWUgb3NjaWxsYXRvcnMgd291bGQgYmUgZGV0dW5lZCBsaWtlIHRoaXM6IFstMjAsIDAsIDIwXVxuXHRcdCAqIGZvciBhIHRvdGFsIGRldHVuZSBzcHJlYWQgb2YgNDAgY2VudHMuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3NwcmVhZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NwcmVhZDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHNwcmVhZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zcHJlYWQgPSBzcHJlYWQ7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSAtc3ByZWFkIC8gMjtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGVwID0gc3ByZWFkIC8gKHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjLCBpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmRldHVuZS52YWx1ZSA9IHN0YXJ0ICsgc3RlcCAqIGk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBkZXR1bmVkIG9zY2lsbGF0b3JzXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuRmF0T3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2NvdW50Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoY291bnQpIHtcblx0ICAgICAgICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgMSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGggIT09IGNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgcGFydGlhbHMgPSB0aGlzLnBhcnRpYWxzO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdCAgICAgICAgICAgICAgICAvL2Rpc3Bvc2UgdGhlIHByZXZpb3VzIG9zY2lsbGF0b3JzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvc2MuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9zYyA9IG5ldyBUb25lLk9zY2lsbGF0b3IoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBUb25lLk9zY2lsbGF0b3IuVHlwZS5DdXN0b20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnBhcnRpYWxzID0gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3NjLnR5cGUgPSB0aGlzLl90eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvc2MucGhhc2UgPSB0aGlzLl9waGFzZTtcblx0ICAgICAgICAgICAgICAgICAgICBvc2Mudm9sdW1lLnZhbHVlID0gLTYgLSBjb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KG9zYy5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3Qob3NjLmRldHVuZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgb3NjLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldID0gb3NjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy9zZXQgdGhlIHNwcmVhZFxuXHQgICAgICAgICAgICAgICAgdGhpcy5zcHJlYWQgPSB0aGlzLl9zcHJlYWQ7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAob3NjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zYy5zdGFydCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGhhc2Ugb2YgdGhlIG9zY2lsbGF0b3IgaW4gZGVncmVlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQG5hbWUgcGhhc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9waGFzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHBoYXNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKG9zYykge1xuXHQgICAgICAgICAgICAgICAgb3NjLnBoYXNlID0gcGhhc2U7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBhcnRpYWxzIG9mIHRoZSBjYXJyaWVyIHdhdmVmb3JtLiBBIHBhcnRpYWwgcmVwcmVzZW50cyBcblx0XHQgKiB0aGUgYW1wbGl0dWRlIGF0IGEgaGFybW9uaWMuIFRoZSBmaXJzdCBoYXJtb25pYyBpcyB0aGUgXG5cdFx0ICogZnVuZGFtZW50YWwgZnJlcXVlbmN5LCB0aGUgc2Vjb25kIGlzIHRoZSBvY3RhdmUgYW5kIHNvIG9uXG5cdFx0ICogZm9sbG93aW5nIHRoZSBoYXJtb25pYyBzZXJpZXMuIFxuXHRcdCAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc2V0IHRoZSB0eXBlIHRvIFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoZSB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZSB0eXBlIGlzIG5vdCBcImN1c3RvbVwiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5GYXRPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAbmFtZSBwYXJ0aWFsc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogb3NjLnBhcnRpYWxzID0gWzEsIDAuMiwgMC4wMV07XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5GYXRPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3BhcnRpYWxzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydGlhbHM7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJ0aWFscykge1xuXHQgICAgICAgICAgICB0aGlzLl9wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB0aGlzLl90eXBlID0gVG9uZS5Pc2NpbGxhdG9yLlR5cGUuQ3VzdG9tO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgICAgIG9zYy5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5GYXRPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZhdE9zY2lsbGF0b3IucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChvc2MpIHtcblx0ICAgICAgICAgICAgb3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fcGFydGlhbHMgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZhdE9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBUb25lLk9tbmlPc2NpbGxhdG9yIGFnZ3JlZ2F0ZXMgVG9uZS5Pc2NpbGxhdG9yLCBUb25lLlB1bHNlT3NjaWxsYXRvcixcblx0XHQgKiAgICAgICAgIFRvbmUuUFdNT3NjaWxsYXRvciwgVG9uZS5GTU9zY2lsbGF0b3IsIFRvbmUuQU1Pc2NpbGxhdG9yLCBhbmQgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICBpbnRvIG9uZSBjbGFzcy4gVGhlIG9zY2lsbGF0b3IgY2xhc3MgY2FuIGJlIGNoYW5nZWQgYnkgc2V0dGluZyB0aGUgYHR5cGVgLiBcblx0XHQgKiAgICAgICAgIGBvbW5pT3NjLnR5cGUgPSBcInB3bVwiYCB3aWxsIHNldCBpdCB0byB0aGUgVG9uZS5QV01Pc2NpbGxhdG9yLiBQcmVmaXhpbmdcblx0XHQgKiAgICAgICAgIGFueSBvZiB0aGUgYmFzaWMgdHlwZXMgKFwic2luZVwiLCBcInNxdWFyZTRcIiwgZXRjLikgd2l0aCBcImZtXCIsIFwiYW1cIiwgb3IgXCJmYXRcIlxuXHRcdCAqICAgICAgICAgd2lsbCB1c2UgdGhlIEZNT3NjaWxsYXRvciwgQU1Pc2NpbGxhdG9yIG9yIEZhdE9zY2lsbGF0b3IgcmVzcGVjdGl2ZWx5LiBcblx0XHQgKiAgICAgICAgIEZvciBleGFtcGxlOiBgb21uaU9zYy50eXBlID0gXCJmYXRzYXd0b290aFwiYCB3aWxsIGNyZWF0ZSBzZXQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgICAgICAgIHRvIGEgRmF0T3NjaWxsYXRvciBvZiB0eXBlIFwic2F3dG9vdGhcIi4gXG5cdFx0ICpcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtGcmVxdWVuY3l9IGZyZXF1ZW5jeSBUaGUgaW5pdGlhbCBmcmVxdWVuY3kgb2YgdGhlIG9zY2lsbGF0b3IuXG5cdFx0ICogIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBvc2NpbGxhdG9yLlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICB2YXIgb21uaU9zYyA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKFwiQyM0XCIsIFwicHdtXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdHMoYXJndW1lbnRzLCBbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndHlwZSdcblx0ICAgICAgICBdLCBUb25lLk9tbmlPc2NpbGxhdG9yKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKG9wdGlvbnMuZnJlcXVlbmN5LCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2xcblx0XHRcdCAqICBAdHlwZSB7Q2VudHN9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBuZXcgVG9uZS5TaWduYWwob3B0aW9ucy5kZXR1bmUsIFRvbmUuVHlwZS5DZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHR5cGUgb2YgdGhlIG9zY2lsbGF0b3Igc291cmNlXG5cdFx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIC8vc2V0IHRoZSBvc2NpbGxhdG9yXG5cdCAgICAgICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgLy9zZXQgdGhlIG9wdGlvbnNcblx0ICAgICAgICB0aGlzLnNldChvcHRpb25zKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLk9tbmlPc2NpbGxhdG9yLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgZGVmYXVsdCB2YWx1ZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqICBAY29uc3Rcblx0XHQgKi9cblx0ICAgIFRvbmUuT21uaU9zY2lsbGF0b3IuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDQ0MCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAndHlwZSc6ICdzaW5lJyxcblx0ICAgICAgICAncGhhc2UnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEBlbnVtIHtTdHJpbmd9XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICB2YXIgT21uaU9zY1R5cGUgPSB7XG5cdCAgICAgICAgUHVsc2U6ICdQdWxzZU9zY2lsbGF0b3InLFxuXHQgICAgICAgIFBXTTogJ1BXTU9zY2lsbGF0b3InLFxuXHQgICAgICAgIE9zYzogJ09zY2lsbGF0b3InLFxuXHQgICAgICAgIEZNOiAnRk1Pc2NpbGxhdG9yJyxcblx0ICAgICAgICBBTTogJ0FNT3NjaWxsYXRvcicsXG5cdCAgICAgICAgRmF0OiAnRmF0T3NjaWxsYXRvcidcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRvIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RhcnQodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSBvc2NpbGxhdG9yXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byBzdGFydCB0aGUgb3NjaWxsYXRvclxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3RvcCh0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgb3NjaWxsYXRvci4gQ2FuIGJlIGFueSBvZiB0aGUgYmFzaWMgdHlwZXM6IHNpbmUsIHNxdWFyZSwgdHJpYW5nbGUsIHNhd3Rvb3RoLiBPclxuXHRcdCAqIHByZWZpeCB0aGUgYmFzaWMgdHlwZXMgd2l0aCBcImZtXCIsIFwiYW1cIiwgb3IgXCJmYXRcIiB0byB1c2UgdGhlIEZNT3NjaWxsYXRvciwgQU1Pc2NpbGxhdG9yIG9yIEZhdE9zY2lsbGF0b3Jcblx0XHQgKiB0eXBlcy4gVGhlIG9zY2lsbGF0b3IgY291bGQgYWxzbyBiZSBzZXQgdG8gXCJwd21cIiBvciBcInB1bHNlXCIuIEFsbCBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGVcblx0XHQgKiBvc2NpbGxhdG9yJ3MgY2xhc3MgYXJlIGFjY2Vzc2libGUgd2hlbiB0aGUgb3NjaWxsYXRvciBpcyBzZXQgdG8gdGhhdCB0eXBlLCBidXQgdGhyb3dzIGFuIGVycm9yIFxuXHRcdCAqIHdoZW4gaXQncyBub3QuXG5cdFx0ICogXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAbmFtZSB0eXBlXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBvbW5pT3NjLnR5cGUgPSBcInB3bVwiO1xuXHRcdCAqIC8vbW9kdWxhdGlvbkZyZXF1ZW5jeSBpcyBwYXJhbWV0ZXIgd2hpY2ggaXMgYXZhaWxhYmxlXG5cdFx0ICogLy9vbmx5IHdoZW4gdGhlIHR5cGUgaXMgXCJwd21cIi4gXG5cdFx0ICogb21uaU9zYy5tb2R1bGF0aW9uRnJlcXVlbmN5LnZhbHVlID0gMC41O1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9hbiBzcXVhcmUgd2F2ZSBmcmVxdWVuY3kgbW9kdWxhdGVkIGJ5IGEgc2F3dG9vdGhcblx0XHQgKiBvbW5pT3NjLnR5cGUgPSBcImZtc3F1YXJlXCI7XG5cdFx0ICogb21uaU9zYy5tb2R1bGF0aW9uVHlwZSA9IFwic2F3dG9vdGhcIjtcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwcmVmaXggPSAnJztcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVmaXggPSAnZm0nO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkFNKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVmaXggPSAnYW0nO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZhdCkge1xuXHQgICAgICAgICAgICAgICAgcHJlZml4ID0gJ2ZhdCc7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHRoaXMuX29zY2lsbGF0b3IudHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGUuc3Vic3RyKDAsIDIpID09PSAnZm0nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLkZNKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDIpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3Vic3RyKDAsIDIpID09PSAnYW0nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLkFNKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGUuc3Vic3RyKDIpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3Vic3RyKDAsIDMpID09PSAnZmF0Jykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlTmV3T3NjaWxsYXRvcihPbW5pT3NjVHlwZS5GYXQpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci50eXBlID0gdHlwZS5zdWJzdHIoMyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3B3bScpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuUFdNKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncHVsc2UnKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdPc2NpbGxhdG9yKE9tbmlPc2NUeXBlLlB1bHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld09zY2lsbGF0b3IoT21uaU9zY1R5cGUuT3NjKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IudHlwZSA9IHR5cGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwYXJ0aWFscyBvZiB0aGUgd2F2ZWZvcm0uIEEgcGFydGlhbCByZXByZXNlbnRzIFxuXHRcdCAqIHRoZSBhbXBsaXR1ZGUgYXQgYSBoYXJtb25pYy4gVGhlIGZpcnN0IGhhcm1vbmljIGlzIHRoZSBcblx0XHQgKiBmdW5kYW1lbnRhbCBmcmVxdWVuY3ksIHRoZSBzZWNvbmQgaXMgdGhlIG9jdGF2ZSBhbmQgc28gb25cblx0XHQgKiBmb2xsb3dpbmcgdGhlIGhhcm1vbmljIHNlcmllcy4gXG5cdFx0ICogU2V0dGluZyB0aGlzIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBzZXQgdGhlIHR5cGUgdG8gXCJjdXN0b21cIi4gXG5cdFx0ICogVGhlIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5IHdoZW4gdGhlIHR5cGUgaXMgbm90IFwiY3VzdG9tXCIuIFxuXHRcdCAqIFRoaXMgaXMgbm90IGF2YWlsYWJsZSBvbiBcInB3bVwiIGFuZCBcInB1bHNlXCIgb3NjaWxsYXRvciB0eXBlcy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQG5hbWUgcGFydGlhbHNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG9zYy5wYXJ0aWFscyA9IFsxLCAwLjIsIDAuMDFdO1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGFydGlhbHMnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBhcnRpYWxzO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGFydGlhbHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5wYXJ0aWFscyA9IHBhcnRpYWxzO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhIG1lbWJlci9hdHRyaWJ1dGUgb2YgdGhlIG9zY2lsbGF0b3IuIFxuXHRcdCAqICBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHBhcmFtc1xuXHRcdCAqICBAcGFyYW0ge251bWJlcj19IHZhbHVlXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHJhbXBUaW1lXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk9tbmlPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZSkge1xuXHQgICAgICAgIC8vbWFrZSBzdXJlIHRoZSB0eXBlIGlzIHNldCBmaXJzdFxuXHQgICAgICAgIGlmIChwYXJhbXMgPT09ICd0eXBlJykge1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcblx0ICAgICAgICB9IGVsc2UgaWYgKFRvbmUuaXNPYmplY3QocGFyYW1zKSAmJiBwYXJhbXMuaGFzT3duUHJvcGVydHkoJ3R5cGUnKSkge1xuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSBwYXJhbXMudHlwZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy90aGVuIHNldCB0aGUgcmVzdFxuXHQgICAgICAgIFRvbmUucHJvdG90eXBlLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjb25uZWN0IHRoZSBvc2NpbGxhdG9yIHRvIHRoZSBmcmVxdWVuY3kgYW5kIGRldHVuZSBzaWduYWxzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5fY3JlYXRlTmV3T3NjaWxsYXRvciA9IGZ1bmN0aW9uIChvc2NUeXBlKSB7XG5cdCAgICAgICAgaWYgKG9zY1R5cGUgIT09IHRoaXMuX3NvdXJjZVR5cGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IG9zY1R5cGU7XG5cdCAgICAgICAgICAgIHZhciBPc2NpbGxhdG9yQ29uc3RydWN0b3IgPSBUb25lW29zY1R5cGVdO1xuXHQgICAgICAgICAgICAvL3Nob3J0IGRlbGF5IHRvIGF2b2lkIGNsaWNrcyBvbiB0aGUgY2hhbmdlXG5cdCAgICAgICAgICAgIHZhciBub3cgPSB0aGlzLm5vdygpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fb3NjaWxsYXRvciAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9sZE9zYyA9IHRoaXMuX29zY2lsbGF0b3I7XG5cdCAgICAgICAgICAgICAgICBvbGRPc2Muc3RvcChub3cpO1xuXHQgICAgICAgICAgICAgICAgLy9kaXNwb3NlIHRoZSBvbGQgb25lXG5cdCAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2xkT3NjLmRpc3Bvc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRPc2MgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfSwgdGhpcy5ibG9ja1RpbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IgPSBuZXcgT3NjaWxsYXRvckNvbnN0cnVjdG9yKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LmNvbm5lY3QodGhpcy5fb3NjaWxsYXRvci5mcmVxdWVuY3kpO1xuXHQgICAgICAgICAgICB0aGlzLmRldHVuZS5jb25uZWN0KHRoaXMuX29zY2lsbGF0b3IuZGV0dW5lKTtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFRvbmUuU3RhdGUuU3RhcnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5zdGFydChub3cpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBwaGFzZSBvZiB0aGUgb3NjaWxsYXRvciBpbiBkZWdyZWVzLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RGVncmVlc31cblx0XHQgKiBAbmFtZSBwaGFzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAncGhhc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnBoYXNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocGhhc2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5waGFzZSA9IHBoYXNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHdpZHRoIG9mIHRoZSBvc2NpbGxhdG9yIChvbmx5IGlmIHRoZSBvc2NpbGxhdG9yIGlzIHNldCB0byBcInB1bHNlXCIpXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuT21uaU9zY2lsbGF0b3IjXG5cdFx0ICogQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSB3aWR0aFxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogdmFyIG9tbmlPc2MgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcig0NDAsIFwicHVsc2VcIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSB3aWR0aCBhdHRyaWJ1dGUgb25seSBpZiB0eXBlID09PSBcInB1bHNlXCJcblx0XHQgKiBvbW5pT3NjLndpZHRoLnZhbHVlID0gMC4yOyBcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ3dpZHRoJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuUHVsc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLndpZHRoO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGRldHVuZWQgb3NjaWxsYXRvcnNcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBuYW1lIGNvdW50XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdjb3VudCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZhdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IuY291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IuY291bnQgPSBjb3VudDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGRldHVuZSBzcHJlYWQgYmV0d2VlbiB0aGUgb3NjaWxsYXRvcnMuIElmIFwiY291bnRcIiBpc1xuXHRcdCAqIHNldCB0byAzIG9zY2lsbGF0b3JzIGFuZCB0aGUgXCJzcHJlYWRcIiBpcyBzZXQgdG8gNDAsXG5cdFx0ICogdGhlIHRocmVlIG9zY2lsbGF0b3JzIHdvdWxkIGJlIGRldHVuZWQgbGlrZSB0aGlzOiBbLTIwLCAwLCAyMF1cblx0XHQgKiBmb3IgYSB0b3RhbCBkZXR1bmUgc3ByZWFkIG9mIDQwIGNlbnRzLiBTZWUgVG9uZS5GYXRPc2NpbGxhdG9yXG5cdFx0ICogZm9yIG1vcmUgaW5mby5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7Q2VudHN9XG5cdFx0ICogQG5hbWUgc3ByZWFkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5PbW5pT3NjaWxsYXRvci5wcm90b3R5cGUsICdzcHJlYWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLnNwcmVhZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3ByZWFkKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2VUeXBlID09PSBPbW5pT3NjVHlwZS5GYXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3Iuc3ByZWFkID0gc3ByZWFkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgbW9kdWxhdG9yIG9zY2lsbGF0b3IuIE9ubHkgaWYgdGhlIG9zY2lsbGF0b3Jcblx0XHQgKiBpcyBzZXQgdG8gXCJhbVwiIG9yIFwiZm1cIiB0eXBlcy4gc2VlLiBUb25lLkFNT3NjaWxsYXRvciBvciBUb25lLkZNT3NjaWxsYXRvclxuXHRcdCAqIGZvciBtb3JlIGluZm8uIFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQG5hbWUgbW9kdWxhdGlvblR5cGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25UeXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLm1vZHVsYXRpb25UeXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtVHlwZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvblR5cGUgPSBtVHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggaXMgaW4gZXNzZW5jZSB0aGUgZGVwdGggb3IgYW1vdW50IG9mIHRoZSBtb2R1bGF0aW9uLiBJbiBvdGhlciB0ZXJtcyBpdCBpcyB0aGUgXG5cdFx0ICogcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBcblx0XHQgKiBtb2R1bGF0aW5nIHNpZ25hbCAobWEpIC0tIGFzIGluIG1hL21mLiBcblx0XHQgKiBTZWUgVG9uZS5GTU9zY2lsbGF0b3IgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ21vZHVsYXRpb25JbmRleCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLkZNKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvci5tb2R1bGF0aW9uSW5kZXg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIGNhcnJpZXIgYW5kIHRoZSBtb2R1bGF0b3Igb3NjaWxsYXRvcnMuIFxuXHRcdCAqICBBIGhhcm1vbmljaXR5IG9mIDEgZ2l2ZXMgYm90aCBvc2NpbGxhdG9ycyB0aGUgc2FtZSBmcmVxdWVuY3kuIFxuXHRcdCAqICBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBTZWUgVG9uZS5BTU9zY2lsbGF0b3Igb3IgVG9uZS5GTU9zY2lsbGF0b3Jcblx0XHQgKiAgZm9yIG1vcmUgaW5mby4gXG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLk9tbmlPc2NpbGxhdG9yI1xuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHQgKiAgQG5hbWUgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZSwgJ2hhcm1vbmljaXR5Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuRk0gfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gT21uaU9zY1R5cGUuQU0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yLmhhcm1vbmljaXR5O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbW9kdWxhdGlvbkZyZXF1ZW5jeSBTaWduYWwgb2YgdGhlIG9zY2lsbGF0b3IgXG5cdFx0ICogKG9ubHkgaWYgdGhlIG9zY2lsbGF0b3IgdHlwZSBpcyBzZXQgdG8gcHdtKS4gU2VlIFxuXHRcdCAqIFRvbmUuUFdNT3NjaWxsYXRvciBmb3IgbW9yZSBpbmZvLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5PbW5pT3NjaWxsYXRvciNcblx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdCAqIEBzaWduYWxcblx0XHQgKiBAbmFtZSBtb2R1bGF0aW9uRnJlcXVlbmN5XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgb21uaU9zYyA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKDQ0MCwgXCJwd21cIik7XG5cdFx0ICogLy9jYW4gYWNjZXNzIHRoZSBtb2R1bGF0aW9uRnJlcXVlbmN5IGF0dHJpYnV0ZSBvbmx5IGlmIHR5cGUgPT09IFwicHdtXCJcblx0XHQgKiBvbW5pT3NjLm1vZHVsYXRpb25GcmVxdWVuY3kudmFsdWUgPSAwLjI7IFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuT21uaU9zY2lsbGF0b3IucHJvdG90eXBlLCAnbW9kdWxhdGlvbkZyZXF1ZW5jeScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZVR5cGUgPT09IE9tbmlPc2NUeXBlLlBXTSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29zY2lsbGF0b3IubW9kdWxhdGlvbkZyZXF1ZW5jeTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLk9tbmlPc2NpbGxhdG9yfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk9tbmlPc2NpbGxhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fb3NjaWxsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fc291cmNlVHlwZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuT21uaU9zY2lsbGF0b3I7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgQmFzZS1jbGFzcyBmb3IgYWxsIGluc3RydW1lbnRzXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkluc3RydW1lbnQuZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuQXVkaW9Ob2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG91dHB1dCBhbmQgdm9sdW1lIHRyaW1pbmcgbm9kZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5Wb2x1bWV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuVm9sdW1lKG9wdGlvbnMudm9sdW1lKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSB2b2x1bWUgb2YgdGhlIG91dHB1dCBpbiBkZWNpYmVscy5cblx0XHRcdCAqIEB0eXBlIHtEZWNpYmVsc31cblx0XHRcdCAqIEBzaWduYWxcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBzb3VyY2Uudm9sdW1lLnZhbHVlID0gLTY7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuSW5zdHJ1bWVudCwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXNcblx0XHQgKiAgQHR5cGUge29iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAvKiogdGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzICovXG5cdCAgICAgICAgJ3ZvbHVtZSc6IDBcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQGFic3RyYWN0XG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbm90ZSB0aGUgbm90ZSB0byB0cmlnZ2VyXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0byB0cmlnZ2VyIHRoZSBudG9lXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IHRvIHRyaWdnZXIgdGhlIG5vdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIHdoZW4gdG8gdHJpZ2dlciB0aGUgcmVsZWFzZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IFRvbmUubm9PcDtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHRoZW4gdGhlIHJlbGVhc2UgYWZ0ZXIgdGhlIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l9IG5vdGUgICAgIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBub3RlIHNob3VsZCBiZSBoZWxkIGZvciBiZWZvcmVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmluZyB0aGUgcmVsZWFzZS4gVGhpcyB2YWx1ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLlxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gIFdoZW4gdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgdGhlIG5vdGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuSW5zdHJ1bWVudH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBcIkM0XCIgZm9yIHRoZSBkdXJhdGlvbiBvZiBhbiA4dGggbm90ZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAobm90ZSwgZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayhub3RlLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5JbnN0cnVtZW50fSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoWyd2b2x1bWUnXSk7XG5cdCAgICAgICAgdGhpcy52b2x1bWUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkluc3RydW1lbnQ7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBvdGhlciBtb25vcGhvbmljIGluc3RydW1lbnRzIHRvIFxuXHRcdCAqICAgICAgICAgIGV4dGVuZC4gSU1QT1JUQU5UOiBJdCBkb2VzIG5vdCBtYWtlIGFueSBzb3VuZCBvbiBpdHMgb3duIGFuZFxuXHRcdCAqICAgICAgICAgIHNob3VsZG4ndCBiZSBkaXJlY3RseSBpbnN0YW50aWF0ZWQuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBhYnN0cmFjdFxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICAvL2dldCB0aGUgZGVmYXVsdHNcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuTW9ub3Bob25pYy5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdsaWRlIHRpbWUgYmV0d2VlbiBub3Rlcy4gXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnBvcnRhbWVudG8gPSBvcHRpb25zLnBvcnRhbWVudG87XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb25vcGhvbmljLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMuZGVmYXVsdHMgPSB7ICdwb3J0YW1lbnRvJzogMCB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBvZiB0aGUgbm90ZSBvcHRpb25hbGx5IHdpdGggYSBnaXZlbiB2ZWxvY2l0eS4gXG5cdFx0ICogIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byB0cmlnZ2VyLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddICAgICBXaGVuIHRoZSBub3RlIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHNjYWxlciBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lcyBob3cgXCJsb3VkXCIgdGhlIG5vdGUgXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgdHJpZ2dlcmVkLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vcGhvbmljfSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFjayhcIkM0XCIpO1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciB0aGUgbm90ZSBhIGhhbGYgc2Vjb25kIGZyb20gbm93IGF0IGhhbGYgdmVsb2NpdHlcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrKFwiQzRcIiwgXCIrMC41XCIsIDAuNSk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlckVudmVsb3BlQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnNldE5vdGUobm90ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSBJZiBubyB0aW1lIGlzIGdpdmVuLCB0aGUgcmVsZWFzZSBoYXBwZW5zIGltbWVkaWF0bHlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHN5bnRoLnRyaWdnZXJSZWxlYXNlKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2l0aCB0aGUgYWN0dWFsIG1ldGhvZFxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2l0aCB0aGUgYWN0dWFsIG1ldGhvZFxuXHRcdCAqICBAYWJzdHJhY3Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgbm90ZSBhdCB0aGUgZ2l2ZW4gdGltZS4gSWYgbm8gdGltZSBpcyBnaXZlbiwgdGhlIG5vdGVcblx0XHQgKiAgd2lsbCBzZXQgaW1tZWRpYXRlbHkuIFxuXHRcdCAqICBAcGFyYW0ge0ZyZXF1ZW5jeX0gbm90ZSBUaGUgbm90ZSB0byBjaGFuZ2UgdG8uXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gVGhlIHRpbWUgd2hlbiB0aGUgbm90ZSBzaG91bGQgYmUgc2V0LiBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub3Bob25pY30gdGhpc1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9jaGFuZ2UgdG8gRiM2IGluIG9uZSBxdWFydGVyIG5vdGUgZnJvbSBub3cuXG5cdFx0ICogc3ludGguc2V0Tm90ZShcIkYjNlwiLCBcIis0blwiKTtcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vY2hhbmdlIHRvIEJiNCByaWdodCBub3dcblx0XHQgKiBzeW50aC5zZXROb3RlKFwiQmI0XCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5zZXROb3RlID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMucG9ydGFtZW50byA+IDApIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnROb3RlID0gdGhpcy5mcmVxdWVuY3kudmFsdWU7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKGN1cnJlbnROb3RlLCB0aW1lKTtcblx0ICAgICAgICAgICAgdmFyIHBvcnRUaW1lID0gdGhpcy50b1NlY29uZHModGhpcy5wb3J0YW1lbnRvKTtcblx0ICAgICAgICAgICAgdGhpcy5mcmVxdWVuY3kuZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZShub3RlLCB0aW1lICsgcG9ydFRpbWUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKG5vdGUsIHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Nb25vcGhvbmljO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuU3ludGggaXMgY29tcG9zZWQgc2ltcGx5IG9mIGEgVG9uZS5PbW5pT3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIHJvdXRlZCB0aHJvdWdoIGEgVG9uZS5BbXBsaXR1ZGVFbnZlbG9wZS4gXG5cdFx0ICogICAgICAgICAgPGltZyBzcmM9XCJodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kcmF3aW5ncy9kLzEtMV8wWVcyWjFKMkVQSTM2UDhmTkNNY1pHN04xdzFHWmx1UHM0b2c0ZXZvL3B1Yj93PTExNjMmaD0yMzFcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuTW9ub3Bob25pY31cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIHN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzRcIiwgXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIC8vZ2V0IHRoZSBkZWZhdWx0c1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT21uaU9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihvcHRpb25zLm9zY2lsbGF0b3IpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5vc2NpbGxhdG9yLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8vY29ubmVjdCB0aGUgb3NjaWxsYXRvcnMgdG8gdGhlIG91dHB1dFxuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgb3NjaWxsYXRvcnNcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQoKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5TeW50aCwgVG9uZS5Nb25vcGhvbmljKTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAndHJpYW5nbGUnIH0sXG5cdCAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAnYXR0YWNrJzogMC4wMDUsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMSxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLjMsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IFt2ZWxvY2l0eT0xXSB0aGUgdmVsb2NpdHkgb2YgdGhlIG5vdGUgKDAtMSlcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBzdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlN5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlN5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnZGV0dW5lJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEFNU3ludGggdXNlcyB0aGUgb3V0cHV0IG9mIG9uZSBUb25lLlN5bnRoIHRvIG1vZHVsYXRlIHRoZVxuXHRcdCAqICAgICAgICAgIGFtcGxpdHVkZSBvZiBhbm90aGVyIFRvbmUuU3ludGguIFRoZSBoYXJtb25pY2l0eSAodGhlIHJhdGlvIGJldHdlZW5cblx0XHQgKiAgICAgICAgICB0aGUgdHdvIHNpZ25hbHMpIGFmZmVjdHMgdGhlIHRpbWJyZSBvZiB0aGUgb3V0cHV0IHNpZ25hbCBncmVhdGx5LlxuXHRcdCAqICAgICAgICAgIFJlYWQgbW9yZSBhYm91dCBBbXBsaXR1ZGUgTW9kdWxhdGlvbiBTeW50aGVzaXMgb25cblx0XHQgKiAgICAgICAgICBbU291bmRPblNvdW5kXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA0MDQxMDM2NTMvaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tOjgwL3Nvcy9tYXIwMC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKS5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMVRRdThFZDRpRnIxWVRMS3BCM1UxX2h1ci1Vd0JyaDVnZEJYYzhCeGZHS3cvcHViP3c9MTAwOSZoPTQ1N1wiPlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuQU1TeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCJDNFwiLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5BTVN5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuQU1TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIgdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIgPSBuZXcgVG9uZS5TeW50aCgpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3Mgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSB0aGlzLl9jYXJyaWVyLm9zY2lsbGF0b3I7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGNhcnJpZXIncyBlbnZlbG9wZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IHRoaXMuX2NhcnJpZXIuZW52ZWxvcGUuc2V0KG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3Igdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLlN5bnRoKCk7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3Mgb3NjaWxsYXRvciB3aGljaCBpcyBhcHBsaWVkXG5cdFx0XHQgKiAgdG8gdGhlIGFtcGxpdHVkZSBvZiB0aGUgb3NjaWxsYXRvclxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSB0aGlzLl9tb2R1bGF0b3Iub3NjaWxsYXRvci5zZXQob3B0aW9ucy5tb2R1bGF0aW9uKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbW9kdWxhdG9yJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BbXBsaXR1ZGVFbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gdGhpcy5fbW9kdWxhdG9yLmVudmVsb3BlLnNldChvcHRpb25zLm1vZHVsYXRpb25FbnZlbG9wZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZyZXF1ZW5jeS5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdm9pY2UxIGFuIG9jdGF2ZSBiZWxvdyB2b2ljZTBcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgY29udmVydCB0aGUgLTEsMSBvdXRwdXQgdG8gMCwxXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQXVkaW9Ub0dhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG5ldyBUb25lLkF1ZGlvVG9HYWluKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG5vZGUgd2hlcmUgdGhlIG1vZHVsYXRpb24gaGFwcGVuc1xuXHRcdFx0ICogIEB0eXBlIHtUb25lLkdhaW59XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgdHdvIHZvaWNlcyBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMuX2NhcnJpZXIuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbih0aGlzLmhhcm1vbmljaXR5LCB0aGlzLl9tb2R1bGF0b3IuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5mYW4odGhpcy5fY2Fycmllci5kZXR1bmUsIHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jaGFpbih0aGlzLl9tb2R1bGF0aW9uU2NhbGUsIHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY2hhaW4odGhpcy5fbW9kdWxhdGlvbk5vZGUsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5BTVN5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAzLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgdHJpZ2dlciB0aGUgYXR0YWNrIHBvcnRpb24gb2YgdGhlIG5vdGVcblx0XHQgKlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgb2NjdXJcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5BTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkFNU3ludGgucHJvdG90eXBlLl90cmlnZ2VyRW52ZWxvcGVBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBwb3J0IGdsaWRlXG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIC8vdGhlIGVudmVsb3Blc1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFNU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy5tb2R1bGF0aW9uRW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkFNU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQU1TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAnaGFybW9uaWNpdHknLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcicsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdtb2R1bGF0aW9uJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5fY2Fycmllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2FycmllciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0aW9uU2NhbGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25TY2FsZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkFNU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5Nb25vU3ludGggaXMgY29tcG9zZWQgb2Ygb25lIG9zY2lsbGF0b3IsIG9uZSBmaWx0ZXIsIGFuZCB0d28gZW52ZWxvcGVzLlxuXHRcdCAqICAgICAgICAgIFRoZSBhbXBsaXR1ZGUgb2YgdGhlIFRvbmUuT3NjaWxsYXRvciBhbmQgdGhlIGN1dG9mZiBmcmVxdWVuY3kgb2YgdGhlIFxuXHRcdCAqICAgICAgICAgIFRvbmUuRmlsdGVyIGFyZSBjb250cm9sbGVkIGJ5IFRvbmUuRW52ZWxvcGVzLiBcblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWdhWTFERjlfSHprb2RxZjhKSTFDZzJWWmZ3U0VscEZRZkk5NElRd2FkMzgvcHViP3c9OTI0Jmg9MjQwXCI+XG5cdFx0ICogICAgICAgICAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5Nb25vcGhvbmljfVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5Nb25vU3ludGgoe1xuXHRcdCAqIFx0XCJvc2NpbGxhdG9yXCIgOiB7XG5cdFx0ICogXHRcdFwidHlwZVwiIDogXCJzcXVhcmVcIlxuXHRcdCAqICB9LFxuXHRcdCAqICBcImVudmVsb3BlXCIgOiB7XG5cdFx0ICogIFx0XCJhdHRhY2tcIiA6IDAuMVxuXHRcdCAqICB9XG5cdFx0ICogfSkudG9NYXN0ZXIoKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk1vbm9TeW50aC5kZWZhdWx0cyk7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG9zY2lsbGF0b3IuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT21uaU9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBuZXcgVG9uZS5PbW5pT3NjaWxsYXRvcihvcHRpb25zLm9zY2lsbGF0b3IpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZGV0dW5lIGNvbnRyb2wuXG5cdFx0XHQgKiAgQHR5cGUge0NlbnRzfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZGV0dW5lID0gdGhpcy5vc2NpbGxhdG9yLmRldHVuZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlsdGVyLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZpbHRlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IFRvbmUuRmlsdGVyKG9wdGlvbnMuZmlsdGVyKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmlsdGVyIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkZyZXF1ZW5jeUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZSA9IG5ldyBUb25lLkZyZXF1ZW5jeUVudmVsb3BlKG9wdGlvbnMuZmlsdGVyRW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBvc2NpbGxhdG9ycyB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmNoYWluKHRoaXMuZmlsdGVyLCB0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgb3NjaWxsYXRvcnNcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3Iuc3RhcnQoKTtcblx0ICAgICAgICAvL2Nvbm5lY3QgdGhlIGZpbHRlciBlbnZlbG9wZVxuXHQgICAgICAgIHRoaXMuZmlsdGVyRW52ZWxvcGUuY29ubmVjdCh0aGlzLmZpbHRlci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2RldHVuZScsXG5cdCAgICAgICAgICAgICdmaWx0ZXInLFxuXHQgICAgICAgICAgICAnZmlsdGVyRW52ZWxvcGUnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Nb25vU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdmcmVxdWVuY3knOiAnQzQnLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ2ZpbHRlcic6IHtcblx0ICAgICAgICAgICAgJ1EnOiA2LFxuXHQgICAgICAgICAgICAndHlwZSc6ICdsb3dwYXNzJyxcblx0ICAgICAgICAgICAgJ3JvbGxvZmYnOiAtMjRcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDA1LFxuXHQgICAgICAgICAgICAnZGVjYXknOiAwLjEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMC45LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDFcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdmaWx0ZXJFbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDYsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMixcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAwLjUsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMixcblx0ICAgICAgICAgICAgJ2Jhc2VGcmVxdWVuY3knOiAyMDAsXG5cdCAgICAgICAgICAgICdvY3RhdmVzJzogNyxcblx0ICAgICAgICAgICAgJ2V4cG9uZW50JzogMlxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZVxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIGF0dGFjayBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Nb25vU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTW9ub1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgLy90aGUgZW52ZWxvcGVzXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHN0YXJ0IHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIGVudmVsb3BlXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXJFbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTW9ub1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1vbm9TeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLk1vbm9waG9uaWMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2ZyZXF1ZW5jeScsXG5cdCAgICAgICAgICAgICdkZXR1bmUnLFxuXHQgICAgICAgICAgICAnZmlsdGVyJyxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJ1xuXHQgICAgICAgIF0pO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZpbHRlckVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmZpbHRlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuTW9ub1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuRHVvU3ludGggaXMgYSBtb25vcGhvbmljIHN5bnRoIGNvbXBvc2VkIG9mIHR3byBcblx0XHQgKiAgICAgICAgICBNb25vU3ludGhzIHJ1biBpbiBwYXJhbGxlbCB3aXRoIGNvbnRyb2wgb3ZlciB0aGUgXG5cdFx0ICogICAgICAgICAgZnJlcXVlbmN5IHJhdGlvIGJldHdlZW4gdGhlIHR3byB2b2ljZXMgYW5kIHZpYnJhdG8gZWZmZWN0LlxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xYkw0R1h2ZlJNTWxxUzdYeUJtOUNqTDlLSlBTVUtiY2RCTnBxT2xrRkx4ay9wdWI/dz0xMDEyJmg9NDQ4XCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHNlZSBkZWZhdWx0cyBiZWxvd1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBkdW9TeW50aCA9IG5ldyBUb25lLkR1b1N5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBkdW9TeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkM0XCIsIFwiMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuRHVvU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmaXJzdCB2b2ljZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk1vbm9TeW50aH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2UwID0gbmV3IFRvbmUuTW9ub1N5bnRoKG9wdGlvbnMudm9pY2UwKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMC52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIHNlY29uZCB2b2ljZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk1vbm9TeW50aH1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2UxID0gbmV3IFRvbmUuTW9ub1N5bnRoKG9wdGlvbnMudm9pY2UxKTtcblx0ICAgICAgICB0aGlzLnZvaWNlMS52b2x1bWUudmFsdWUgPSAtMTA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHZpYnJhdG8gTEZPLiBcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5MRk99XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG8gPSBuZXcgVG9uZS5MRk8ob3B0aW9ucy52aWJyYXRvUmF0ZSwgLTUwLCA1MCk7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0by5zdGFydCgpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogdGhlIHZpYnJhdG8gZnJlcXVlbmN5XG5cdFx0XHQgKiBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy52aWJyYXRvUmF0ZSA9IHRoaXMuX3ZpYnJhdG8uZnJlcXVlbmN5O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSB2aWJyYXRvIGdhaW5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92aWJyYXRvR2FpbiA9IG5ldyBUb25lLkdhaW4ob3B0aW9ucy52aWJyYXRvQW1vdW50LCBUb25lLlR5cGUuUG9zaXRpdmUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGFtb3VudCBvZiB2aWJyYXRvXG5cdFx0XHQgKiBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZpYnJhdG9BbW91bnQgPSB0aGlzLl92aWJyYXRvR2Fpbi5nYWluO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBmcmVxdWVuY3kgY29udHJvbFxuXHRcdFx0ICogIEB0eXBlIHtGcmVxdWVuY3l9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBuZXcgVG9uZS5TaWduYWwoNDQwLCBUb25lLlR5cGUuRnJlcXVlbmN5KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLiBcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3BpdGNoIHZvaWNlMSBhbiBvY3RhdmUgYmVsb3cgdm9pY2UwXG5cdFx0XHQgKiBkdW9TeW50aC5oYXJtb25pY2l0eS52YWx1ZSA9IDAuNTtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkgPSBuZXcgVG9uZS5NdWx0aXBseShvcHRpb25zLmhhcm1vbmljaXR5KTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8vY29udHJvbCB0aGUgdHdvIHZvaWNlcyBmcmVxdWVuY3lcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jb25uZWN0KHRoaXMudm9pY2UwLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy52b2ljZTEuZnJlcXVlbmN5KTtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvLmNvbm5lY3QodGhpcy5fdmlicmF0b0dhaW4pO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluLmZhbih0aGlzLnZvaWNlMC5kZXR1bmUsIHRoaXMudm9pY2UxLmRldHVuZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAndm9pY2UwJyxcblx0ICAgICAgICAgICAgJ3ZvaWNlMScsXG5cdCAgICAgICAgICAgICdmcmVxdWVuY3knLFxuXHQgICAgICAgICAgICAndmlicmF0b0Ftb3VudCcsXG5cdCAgICAgICAgICAgICd2aWJyYXRvUmF0ZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkR1b1N5bnRoLCBUb25lLk1vbm9waG9uaWMpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuRHVvU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZpYnJhdG9BbW91bnQnOiAwLjUsXG5cdCAgICAgICAgJ3ZpYnJhdG9SYXRlJzogNSxcblx0ICAgICAgICAnaGFybW9uaWNpdHknOiAxLjUsXG5cdCAgICAgICAgJ3ZvaWNlMCc6IHtcblx0ICAgICAgICAgICAgJ3ZvbHVtZSc6IC0xMCxcblx0ICAgICAgICAgICAgJ3BvcnRhbWVudG8nOiAwLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ3ZvaWNlMSc6IHtcblx0ICAgICAgICAgICAgJ3ZvbHVtZSc6IC0xMCxcblx0ICAgICAgICAgICAgJ3BvcnRhbWVudG8nOiAwLFxuXHQgICAgICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAgICAgJ2ZpbHRlckVudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJzoge1xuXHQgICAgICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICAgICAnZGVjYXknOiAwLFxuXHQgICAgICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXNcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge05vcm1hbFJhbmdlfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlQXR0YWNrID0gZnVuY3Rpb24gKHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudm9pY2UxLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwLmZpbHRlckVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEuZmlsdGVyRW52ZWxvcGUudHJpZ2dlckF0dGFjayh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgc3RhcnQgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0ge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIHJlbGVhc2Ugc2hvdWxkIHN0YXJ0XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5fdHJpZ2dlckVudmVsb3BlUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy52b2ljZTAudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkR1b1N5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkR1b1N5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3ZvaWNlMCcsXG5cdCAgICAgICAgICAgICd2b2ljZTEnLFxuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ3ZpYnJhdG9BbW91bnQnLFxuXHQgICAgICAgICAgICAndmlicmF0b1JhdGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy52b2ljZTAuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudm9pY2UwID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvaWNlMS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy52b2ljZTEgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fdmlicmF0b0dhaW4uZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZpYnJhdG9HYWluID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl92aWJyYXRvID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmhhcm1vbmljaXR5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZpYnJhdG9BbW91bnQuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMudmlicmF0b0Ftb3VudCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy52aWJyYXRvUmF0ZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuRHVvU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgRk1TeW50aCBpcyBjb21wb3NlZCBvZiB0d28gVG9uZS5TeW50aHMgd2hlcmUgb25lIFRvbmUuU3ludGggbW9kdWxhdGVzXG5cdFx0ICogICAgICAgICAgdGhlIGZyZXF1ZW5jeSBvZiBhIHNlY29uZCBUb25lLlN5bnRoLiBBIGxvdCBvZiBzcGVjdHJhbCBjb250ZW50IFxuXHRcdCAqICAgICAgICAgIGNhbiBiZSBleHBsb3JlZCB1c2luZyB0aGUgbW9kdWxhdGlvbkluZGV4IHBhcmFtZXRlci4gUmVhZCBtb3JlIGFib3V0XG5cdFx0ICogICAgICAgICAgZnJlcXVlbmN5IG1vZHVsYXRpb24gc3ludGhlc2lzIG9uIFNvdW5kIE9uIFNvdW5kOiBbUGFydCAxXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA0MDMxMjM3MDQvaHR0cDovL3d3dy5zb3VuZG9uc291bmQuY29tL3Nvcy9hcHIwMC9hcnRpY2xlcy9zeW50aHNlY3JldHMuaHRtKSwgW1BhcnQgMl0oaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTYwNDAzMTE1ODM1L2h0dHA6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvbWF5MDAvYXJ0aWNsZXMvc3ludGguaHRtKS5cblx0XHQgKiAgICAgICAgICA8aW1nIHNyYz1cImh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RyYXdpbmdzL2QvMWgwUFVEWlhQZ2k0SWt4NmJWVDZvbmNyWVBMbHVGS3k3bGo1M3B1eGotRE0vcHViP3c9OTAyJmg9NDYyXCI+XG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLk1vbm9waG9uaWN9XG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgc3ludGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogdmFyIGZtU3ludGggPSBuZXcgVG9uZS5GTVN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBmbVN5bnRoLnRyaWdnZXJBdHRhY2tSZWxlYXNlKFwiQzVcIiwgXCI0blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLkZNU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuTW9ub3Bob25pYy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyIHZvaWNlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLlN5bnRofVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbmV3IFRvbmUuU3ludGgob3B0aW9ucy5jYXJyaWVyKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLnZvbHVtZS52YWx1ZSA9IC0xMDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FycmllcidzIG9zY2lsbGF0b3Jcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yID0gdGhpcy5fY2Fycmllci5vc2NpbGxhdG9yO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBjYXJyaWVyJ3MgZW52ZWxvcGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5Pc2NpbGxhdG9yfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IHRoaXMuX2NhcnJpZXIuZW52ZWxvcGUuc2V0KG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3Igdm9pY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU3ludGh9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG5ldyBUb25lLlN5bnRoKG9wdGlvbnMubW9kdWxhdG9yKTtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3Iudm9sdW1lLnZhbHVlID0gLTEwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3IncyBvc2NpbGxhdG9yIHdoaWNoIGlzIGFwcGxpZWRcblx0XHRcdCAqICB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZSBvc2NpbGxhdG9yXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbiA9IHRoaXMuX21vZHVsYXRvci5vc2NpbGxhdG9yLnNldChvcHRpb25zLm1vZHVsYXRpb24pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBtb2R1bGF0b3IncyBlbnZlbG9wZVxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk9zY2lsbGF0b3J9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25FbnZlbG9wZSA9IHRoaXMuX21vZHVsYXRvci5lbnZlbG9wZS5zZXQob3B0aW9ucy5tb2R1bGF0aW9uRW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgY29udHJvbC5cblx0XHRcdCAqICBAdHlwZSB7RnJlcXVlbmN5fVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbmV3IFRvbmUuU2lnbmFsKDQ0MCwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBIYXJtb25pY2l0eSBpcyB0aGUgcmF0aW8gYmV0d2VlbiB0aGUgdHdvIHZvaWNlcy4gQSBoYXJtb25pY2l0eSBvZlxuXHRcdFx0ICogIDEgaXMgbm8gY2hhbmdlLiBIYXJtb25pY2l0eSA9IDIgbWVhbnMgYSBjaGFuZ2Ugb2YgYW4gb2N0YXZlLlxuXHRcdFx0ICogIEB0eXBlIHtQb3NpdGl2ZX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIC8vcGl0Y2ggdm9pY2UxIGFuIG9jdGF2ZSBiZWxvdyB2b2ljZTBcblx0XHRcdCAqIHN5bnRoLmhhcm1vbmljaXR5LnZhbHVlID0gMC41O1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG5ldyBUb25lLk11bHRpcGx5KG9wdGlvbnMuaGFybW9uaWNpdHkpO1xuXHQgICAgICAgIHRoaXMuaGFybW9uaWNpdHkudW5pdHMgPSBUb25lLlR5cGUuUG9zaXRpdmU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIG1vZHVsYXRpb24gaW5kZXggd2hpY2ggZXNzZW50aWFsbHkgdGhlIGRlcHRoIG9yIGFtb3VudCBvZiB0aGUgbW9kdWxhdGlvbi4gSXQgaXMgdGhlXG5cdFx0XHQgKiAgcmF0aW8gb2YgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgbW9kdWxhdGluZyBzaWduYWwgKG1mKSB0byB0aGUgYW1wbGl0dWRlIG9mIHRoZVxuXHRcdFx0ICogIG1vZHVsYXRpbmcgc2lnbmFsIChtYSkgLS0gYXMgaW4gbWEvbWYuXG5cdFx0XHQgKlx0QHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICpcdEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4ID0gbmV3IFRvbmUuTXVsdGlwbHkob3B0aW9ucy5tb2R1bGF0aW9uSW5kZXgpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LnVuaXRzID0gVG9uZS5UeXBlLlBvc2l0aXZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHRoZSBub2RlIHdoZXJlIHRoZSBtb2R1bGF0aW9uIGhhcHBlbnNcblx0XHRcdCAqICBAdHlwZSB7R2Fpbk5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbmV3IFRvbmUuR2FpbigwKTtcblx0ICAgICAgICAvL2NvbnRyb2wgdGhlIHR3byB2b2ljZXMgZnJlcXVlbmN5XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY29ubmVjdCh0aGlzLl9jYXJyaWVyLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5oYXJtb25pY2l0eSwgdGhpcy5fbW9kdWxhdG9yLmZyZXF1ZW5jeSk7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuY2hhaW4odGhpcy5tb2R1bGF0aW9uSW5kZXgsIHRoaXMuX21vZHVsYXRpb25Ob2RlKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5mYW4odGhpcy5fY2Fycmllci5kZXR1bmUsIHRoaXMuX21vZHVsYXRvci5kZXR1bmUpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvci5jb25uZWN0KHRoaXMuX21vZHVsYXRpb25Ob2RlLmdhaW4pO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlLmNvbm5lY3QodGhpcy5fY2Fycmllci5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuX2NhcnJpZXIuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLkZNU3ludGgsIFRvbmUuTW9ub3Bob25pYyk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5GTVN5bnRoLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdoYXJtb25pY2l0eSc6IDMsXG5cdCAgICAgICAgJ21vZHVsYXRpb25JbmRleCc6IDEwLFxuXHQgICAgICAgICdkZXR1bmUnOiAwLFxuXHQgICAgICAgICdvc2NpbGxhdG9yJzogeyAndHlwZSc6ICdzaW5lJyB9LFxuXHQgICAgICAgICdlbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuMDEsXG5cdCAgICAgICAgICAgICdkZWNheSc6IDAuMDEsXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMSxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiAwLjVcblx0ICAgICAgICB9LFxuXHQgICAgICAgICdtb2R1bGF0aW9uJzogeyAndHlwZSc6ICdzcXVhcmUnIH0sXG5cdCAgICAgICAgJ21vZHVsYXRpb25FbnZlbG9wZSc6IHtcblx0ICAgICAgICAgICAgJ2F0dGFjayc6IDAuNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMCxcblx0ICAgICAgICAgICAgJ3N1c3RhaW4nOiAxLFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuNVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBcdHRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgbm90ZSB3aWxsIG9jY3VyXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5IG9mIHRoZSBub3RlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZNU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZUF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIHRyaWdnZXIgdGhlIHJlbGVhc2UgcG9ydGlvbiBvZiB0aGUgbm90ZVxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gdGhlIHRpbWUgdGhlIG5vdGUgd2lsbCByZWxlYXNlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLkZNU3ludGh9IHRoaXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuRk1TeW50aC5wcm90b3R5cGUuX3RyaWdnZXJFbnZlbG9wZVJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBjbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5GTVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkZNU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5Nb25vcGhvbmljLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoW1xuXHQgICAgICAgICAgICAnZnJlcXVlbmN5Jyxcblx0ICAgICAgICAgICAgJ2hhcm1vbmljaXR5Jyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb25JbmRleCcsXG5cdCAgICAgICAgICAgICdvc2NpbGxhdG9yJyxcblx0ICAgICAgICAgICAgJ2VudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ21vZHVsYXRpb24nLFxuXHQgICAgICAgICAgICAnbW9kdWxhdGlvbkVudmVsb3BlJyxcblx0ICAgICAgICAgICAgJ2RldHVuZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9jYXJyaWVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tb2R1bGF0b3IuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRvciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5mcmVxdWVuY3kuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkluZGV4LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb25JbmRleCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5oYXJtb25pY2l0eSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fbW9kdWxhdGlvbk5vZGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX21vZHVsYXRpb25Ob2RlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMubW9kdWxhdGlvbkVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm1vZHVsYXRpb24gPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLkZNU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5NZW1icmFuZVN5bnRoIG1ha2VzIGtpY2sgYW5kIHRvbSBzb3VuZHMgdXNpbmcgYSBzaW5nbGUgb3NjaWxsYXRvclxuXHRcdCAqICAgICAgICAgIHdpdGggYW4gYW1wbGl0dWRlIGVudmVsb3BlIGFuZCBmcmVxdWVuY3kgcmFtcC4gQSBUb25lLk9tbmlPc2NpbGxhdG9yXG5cdFx0ICogICAgICAgICAgaXMgcm91dGVkIHRocm91Z2ggYSBUb25lLkFtcGxpdHVkZUVudmVsb3BlIHRvIHRoZSBvdXRwdXQuIFRoZSBkcnVtXG5cdFx0ICogICAgICAgICAgcXVhbGl0eSBvZiB0aGUgc291bmQgY29tZXMgZnJvbSB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIGFwcGxpZWRcblx0XHQgKiAgICAgICAgICBkdXJpbmcgVG9uZS5NZW1icmFuZVN5bnRoLnRyaWdnZXJBdHRhY2sobm90ZSkuIFRoZSBmcmVxdWVuY3kgZW52ZWxvcGVcblx0XHQgKiAgICAgICAgICBzdGFydHMgYXQgPGNvZGU+bm90ZSAqIC5vY3RhdmVzPC9jb2RlPiBhbmQgcmFtcHMgdG8gPGNvZGU+bm90ZTwvY29kZT5cblx0XHQgKiAgICAgICAgICBvdmVyIHRoZSBkdXJhdGlvbiBvZiA8Y29kZT4ucGl0Y2hEZWNheTwvY29kZT4uIFxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlIHN5bnRoIFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICBzZWUgZGVmYXVsdHMgYmVsb3dcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgc3ludGggPSBuZXcgVG9uZS5NZW1icmFuZVN5bnRoKCkudG9NYXN0ZXIoKTtcblx0XHQgKiBzeW50aC50cmlnZ2VyQXR0YWNrUmVsZWFzZShcIkMyXCIsIFwiOG5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NZW1icmFuZVN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3NjaWxsYXRvci5cblx0XHRcdCAqICBAdHlwZSB7VG9uZS5PbW5pT3NjaWxsYXRvcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvciA9IG5ldyBUb25lLk9tbmlPc2NpbGxhdG9yKG9wdGlvbnMub3NjaWxsYXRvcikuc3RhcnQoKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkFtcGxpdHVkZUVudmVsb3BlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZSA9IG5ldyBUb25lLkFtcGxpdHVkZUVudmVsb3BlKG9wdGlvbnMuZW52ZWxvcGUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBudW1iZXIgb2Ygb2N0YXZlcyB0aGUgcGl0Y2ggZW52ZWxvcGUgcmFtcHMuXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vY3RhdmVzID0gb3B0aW9ucy5vY3RhdmVzO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbW91bnQgb2YgdGltZSB0aGUgZnJlcXVlbmN5IGVudmVsb3BlIHRha2VzLiBcblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucGl0Y2hEZWNheSA9IG9wdGlvbnMucGl0Y2hEZWNheTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IuY2hhaW4odGhpcy5lbnZlbG9wZSwgdGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3JlYWRPbmx5KFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZW1icmFuZVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTWVtYnJhbmVTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncGl0Y2hEZWNheSc6IDAuMDUsXG5cdCAgICAgICAgJ29jdGF2ZXMnOiAxMCxcblx0ICAgICAgICAnb3NjaWxsYXRvcic6IHsgJ3R5cGUnOiAnc2luZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC40LFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDAuMDEsXG5cdCAgICAgICAgICAgICdyZWxlYXNlJzogMS40LFxuXHQgICAgICAgICAgICAnYXR0YWNrQ3VydmUnOiAnZXhwb25lbnRpYWwnXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBub3RlIGF0IHRoZSBnaXZlbiB0aW1lIHdpdGggdGhlIGdpdmVuIHZlbG9jaXR5LiBcblx0XHQgKiAgXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgdGhlIG5vdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgdGhlIHRpbWUsIGlmIG5vdCBnaXZlbiBpcyBub3dcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdmVsb2NpdHkgZGVmYXVsdHMgdG8gMVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogIGtpY2sudHJpZ2dlckF0dGFjayg2MCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAobm90ZSwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgbm90ZSA9IHRoaXMudG9GcmVxdWVuY3kobm90ZSk7XG5cdCAgICAgICAgdmFyIG1heE5vdGUgPSBub3RlICogdGhpcy5vY3RhdmVzO1xuXHQgICAgICAgIHRoaXMub3NjaWxsYXRvci5mcmVxdWVuY3kuc2V0VmFsdWVBdFRpbWUobWF4Tm90ZSwgdGltZSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmZyZXF1ZW5jeS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKG5vdGUsIHRpbWUgKyB0aGlzLnRvU2Vjb25kcyh0aGlzLnBpdGNoRGVjYXkpKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgdGhlIG5vdGUuXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbdGltZT1ub3ddIHRoZSB0aW1lIHRoZSBub3RlIHdpbGwgcmVsZWFzZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZW1icmFuZVN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1lbWJyYW5lU3ludGgucHJvdG90eXBlLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuTWVtYnJhbmVTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZW1icmFuZVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ29zY2lsbGF0b3InLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5vc2NpbGxhdG9yLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm9zY2lsbGF0b3IgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1lbWJyYW5lU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBJbmhhcm1vbmljIHJhdGlvIG9mIGZyZXF1ZW5jaWVzIGJhc2VkIG9uIHRoZSBSb2xhbmQgVFItODA4XG5cdFx0ICogIFRha2VuIGZyb20gaHR0cHM6Ly9jY3JtYS5zdGFuZm9yZC5lZHUvcGFwZXJzL3RyLTgwOC1jeW1iYWwtcGh5c2ljYWxseS1pbmZvcm1lZC1jaXJjdWl0LWJlbmRhYmxlLWRpZ2l0YWwtbW9kZWxcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdCAgICB2YXIgaW5oYXJtUmF0aW9zID0gW1xuXHQgICAgICAgIDEsXG5cdCAgICAgICAgMS40ODMsXG5cdCAgICAgICAgMS45MzIsXG5cdCAgICAgICAgMi41NDYsXG5cdCAgICAgICAgMi42Myxcblx0ICAgICAgICAzLjg5N1xuXHQgICAgXTtcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIEEgaGlnaGx5IGluaGFybW9uaWMgYW5kIHNwZWN0cmFsbHkgY29tcGxleCBzb3VyY2Ugd2l0aCBhIGhpZ2hwYXNzIGZpbHRlclxuXHRcdCAqICAgICAgICAgIGFuZCBhbXBsaXR1ZGUgZW52ZWxvcGUgd2hpY2ggaXMgZ29vZCBmb3IgbWFraW5nIG1ldGFsb3Bob25lIHNvdW5kcy4gQmFzZWRcblx0XHQgKiAgICAgICAgICBvbiBDeW1iYWxTeW50aCBieSBbQHBvbHlyaHl0aG1hdGljXShodHRwczovL2dpdGh1Yi5jb20vcG9seXJoeXRobWF0aWMpLlxuXHRcdCAqICAgICAgICAgIEluc3BpcmF0aW9uIGZyb20gW1NvdW5kIG9uIFNvdW5kXShodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNjA2MTAxNDM5MjQvaHR0cHM6Ly93d3cuc291bmRvbnNvdW5kLmNvbS9zb3MvanVsMDIvYXJ0aWNsZXMvc3ludGhzZWNyZXRzMDcwMi5hc3ApLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGF2YWlsYmxlIGZvciB0aGUgc3ludGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRBcmcob3B0aW9ucywgVG9uZS5NZXRhbFN5bnRoLmRlZmF1bHRzKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZnJlcXVlbmN5IG9mIHRoZSBjeW1iYWxcblx0XHRcdCAqICBAdHlwZSAge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmZyZXF1ZW5jeSwgVG9uZS5UeXBlLkZyZXF1ZW5jeSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFycmF5IG9mIEZNT3NjaWxsYXRvcnNcblx0XHRcdCAqICBAdHlwZSAge0FycmF5fVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9vc2NpbGxhdG9ycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmcmVxdWVuY3kgbXVsdGlwbGllcnNcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVycyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBhbXBsaXR1ZGUgZm9yIHRoZSBib2R5XG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuR2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUgPSBuZXcgVG9uZS5HYWluKDApLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGhpZ2hwYXNzIHRoZSBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5GaWx0ZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2hpZ2hwYXNzID0gbmV3IFRvbmUuRmlsdGVyKHtcblx0ICAgICAgICAgICAgJ3R5cGUnOiAnaGlnaHBhc3MnLFxuXHQgICAgICAgICAgICAnUSc6IC0zLjAxMDI5OTk1NjYzOTgxMjVcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMuX2FtcGxpdHVlKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgdGhlIGhpZ2hwYXNzXG5cdFx0XHQgKiAgZmlsdGVyIGZyZXF1ZW5jeSByYW1wc1xuXHRcdFx0ICogIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgU2NhbGUgdGhlIGJvZHkgZW52ZWxvcGVcblx0XHRcdCAqICBmb3IgdGhlIGJhbmRwYXNzXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuU2NhbGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIgPSBuZXcgVG9uZS5TY2FsZShvcHRpb25zLnJlc29uYW5jZSwgNzAwMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGVudmVsb3BlIHdoaWNoIGlzIGNvbm5lY3RlZCBib3RoIHRvIHRoZVxuXHRcdFx0ICogIGFtcGxpdHVkZSBhbmQgaGlnaHBhc3MgZmlsdGVyJ3MgY3V0b2ZmIGZyZXF1ZW5jeVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5FbnZlbG9wZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUgPSBuZXcgVG9uZS5FbnZlbG9wZSh7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiBvcHRpb25zLmVudmVsb3BlLmF0dGFjayxcblx0ICAgICAgICAgICAgJ2F0dGFja0N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgICAgICdkZWNheSc6IG9wdGlvbnMuZW52ZWxvcGUuZGVjYXksXG5cdCAgICAgICAgICAgICdzdXN0YWluJzogMCxcblx0ICAgICAgICAgICAgJ3JlbGVhc2UnOiBvcHRpb25zLmVudmVsb3BlLnJlbGVhc2Vcblx0ICAgICAgICB9KS5jaGFpbih0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLCB0aGlzLl9oaWdocGFzcy5mcmVxdWVuY3kpO1xuXHQgICAgICAgIHRoaXMuZW52ZWxvcGUuY29ubmVjdCh0aGlzLl9hbXBsaXR1ZS5nYWluKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaGFybVJhdGlvcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgb3NjID0gbmV3IFRvbmUuRk1Pc2NpbGxhdG9yKHtcblx0ICAgICAgICAgICAgICAgICd0eXBlJzogJ3NxdWFyZScsXG5cdCAgICAgICAgICAgICAgICAnbW9kdWxhdGlvblR5cGUnOiAnc3F1YXJlJyxcblx0ICAgICAgICAgICAgICAgICdoYXJtb25pY2l0eSc6IG9wdGlvbnMuaGFybW9uaWNpdHksXG5cdCAgICAgICAgICAgICAgICAnbW9kdWxhdGlvbkluZGV4Jzogb3B0aW9ucy5tb2R1bGF0aW9uSW5kZXhcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIG9zYy5jb25uZWN0KHRoaXMuX2hpZ2hwYXNzKS5zdGFydCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXSA9IG9zYztcblx0ICAgICAgICAgICAgdmFyIG11bHQgPSBuZXcgVG9uZS5NdWx0aXBseShpbmhhcm1SYXRpb3NbaV0pO1xuXHQgICAgICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnNbaV0gPSBtdWx0O1xuXHQgICAgICAgICAgICB0aGlzLmZyZXF1ZW5jeS5jaGFpbihtdWx0LCBvc2MuZnJlcXVlbmN5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy9zZXQgdGhlIG9jdGF2ZXNcblx0ICAgICAgICB0aGlzLm9jdGF2ZXMgPSBvcHRpb25zLm9jdGF2ZXM7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5NZXRhbFN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIGRlZmF1bHQgdmFsdWVzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ2ZyZXF1ZW5jeSc6IDIwMCxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwMSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMS40LFxuXHQgICAgICAgICAgICAncmVsZWFzZSc6IDAuMlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgJ2hhcm1vbmljaXR5JzogNS4xLFxuXHQgICAgICAgICdtb2R1bGF0aW9uSW5kZXgnOiAzMixcblx0ICAgICAgICAncmVzb25hbmNlJzogNDAwMCxcblx0ICAgICAgICAnb2N0YXZlcyc6IDEuNVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2suXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9ICB0aW1lICAgICAgV2hlbiB0aGUgYXR0YWNrIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEBwYXJhbSAge05vcm1hbFJhbmdlfSAgW3ZlbG9jaXR5PTFdICBUaGUgdmVsb2NpdHkgdGhhdCB0aGUgZW52ZWxvcGUgc2hvdWxkIGJlIHRyaWdnZXJlZCBhdC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uICh0aW1lLCB2ZWwpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdmVsID0gVG9uZS5kZWZhdWx0QXJnKHZlbCwgMSk7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgdGltZSAgICAgIFdoZW4gdGhlIHJlbGVhc2Ugc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuTWV0YWxTeW50aH0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSBhdHRhY2sgYW5kIHJlbGVhc2Ugb2YgdGhlIGVudmVsb3BlIGFmdGVyIHRoZSBnaXZlblxuXHRcdCAqICBkdXJhdGlvbi5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIGR1cmF0aW9uICBUaGUgZHVyYXRpb24gYmVmb3JlIHRyaWdnZXJpbmcgdGhlIHJlbGVhc2Vcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWUgICAgICBXaGVuIHRoZSBhdHRhY2sgc2hvdWxkIGJlIHRyaWdnZXJlZC5cblx0XHQgKiAgQHBhcmFtICB7Tm9ybWFsUmFuZ2V9ICBbdmVsb2NpdHk9MV0gIFRoZSB2ZWxvY2l0eSB0aGF0IHRoZSBlbnZlbG9wZSBzaG91bGQgYmUgdHJpZ2dlcmVkIGF0LlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5NZXRhbFN5bnRofSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5NZXRhbFN5bnRoLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtb2R1bGF0aW9uSW5kZXggb2YgdGhlIG9zY2lsbGF0b3JzIHdoaWNoIG1ha2UgdXAgdGhlIHNvdXJjZS5cblx0XHQgKiAgc2VlIFRvbmUuRk1Pc2NpbGxhdG9yLm1vZHVsYXRpb25JbmRleFxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0ICogIEBuYW1lICBtb2R1bGF0aW9uSW5kZXhcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnbW9kdWxhdGlvbkluZGV4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3NjaWxsYXRvcnNbMF0ubW9kdWxhdGlvbkluZGV4LnZhbHVlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3NjaWxsYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzW2ldLm1vZHVsYXRpb25JbmRleC52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBoYXJtb25pY2l0eSBvZiB0aGUgb3NjaWxsYXRvcnMgd2hpY2ggbWFrZSB1cCB0aGUgc291cmNlLlxuXHRcdCAqICBzZWUgVG9uZS5GTU9zY2lsbGF0b3IuaGFybW9uaWNpdHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAbmFtZSAgaGFybW9uaWNpdHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLCAnaGFybW9uaWNpdHknLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9vc2NpbGxhdG9yc1swXS5oYXJtb25pY2l0eS52YWx1ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29zY2lsbGF0b3JzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5oYXJtb25pY2l0eS52YWx1ZSA9IHZhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGhpZ2hwYXNzIGZpbHRlciBhdHRhY2hlZCB0byB0aGUgZW52ZWxvcGVcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuTWV0YWxTeW50aCNcblx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHQgKiAgQG5hbWUgIHJlc29uYW5jZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdyZXNvbmFuY2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9maWx0ZXJGcmVxU2NhbGVyLm1pbiA9IHZhbDtcblx0ICAgICAgICAgICAgdGhpcy5vY3RhdmVzID0gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgbnVtYmVyIG9mIG9jdGF2ZXMgYWJvdmUgdGhlIFwicmVzb25hbmNlXCIgZnJlcXVlbmN5XG5cdFx0ICogIHRoYXQgdGhlIGZpbHRlciByYW1wcyBkdXJpbmcgdGhlIGF0dGFjay9kZWNheSBlbnZlbG9wZVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5NZXRhbFN5bnRoI1xuXHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqICBAbmFtZSAgb2N0YXZlc1xuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuTWV0YWxTeW50aC5wcm90b3R5cGUsICdvY3RhdmVzJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb2N0YXZlcztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG9jdHMpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb2N0YXZlcyA9IG9jdHM7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbHRlckZyZXFTY2FsZXIubWF4ID0gdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5taW4gKiBNYXRoLnBvdygyLCBvY3RzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cFxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5NZXRhbFN5bnRofSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk1ldGFsU3ludGgucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5JbnN0cnVtZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vc2NpbGxhdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLl9vc2NpbGxhdG9yc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2ZyZXFNdWx0aXBsaWVyc1tpXS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX29zY2lsbGF0b3JzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9mcmVxTXVsdGlwbGllcnMgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZnJlcXVlbmN5LmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmZyZXF1ZW5jeSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZmlsdGVyRnJlcVNjYWxlciA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fYW1wbGl0dWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2FtcGxpdHVlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9oaWdocGFzcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5faGlnaHBhc3MgPSBudWxsO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLk1ldGFsU3ludGg7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqICBCdWZmZXJTb3VyY2UgcG9seWZpbGxcblx0XHQgKi9cblx0ICAgIGlmICh3aW5kb3cuQXVkaW9CdWZmZXJTb3VyY2VOb2RlICYmICFBdWRpb0J1ZmZlclNvdXJjZU5vZGUucHJvdG90eXBlLnN0YXJ0KSB7XG5cdCAgICAgICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdGFydCA9IEF1ZGlvQnVmZmVyU291cmNlTm9kZS5wcm90b3R5cGUubm90ZUdyYWluT247XG5cdCAgICAgICAgQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5zdG9wID0gQXVkaW9CdWZmZXJTb3VyY2VOb2RlLnByb3RvdHlwZS5ub3RlT2ZmO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBXcmFwcGVyIGFyb3VuZCB0aGUgbmF0aXZlIEJ1ZmZlclNvdXJjZU5vZGUuXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtICB7QXVkaW9CdWZmZXJ8VG9uZS5CdWZmZXJ9ICBidWZmZXIgICBUaGUgYnVmZmVyIHRvIHBsYXlcblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb259ICBvbmxvYWQgIFRoZSBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgaXMgZG9uZSBwbGF5aW5nLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAnYnVmZmVyJyxcblx0ICAgICAgICAgICAgJ29ubG9hZCdcblx0ICAgICAgICBdLCBUb25lLkJ1ZmZlclNvdXJjZSk7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHRoZVxuXHRcdFx0ICogIGJ1ZmZlciBzb3VyY2UgaXMgZG9uZSBwbGF5aW5nLlxuXHRcdFx0ICogIEB0eXBlICB7RnVuY3Rpb259XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLm9uZW5kZWQgPSBvcHRpb25zLm9uZW5kZWQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIHRpbWUgdGhhdCB0aGUgYnVmZmVyIHdhcyBzdGFydGVkLlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAtMTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgdGltZSB0aGF0IHRoZSBidWZmZXIgaXMgc2NoZWR1bGVkIHRvIHN0b3AuXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N0b3BUaW1lID0gLTE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGdhaW4gbm9kZSB3aGljaCBlbnZlbG9wZXMgdGhlIEJ1ZmZlclNvdXJjZVxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5HYWlufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9nYWluTm9kZSA9IHRoaXMub3V0cHV0ID0gbmV3IFRvbmUuR2FpbigpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBidWZmZXIgc291cmNlXG5cdFx0XHQgKiAgQHR5cGUgIHtBdWRpb0J1ZmZlclNvdXJjZU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcHJpdmF0ZSBidWZmZXIgaW5zdGFuY2Vcblx0XHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIob3B0aW9ucy5idWZmZXIsIG9wdGlvbnMub25sb2FkKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2tSYXRlIG9mIHRoZSBidWZmZXJcblx0XHRcdCAqICBAdHlwZSB7UG9zaXRpdmV9XG5cdFx0XHQgKiAgQHNpZ25hbFxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSBuZXcgVG9uZS5QYXJhbSh0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLCBUb25lLlR5cGUuUG9zaXRpdmUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBmYWRlSW4gdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZU91dCB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0XHQgKiAgQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgY3VydmUgYXBwbGllZCB0byB0aGUgZmFkZXMsIGVpdGhlciBcImxpbmVhclwiIG9yIFwiZXhwb25lbnRpYWxcIlxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSB2YWx1ZSB0aGF0IHRoZSBidWZmZXIgcmFtcHMgdG9cblx0XHRcdCAqICBAdHlwZSB7R2Fpbn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ2FpbiA9IDE7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgb25lbmRlZCB0aW1lb3V0XG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX29uZW5kZWRUaW1lb3V0ID0gLTE7XG5cdCAgICAgICAgLy9zZXQgc29tZSB2YWx1ZXMgaW5pdGlhbGx5XG5cdCAgICAgICAgdGhpcy5sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIHRoaXMubG9vcFN0YXJ0ID0gb3B0aW9ucy5sb29wU3RhcnQ7XG5cdCAgICAgICAgdGhpcy5sb29wRW5kID0gb3B0aW9ucy5sb29wRW5kO1xuXHQgICAgICAgIHRoaXMucGxheWJhY2tSYXRlLnZhbHVlID0gb3B0aW9ucy5wbGF5YmFja1JhdGU7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5CdWZmZXJTb3VyY2UsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqICBUaGUgZGVmYXVsdHNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlICB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29uZW5kZWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogMCxcblx0ICAgICAgICAnZmFkZUluJzogMCxcblx0ICAgICAgICAnZmFkZU91dCc6IDAsXG5cdCAgICAgICAgJ2N1cnZlJzogJ2xpbmVhcicsXG5cdCAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IDFcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUmV0dXJucyB0aGUgcGxheWJhY2sgc3RhdGUgb2YgdGhlIHNvdXJjZSwgZWl0aGVyIFwic3RhcnRlZFwiIG9yIFwic3RvcHBlZFwiLlxuXHRcdCAqICBAdHlwZSB7VG9uZS5TdGF0ZX1cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiAgQG5hbWUgc3RhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdzdGF0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydFRpbWUgIT09IC0xICYmIG5vdyA+PSB0aGlzLl9zdGFydFRpbWUgJiYgbm93IDwgdGhpcy5fc3RvcFRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBUb25lLlN0YXRlLlN0YXJ0ZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gVG9uZS5TdGF0ZS5TdG9wcGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgU3RhcnQgdGhlIGJ1ZmZlclxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbc3RhcnRUaW1lPW5vd10gV2hlbiB0aGUgcGxheWVyIHNob3VsZCBzdGFydC5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW29mZnNldD0wXSBUaGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzdGFydCBhdC5cblx0XHQgKiAgQHBhcmFtICB7VGltZT19IGR1cmF0aW9uIEhvdyBsb25nIHRoZSBzYW1wbGUgc2hvdWxkIHBsYXkuIElmIG5vIGR1cmF0aW9uXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGZ1bGwgbGVuZ3RoXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBzYW1wbGUgKG1pbnVzIGFueSBvZmZzZXQpXG5cdFx0ICogIEBwYXJhbSAge0dhaW59ICBbZ2Fpbj0xXSAgVGhlIGdhaW4gdG8gcGxheSB0aGUgYnVmZmVyIGJhY2sgYXQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWU9fSAgZmFkZUluVGltZSAgVGhlIG9wdGlvbmFsIGZhZGVJbiByYW1wIHRpbWUuXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICh0aW1lLCBvZmZzZXQsIGR1cmF0aW9uLCBnYWluLCBmYWRlSW5UaW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXJ0VGltZSAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb25lLkJ1ZmZlclNvdXJjZSBjYW4gb25seSBiZSBzdGFydGVkIG9uY2UuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sb2FkZWQpIHtcblx0ICAgICAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgICAgICAvL2lmIGl0J3MgYSBsb29wIHRoZSBkZWZhdWx0IG9mZnNldCBpcyB0aGUgbG9vcHN0YXJ0IHBvaW50XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMubG9vcFN0YXJ0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IG9mZnNldCBpcyAwXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBUb25lLmRlZmF1bHRBcmcob2Zmc2V0LCAwKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgICAgICBnYWluID0gVG9uZS5kZWZhdWx0QXJnKGdhaW4sIDEpO1xuXHQgICAgICAgICAgICB0aGlzLl9nYWluID0gZ2Fpbjtcblx0ICAgICAgICAgICAgZmFkZUluVGltZSA9IHRoaXMudG9TZWNvbmRzKFRvbmUuZGVmYXVsdEFyZyhmYWRlSW5UaW1lLCB0aGlzLmZhZGVJbikpO1xuXHQgICAgICAgICAgICB0aGlzLmZhZGVJbiA9IGZhZGVJblRpbWU7XG5cdCAgICAgICAgICAgIGlmIChmYWRlSW5UaW1lID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnZlID09PSAnbGluZWFyJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5fZ2FpbiwgdGltZSArIGZhZGVJblRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLmV4cG9uZW50aWFsQXBwcmFvY2hWYWx1ZUF0VGltZSh0aGlzLl9nYWluLCB0aW1lLCBmYWRlSW5UaW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoZ2FpbiwgdGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcblx0ICAgICAgICAgICAgdmFyIGNvbXB1dGVkRHVyID0gdGhpcy50b1NlY29uZHMoVG9uZS5kZWZhdWx0QXJnKGR1cmF0aW9uLCB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIG9mZnNldCkpO1xuXHQgICAgICAgICAgICBjb21wdXRlZER1ciA9IE1hdGgubWF4KGNvbXB1dGVkRHVyLCAwKTtcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLmxvb3AgfHwgdGhpcy5sb29wICYmICFUb25lLmlzVW5kZWYoZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NsaXAgdGhlIGR1cmF0aW9uIHdoZW4gbm90IGxvb3Bpbmdcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREdXIgPSBNYXRoLm1pbihjb21wdXRlZER1ciwgdGhpcy5idWZmZXIuZHVyYXRpb24gLSBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUgKyBjb21wdXRlZER1ciwgdGhpcy5mYWRlT3V0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvL3N0YXJ0IHRoZSBidWZmZXIgc291cmNlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcblx0ICAgICAgICAgICAgICAgIC8vbW9kaWZ5IHRoZSBvZmZzZXQgaWYgaXQncyBncmVhdGVyIHRoYW4gdGhlIGxvb3AgdGltZVxuXHQgICAgICAgICAgICAgICAgdmFyIGxvb3BFbmQgPSB0aGlzLmxvb3BFbmQgfHwgdGhpcy5idWZmZXIuZHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9vcFN0YXJ0ID0gdGhpcy5sb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgbG9vcER1cmF0aW9uID0gbG9vcEVuZCAtIGxvb3BTdGFydDtcblx0ICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgb2Zmc2V0IGJhY2tcblx0ICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiBsb29wRW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCAtIGxvb3BTdGFydCkgJSBsb29wRHVyYXRpb24gKyBsb29wU3RhcnQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLmdldCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UubG9vcEVuZCA9IHRoaXMubG9vcEVuZCB8fCB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcblx0ICAgICAgICAgICAgVG9uZS5pc1Bhc3QodGltZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydCh0aW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5CdWZmZXJTb3VyY2U6IGJ1ZmZlciBpcyBlaXRoZXIgbm90IHNldCBvciBub3QgbG9hZGVkLicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCB0aGUgYnVmZmVyLiBPcHRpb25hbGx5IGFkZCBhIHJhbXAgdGltZSB0byBmYWRlIHRoZVxuXHRcdCAqICBidWZmZXIgb3V0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIHRpbWUgICAgICAgICBUaGUgdGltZSB0aGUgYnVmZmVyIHNob3VsZCBzdG9wLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gIGZhZGVPdXRUaW1lICBIb3cgbG9uZyB0aGUgZ2FpbiBzaG91bGQgZmFkZSBvdXQgZm9yXG5cdFx0ICogIEByZXR1cm4gIHtUb25lLkJ1ZmZlclNvdXJjZX0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHRpbWUsIGZhZGVPdXRUaW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxvYWRlZCkge1xuXHQgICAgICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgICAgIC8vaWYgdGhpcyBpcyBiZWZvcmUgdGhlIHByZXZpb3VzIHN0b3Bcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BUaW1lID09PSAtMSB8fCB0aGlzLl9zdG9wVGltZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vc3RvcCBpZiBpdCdzIHNjaGVkdWxlIGJlZm9yZSB0aGUgc3RhcnQgdGltZVxuXHQgICAgICAgICAgICAgICAgaWYgKHRpbWUgPD0gdGhpcy5fc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aW1lID0gTWF0aC5tYXgodGhpcy5fc3RhcnRUaW1lICsgdGhpcy5mYWRlSW4gKyB0aGlzLnNhbXBsZVRpbWUsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgLy9jYW5jZWwgdGhlIHByZXZpb3VzIGN1cnZlXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BUaW1lID0gdGltZTtcblx0ICAgICAgICAgICAgICAgIC8vdGhlIGZhZGVPdXQgdGltZVxuXHQgICAgICAgICAgICAgICAgZmFkZU91dFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhUb25lLmRlZmF1bHRBcmcoZmFkZU91dFRpbWUsIHRoaXMuZmFkZU91dCkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGhlbGREdXJhdGlvbiA9IHRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLmZhZGVJbiAtIHRoaXMuc2FtcGxlVGltZTtcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5sb29wKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIGZhZGUgZG9lcyBub3QgZ28gYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgICAgIGhlbGREdXJhdGlvbiA9IE1hdGgubWluKGhlbGREdXJhdGlvbiwgdGhpcy5idWZmZXIuZHVyYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZmFkZU91dFRpbWUgPSBNYXRoLm1pbihoZWxkRHVyYXRpb24sIGZhZGVPdXRUaW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGFydEZhZGUgPSB0aW1lIC0gZmFkZU91dFRpbWU7XG5cdCAgICAgICAgICAgICAgICBpZiAoZmFkZU91dFRpbWUgPiB0aGlzLnNhbXBsZVRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuX2dhaW4sIHN0YXJ0RmFkZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VydmUgPT09ICdsaW5lYXInKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dhaW5Ob2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZ2Fpbi5leHBvbmVudGlhbEFwcHJhb2NoVmFsdWVBdFRpbWUoMCwgc3RhcnRGYWRlLCBmYWRlT3V0VGltZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgVG9uZS5jb250ZXh0LmNsZWFyVGltZW91dCh0aGlzLl9vbmVuZGVkVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9vbmVuZGVkVGltZW91dCA9IFRvbmUuY29udGV4dC5zZXRUaW1lb3V0KHRoaXMuX29uZW5kZWQuYmluZCh0aGlzKSwgdGhpcy5fc3RvcFRpbWUgLSB0aGlzLm5vdygpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5CdWZmZXJTb3VyY2U6IGJ1ZmZlciBpcyBlaXRoZXIgbm90IHNldCBvciBub3QgbG9hZGVkLicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgY2FsbGJhY2sgd2hlbiB0aGUgYnVmZmVyIGlzIGVuZGVkLlxuXHRcdCAqICBJbnZva2VzIGBvbmVuZGVkYCBhbmQgZGlzcG9zZXMgdGhlIG5vZGUuXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUuX29uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5vbmVuZGVkKHRoaXMpO1xuXHQgICAgICAgIC8vYWxsb3cgYWRkaXRpb25hbCB0aW1lIGZvciB0aGUgZXhwb25lbnRpYWwgY3VydmUgdG8gZnVsbHkgZGVjYXlcblx0ICAgICAgICB2YXIgYWRkaXRpb25hbFRhaWwgPSB0aGlzLmN1cnZlID09PSAnZXhwb25lbnRpYWwnID8gdGhpcy5mYWRlT3V0ICogMiA6IDA7XG5cdCAgICAgICAgdGhpcy5fc291cmNlLnN0b3AodGhpcy5fc3RvcFRpbWUgKyBhZGRpdGlvbmFsVGFpbCk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgbG9vcCBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BTdGFydFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuQnVmZmVyU291cmNlLnByb3RvdHlwZSwgJ2xvb3BTdGFydCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wU3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBJZiBsb29wIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgZW5kIGF0IHRoaXMgcG9zaXRpb24uXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGxvb3BFbmRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wRW5kJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wRW5kKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wRW5kID0gdGhpcy50b1NlY29uZHMobG9vcEVuZCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkJ1ZmZlclNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0ICogQG5hbWUgYnVmZmVyXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLCAnYnVmZmVyJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQoYnVmZmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXIgc2hvdWxkIGxvb3Agb25jZSBpdCdzIG92ZXIuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuQnVmZmVyU291cmNlI1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkJ1ZmZlclNvdXJjZS5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlLmxvb3A7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsb29wKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gbG9vcDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC5cblx0XHQgKiAgQHJldHVybiAge1RvbmUuQnVmZmVyU291cmNlfSAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5CdWZmZXJTb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLm9uZW5kZWQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5kaXNjb25uZWN0KCk7XG5cdCAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9nYWluTm9kZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlci5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSAtMTtcblx0ICAgICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IG51bGw7XG5cdCAgICAgICAgVG9uZS5jb250ZXh0LmNsZWFyVGltZW91dCh0aGlzLl9vbmVuZGVkVGltZW91dCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuQnVmZmVyU291cmNlO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuTm9pc2UgaXMgYSBub2lzZSBnZW5lcmF0b3IuIEl0IHVzZXMgbG9vcGVkIG5vaXNlIGJ1ZmZlcnMgdG8gc2F2ZSBvbiBwZXJmb3JtYW5jZS5cblx0XHQgKiAgICAgICAgICBUb25lLk5vaXNlIHN1cHBvcnRzIHRoZSBub2lzZSB0eXBlczogXCJwaW5rXCIsIFwid2hpdGVcIiwgYW5kIFwiYnJvd25cIi4gUmVhZCBtb3JlIGFib3V0XG5cdFx0ICogICAgICAgICAgY29sb3JzIG9mIG5vaXNlIG9uIFtXaWtpcGVkaWFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbG9yc19vZl9ub2lzZSkuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX1cblx0XHQgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgdGhlIG5vaXNlIHR5cGUgKHdoaXRlfHBpbmt8YnJvd24pXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy9pbml0aWFsaXplIHRoZSBub2lzZSBhbmQgc3RhcnRcblx0XHQgKiB2YXIgbm9pc2UgPSBuZXcgVG9uZS5Ob2lzZShcInBpbmtcIikuc3RhcnQoKTtcblx0XHQgKiBcblx0XHQgKiAvL21ha2UgYW4gYXV0b2ZpbHRlciB0byBzaGFwZSB0aGUgbm9pc2Vcblx0XHQgKiB2YXIgYXV0b0ZpbHRlciA9IG5ldyBUb25lLkF1dG9GaWx0ZXIoe1xuXHRcdCAqIFx0XCJmcmVxdWVuY3lcIiA6IFwiOG1cIiwgXG5cdFx0ICogXHRcIm1pblwiIDogODAwLCBcblx0XHQgKiBcdFwibWF4XCIgOiAxNTAwMFxuXHRcdCAqIH0pLmNvbm5lY3QoVG9uZS5NYXN0ZXIpO1xuXHRcdCAqIFxuXHRcdCAqIC8vY29ubmVjdCB0aGUgbm9pc2Vcblx0XHQgKiBub2lzZS5jb25uZWN0KGF1dG9GaWx0ZXIpO1xuXHRcdCAqIC8vc3RhcnQgdGhlIGF1dG9maWx0ZXIgTEZPXG5cdFx0ICogYXV0b0ZpbHRlci5zdGFydCgpXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsndHlwZSddLCBUb25lLk5vaXNlKTtcblx0ICAgICAgICBUb25lLlNvdXJjZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyU291cmNlTm9kZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGJ1ZmZlclxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge0F1ZGlvQnVmZmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgbm9pc2UuIEFmZmVjdHNcblx0XHRcdCAqICB0aGUgXCJmcmVxdWVuY3lcIiBvZiB0aGUgbm9pc2UuXG5cdFx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuTm9pc2UsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICpcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2UuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3R5cGUnOiAnd2hpdGUnLFxuXHQgICAgICAgICdwbGF5YmFja1JhdGUnOiAxXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIG5vaXNlLiBDYW4gYmUgXCJ3aGl0ZVwiLCBcImJyb3duXCIsIG9yIFwicGlua1wiLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Ob2lzZSNcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBuYW1lIHR5cGVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIG5vaXNlLnR5cGUgPSBcIndoaXRlXCI7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob2lzZS5wcm90b3R5cGUsICd0eXBlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHR5cGUpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUgIT09IHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlIGluIF9ub2lzZUJ1ZmZlcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgcGxheWluZywgc3RvcCBhbmQgcmVzdGFydCBpdFxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHRoaXMubm93KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3Aobm93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQobm93KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbmUuTm9pc2U6IGludmFsaWQgdHlwZTogJyArIHR5cGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVGhlIHBsYXliYWNrIHJhdGUgb2YgdGhlIG5vaXNlLiBBZmZlY3RzXG5cdFx0ICogIHRoZSBcImZyZXF1ZW5jeVwiIG9mIHRoZSBub2lzZS5cblx0XHQgKiAgQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqICBAc2lnbmFsXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob2lzZS5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByYXRlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgaW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICpcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHZhciBidWZmZXIgPSBfbm9pc2VCdWZmZXJzW3RoaXMuX3R5cGVdO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZSA9IG5ldyBUb25lLkJ1ZmZlclNvdXJjZShidWZmZXIpLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLl9zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydCh0aGlzLnRvU2Vjb25kcyh0aW1lKSwgTWF0aC5yYW5kb20oKSAqIChidWZmZXIuZHVyYXRpb24gLSAwLjAwMSkpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBpbnRlcm5hbCBzdG9wIG1ldGhvZFxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZS5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLnN0b3AodGhpcy50b1NlY29uZHModGltZSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xlYW4gdXAuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UuZGlzY29ubmVjdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gVEhFIEJVRkZFUlNcblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy9Ob2lzZSBidWZmZXIgc3RhdHNcblx0ICAgIHZhciBidWZmZXJMZW5ndGggPSA0NDEwMCAqIDU7XG5cdCAgICB2YXIgY2hhbm5lbHMgPSAyO1xuXHQgICAgLyoqXG5cdFx0ICpcdFRoZSBub2lzZSBhcnJheXMuIEdlbmVyYXRlZCBvbiBpbml0aWFsaXphdGlvbi5cblx0XHQgKiAgYm9ycm93ZWQgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS96YWNoYXJ5ZGVudG9uL25vaXNlLmpzIFxuXHRcdCAqICAoYykgMjAxMyBaYWNoIERlbnRvbiAoTUlUKVxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0ICAgIHZhciBfbm9pc2VBcnJheXMgPSB7XG5cdCAgICAgICAgJ3BpbmsnOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBjaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltjaGFubmVsTnVtXSA9IGNoYW5uZWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjY7XG5cdCAgICAgICAgICAgICAgICBiMCA9IGIxID0gYjIgPSBiMyA9IGI0ID0gYjUgPSBiNiA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHdoaXRlID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGIwID0gMC45OTg4NiAqIGIwICsgd2hpdGUgKiAwLjA1NTUxNzk7XG5cdCAgICAgICAgICAgICAgICAgICAgYjEgPSAwLjk5MzMyICogYjEgKyB3aGl0ZSAqIDAuMDc1MDc1OTtcblx0ICAgICAgICAgICAgICAgICAgICBiMiA9IDAuOTY5ICogYjIgKyB3aGl0ZSAqIDAuMTUzODUyO1xuXHQgICAgICAgICAgICAgICAgICAgIGIzID0gMC44NjY1ICogYjMgKyB3aGl0ZSAqIDAuMzEwNDg1Njtcblx0ICAgICAgICAgICAgICAgICAgICBiNCA9IDAuNTUgKiBiNCArIHdoaXRlICogMC41MzI5NTIyO1xuXHQgICAgICAgICAgICAgICAgICAgIGI1ID0gLTAuNzYxNiAqIGI1IC0gd2hpdGUgKiAwLjAxNjg5ODtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gYjAgKyBiMSArIGIyICsgYjMgKyBiNCArIGI1ICsgYjYgKyB3aGl0ZSAqIDAuNTM2Mjtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldICo9IDAuMTE7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gKHJvdWdobHkpIGNvbXBlbnNhdGUgZm9yIGdhaW5cblx0ICAgICAgICAgICAgICAgICAgICBiNiA9IHdoaXRlICogMC4xMTU5MjY7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcblx0ICAgICAgICB9KCksXG5cdCAgICAgICAgJ2Jyb3duJzogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGNoYW5uZWxOdW0gPSAwOyBjaGFubmVsTnVtIDwgY2hhbm5lbHM7IGNoYW5uZWxOdW0rKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICBidWZmZXJbY2hhbm5lbE51bV0gPSBjaGFubmVsO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhc3RPdXQgPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3aGl0ZSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldID0gKGxhc3RPdXQgKyAwLjAyICogd2hpdGUpIC8gMS4wMjtcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0T3V0ID0gY2hhbm5lbFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFubmVsW2ldICo9IDMuNTsgICAgLy8gKHJvdWdobHkpIGNvbXBlbnNhdGUgZm9yIGdhaW5cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgICAgIH0oKSxcblx0ICAgICAgICAnd2hpdGUnOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgY2hhbm5lbE51bSA9IDA7IGNoYW5uZWxOdW0gPCBjaGFubmVsczsgY2hhbm5lbE51bSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyTGVuZ3RoKTtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlcltjaGFubmVsTnVtXSA9IGNoYW5uZWw7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuXHQgICAgICAgIH0oKVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqXHRzdGF0aWMgbm9pc2UgYnVmZmVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICogIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHQgKi9cblx0ICAgIHZhciBfbm9pc2VCdWZmZXJzID0ge307XG5cdCAgICAvL2NyZWF0ZSB0aGUgVG9uZS5CdWZmZXJzXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXJzKCkge1xuXHQgICAgICAgIGZvciAodmFyIHR5cGUgaW4gX25vaXNlQXJyYXlzKSB7XG5cdCAgICAgICAgICAgIF9ub2lzZUJ1ZmZlcnNbdHlwZV0gPSBuZXcgVG9uZS5CdWZmZXIoKS5mcm9tQXJyYXkoX25vaXNlQXJyYXlzW3R5cGVdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvL2NyZWF0ZSB0aGUgbm9pc2UgYnVmZmVyc1xuXHQgICAgVG9uZS5nZXRDb250ZXh0KGNyZWF0ZUJ1ZmZlcnMpO1xuXHQgICAgVG9uZS5Db250ZXh0Lm9uKCdpbml0JywgY3JlYXRlQnVmZmVycyk7XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZTtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLk5vaXNlU3ludGggaXMgY29tcG9zZWQgb2YgYSBub2lzZSBnZW5lcmF0b3IgKFRvbmUuTm9pc2UpLCBvbmUgZmlsdGVyIChUb25lLkZpbHRlciksIFxuXHRcdCAqICAgICAgICAgIGFuZCB0d28gZW52ZWxvcGVzIChUb25lLkVudmVsb3ApLiBPbmUgZW52ZWxvcGUgY29udHJvbHMgdGhlIGFtcGxpdHVkZVxuXHRcdCAqICAgICAgICAgIG9mIHRoZSBub2lzZSBhbmQgdGhlIG90aGVyIGlzIGNvbnRyb2xzIHRoZSBjdXRvZmYgZnJlcXVlbmN5IG9mIHRoZSBmaWx0ZXIuIFxuXHRcdCAqICAgICAgICAgIDxpbWcgc3JjPVwiaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZHJhd2luZ3MvZC8xcnF6dVg5ckJsaFQ1ME1SdkQyVEttbDliblpoY1ptelhGMXJmX283dmRuRS9wdWI/dz05MTgmaD0yNDJcIj5cblx0XHQgKlxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQGV4dGVuZHMge1RvbmUuSW5zdHJ1bWVudH1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZSBzeW50aCBcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlIGRlZmF1bHRzIGJlbG93XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9pc2VTeW50aCA9IG5ldyBUb25lLk5vaXNlU3ludGgoKS50b01hc3RlcigpO1xuXHRcdCAqIG5vaXNlU3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoXCI4blwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgLy9nZXQgdGhlIGRlZmF1bHRzXG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBub2lzZSBzb3VyY2UuXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuTm9pc2V9XG5cdFx0XHQgKiAgQGV4YW1wbGVcblx0XHRcdCAqIG5vaXNlU3ludGguc2V0KFwibm9pc2UudHlwZVwiLCBcImJyb3duXCIpO1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtcGxpdHVkZSBlbnZlbG9wZS4gXG5cdFx0XHQgKiAgQHR5cGUge1RvbmUuQW1wbGl0dWRlRW52ZWxvcGV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbmV3IFRvbmUuQW1wbGl0dWRlRW52ZWxvcGUob3B0aW9ucy5lbnZlbG9wZSk7XG5cdCAgICAgICAgLy9jb25uZWN0IHRoZSBub2lzZSB0byB0aGUgb3V0cHV0XG5cdCAgICAgICAgdGhpcy5ub2lzZS5jaGFpbih0aGlzLmVudmVsb3BlLCB0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgLy9zdGFydCB0aGUgbm9pc2Vcblx0ICAgICAgICB0aGlzLm5vaXNlLnN0YXJ0KCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAnbm9pc2UnLFxuXHQgICAgICAgICAgICAnZW52ZWxvcGUnXG5cdCAgICAgICAgXSk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob2lzZVN5bnRoLCBUb25lLkluc3RydW1lbnQpO1xuXHQgICAgLyoqXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGguZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ25vaXNlJzogeyAndHlwZSc6ICd3aGl0ZScgfSxcblx0ICAgICAgICAnZW52ZWxvcGUnOiB7XG5cdCAgICAgICAgICAgICdhdHRhY2snOiAwLjAwNSxcblx0ICAgICAgICAgICAgJ2RlY2F5JzogMC4xLFxuXHQgICAgICAgICAgICAnc3VzdGFpbic6IDBcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFN0YXJ0IHRoZSBhdHRhY2sgcG9ydGlvbiBvZiB0aGUgZW52ZWxvcGVzLiBVbmxpa2Ugb3RoZXIgXG5cdFx0ICogIGluc3RydW1lbnRzLCBUb25lLk5vaXNlU3ludGggZG9lc24ndCBoYXZlIGEgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgYXR0YWNrIHNob3VsZCBzdGFydFxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZSAoMC0xKVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Ob2lzZVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogbm9pc2VTeW50aC50cmlnZ2VyQXR0YWNrKCk7XG5cdFx0ICovXG5cdCAgICBUb25lLk5vaXNlU3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2sgPSBmdW5jdGlvbiAodGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICAvL3RoZSBlbnZlbG9wZXNcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLnRyaWdnZXJBdHRhY2sodGltZSwgdmVsb2NpdHkpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCB0aGUgcmVsZWFzZSBwb3J0aW9uIG9mIHRoZSBlbnZlbG9wZXMuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSB0aGUgdGltZSB0aGUgcmVsZWFzZSBzaG91bGQgc3RhcnRcblx0XHQgKiAgQHJldHVybnMge1RvbmUuTm9pc2VTeW50aH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob2lzZVN5bnRoLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5lbnZlbG9wZS50cmlnZ2VyUmVsZWFzZSh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgYXR0YWNrIGFuZCB0aGVuIHRoZSByZWxlYXNlLiBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gZHVyYXRpb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gICAgIHRoZSB0aW1lIG9mIHRoZSBhdHRhY2tcblx0XHQgKiAgQHBhcmFtICB7bnVtYmVyfSBbdmVsb2NpdHk9MV0gdGhlIHZlbG9jaXR5XG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFja1JlbGVhc2UgPSBmdW5jdGlvbiAoZHVyYXRpb24sIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1NlY29uZHMoZHVyYXRpb24pO1xuXHQgICAgICAgIHRoaXMudHJpZ2dlckF0dGFjayh0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyUmVsZWFzZSh0aW1lICsgZHVyYXRpb24pO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vaXNlU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9pc2VTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl93cml0YWJsZShbXG5cdCAgICAgICAgICAgICdub2lzZScsXG5cdCAgICAgICAgICAgICdlbnZlbG9wZSdcblx0ICAgICAgICBdKTtcblx0ICAgICAgICB0aGlzLm5vaXNlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLm5vaXNlID0gbnVsbDtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Ob2lzZVN5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgS2FycGx1cy1TdHJpbmcgc3RyaW5nIHN5bnRoZXNpcy4gT2Z0ZW4gb3V0IG9mIHR1bmUuIFxuXHRcdCAqICAgICAgICAgV2lsbCBjaGFuZ2Ugd2hlbiB0aGUgQXVkaW9Xb3JrZXJOb2RlIGlzIGF2YWlsYWJsZSBhY3Jvc3Ncblx0XHQgKiAgICAgICAgIGJyb3dzZXJzLiBcblx0XHQgKiAgXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5JbnN0cnVtZW50fVxuXHRcdCAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgZGVmYXVsdHNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGx1Y2t5ID0gbmV3IFRvbmUuUGx1Y2tTeW50aCgpLnRvTWFzdGVyKCk7XG5cdFx0ICogcGx1Y2t5LnRyaWdnZXJBdHRhY2soXCJDNFwiKTtcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IFRvbmUuZGVmYXVsdEFyZyhvcHRpb25zLCBUb25lLlBsdWNrU3ludGguZGVmYXVsdHMpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLk5vaXNlfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9ub2lzZSA9IG5ldyBUb25lLk5vaXNlKCdwaW5rJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGFtb3VudCBvZiBub2lzZSBhdCB0aGUgYXR0YWNrLiBcblx0XHRcdCAqICBOb21pbmFsIHJhbmdlIG9mIFswLjEsIDIwXVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFja05vaXNlID0gb3B0aW9ucy5hdHRhY2tOb2lzZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgTEZDRlxuXHRcdFx0ICogIEB0eXBlIHtUb25lLkxvd3Bhc3NDb21iRmlsdGVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sZmNmID0gbmV3IFRvbmUuTG93cGFzc0NvbWJGaWx0ZXIoe1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJzogb3B0aW9ucy5yZXNvbmFuY2UsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnOiBvcHRpb25zLmRhbXBlbmluZ1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSByZXNvbmFuY2UgY29udHJvbC4gXG5cdFx0XHQgKiAgQHR5cGUge05vcm1hbFJhbmdlfVxuXHRcdFx0ICogIEBzaWduYWxcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gdGhpcy5fbGZjZi5yZXNvbmFuY2U7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRhbXBlbmluZyBjb250cm9sLiBpLmUuIHRoZSBsb3dwYXNzIGZpbHRlciBmcmVxdWVuY3kgb2YgdGhlIGNvbWIgZmlsdGVyXG5cdFx0XHQgKiAgQHR5cGUge0ZyZXF1ZW5jeX1cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRhbXBlbmluZyA9IHRoaXMuX2xmY2YuZGFtcGVuaW5nO1xuXHQgICAgICAgIC8vY29ubmVjdGlvbnNcblx0ICAgICAgICB0aGlzLl9ub2lzZS5jb25uZWN0KHRoaXMuX2xmY2YpO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoW1xuXHQgICAgICAgICAgICAncmVzb25hbmNlJyxcblx0ICAgICAgICAgICAgJ2RhbXBlbmluZydcblx0ICAgICAgICBdKTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsdWNrU3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAY29uc3Rcblx0XHQgKiAgQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAnYXR0YWNrTm9pc2UnOiAxLFxuXHQgICAgICAgICdkYW1wZW5pbmcnOiA0MDAwLFxuXHQgICAgICAgICdyZXNvbmFuY2UnOiAwLjlcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgVHJpZ2dlciB0aGUgbm90ZS4gXG5cdFx0ICogIEBwYXJhbSB7RnJlcXVlbmN5fSBub3RlIFRoZSBub3RlIHRvIHRyaWdnZXIuXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gW3RpbWU9bm93XSBXaGVuIHRoZSBub3RlIHNob3VsZCBiZSB0cmlnZ2VyZWQuXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgbm90ZSA9IHRoaXMudG9GcmVxdWVuY3kobm90ZSk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHZhciBkZWxheUFtb3VudCA9IDEgLyBub3RlO1xuXHQgICAgICAgIHRoaXMuX2xmY2YuZGVsYXlUaW1lLnNldFZhbHVlQXRUaW1lKGRlbGF5QW1vdW50LCB0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdGFydCh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5zdG9wKHRpbWUgKyBkZWxheUFtb3VudCAqIHRoaXMuYXR0YWNrTm9pc2UpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDbGVhbiB1cC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsdWNrU3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGx1Y2tTeW50aC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9ub2lzZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbGZjZi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9pc2UgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2xmY2YgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKFtcblx0ICAgICAgICAgICAgJ3Jlc29uYW5jZScsXG5cdCAgICAgICAgICAgICdkYW1wZW5pbmcnXG5cdCAgICAgICAgXSk7XG5cdCAgICAgICAgdGhpcy5kYW1wZW5pbmcgPSBudWxsO1xuXHQgICAgICAgIHRoaXMucmVzb25hbmNlID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5QbHVja1N5bnRoO1xuXHR9KTtcblx0TW9kdWxlKGZ1bmN0aW9uIChUb25lKSB7XG5cdCAgICBcblx0ICAgIC8qKlxuXHRcdCAqICBAY2xhc3MgIFRvbmUuUG9seVN5bnRoIGhhbmRsZXMgdm9pY2UgY3JlYXRpb24gYW5kIGFsbG9jYXRpb24gZm9yIGFueVxuXHRcdCAqICAgICAgICAgIGluc3RydW1lbnRzIHBhc3NlZCBpbiBhcyB0aGUgc2Vjb25kIHBhcmFtdGVyLiBQb2x5U3ludGggaXMgXG5cdFx0ICogICAgICAgICAgbm90IGEgc3ludGhlc2l6ZXIgYnkgaXRzZWxmLCBpdCBtZXJlbHkgbWFuYWdlcyB2b2ljZXMgb2YgXG5cdFx0ICogICAgICAgICAgb25lIG9mIHRoZSBvdGhlciB0eXBlcyBvZiBzeW50aHMsIGFsbG93aW5nIGFueSBvZiB0aGUgXG5cdFx0ICogICAgICAgICAgbW9ub3Bob25pYyBzeW50aGVzaXplcnMgdG8gYmUgcG9seXBob25pYy4gXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyfE9iamVjdH0gW3BvbHlwaG9ueT00XSBUaGUgbnVtYmVyIG9mIHZvaWNlcyB0byBjcmVhdGVcblx0XHQgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW3ZvaWNlPVRvbmUuU3ludGhdIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdm9pY2VzXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXMgVG9uZS5TeW50aCBieSBkZWZhdWx0LiBcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2EgcG9seXN5bnRoIGNvbXBvc2VkIG9mIDYgVm9pY2VzIG9mIFN5bnRoXG5cdFx0ICogdmFyIHN5bnRoID0gbmV3IFRvbmUuUG9seVN5bnRoKDYsIFRvbmUuU3ludGgpLnRvTWFzdGVyKCk7XG5cdFx0ICogLy9zZXQgdGhlIGF0dHJpYnV0ZXMgdXNpbmcgdGhlIHNldCBpbnRlcmZhY2Vcblx0XHQgKiBzeW50aC5zZXQoXCJkZXR1bmVcIiwgLTEyMDApO1xuXHRcdCAqIC8vcGxheSBhIGNob3JkXG5cdFx0ICogc3ludGgudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiQzRcIiwgXCJFNFwiLCBcIkE0XCJdLCBcIjRuXCIpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGggPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAncG9seXBob255Jyxcblx0ICAgICAgICAgICAgJ3ZvaWNlJ1xuXHQgICAgICAgIF0sIFRvbmUuUG9seVN5bnRoKTtcblx0ICAgICAgICBUb25lLkluc3RydW1lbnQuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICBvcHRpb25zID0gVG9uZS5kZWZhdWx0QXJnKG9wdGlvbnMsIFRvbmUuSW5zdHJ1bWVudC5kZWZhdWx0cyk7XG5cdCAgICAgICAgLy9tYXggcG9seXBob255XG5cdCAgICAgICAgb3B0aW9ucy5wb2x5cGhvbnkgPSBNYXRoLm1pbihUb25lLlBvbHlTeW50aC5NQVhfUE9MWVBIT05ZLCBvcHRpb25zLnBvbHlwaG9ueSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIGFycmF5IG9mIHZvaWNlc1xuXHRcdFx0ICogIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9pY2VzID0gbmV3IEFycmF5KG9wdGlvbnMucG9seXBob255KTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgcXVldWUgb2Ygdm9pY2VzIHdpdGggZGF0YSBhYm91dCBsYXN0IHRyaWdnZXJcblx0XHRcdCAqICBhbmQgdGhlIHRyaWdnZXJlZCBub3RlXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl90cmlnZ2VycyA9IG5ldyBBcnJheShvcHRpb25zLnBvbHlwaG9ueSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGRldHVuZSBpbiBjZW50c1xuXHRcdFx0ICogIEB0eXBlIHtDZW50c31cblx0XHRcdCAqICBAc2lnbmFsXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmRldHVuZSA9IG5ldyBUb25lLlNpZ25hbChvcHRpb25zLmRldHVuZSwgVG9uZS5UeXBlLkNlbnRzKTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgnZGV0dW5lJyk7XG5cdCAgICAgICAgLy9jcmVhdGUgdGhlIHZvaWNlc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5wb2x5cGhvbnk7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdiA9IG5ldyBvcHRpb25zLnZvaWNlKGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0gPSB2O1xuXHQgICAgICAgICAgICB2LmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICBpZiAodi5oYXNPd25Qcm9wZXJ0eSgnZGV0dW5lJykpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGV0dW5lLmNvbm5lY3Qodi5kZXR1bmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJzW2ldID0ge1xuXHQgICAgICAgICAgICAgICAgcmVsZWFzZTogLTEsXG5cdCAgICAgICAgICAgICAgICBub3RlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgdm9pY2U6IHZcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Qb2x5U3ludGgsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHRzXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAncG9seXBob255JzogNCxcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAndm9pY2UnOiBUb25lLlN5bnRoXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBwb3J0aW9uIG9mIHRoZSBub3RlXG5cdFx0ICogIEBwYXJhbSAge0ZyZXF1ZW5jeXxBcnJheX0gbm90ZXMgVGhlIG5vdGVzIHRvIHBsYXkuIEFjY2VwdHMgYSBzaW5nbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGcmVxdWVuY3kgb3IgYW4gYXJyYXkgb2YgZnJlcXVlbmNpZXMuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFt0aW1lPW5vd10gIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBub3RlLlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5PTFdIFRoZSB2ZWxvY2l0eSBvZiB0aGUgbm90ZS5cblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogLy90cmlnZ2VyIGEgY2hvcmQgaW1tZWRpYXRlbHkgd2l0aCBhIHZlbG9jaXR5IG9mIDAuMlxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFjayhbXCJBYjNcIiwgXCJDNFwiLCBcIkY1XCJdLCB1bmRlZmluZWQsIDAuMik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlckF0dGFjayA9IGZ1bmN0aW9uIChub3RlcywgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHZhbCA9IG5vdGVzW2ldO1xuXHQgICAgICAgICAgICAvL3RyaWdnZXIgdGhlIG9sZGVzdCB2b2ljZVxuXHQgICAgICAgICAgICB2YXIgb2xkZXN0ID0gdGhpcy5fdHJpZ2dlcnNbMF07XG5cdCAgICAgICAgICAgIHZhciBvbGRlc3RJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdGhpcy5fdHJpZ2dlcnMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2Vyc1tqXS5yZWxlYXNlIDwgb2xkZXN0LnJlbGVhc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3QgPSB0aGlzLl90cmlnZ2Vyc1tqXTtcblx0ICAgICAgICAgICAgICAgICAgICBvbGRlc3RJbmRleCA9IGo7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2xkZXN0LnJlbGVhc2UgPSBJbmZpbml0eTtcblx0ICAgICAgICAgICAgb2xkZXN0Lm5vdGUgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHQgICAgICAgICAgICBvbGRlc3Qudm9pY2UudHJpZ2dlckF0dGFjayh2YWwsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIGF0dGFjayBhbmQgcmVsZWFzZSBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXG5cdFx0ICogIFxuXHRcdCAqICBAcGFyYW0gIHtGcmVxdWVuY3l8QXJyYXl9IG5vdGVzIFRoZSBub3RlcyB0byBwbGF5LiBBY2NlcHRzIGEgc2luZ2xlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRnJlcXVlbmN5IG9yIGFuIGFycmF5IG9mIGZyZXF1ZW5jaWVzLlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBkdXJhdGlvbiB0aGUgZHVyYXRpb24gb2YgdGhlIG5vdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgICAgaWYgbm8gdGltZSBpcyBnaXZlbiwgZGVmYXVsdHMgdG8gbm93XG5cdFx0ICogIEBwYXJhbSAge251bWJlcn0gW3ZlbG9jaXR5PTFdIHRoZSB2ZWxvY2l0eSBvZiB0aGUgYXR0YWNrICgwLTEpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vdHJpZ2dlciBhIGNob3JkIGZvciBhIGR1cmF0aW9uIG9mIGEgaGFsZiBub3RlIFxuXHRcdCAqIHBvbHkudHJpZ2dlckF0dGFja1JlbGVhc2UoW1wiRWIzXCIsIFwiRzRcIiwgXCJDNVwiXSwgXCIyblwiKTtcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2NhbiBwYXNzIGluIGFuIGFycmF5IG9mIGR1cmF0aW9ucyBhcyB3ZWxsXG5cdFx0ICogcG9seS50cmlnZ2VyQXR0YWNrUmVsZWFzZShbXCJFYjNcIiwgXCJHNFwiLCBcIkM1XCJdLCBbXCIyblwiLCBcIjRuXCIsIFwiNG5cIl0pO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Qb2x5U3ludGgucHJvdG90eXBlLnRyaWdnZXJBdHRhY2tSZWxlYXNlID0gZnVuY3Rpb24gKG5vdGVzLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGVzLCB0aW1lLCB2ZWxvY2l0eSk7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNBcnJheShkdXJhdGlvbikgJiYgVG9uZS5pc0FycmF5KG5vdGVzKSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZCA9IGR1cmF0aW9uW01hdGgubWluKGksIGR1cmF0aW9uLmxlbmd0aCAtIDEpXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclJlbGVhc2Uobm90ZXNbaV0sIHRpbWUgKyB0aGlzLnRvU2Vjb25kcyhkKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGVzLCB0aW1lICsgdGhpcy50b1NlY29uZHMoZHVyYXRpb24pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRyaWdnZXIgdGhlIHJlbGVhc2Ugb2YgdGhlIG5vdGUuIFVubGlrZSBtb25vcGhvbmljIGluc3RydW1lbnRzLCBcblx0XHQgKiAgYSBub3RlIChvciBhcnJheSBvZiBub3RlcykgbmVlZHMgdG8gYmUgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cblx0XHQgKiAgQHBhcmFtICB7RnJlcXVlbmN5fEFycmF5fSBub3RlcyBUaGUgbm90ZXMgdG8gcGxheS4gQWNjZXB0cyBhIHNpbmdsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZyZXF1ZW5jeSBvciBhbiBhcnJheSBvZiBmcmVxdWVuY2llcy5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XSAgV2hlbiB0aGUgcmVsZWFzZSB3aWxsIGJlIHRyaWdnZXJlZC4gXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBvbHlTeW50aH0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHBvbHkudHJpZ2dlclJlbGVhc2UoW1wiQWIzXCIsIFwiQzRcIiwgXCJGNVwiXSwgXCIrMm5cIik7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUudHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAobm90ZXMsIHRpbWUpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm90ZXMpKSB7XG5cdCAgICAgICAgICAgIG5vdGVzID0gW25vdGVzXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm90ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgLy9nZXQgdGhlIHZvaWNlXG5cdCAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KG5vdGVzW2ldKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IHYrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB0aGlzLl90cmlnZ2Vyc1t2XTtcblx0ICAgICAgICAgICAgICAgIGlmIChkZXNjLm5vdGUgPT09IHN0cmluZ2lmaWVkICYmIGRlc2MucmVsZWFzZSA+IHRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXNjLnZvaWNlLnRyaWdnZXJSZWxlYXNlKHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc2MucmVsZWFzZSA9IHRpbWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCBhIG1lbWJlci9hdHRyaWJ1dGUgb2YgdGhlIHZvaWNlcy4gXG5cdFx0ICogIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcGFyYW1zXG5cdFx0ICogIEBwYXJhbSB7bnVtYmVyPX0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUaW1lPX0gcmFtcFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUG9seVN5bnRofSB0aGlzXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogcG9seS5zZXQoe1xuXHRcdCAqIFx0XCJmaWx0ZXJcIiA6IHtcblx0XHQgKiBcdFx0XCJ0eXBlXCIgOiBcImhpZ2hwYXNzXCJcblx0XHQgKiBcdH0sXG5cdFx0ICogXHRcImVudmVsb3BlXCIgOiB7XG5cdFx0ICogXHRcdFwiYXR0YWNrXCIgOiAwLjI1XG5cdFx0ICogXHR9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBvbHlTeW50aC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWUsIHJhbXBUaW1lKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZvaWNlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXS5zZXQocGFyYW1zLCB2YWx1ZSwgcmFtcFRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzeW50aCdzIGF0dHJpYnV0ZXMuIEdpdmVuIG5vIGFyZ3VtZW50cyBnZXRcblx0XHQgKiAgd2lsbCByZXR1cm4gYWxsIGF2YWlsYWJsZSBvYmplY3QgcHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZ1xuXHRcdCAqICB2YWx1ZXMuIFBhc3MgaW4gYSBzaW5nbGUgYXR0cmlidXRlIHRvIHJldHJpZXZlIG9yIGFuIGFycmF5XG5cdFx0ICogIG9mIGF0dHJpYnV0ZXMuIFRoZSBhdHRyaWJ1dGUgc3RyaW5ncyBjYW4gYWxzbyBpbmNsdWRlIGEgXCIuXCJcblx0XHQgKiAgdG8gYWNjZXNzIGRlZXBlciBwcm9wZXJ0aWVzLlxuXHRcdCAqICBAcGFyYW0ge0FycmF5PX0gcGFyYW1zIHRoZSBwYXJhbWV0ZXJzIHRvIGdldCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIFxuXHRcdCAqICBcdFx0XHRcdFx0ICAgYWxsIGF2YWlsYWJsZS5cblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudm9pY2VzWzBdLmdldChwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBUcmlnZ2VyIHRoZSByZWxlYXNlIHBvcnRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlIHZvaWNlcy5cblx0XHQgKiAgQHBhcmFtIHtUaW1lfSBbdGltZT1ub3ddIFdoZW4gdGhlIG5vdGVzIHNob3VsZCBiZSByZWxlYXNlZC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5yZWxlYXNlQWxsID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgZGVzYyA9IHRoaXMuX3RyaWdnZXJzW2ldO1xuXHQgICAgICAgICAgICBpZiAoZGVzYy5yZWxlYXNlID4gdGltZSkge1xuXHQgICAgICAgICAgICAgICAgZGVzYy5yZWxlYXNlID0gdGltZTtcblx0ICAgICAgICAgICAgICAgIGRlc2Mudm9pY2UudHJpZ2dlclJlbGVhc2UodGltZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIENsZWFuIHVwLlxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5Qb2x5U3ludGh9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52b2ljZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy52b2ljZXNbaV0uZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB0aGlzLnZvaWNlc1tpXSA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX3dyaXRhYmxlKCdkZXR1bmUnKTtcblx0ICAgICAgICB0aGlzLmRldHVuZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBudWxsO1xuXHQgICAgICAgIHRoaXMudm9pY2VzID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl90cmlnZ2VycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub3RlcyB0aGF0IGNhbiBiZSBhbGxvY2F0ZWQgXG5cdFx0ICogIHRvIGEgcG9seXN5bnRoLiBcblx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKi9cblx0ICAgIFRvbmUuUG9seVN5bnRoLk1BWF9QT0xZUEhPTlkgPSAyMDtcblx0ICAgIHJldHVybiBUb25lLlBvbHlTeW50aDtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgLyoqXG5cdFx0ICogQGNsYXNzIEF1dG9tYXRpY2FsbHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gYSBzZXQgb2YgcGl0Y2hlZCBzYW1wbGVzLiBQYXNzIGluIGFuIG9iamVjdCB3aGljaCBtYXBzIHRoZSBub3RlJ3MgcGl0Y2ggb3IgbWlkaSB2YWx1ZSB0byB0aGUgdXJsLCB0aGVuIHlvdSBjYW4gdHJpZ2dlciB0aGUgYXR0YWNrIGFuZCByZWxlYXNlIG9mIHRoYXQgbm90ZSBsaWtlIG90aGVyIGluc3RydW1lbnRzLiBCeSBhdXRvbWF0aWNhbGx5IHJlcGl0Y2hpbmcgdGhlIHNhbXBsZXMsIGl0IGlzIHBvc3NpYmxlIHRvIHBsYXkgcGl0Y2hlcyB3aGljaCB3ZXJlIG5vdCBleHBsaWNpdGx5IGluY2x1ZGVkIHdoaWNoIGNhbiBzYXZlIGxvYWRpbmcgdGltZS5cblx0XHQgKiAgICAgICAgRm9yIHNhbXBsZSBvciBidWZmZXIgcGxheWJhY2sgd2hlcmUgcmVwaXRjaGluZyBpcyBub3QgbmVjZXNzYXJ5LCB1c2UgW1RvbmUuUGxheWVyXShodHRwczovL3RvbmVqcy5naXRodWIuaW8vZG9jcy9QbGF5ZXIpLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVzIEFuIG9iamVjdCBvZiBzYW1wbGVzIG1hcHBpbmcgZWl0aGVyIE1pZGlcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIE51bWJlcnMgb3IgU2NpZW50aWZpYyBQaXRjaCBOb3RhdGlvblxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSB1cmwgb2YgdGhhdCBzYW1wbGUuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbj19IG9ubG9hZCBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9mIHRoZSBzYW1wbGVzIGFyZSBsb2FkZWQuXG5cdFx0ICogQHBhcmFtIHtTdHJpbmc9fSBiYXNlVXJsIFRoZSByb290IFVSTCBvZiBhbGwgb2YgdGhlIHNhbXBsZXMsIHdoaWNoIGlzIHByZXBlbmRlZCB0byBhbGwgdGhlIFVSTHMuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiB2YXIgc2FtcGxlciA9IG5ldyBUb25lLlNhbXBsZXIoe1xuXHRcdCAqIFx0XCJDM1wiIDogXCJwYXRoL3RvL0MzLm1wM1wiLFxuXHRcdCAqIFx0XCJEIzNcIiA6IFwicGF0aC90by9Ec2hhcnAzLm1wM1wiLFxuXHRcdCAqIFx0XCJGIzNcIiA6IFwicGF0aC90by9Gc2hhcnAzLm1wM1wiLFxuXHRcdCAqIFx0XCJBM1wiIDogXCJwYXRoL3RvL0EzLm1wM1wiLFxuXHRcdCAqIH0sIGZ1bmN0aW9uKCl7XG5cdFx0ICogXHQvL3NhbXBsZXIgd2lsbCByZXBpdGNoIHRoZSBjbG9zZXN0IHNhbXBsZVxuXHRcdCAqIFx0c2FtcGxlci50cmlnZ2VyQXR0YWNrKFwiRDNcIilcblx0XHQgKiB9KVxuXHRcdCAqIEBleHRlbmRzIHtUb25lLkluc3RydW1lbnR9XG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIgPSBmdW5jdGlvbiAodXJscykge1xuXHQgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBvdmVyIG9uZS4gVGhvc2UgYXJlIHRoZSByZW1haW5kZXIgb2YgdGhlIG9wdGlvbnNcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbXG5cdCAgICAgICAgICAgICdvbmxvYWQnLFxuXHQgICAgICAgICAgICAnYmFzZVVybCdcblx0ICAgICAgICBdLCBUb25lLlNhbXBsZXIpO1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgIHZhciB1cmxNYXAgPSB7fTtcblx0ICAgICAgICBmb3IgKHZhciBub3RlIGluIHVybHMpIHtcblx0ICAgICAgICAgICAgaWYgKFRvbmUuaXNOb3RlKG5vdGUpKSB7XG5cdCAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIG5vdGUgbmFtZSB0byBNSURJXG5cdCAgICAgICAgICAgICAgICB2YXIgbWlkID0gVG9uZS5GcmVxdWVuY3kobm90ZSkudG9NaWRpKCk7XG5cdCAgICAgICAgICAgICAgICB1cmxNYXBbbWlkXSA9IHVybHNbbm90ZV07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQobm90ZSkpKSB7XG5cdCAgICAgICAgICAgICAgICAvL290aGVyd2lzZSBpZiBpdCdzIG51bWJlcnMgYXNzdW1lIGl0J3MgbWlkaVxuXHQgICAgICAgICAgICAgICAgdXJsTWFwW25vdGVdID0gdXJsc1tub3RlXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5TYW1wbGVyOiB1cmwga2V5cyBtdXN0IGJlIHRoZSBub3RlXFwncyBwaXRjaCcpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHN0b3JlZCBhbmQgbG9hZGVkIGJ1ZmZlcnNcblx0XHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcnN9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYnVmZmVycyA9IG5ldyBUb25lLkJ1ZmZlcnModXJsTWFwLCBvcHRpb25zLm9ubG9hZCwgb3B0aW9ucy5iYXNlVXJsKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBvYmplY3Qgb2YgYWxsIGN1cnJlbnRseSBwbGF5aW5nIEJ1ZmZlclNvdXJjZXNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IHt9O1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGVudmVsb3BlIGFwcGxpZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2FtcGxlLlxuXHRcdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmF0dGFjayA9IG9wdGlvbnMuYXR0YWNrO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIGVudmVsb3BlIGFwcGxpZWQgdG8gdGhlIGVuZCBvZiB0aGUgZW52ZWxvcGUuXG5cdFx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMucmVsZWFzZSA9IG9wdGlvbnMucmVsZWFzZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlNhbXBsZXIsIFRvbmUuSW5zdHJ1bWVudCk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGVmYXVsdHNcblx0XHQgKiBAY29uc3Rcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgIGF0dGFjazogMCxcblx0ICAgICAgICByZWxlYXNlOiAwLjEsXG5cdCAgICAgICAgb25sb2FkOiBUb25lLm5vT3AsXG5cdCAgICAgICAgYmFzZVVybDogJydcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGluIHN0ZXBzIGJldHdlZW4gdGhlIGdpdmVuIG1pZGkgbm90ZSBhdCB0aGUgY2xvc2V0cyBzYW1wbGUuXG5cdFx0ICogQHBhcmFtICB7TWlkaX0gbWlkaVxuXHRcdCAqIEByZXR1cm4ge0ludGVydmFsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLl9maW5kQ2xvc2VzdCA9IGZ1bmN0aW9uIChtaWRpKSB7XG5cdCAgICAgICAgdmFyIE1BWF9JTlRFUlZBTCA9IDI0O1xuXHQgICAgICAgIHZhciBpbnRlcnZhbCA9IDA7XG5cdCAgICAgICAgd2hpbGUgKGludGVydmFsIDwgTUFYX0lOVEVSVkFMKSB7XG5cdCAgICAgICAgICAgIC8vIGNoZWNrIGFib3ZlIGFuZCBiZWxvd1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fYnVmZmVycy5oYXMobWlkaSArIGludGVydmFsKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIC1pbnRlcnZhbDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9idWZmZXJzLmhhcyhtaWRpIC0gaW50ZXJ2YWwpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaW50ZXJ2YWwrKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byBwbGF5XG5cdFx0ICogQHBhcmFtICB7VGltZT19IHRpbWUgICAgIFdoZW4gdG8gcGxheSB0aGUgbm90ZVxuXHRcdCAqIEBwYXJhbSAge05vcm1hbFJhbmdlPX0gdmVsb2NpdHkgVGhlIHZlbG9jaXR5IHRvIHBsYXkgdGhlIHNhbXBsZSBiYWNrLlxuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gICAgICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrID0gZnVuY3Rpb24gKG5vdGUsIHRpbWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdmFyIG1pZGkgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0ICAgICAgICAvLyBmaW5kIHRoZSBjbG9zZXN0IG5vdGUgcGl0Y2hcblx0ICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IHRoaXMuX2ZpbmRDbG9zZXN0KG1pZGkpO1xuXHQgICAgICAgIGlmIChkaWZmZXJlbmNlICE9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9zZXN0Tm90ZSA9IG1pZGkgLSBkaWZmZXJlbmNlO1xuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5fYnVmZmVycy5nZXQoY2xvc2VzdE5vdGUpO1xuXHQgICAgICAgICAgICAvLyBwbGF5IHRoYXQgbm90ZVxuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKHtcblx0ICAgICAgICAgICAgICAgICdidWZmZXInOiBidWZmZXIsXG5cdCAgICAgICAgICAgICAgICAncGxheWJhY2tSYXRlJzogVG9uZS5pbnRlcnZhbFRvRnJlcXVlbmN5UmF0aW8oZGlmZmVyZW5jZSksXG5cdCAgICAgICAgICAgICAgICAnZmFkZUluJzogdGhpcy5hdHRhY2ssXG5cdCAgICAgICAgICAgICAgICAnZmFkZU91dCc6IHRoaXMucmVsZWFzZSxcblx0ICAgICAgICAgICAgICAgICdjdXJ2ZSc6ICdleHBvbmVudGlhbCdcblx0ICAgICAgICAgICAgfSkuY29ubmVjdCh0aGlzLm91dHB1dCk7XG5cdCAgICAgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCAwLCBidWZmZXIuZHVyYXRpb24sIHZlbG9jaXR5KTtcblx0ICAgICAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBhY3RpdmUgc291cmNlc1xuXHQgICAgICAgICAgICBpZiAoIVRvbmUuaXNBcnJheSh0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldKSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXSA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0ucHVzaCh7XG5cdCAgICAgICAgICAgICAgICBub3RlOiBtaWRpLFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2Vcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEBwYXJhbSAge0ZyZXF1ZW5jeX0gbm90ZSAgICAgVGhlIG5vdGUgdG8gcmVsZWFzZS5cblx0XHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSAgICAgXHRXaGVuIHRvIHJlbGVhc2UgdGhlIG5vdGUuXG5cdFx0ICogQHJldHVybiB7VG9uZS5TYW1wbGVyfVx0dGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uIChub3RlLCB0aW1lKSB7XG5cdCAgICAgICAgdmFyIG1pZGkgPSBUb25lLkZyZXF1ZW5jeShub3RlKS50b01pZGkoKTtcblx0ICAgICAgICAvLyBmaW5kIHRoZSBub3RlXG5cdCAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0gJiYgdGhpcy5fYWN0aXZlU291cmNlc1ttaWRpXS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2FjdGl2ZVNvdXJjZXNbbWlkaV0uc2hpZnQoKS5zb3VyY2U7XG5cdCAgICAgICAgICAgIHRpbWUgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICAgICAgc291cmNlLnN0b3AodGltZSArIHRoaXMucmVsZWFzZSwgdGhpcy5yZWxlYXNlKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSW52b2tlIHRoZSBhdHRhY2sgcGhhc2UsIHRoZW4gYWZ0ZXIgdGhlIGR1cmF0aW9uLCBpbnZva2UgdGhlIHJlbGVhc2UuXG5cdFx0ICogQHBhcmFtICB7RnJlcXVlbmN5fSBub3RlICAgICBUaGUgbm90ZSB0byBwbGF5XG5cdFx0ICogQHBhcmFtICB7VGltZX0gZHVyYXRpb24gVGhlIHRpbWUgdGhlIG5vdGUgc2hvdWxkIGJlIGhlbGRcblx0XHQgKiBAcGFyYW0gIHtUaW1lPX0gdGltZSAgICAgV2hlbiB0byBzdGFydCB0aGUgYXR0YWNrXG5cdFx0ICogQHBhcmFtICB7Tm9ybWFsUmFuZ2V9IFt2ZWxvY2l0eT0xXSBUaGUgdmVsb2NpdHkgb2YgdGhlIGF0dGFja1xuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gICAgICAgICAgdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS50cmlnZ2VyQXR0YWNrUmVsZWFzZSA9IGZ1bmN0aW9uIChub3RlLCBkdXJhdGlvbiwgdGltZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgZHVyYXRpb24gPSB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbik7XG5cdCAgICAgICAgdGhpcy50cmlnZ2VyQXR0YWNrKG5vdGUsIHRpbWUsIHZlbG9jaXR5KTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXJSZWxlYXNlKG5vdGUsIHRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEFkZCBhIG5vdGUgdG8gdGhlIHNhbXBsZXIuXG5cdFx0ICogIEBwYXJhbSAge05vdGV8TWlkaX0gICBub3RlICAgICAgVGhlIGJ1ZmZlcidzIHBpdGNoLlxuXHRcdCAqICBAcGFyYW0gIHtTdHJpbmd8VG9uZS5CdWZmZXJ8QXVkaW9idWZmZXJ9ICB1cmwgIEVpdGhlciB0aGUgdXJsIG9mIHRoZSBidWZlcixcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBhIGJ1ZmZlciB3aGljaCB3aWxsIGJlIGFkZGVkXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7RnVuY3Rpb249fSAgY2FsbGJhY2sgIFRoZSBjYWxsYmFjayB0byBpbnZva2Vcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIHVybCBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLlNhbXBsZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChub3RlLCB1cmwsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKFRvbmUuaXNOb3RlKG5vdGUpKSB7XG5cdCAgICAgICAgICAgIC8vY29udmVydCB0aGUgbm90ZSBuYW1lIHRvIE1JRElcblx0ICAgICAgICAgICAgdmFyIG1pZCA9IFRvbmUuRnJlcXVlbmN5KG5vdGUpLnRvTWlkaSgpO1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXJzLmFkZChtaWQsIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHBhcnNlRmxvYXQobm90ZSkpKSB7XG5cdCAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGlmIGl0J3MgbnVtYmVycyBhc3N1bWUgaXQncyBtaWRpXG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnMuYWRkKG5vdGUsIHVybCwgY2FsbGJhY2spO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5TYW1wbGVyOiBub3RlIG11c3QgYmUgdGhlIG5vdGVcXCdzIHBpdGNoLiBJbnN0ZWFkIGdvdCAnICsgbm90ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU2FtcGxlciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlNhbXBsZXIucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVycy5sb2FkZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuU2FtcGxlcn0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5TYW1wbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuSW5zdHJ1bWVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBudWxsO1xuXHQgICAgICAgIGZvciAodmFyIG1pZGkgaW4gdGhpcy5fYWN0aXZlU291cmNlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzW21pZGldLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBldmVudC5zb3VyY2UuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuU2FtcGxlcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzIE1hcHMgYSBOb3JtYWxSYW5nZSBbMCwgMV0gdG8gYW4gQXVkaW9SYW5nZSBbLTEsIDFdLiBcblx0XHQgKiAgICAgICAgIFNlZSBhbHNvIFRvbmUuQXVkaW9Ub0dhaW4uIFxuXHRcdCAqXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNpZ25hbEJhc2V9XG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHZhciBnMmEgPSBuZXcgVG9uZS5HYWluVG9BdWRpbygpO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5HYWluVG9BdWRpbyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNpZ25hbEJhc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSB7V2F2ZVNoYXBlck5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX25vcm0gPSB0aGlzLmlucHV0ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5XYXZlU2hhcGVyKGZ1bmN0aW9uICh4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh4KSAqIDIgLSAxO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR2FpblRvQXVkaW8sIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiAgY2xlYW4gdXBcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR2FpblRvQXVkaW99IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR2FpblRvQXVkaW8ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fbm9ybS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fbm9ybSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR2FpblRvQXVkaW87XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyBOb3JtYWxpemUgdGFrZXMgYW4gaW5wdXQgbWluIGFuZCBtYXggYW5kIG1hcHMgaXQgbGluZWFybHkgdG8gTm9ybWFsUmFuZ2UgWzAsMV1cblx0XHQgKlxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5TaWduYWxCYXNlfVxuXHRcdCAqICBAY29uc3RydWN0b3Jcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWluIHRoZSBtaW4gaW5wdXQgdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IGlucHV0TWF4IHRoZSBtYXggaW5wdXQgdmFsdWVcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgbm9ybSA9IG5ldyBUb25lLk5vcm1hbGl6ZSgyLCA0KTtcblx0XHQgKiB2YXIgc2lnID0gbmV3IFRvbmUuU2lnbmFsKDMpLmNvbm5lY3Qobm9ybSk7XG5cdFx0ICogLy9vdXRwdXQgb2Ygbm9ybSBpcyAwLjUuIFxuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUgPSBmdW5jdGlvbiAoaW5wdXRNaW4sIGlucHV0TWF4KSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgdGhlIG1pbiBpbnB1dCB2YWx1ZVxuXHRcdFx0ICogIEB0eXBlIHtudW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2lucHV0TWluID0gVG9uZS5kZWZhdWx0QXJnKGlucHV0TWluLCAwKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgbWF4IGlucHV0IHZhbHVlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5faW5wdXRNYXggPSBUb25lLmRlZmF1bHRBcmcoaW5wdXRNYXgsIDEpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIHN1YnRyYWN0IHRoZSBtaW4gZnJvbSB0aGUgaW5wdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5BZGR9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3N1YiA9IHRoaXMuaW5wdXQgPSBuZXcgVG9uZS5BZGQoMCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgZGl2aWRlIGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGlucHV0IGFuZCBvdXRwdXRcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5NdWx0aXBseX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZGl2ID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5NdWx0aXBseSgxKTtcblx0ICAgICAgICB0aGlzLl9zdWIuY29ubmVjdCh0aGlzLl9kaXYpO1xuXHQgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICB9O1xuXHQgICAgVG9uZS5leHRlbmQoVG9uZS5Ob3JtYWxpemUsIFRvbmUuU2lnbmFsQmFzZSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWluaW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWluXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWluJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNaW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtaW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNaW4gPSBtaW47XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgaW5wdXQgc2lnbmFsIHdpbGwgcmVhY2guXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuTm9ybWFsaXplI1xuXHRcdCAqIEB0eXBlIHtudW1iZXJ9XG5cdFx0ICogQG5hbWUgbWF4XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLCAnbWF4Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRNYXg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtYXgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faW5wdXRNYXggPSBtYXg7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldFJhbmdlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgc2V0IHRoZSB2YWx1ZXNcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuTm9ybWFsaXplLnByb3RvdHlwZS5fc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5fc3ViLnZhbHVlID0gLXRoaXMuX2lucHV0TWluO1xuXHQgICAgICAgIHRoaXMuX2Rpdi52YWx1ZSA9IDEgLyAodGhpcy5faW5wdXRNYXggLSB0aGlzLl9pbnB1dE1pbik7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIGNsZWFuIHVwXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLk5vcm1hbGl6ZX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Ob3JtYWxpemUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5TaWduYWxCYXNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5fc3ViLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9zdWIgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2Rpdi5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fZGl2ID0gbnVsbDtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVG9uZS5Ob3JtYWxpemU7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsIGV4dGVuZHMgVG9uZS5UaW1lbGluZVNpZ25hbCwgYnV0IGFkZHMgdGhlIGFiaWxpdHkgdG8gc3luY2hyb25pemUgdGhlIHNpZ25hbCB0byB0aGUgc2lnbmFsIHRvIHRoZSBUb25lLlRyYW5zcG9ydFxuXHRcdCAqIEBleHRlbmRzIHtUb25lLlRpbWVsaW5lU2lnbmFsfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgcmVhbCBzaWduYWwgb3V0cHV0XG5cdFx0XHQgKiBAdHlwZSB7VG9uZS5TaWduYWx9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLl9vdXRwdXRTaWcgPSBuZXcgVG9uZS5TaWduYWwodGhpcy5faW5pdGlhbCk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHZhbHVlLiAoc21hbGwgb3B0aW1pemF0aW9uKVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sYXN0VmFsID0gdGhpcy52YWx1ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIFRoZSBldmVudCBpZCBvZiB0aGUgdGljayB1cGRhdGUgbG9vcFxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zeW5jZWQgPSBUb25lLlRyYW5zcG9ydC5zY2hlZHVsZVJlcGVhdCh0aGlzLl9vblRpY2suYmluZCh0aGlzKSwgJzFpJyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBBIGJvdW5kIHZlcnNpb24gb2YgdGhlIGFuY2hvciB2YWx1ZSBtZXRob2RzXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYmluZEFuY2hvclZhbHVlID0gdGhpcy5fYW5jaG9yVmFsdWUuYmluZCh0aGlzKTtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5vbignc3RhcnQgc3RvcCBwYXVzZScsIHRoaXMuX2JpbmRBbmNob3JWYWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzLm1lbW9yeSA9IEluZmluaXR5O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwsIFRvbmUuVGltZWxpbmVTaWduYWwpO1xuXHQgICAgLyoqXG5cdFx0ICogQ2FsbGJhY2sgd2hpY2ggaXMgaW52b2tlZCBldmVyeSB0aWNrLlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5fb25UaWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZUF0VGltZShUb25lLlRyYW5zcG9ydC5zZWNvbmRzKTtcblx0ICAgICAgICBpZiAodGhpcy5fbGFzdFZhbCAhPT0gdmFsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xhc3RWYWwgPSB2YWw7XG5cdCAgICAgICAgICAgIC8vYXBwcm94aW1hdGUgcmFtcCBjdXJ2ZXMgd2l0aCBsaW5lYXIgcmFtcHNcblx0ICAgICAgICAgICAgdGhpcy5fb3V0cHV0U2lnLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHZhbCwgdGltZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIEFuY2hvciB0aGUgdmFsdWUgYXQgdGhlIHN0YXJ0IGFuZCBzdG9wIG9mIHRoZSBUcmFuc3BvcnRcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgVGhlIHRpbWUgb2YgdGhlIGV2ZW50XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gICAgICB0aGlzXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLl9hbmNob3JWYWx1ZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoVG9uZS5UcmFuc3BvcnQudGlja3MpO1xuXHQgICAgICAgIHRoaXMuX2xhc3RWYWwgPSB2YWw7XG5cdCAgICAgICAgdGhpcy5fb3V0cHV0U2lnLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcblx0ICAgICAgICB0aGlzLl9vdXRwdXRTaWcuc2V0VmFsdWVBdFRpbWUodmFsLCB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgR2V0IHRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuIFRoaXMgd2lsbFxuXHRcdCAqICByZXR1cm4gdGhlIHVuY29udmVydGVkIChyYXcpIHZhbHVlLlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSAgdGltZSAgVGhlIHRpbWUgaW4gc2Vjb25kcy5cblx0XHQgKiAgQHJldHVybiAge051bWJlcn0gIFRoZSBzY2hlZHVsZWQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUuXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICByZXR1cm4gVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUuY2FsbCh0aGlzLCB0aW1lKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBTZXQgdGhlIG91dHB1dCBvZiB0aGUgc2lnbmFsIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hhbmdlIHRvIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gdGltZSAgVGhlIHRpbWUgdG8gY2hhbmdlIHRoZSBzaWduYWxcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB0aGlzLnRvVGlja3ModGltZSk7XG5cdCAgICAgICAgVG9uZS5UaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuc2V0VmFsdWVBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZSwgdGltZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogTGluZWFyIHJhbXAgdG8gdGhlIGdpdmVuIHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIHNjaGVkdWxlZCBwb2ludCB0byB0aGUgZ2l2ZW4gdmFsdWVcblx0XHQgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGFuZ2UgdG8gYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSB0aW1lICBUaGUgdGltZSB0byBjaGFuZ2UgdGhlIHNpZ25hbFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZS5jYWxsKHRoaXMsIHZhbHVlLCB0aW1lKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBFeHBvbmVudGlhbCByYW1wIHRvIHRoZSBnaXZlbiB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBzY2hlZHVsZWQgcG9pbnQgdG8gdGhlIGdpdmVuIHZhbHVlXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hhbmdlIHRvIGF0IHRoZSBnaXZlbiB0aW1lXG5cdFx0ICogQHBhcmFtICB7VHJhbnNwb3J0VGltZX0gdGltZSAgVGhlIHRpbWUgdG8gY2hhbmdlIHRoZSBzaWduYWxcblx0XHQgKiBAcmV0dXJuIHtUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsfSAgICAgICB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlLCB0aW1lKSB7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9UaWNrcyh0aW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lLmNhbGwodGhpcywgdmFsdWUsIHRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTdGFydCBleHBvbmVudGlhbGx5IGFwcHJvYWNoaW5nIHRoZSB0YXJnZXQgdmFsdWUgYXQgdGhlIGdpdmVuIHRpbWUgd2l0aFxuXHRcdCAqICBhIHJhdGUgaGF2aW5nIHRoZSBnaXZlbiB0aW1lIGNvbnN0YW50LlxuXHRcdCAqICBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0XHQgKiAgQHBhcmFtIHtUcmFuc3BvcnRUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHBhcmFtIHtudW1iZXJ9IHRpbWVDb25zdGFudFxuXHRcdCAqIEByZXR1cm4ge1RvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWx9ICAgICAgIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLnNldFRhcmdldEF0VGltZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpIHtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvVGlja3Moc3RhcnRUaW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRUYXJnZXRBdFRpbWUuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhcnRUaW1lLCB0aW1lQ29uc3RhbnQpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBDYW5jZWxzIGFsbCBzY2hlZHVsZWQgcGFyYW1ldGVyIGNoYW5nZXMgd2l0aCB0aW1lcyBncmVhdGVyIHRoYW4gb3Jcblx0XHQgKiAgZXF1YWwgdG8gc3RhcnRUaW1lLlxuXHRcdCAqICBAcGFyYW0gIHtUcmFuc3BvcnRUaW1lfSBzdGFydFRpbWVcblx0XHQgKiAgQHJldHVybnMge1RvbmUuUGFyYW19IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWwucHJvdG90eXBlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyA9IGZ1bmN0aW9uIChzdGFydFRpbWUpIHtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvVGlja3Moc3RhcnRUaW1lKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMuY2FsbCh0aGlzLCBzdGFydFRpbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZXQgYW4gYXJyYXkgb2YgYXJiaXRyYXJ5IHZhbHVlcyBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gdGltZSBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqICBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmFsdWVzXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gc3RhcnRUaW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gZHVyYXRpb25cblx0XHQgKiAgQHBhcmFtIHtOb3JtYWxSYW5nZX0gW3NjYWxpbmc9MV0gSWYgdGhlIHZhbHVlcyBpbiB0aGUgY3VydmUgc2hvdWxkIGJlIHNjYWxlZCBieSBzb21lIHZhbHVlXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlRpbWVsaW5lU2lnbmFsfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlRyYW5zcG9ydFRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lID0gZnVuY3Rpb24gKHZhbHVlcywgc3RhcnRUaW1lLCBkdXJhdGlvbiwgc2NhbGluZykge1xuXHQgICAgICAgIHN0YXJ0VGltZSA9IHRoaXMudG9UaWNrcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gdGhpcy50b1RpY2tzKGR1cmF0aW9uKTtcblx0ICAgICAgICBUb25lLlRpbWVsaW5lU2lnbmFsLnByb3RvdHlwZS5zZXRWYWx1ZUN1cnZlQXRUaW1lLmNhbGwodGhpcywgdmFsdWVzLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBzY2FsaW5nKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBEaXNwb3NlIGFuZCBkaXNjb25uZWN0XG5cdFx0ICogQHJldHVybiB7VG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbH0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5UcmFuc3BvcnRUaW1lbGluZVNpZ25hbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlRyYW5zcG9ydC5jbGVhcih0aGlzLl9zeW5jZWQpO1xuXHQgICAgICAgIFRvbmUuVHJhbnNwb3J0Lm9mZignc3RhcnQgc3RvcCBwYXVzZScsIHRoaXMuX3N5bmNlZENhbGxiYWNrKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMuY2FuY2VsKDApO1xuXHQgICAgICAgIFRvbmUuVGltZWxpbmVTaWduYWwucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9vdXRwdXRTaWcuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX291dHB1dFNpZyA9IG51bGw7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuVHJhbnNwb3J0VGltZWxpbmVTaWduYWw7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIC8qKlxuXHRcdCAqIEBjbGFzcyBUb25lLkdyYWluUGxheWVyIGltcGxlbWVudHMgW2dyYW51bGFyIHN5bnRoZXNpc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JhbnVsYXJfc3ludGhlc2lzKS5cblx0XHQgKiAgICAgICAgR3JhbnVsYXIgU3ludGhlc2lzIGVuYWJsZXMgeW91IHRvIGFkanVzdCBwaXRjaCBhbmQgcGxheWJhY2sgcmF0ZSBpbmRlcGVuZGVudGx5LiBUaGUgZ3JhaW5TaXplIGlzIHRoZVxuXHRcdCAqICAgICAgICBhbW91bnQgb2YgdGltZSBlYWNoIHNtYWxsIGNodW5rIG9mIGF1ZGlvIGlzIHBsYXllZCBmb3IgYW5kIHRoZSBvdmVybGFwIGlzIHRoZVxuXHRcdCAqICAgICAgICBhbW91bnQgb2YgY3Jvc3NmYWRpbmcgdHJhbnNpdGlvbiB0aW1lIGJldHdlZW4gc3VjY2Vzc2l2ZSBncmFpbnMuXG5cdFx0ICogQGV4dGVuZHMge1RvbmUuU291cmNlfVxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfFRvbmUuQnVmZmVyfSB1cmxcdFRoZSB1cmwgdG8gbG9hZCwgb3IgdGhlIFRvbmUuQnVmZmVyIHRvIHBsYXkuXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgdGhlIHVybCBpcyBsb2FkZWQuXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFtcblx0ICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICdvbmxvYWQnXG5cdCAgICAgICAgXSwgVG9uZS5HcmFpblBsYXllcik7XG5cdCAgICAgICAgVG9uZS5Tb3VyY2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgYXVkaW8gYnVmZmVyIGJlbG9uZ2luZyB0byB0aGUgcGxheWVyLlxuXHRcdFx0ICogIEB0eXBlICB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBUb25lLkJ1ZmZlcihvcHRpb25zLnVybCwgb3B0aW9ucy5vbmxvYWQpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIENyZWF0ZSBhIHJlcGVhdGluZyB0aWNrIHRvIHNjaGVkdWxlXG5cdFx0XHQgKiAgdGhlIGdyYWlucy5cblx0XHRcdCAqICBAdHlwZSAge1RvbmUuQ2xvY2t9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrID0gbmV3IFRvbmUuQ2xvY2sodGhpcy5fdGljay5iaW5kKHRoaXMpLCBvcHRpb25zLmdyYWluU2l6ZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IDA7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHR5cGUgIHtOdW1iZXJ9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2xvb3BFbmQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogQWxsIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBCdWZmZXJTb3VyY2VzXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0XHQgKiBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IFtdO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEB0eXBlICB7TnVtYmVyfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSBvcHRpb25zLnBsYXliYWNrUmF0ZTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBAdHlwZSAge051bWJlcn1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fZ3JhaW5TaXplID0gb3B0aW9ucy5ncmFpblNpemU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fb3ZlcmxhcCA9IG9wdGlvbnMub3ZlcmxhcDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBBZGp1c3QgdGhlIHBpdGNoIGluZGVwZW5kZW50bHkgb2YgdGhlIHBsYXliYWNrUmF0ZS5cblx0XHRcdCAqICBAdHlwZSAge0NlbnRzfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5kZXR1bmUgPSBvcHRpb25zLmRldHVuZTtcblx0ICAgICAgICAvL3NldHVwXG5cdCAgICAgICAgdGhpcy5vdmVybGFwID0gb3B0aW9ucy5vdmVybGFwO1xuXHQgICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcDtcblx0ICAgICAgICB0aGlzLnBsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgICAgIHRoaXMuZ3JhaW5TaXplID0gb3B0aW9ucy5ncmFpblNpemU7XG5cdCAgICAgICAgdGhpcy5sb29wU3RhcnQgPSBvcHRpb25zLmxvb3BTdGFydDtcblx0ICAgICAgICB0aGlzLmxvb3BFbmQgPSBvcHRpb25zLmxvb3BFbmQ7XG5cdCAgICAgICAgdGhpcy5yZXZlcnNlID0gb3B0aW9ucy5yZXZlcnNlO1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLm9uKCdzdG9wJywgdGhpcy5fb25zdG9wLmJpbmQodGhpcykpO1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuR3JhaW5QbGF5ZXIsIFRvbmUuU291cmNlKTtcblx0ICAgIC8qKlxuXHRcdCAqICB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzXG5cdFx0ICogIEBzdGF0aWNcblx0XHQgKiAgQGNvbnN0XG5cdFx0ICogIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLmRlZmF1bHRzID0ge1xuXHQgICAgICAgICdvbmxvYWQnOiBUb25lLm5vT3AsXG5cdCAgICAgICAgJ292ZXJsYXAnOiAwLjEsXG5cdCAgICAgICAgJ2dyYWluU2l6ZSc6IDAuMixcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAnZGV0dW5lJzogMCxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdsb29wU3RhcnQnOiAwLFxuXHQgICAgICAgICdsb29wRW5kJzogMCxcblx0ICAgICAgICAncmV2ZXJzZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFBsYXkgdGhlIGJ1ZmZlciBhdCB0aGUgZ2l2ZW4gc3RhcnRUaW1lLiBPcHRpb25hbGx5IGFkZCBhbiBvZmZzZXRcblx0XHQgKiAgYW5kL29yIGR1cmF0aW9uIHdoaWNoIHdpbGwgcGxheSB0aGUgYnVmZmVyIGZyb20gYSBwb3NpdGlvblxuXHRcdCAqICB3aXRoaW4gdGhlIGJ1ZmZlciBmb3IgdGhlIGdpdmVuIGR1cmF0aW9uLlxuXHRcdCAqXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtzdGFydFRpbWU9bm93XSBXaGVuIHRoZSBwbGF5ZXIgc2hvdWxkIHN0YXJ0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzYW1wbGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHN0YXJ0IGF0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gZHVyYXRpb24gSG93IGxvbmcgdGhlIHNhbXBsZSBzaG91bGQgcGxheS4gSWYgbm8gZHVyYXRpb25cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZ2l2ZW4sIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgZnVsbCBsZW5ndGhcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHNhbXBsZSAobWludXMgYW55IG9mZnNldClcblx0XHQgKiAgQHJldHVybnMge1RvbmUuR3JhaW5QbGF5ZXJ9IHRoaXNcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogIEBtZXRob2Qgc3RhcnRcblx0XHQgKiAgQG5hbWUgc3RhcnRcblx0XHQgKi9cblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBzdGFydCBtZXRob2Rcblx0XHQgKiAgQHBhcmFtIHtUaW1lfSB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gb2Zmc2V0XG5cdFx0ICogIEBwcml2YXRlXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAodGltZSwgb2Zmc2V0LCBkdXJhdGlvbikge1xuXHQgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIDApO1xuXHQgICAgICAgIG9mZnNldCA9IHRoaXMudG9TZWNvbmRzKG9mZnNldCk7XG5cdCAgICAgICAgdGltZSA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICB0aGlzLl9jbG9jay5zdGFydCh0aW1lKTtcblx0ICAgICAgICBpZiAoZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgdGhpcy5zdG9wKHRpbWUgKyB0aGlzLnRvU2Vjb25kcyhkdXJhdGlvbikpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgSW50ZXJuYWwgc3RhcnQgbWV0aG9kXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gdGltZVxuXHRcdCAqICBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUuX3N0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2Nsb2NrLnN0b3AodGltZSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSW52b2tlZCB3aGVuIHRoZSBjbG9jayBpcyBzdG9wcGVkXG5cdFx0ICogQHBhcmFtICB7TnVtYmVyfSB0aW1lXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLl9vbnN0b3AgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIC8vc3RvcCB0aGUgcGxheWVyc1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgIHNvdXJjZS5zdG9wKHRpbWUsIDApO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBJbnZva2VkIG9uIGVhY2ggY2xvY2sgdGljay4gc2NoZWR1bGVkIGEgbmV3XG5cdFx0ICogIGdyYWluIGF0IHRoaXMgdGltZS5cblx0XHQgKiAgQHBhcmFtICB7VGltZX0gIHRpbWVcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICB2YXIgZmFkZUluID0gdGhpcy5fb2Zmc2V0IDwgdGhpcy5fb3ZlcmxhcCA/IDAgOiB0aGlzLl9vdmVybGFwO1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSBuZXcgVG9uZS5CdWZmZXJTb3VyY2Uoe1xuXHQgICAgICAgICAgICAnYnVmZmVyJzogdGhpcy5idWZmZXIsXG5cdCAgICAgICAgICAgICdmYWRlSW4nOiBmYWRlSW4sXG5cdCAgICAgICAgICAgICdmYWRlT3V0JzogdGhpcy5fb3ZlcmxhcCxcblx0ICAgICAgICAgICAgJ2xvb3AnOiB0aGlzLmxvb3AsXG5cdCAgICAgICAgICAgICdsb29wU3RhcnQnOiB0aGlzLl9sb29wU3RhcnQsXG5cdCAgICAgICAgICAgICdsb29wRW5kJzogdGhpcy5fbG9vcEVuZCxcblx0ICAgICAgICAgICAgJ3BsYXliYWNrUmF0ZSc6IFRvbmUuaW50ZXJ2YWxUb0ZyZXF1ZW5jeVJhdGlvKHRoaXMuZGV0dW5lIC8gMTAwKVxuXHQgICAgICAgIH0pLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHNvdXJjZS5zdGFydCh0aW1lLCB0aGlzLl9vZmZzZXQpO1xuXHQgICAgICAgIHRoaXMuX29mZnNldCArPSB0aGlzLmdyYWluU2l6ZTtcblx0ICAgICAgICBzb3VyY2Uuc3RvcCh0aW1lICsgdGhpcy5ncmFpblNpemUpO1xuXHQgICAgICAgIC8vYWRkIGl0IHRvIHRoZSBhY3RpdmUgc291cmNlc1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHQgICAgICAgIC8vcmVtb3ZlIGl0IHdoZW4gaXQncyBkb25lXG5cdCAgICAgICAgc291cmNlLm9uZW5kZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FjdGl2ZVNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXHQgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVTb3VyY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcyk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIEp1bXAgdG8gYSBzcGVjaWZpYyB0aW1lIGFuZCBwbGF5IGl0LlxuXHRcdCAqICBAcGFyYW0gIHtUaW1lfSAgb2Zmc2V0ICBUaGUgb2Zmc2V0IHRvIGp1bXAgdG8uXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHRpbWUgV2hlbiB0byBtYWtlIHRoZSBqdW1wLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5HcmFpblBsYXllcn0gIHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAob2Zmc2V0LCB0aW1lKSB7XG5cdCAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICB0aGlzLl90aWNrKHRoaXMudG9TZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBUaGUgcGxheWJhY2sgcmF0ZSBvZiB0aGUgc2FtcGxlXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1Bvc2l0aXZlfVxuXHRcdCAqIEBuYW1lIHBsYXliYWNrUmF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAncGxheWJhY2tSYXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9wbGF5YmFja1JhdGUgPSByYXRlO1xuXHQgICAgICAgICAgICB0aGlzLmdyYWluU2l6ZSA9IHRoaXMuX2dyYWluU2l6ZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBsb29wIHN0YXJ0IHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdsb29wU3RhcnQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wU3RhcnQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGxvb3AgZW5kIHRpbWUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuR3JhaW5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcEVuZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3BFbmQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BFbmQgPSB0aGlzLnRvU2Vjb25kcyh0aW1lKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkaXJlY3Rpb24gdGhlIGJ1ZmZlciBzaG91bGQgcGxheSBpblxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLkdyYWluUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIHJldmVyc2Vcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZSwgJ3JldmVyc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5yZXZlcnNlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAocmV2KSB7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVyLnJldmVyc2UgPSByZXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgc2l6ZSBvZiBlYWNoIGNodW5rIG9mIGF1ZGlvIHRoYXQgdGhlXG5cdFx0ICogYnVmZmVyIGlzIGNob3BwZWQgaW50byBhbmQgcGxheWVkIGJhY2sgYXQuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuR3JhaW5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgZ3JhaW5TaXplXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdncmFpblNpemUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ncmFpblNpemU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzaXplKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2dyYWluU2l6ZSA9IHRoaXMudG9TZWNvbmRzKHNpemUpO1xuXHQgICAgICAgICAgICB0aGlzLl9jbG9jay5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLl9wbGF5YmFja1JhdGUgLyB0aGlzLl9ncmFpblNpemU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgY3Jvc3MtZmFkZSBiZXR3ZWVuXG5cdFx0ICogc3VjZXNzaXZlIGdyYWlucy5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5HcmFpblBsYXllciNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBvdmVybGFwXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5HcmFpblBsYXllci5wcm90b3R5cGUsICdvdmVybGFwJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxhcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fb3ZlcmxhcCA9IHRoaXMudG9TZWNvbmRzKHRpbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogQ2xlYW4gdXBcblx0XHQgKiBAcmV0dXJuIHtUb25lLkdyYWluUGxheWVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLkdyYWluUGxheWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIFRvbmUuU291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5idWZmZXIuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9jbG9jay5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fY2xvY2sgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZVNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG5cdCAgICAgICAgICAgIHNvdXJjZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlU291cmNlcyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuR3JhaW5QbGF5ZXI7XG5cdH0pO1xuXHRNb2R1bGUoZnVuY3Rpb24gKFRvbmUpIHtcblx0ICAgIFxuXHQgICAgLyoqXG5cdFx0ICogIEBjbGFzcyAgVG9uZS5QbGF5ZXIgaXMgYW4gYXVkaW8gZmlsZSBwbGF5ZXIgd2l0aCBzdGFydCwgbG9vcCwgYW5kIHN0b3AgZnVuY3Rpb25zLlxuXHRcdCAqICBcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLlNvdXJjZX0gXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfEF1ZGlvQnVmZmVyfSB1cmwgRWl0aGVyIHRoZSBBdWRpb0J1ZmZlciBvciB0aGUgdXJsIGZyb21cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGljaCB0byBsb2FkIHRoZSBBdWRpb0J1ZmZlclxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9uPX0gb25sb2FkIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYnVmZmVyIGlzIGxvYWRlZC4gXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVjb21tZW5kZWQgdG8gdXNlIFRvbmUuQnVmZmVyLm9uKCdsb2FkJykgaW5zdGVhZC5cblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiB2YXIgcGxheWVyID0gbmV3IFRvbmUuUGxheWVyKFwiLi9wYXRoL3RvL3NhbXBsZS5tcDNcIikudG9NYXN0ZXIoKTtcblx0XHQgKiAvL3BsYXkgYXMgc29vbiBhcyB0aGUgYnVmZmVyIGlzIGxvYWRlZFxuXHRcdCAqIHBsYXllci5hdXRvc3RhcnQgPSB0cnVlO1xuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIgPSBmdW5jdGlvbiAodXJsKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnM7XG5cdCAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFRvbmUuQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHVybCA9IHVybC5nZXQoKTtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IFRvbmUuUGxheWVyLmRlZmF1bHRzO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBUb25lLmRlZmF1bHRzKGFyZ3VtZW50cywgW1xuXHQgICAgICAgICAgICAgICAgJ3VybCcsXG5cdCAgICAgICAgICAgICAgICAnb25sb2FkJ1xuXHQgICAgICAgICAgICBdLCBUb25lLlBsYXllcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIFRvbmUuU291cmNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7QXVkaW9CdWZmZXJTb3VyY2VOb2RlfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBJZiB0aGUgZmlsZSBzaG91bGQgcGxheSBhcyBzb29uXG5cdFx0XHQgKiAgYXMgdGhlIGJ1ZmZlciBpcyBsb2FkZWQuIFxuXHRcdFx0ICogIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICogIEBleGFtcGxlXG5cdFx0XHQgKiAvL3dpbGwgcGxheSBhcyBzb29uIGFzIGl0J3MgbG9hZGVkXG5cdFx0XHQgKiB2YXIgcGxheWVyID0gbmV3IFRvbmUuUGxheWVyKHtcblx0XHRcdCAqIFx0XCJ1cmxcIiA6IFwiLi9wYXRoL3RvL3NhbXBsZS5tcDNcIixcblx0XHRcdCAqIFx0XCJhdXRvc3RhcnRcIiA6IHRydWUsXG5cdFx0XHQgKiB9KS50b01hc3RlcigpO1xuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5hdXRvc3RhcnQgPSBvcHRpb25zLmF1dG9zdGFydDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgYnVmZmVyXG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqICBAdHlwZSB7VG9uZS5CdWZmZXJ9XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgVG9uZS5CdWZmZXIoe1xuXHQgICAgICAgICAgICAndXJsJzogb3B0aW9ucy51cmwsXG5cdCAgICAgICAgICAgICdvbmxvYWQnOiB0aGlzLl9vbmxvYWQuYmluZCh0aGlzLCBvcHRpb25zLm9ubG9hZCksXG5cdCAgICAgICAgICAgICdyZXZlcnNlJzogb3B0aW9ucy5yZXZlcnNlXG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIEF1ZGlvQnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zZXQodXJsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaWYgdGhlIGJ1ZmZlciBzaG91bGQgbG9vcCBvbmNlIGl0J3Mgb3ZlclxuXHRcdFx0ICogIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb29wID0gb3B0aW9ucy5sb29wO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIGlmICdsb29wJyBpcyB0cnVlLCB0aGUgbG9vcCB3aWxsIHN0YXJ0IGF0IHRoaXMgcG9zaXRpb25cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcFN0YXJ0ID0gb3B0aW9ucy5sb29wU3RhcnQ7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgaWYgJ2xvb3AnIGlzIHRydWUsIHRoZSBsb29wIHdpbGwgZW5kIGF0IHRoaXMgcG9zaXRpb25cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fbG9vcEVuZCA9IG9wdGlvbnMubG9vcEVuZDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICB0aGUgcGxheWJhY2sgcmF0ZVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKiAgQHR5cGUge251bWJlcn1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIEVuYWJsaW5nIHJldHJpZ2dlciB3aWxsIGFsbG93IGEgcGxheWVyIHRvIGJlIHJlc3RhcnRlZFxuXHRcdFx0ICogIGJlZm9yZSB0aGUgdGhlIHByZXZpb3VzICdzdGFydCcgaXMgZG9uZSBwbGF5aW5nLiBPdGhlcndpc2UsIFxuXHRcdFx0ICogIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gVG9uZS5QbGF5ZXIuc3RhcnQgd2lsbCBvbmx5IHN0YXJ0XG5cdFx0XHQgKiAgdGhlIHNhbXBsZSBpZiBpdCBoYWQgcGxheWVkIGFsbCB0aGUgd2F5IHRocm91Z2guIFxuXHRcdFx0ICogIEB0eXBlIHtib29sZWFufVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5yZXRyaWdnZXIgPSBvcHRpb25zLnJldHJpZ2dlcjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgZmFkZUluIHRpbWUgb2YgdGhlIGFtcGxpdHVkZSBlbnZlbG9wZS5cblx0XHRcdCAqICBAdHlwZSB7VGltZX1cblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuZmFkZUluID0gb3B0aW9ucy5mYWRlSW47XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiAgVGhlIGZhZGVPdXQgdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdFx0ICogIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5mYWRlT3V0ID0gb3B0aW9ucy5mYWRlT3V0O1xuXHQgICAgfTtcblx0ICAgIFRvbmUuZXh0ZW5kKFRvbmUuUGxheWVyLCBUb25lLlNvdXJjZSk7XG5cdCAgICAvKipcblx0XHQgKiAgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqICBAc3RhdGljXG5cdFx0ICogIEBjb25zdFxuXHRcdCAqICBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ29ubG9hZCc6IFRvbmUubm9PcCxcblx0ICAgICAgICAncGxheWJhY2tSYXRlJzogMSxcblx0ICAgICAgICAnbG9vcCc6IGZhbHNlLFxuXHQgICAgICAgICdhdXRvc3RhcnQnOiBmYWxzZSxcblx0ICAgICAgICAnbG9vcFN0YXJ0JzogMCxcblx0ICAgICAgICAnbG9vcEVuZCc6IDAsXG5cdCAgICAgICAgJ3JldHJpZ2dlcic6IGZhbHNlLFxuXHQgICAgICAgICdyZXZlcnNlJzogZmFsc2UsXG5cdCAgICAgICAgJ2ZhZGVJbic6IDAsXG5cdCAgICAgICAgJ2ZhZGVPdXQnOiAwXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIExvYWQgdGhlIGF1ZGlvIGZpbGUgYXMgYW4gYXVkaW8gYnVmZmVyLlxuXHRcdCAqICBEZWNvZGVzIHRoZSBhdWRpbyBhc3luY2hyb25vdXNseSBhbmQgaW52b2tlc1xuXHRcdCAqICB0aGUgY2FsbGJhY2sgb25jZSB0aGUgYXVkaW8gYnVmZmVyIGxvYWRzLiBcblx0XHQgKiAgTm90ZTogdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCBpZiBhIHVybFxuXHRcdCAqICB3YXMgcGFzc2VkIGluIHRvIHRoZSBjb25zdHJ1Y3Rvci4gT25seSB1c2UgdGhpc1xuXHRcdCAqICBpZiB5b3Ugd2FudCB0byBtYW51YWxseSBsb2FkIGEgbmV3IHVybC4gXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgdXJsIG9mIHRoZSBidWZmZXIgdG8gbG9hZC5cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgIEZpbGV0eXBlIHN1cHBvcnQgZGVwZW5kcyBvbiB0aGVcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuXG5cdFx0ICogIEBwYXJhbSAge2Z1bmN0aW9uPX0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBvbmNlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNhbXBsZSBpcyBsb2FkZWQuXG5cdFx0ICogIEByZXR1cm5zIHtQcm9taXNlfVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubG9hZCh1cmwsIHRoaXMuX29ubG9hZC5iaW5kKHRoaXMsIGNhbGxiYWNrKSk7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSW50ZXJuYWwgY2FsbGJhY2sgd2hlbiB0aGUgYnVmZmVyIGlzIGxvYWRlZC5cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXIucHJvdG90eXBlLl9vbmxvYWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0ICAgICAgICBjYWxsYmFjayA9IFRvbmUuZGVmYXVsdEFyZyhjYWxsYmFjaywgVG9uZS5ub09wKTtcblx0ICAgICAgICBjYWxsYmFjayh0aGlzKTtcblx0ICAgICAgICBpZiAodGhpcy5hdXRvc3RhcnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgUGxheSB0aGUgYnVmZmVyIGF0IHRoZSBnaXZlbiBzdGFydFRpbWUuIE9wdGlvbmFsbHkgYWRkIGFuIG9mZnNldFxuXHRcdCAqICBhbmQvb3IgZHVyYXRpb24gd2hpY2ggd2lsbCBwbGF5IHRoZSBidWZmZXIgZnJvbSBhIHBvc2l0aW9uXG5cdFx0ICogIHdpdGhpbiB0aGUgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb24uIFxuXHRcdCAqICBcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3N0YXJ0VGltZT1ub3ddIFdoZW4gdGhlIHBsYXllciBzaG91bGQgc3RhcnQuXG5cdFx0ICogIEBwYXJhbSAge1RpbWV9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNhbXBsZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gc3RhcnQgYXQuIFxuXHRcdCAqICBAcGFyYW0gIHtUaW1lPX0gZHVyYXRpb24gSG93IGxvbmcgdGhlIHNhbXBsZSBzaG91bGQgcGxheS4gSWYgbm8gZHVyYXRpb25cblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgZ2l2ZW4sIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgZnVsbCBsZW5ndGggXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBzYW1wbGUgKG1pbnVzIGFueSBvZmZzZXQpXG5cdFx0ICogIEByZXR1cm5zIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogIEBtZXRob2Qgc3RhcnRcblx0XHQgKiAgQG5hbWUgc3RhcnRcblx0XHQgKi9cblx0ICAgIC8qKlxuXHRcdCAqICBJbnRlcm5hbCBzdGFydCBtZXRob2Rcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbiAoc3RhcnRUaW1lLCBvZmZzZXQsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgLy9pZiBpdCdzIGEgbG9vcCB0aGUgZGVmYXVsdCBvZmZzZXQgaXMgdGhlIGxvb3BzdGFydCBwb2ludFxuXHQgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG5cdCAgICAgICAgICAgIG9mZnNldCA9IFRvbmUuZGVmYXVsdEFyZyhvZmZzZXQsIHRoaXMuX2xvb3BTdGFydCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy9vdGhlcndpc2UgdGhlIGRlZmF1bHQgb2Zmc2V0IGlzIDBcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gVG9uZS5kZWZhdWx0QXJnKG9mZnNldCwgMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vY29tcHV0ZSB0aGUgdmFsdWVzIGluIHNlY29uZHNcblx0ICAgICAgICBvZmZzZXQgPSB0aGlzLnRvU2Vjb25kcyhvZmZzZXQpO1xuXHQgICAgICAgIGR1cmF0aW9uID0gVG9uZS5kZWZhdWx0QXJnKGR1cmF0aW9uLCBNYXRoLm1heCh0aGlzLl9idWZmZXIuZHVyYXRpb24gLSBvZmZzZXQsIDApKTtcblx0ICAgICAgICBkdXJhdGlvbiA9IHRoaXMudG9TZWNvbmRzKGR1cmF0aW9uKTtcblx0ICAgICAgICBzdGFydFRpbWUgPSB0aGlzLnRvU2Vjb25kcyhzdGFydFRpbWUpO1xuXHQgICAgICAgIC8vIC8vbWFrZSB0aGUgc291cmNlXG5cdCAgICAgICAgdGhpcy5fc291cmNlID0gbmV3IFRvbmUuQnVmZmVyU291cmNlKHtcblx0ICAgICAgICAgICAgJ2J1ZmZlcic6IHRoaXMuX2J1ZmZlcixcblx0ICAgICAgICAgICAgJ2xvb3AnOiB0aGlzLl9sb29wLFxuXHQgICAgICAgICAgICAnbG9vcFN0YXJ0JzogdGhpcy5fbG9vcFN0YXJ0LFxuXHQgICAgICAgICAgICAnbG9vcEVuZCc6IHRoaXMuX2xvb3BFbmQsXG5cdCAgICAgICAgICAgICdwbGF5YmFja1JhdGUnOiB0aGlzLl9wbGF5YmFja1JhdGUsXG5cdCAgICAgICAgICAgICdmYWRlSW4nOiB0aGlzLmZhZGVJbixcblx0ICAgICAgICAgICAgJ2ZhZGVPdXQnOiB0aGlzLmZhZGVPdXRcblx0ICAgICAgICB9KS5jb25uZWN0KHRoaXMub3V0cHV0KTtcblx0ICAgICAgICAvL3NldCB0aGUgbG9vcGluZyBwcm9wZXJ0aWVzXG5cdCAgICAgICAgaWYgKCF0aGlzLl9sb29wICYmICF0aGlzLl9zeW5jZWQpIHtcblx0ICAgICAgICAgICAgLy9pZiBpdCdzIG5vdCBsb29waW5nLCBzZXQgdGhlIHN0YXRlIGNoYW5nZSBhdCB0aGUgZW5kIG9mIHRoZSBzYW1wbGVcblx0ICAgICAgICAgICAgdGhpcy5fc3RhdGUuc2V0U3RhdGVBdFRpbWUoVG9uZS5TdGF0ZS5TdG9wcGVkLCBzdGFydFRpbWUgKyBkdXJhdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vc3RhcnQgaXRcblx0ICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2Uuc3RhcnQoc3RhcnRUaW1lLCBvZmZzZXQpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5zdGFydChzdGFydFRpbWUsIG9mZnNldCwgZHVyYXRpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgU3RvcCBwbGF5YmFjay5cblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKiAgQHBhcmFtICB7VGltZX0gW3RpbWU9bm93XVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVyLnByb3RvdHlwZS5fc3RvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9zb3VyY2Uuc3RvcCh0aGlzLnRvU2Vjb25kcyh0aW1lKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBTZWVrIHRvIGEgc3BlY2lmaWMgdGltZSBpbiB0aGUgcGxheWVyJ3MgYnVmZmVyLiBJZiB0aGUgXG5cdFx0ICogIHNvdXJjZSBpcyBubyBsb25nZXIgcGxheWluZyBhdCB0aGF0IHRpbWUsIGl0IHdpbGwgc3RvcC5cblx0XHQgKiAgSWYgeW91IHNlZWsgdG8gYSB0aW1lIHRoYXQgXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gb2Zmc2V0IFRoZSB0aW1lIHRvIHNlZWsgdG8uXG5cdFx0ICogIEBwYXJhbSB7VGltZT19IHRpbWUgVGhlIHRpbWUgZm9yIHRoZSBzZWVrIGV2ZW50IHRvIG9jY3VyLlxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlBsYXllcn0gdGhpc1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIHNvdXJjZS5zdGFydCgwLjIpO1xuXHRcdCAqIHNvdXJjZS5zdG9wKDAuNCk7XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuc2VlayA9IGZ1bmN0aW9uIChvZmZzZXQsIHRpbWUpIHtcblx0ICAgICAgICB0aW1lID0gdGhpcy50b1NlY29uZHModGltZSk7XG5cdCAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmdldFZhbHVlQXRUaW1lKHRpbWUpID09PSBUb25lLlN0YXRlLlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b1NlY29uZHMob2Zmc2V0KTtcblx0ICAgICAgICAgICAgLy8gaWYgaXQncyBjdXJyZW50bHkgcGxheWluZywgc3RvcCBpdFxuXHQgICAgICAgICAgICB0aGlzLl9zdG9wKHRpbWUpO1xuXHQgICAgICAgICAgICAvL3Jlc3RhcnQgaXQgYXQgdGhlIGdpdmVuIHRpbWVcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIFNldCB0aGUgbG9vcCBzdGFydCBhbmQgZW5kLiBXaWxsIG9ubHkgbG9vcCBpZiBsb29wIGlzIFxuXHRcdCAqICBzZXQgdG8gdHJ1ZS4gXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gbG9vcFN0YXJ0IFRoZSBsb29wIGVuZCB0aW1lXG5cdFx0ICogIEBwYXJhbSB7VGltZX0gbG9vcEVuZCBUaGUgbG9vcCBlbmQgdGltZVxuXHRcdCAqICBAcmV0dXJucyB7VG9uZS5QbGF5ZXJ9IHRoaXNcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAvL2xvb3AgMC4xIHNlY29uZHMgb2YgdGhlIGZpbGUuIFxuXHRcdCAqIHBsYXllci5zZXRMb29wUG9pbnRzKDAuMiwgMC4zKTtcblx0XHQgKiBwbGF5ZXIubG9vcCA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuc2V0TG9vcFBvaW50cyA9IGZ1bmN0aW9uIChsb29wU3RhcnQsIGxvb3BFbmQpIHtcblx0ICAgICAgICB0aGlzLmxvb3BTdGFydCA9IGxvb3BTdGFydDtcblx0ICAgICAgICB0aGlzLmxvb3BFbmQgPSBsb29wRW5kO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGxvb3AgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBzdGFydCBhdCB0aGlzIHBvc2l0aW9uLiBcblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcFN0YXJ0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXIucHJvdG90eXBlLCAnbG9vcFN0YXJ0Jywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcFN0YXJ0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcFN0YXJ0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvb3BTdGFydCA9IGxvb3BTdGFydDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BTdGFydCA9IHRoaXMudG9TZWNvbmRzKGxvb3BTdGFydCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGxvb3AgaXMgdHJ1ZSwgdGhlIGxvb3Agd2lsbCBlbmQgYXQgdGhpcyBwb3NpdGlvbi5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge1RpbWV9XG5cdFx0ICogQG5hbWUgbG9vcEVuZFxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ2xvb3BFbmQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb29wRW5kO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobG9vcEVuZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sb29wRW5kID0gbG9vcEVuZDtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmxvb3BFbmQgPSB0aGlzLnRvU2Vjb25kcyhsb29wRW5kKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGF1ZGlvIGJ1ZmZlciBiZWxvbmdpbmcgdG8gdGhlIHBsYXllci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtUb25lLkJ1ZmZlcn1cblx0XHQgKiBAbmFtZSBidWZmZXJcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdidWZmZXInLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXI7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChidWZmZXIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnNldChidWZmZXIpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogSWYgdGhlIGJ1ZmZlciBzaG91bGQgbG9vcCBvbmNlIGl0J3Mgb3Zlci4gXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVyI1xuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBuYW1lIGxvb3Bcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdsb29wJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKGxvb3ApIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9vcCA9IGxvb3A7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5sb29wID0gbG9vcDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHBsYXliYWNrIHNwZWVkLiAxIGlzIG5vcm1hbCBzcGVlZC4gVGhpcyBpcyBub3QgYSBzaWduYWwgYmVjYXVzZVxuXHRcdCAqIFNhZmFyaSBhbmQgaU9TIGN1cnJlbnRseSBkb24ndCBzdXBwb3J0IHBsYXliYWNrUmF0ZSBhcyBhIHNpZ25hbC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge251bWJlcn1cblx0XHQgKiBAbmFtZSBwbGF5YmFja1JhdGVcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdwbGF5YmFja1JhdGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1JhdGU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyYXRlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3BsYXliYWNrUmF0ZSA9IHJhdGU7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByYXRlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBUaGUgZGlyZWN0aW9uIHRoZSBidWZmZXIgc2hvdWxkIHBsYXkgaW5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5QbGF5ZXIjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgcmV2ZXJzZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVyLnByb3RvdHlwZSwgJ3JldmVyc2UnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIucmV2ZXJzZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHJldikge1xuXHQgICAgICAgICAgICB0aGlzLl9idWZmZXIucmV2ZXJzZSA9IHJldjtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIElmIGFsbCB0aGUgYnVmZmVyIGlzIGxvYWRlZFxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlBsYXllciNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllci5wcm90b3R5cGUsICdsb2FkZWQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWZmZXIubG9hZGVkO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogIERpc3Bvc2UgYW5kIGRpc2Nvbm5lY3QuXG5cdFx0ICogIEByZXR1cm4ge1RvbmUuUGxheWVyfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBUb25lLlNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIGlmICh0aGlzLl9zb3VyY2UgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fc291cmNlID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYnVmZmVyLmRpc3Bvc2UoKTtcblx0ICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUb25lLlBsYXllcjtcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlBsYXllcnMgY29tYmluZXMgbXVsdGlwbGUgW1RvbmUuUGxheWVyXShQbGF5ZXIpIG9iamVjdHMuXG5cdFx0ICpcblx0XHQgKiAgQGNvbnN0cnVjdG9yXG5cdFx0ICogIEBleHRlbmRzIHtUb25lLkF1ZGlvTm9kZX1cblx0XHQgKiAgQHBhcmFtIHtPYmplY3R9IHVybHMgQW4gb2JqZWN0IG1hcHBpbmcgYSBuYW1lIHRvIGEgdXJsLlxuXHRcdCAqICBAcGFyYW0ge2Z1bmN0aW9uPX0gb25sb2FkIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiBhbGwgYnVmZmVycyBhcmUgbG9hZGVkLlxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzID0gZnVuY3Rpb24gKHVybHMpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgYXJncy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmdzLCBbJ29ubG9hZCddLCBUb25lLlBsYXllcnMpO1xuXHQgICAgICAgIFRvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgb3V0cHV0IHZvbHVtZSBub2RlXG5cdFx0XHQgKiAgQHR5cGUgIHtUb25lLlZvbHVtZX1cblx0XHRcdCAqICBAcHJpdmF0ZVxuXHRcdFx0ICovXG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gdGhpcy5vdXRwdXQgPSBuZXcgVG9uZS5Wb2x1bWUob3B0aW9ucy52b2x1bWUpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogVGhlIHZvbHVtZSBvZiB0aGUgb3V0cHV0IGluIGRlY2liZWxzLlxuXHRcdFx0ICogQHR5cGUge0RlY2liZWxzfVxuXHRcdFx0ICogQHNpZ25hbFxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHNvdXJjZS52b2x1bWUudmFsdWUgPSAtNjtcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gdGhpcy5fdm9sdW1lLnZvbHVtZTtcblx0ICAgICAgICB0aGlzLl9yZWFkT25seSgndm9sdW1lJyk7XG5cdCAgICAgICAgLy9tYWtlIHRoZSBvdXRwdXQgZXhwbGljaXRseSBzdGVyZW9cblx0ICAgICAgICB0aGlzLl92b2x1bWUub3V0cHV0Lm91dHB1dC5jaGFubmVsQ291bnQgPSAyO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5vdXRwdXQub3V0cHV0LmNoYW5uZWxDb3VudE1vZGUgPSAnZXhwbGljaXQnO1xuXHQgICAgICAgIC8vbXV0ZSBpbml0aWFsbHlcblx0ICAgICAgICB0aGlzLm11dGUgPSBvcHRpb25zLm11dGU7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgY29udGFpbmVyIG9mIGFsbCBvZiB0aGUgcGxheWVyc1xuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9wbGF5ZXJzID0ge307XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgbG9hZGluZyBjb3VudFxuXHRcdFx0ICogQHR5cGUge051bWJlcn1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9sb2FkaW5nQ291bnQgPSAwO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogcHJpdmF0ZSBob2xkZXIgb2YgdGhlIGZhZGVJbiB0aW1lXG5cdFx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHRcdCAqIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9mYWRlSW4gPSBvcHRpb25zLmZhZGVJbjtcblx0ICAgICAgICAvKipcblx0XHRcdCAqIHByaXZhdGUgaG9sZGVyIG9mIHRoZSBmYWRlT3V0IHRpbWVcblx0XHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdFx0ICogQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX2ZhZGVPdXQgPSBvcHRpb25zLmZhZGVPdXQ7XG5cdCAgICAgICAgLy9hZGQgYWxsIG9mIHRoZSBwbGF5ZXJzXG5cdCAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB1cmxzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudCsrO1xuXHQgICAgICAgICAgICB0aGlzLmFkZChuYW1lLCB1cmxzW25hbWVdLCB0aGlzLl9idWZmZXJMb2FkZWQuYmluZCh0aGlzLCBvcHRpb25zLm9ubG9hZCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlBsYXllcnMsIFRvbmUuQXVkaW9Ob2RlKTtcblx0ICAgIC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IHZhbHVlc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMuZGVmYXVsdHMgPSB7XG5cdCAgICAgICAgJ3ZvbHVtZSc6IDAsXG5cdCAgICAgICAgJ211dGUnOiBmYWxzZSxcblx0ICAgICAgICAnb25sb2FkJzogVG9uZS5ub09wLFxuXHQgICAgICAgICdmYWRlSW4nOiAwLFxuXHQgICAgICAgICdmYWRlT3V0JzogMFxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBBIGJ1ZmZlciB3YXMgbG9hZGVkLiBkZWNyZW1lbnQgdGhlIGNvdW50ZXIuXG5cdFx0ICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2tcblx0XHQgKiAgQHByaXZhdGVcblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuX2J1ZmZlckxvYWRlZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIHRoaXMuX2xvYWRpbmdDb3VudC0tO1xuXHQgICAgICAgIGlmICh0aGlzLl9sb2FkaW5nQ291bnQgPT09IDAgJiYgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgY2FsbGJhY2sodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Tb3VyY2UjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiBzb3VyY2UubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ211dGUnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl92b2x1bWUubXV0ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKG11dGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdm9sdW1lLm11dGUgPSBtdXRlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGZhZGVJbiB0aW1lIG9mIHRoZSBhbXBsaXR1ZGUgZW52ZWxvcGUuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuU291cmNlI1xuXHRcdCAqIEB0eXBlIHtUaW1lfVxuXHRcdCAqIEBuYW1lIGZhZGVJblxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuUGxheWVycy5wcm90b3R5cGUsICdmYWRlSW4nLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWRlSW47XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChmYWRlSW4pIHtcblx0ICAgICAgICAgICAgdGhpcy5fZmFkZUluID0gZmFkZUluO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHBsYXllci5mYWRlSW4gPSBmYWRlSW47XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIGZhZGVPdXQgdGltZSBvZiB0aGUgYW1wbGl0dWRlIGVudmVsb3BlLlxuXHRcdCAqIEBtZW1iZXJPZiBUb25lLlNvdXJjZSNcblx0XHQgKiBAdHlwZSB7VGltZX1cblx0XHQgKiBAbmFtZSBmYWRlT3V0XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ2ZhZGVPdXQnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWRlT3V0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZmFkZU91dCkge1xuXHQgICAgICAgICAgICB0aGlzLl9mYWRlT3V0ID0gZmFkZU91dDtcblx0ICAgICAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG5cdCAgICAgICAgICAgICAgICBwbGF5ZXIuZmFkZU91dCA9IGZhZGVPdXQ7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogVGhlIHN0YXRlIG9mIHRoZSBwbGF5ZXJzIG9iamVjdC4gUmV0dXJucyBcInN0YXJ0ZWRcIiBpZiBhbnkgb2YgdGhlIHBsYXllcnMgYXJlIHBsYXlpbmcuXG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVycyNcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBuYW1lIHN0YXRlXG5cdFx0ICogQHJlYWRPbmx5XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5QbGF5ZXJzLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGxheWluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIHBsYXlpbmcgPSBwbGF5aW5nIHx8IHBsYXllci5zdGF0ZSA9PT0gVG9uZS5TdGF0ZS5TdGFydGVkO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHBsYXlpbmcgPyBUb25lLlN0YXRlLlN0YXJ0ZWQgOiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiAgVHJ1ZSBpZiB0aGUgYnVmZmVycyBvYmplY3QgaGFzIGEgYnVmZmVyIGJ5IHRoYXQgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gIG5hbWUgIFRoZSBrZXkgb3IgaW5kZXggb2YgdGhlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuXG5cdFx0ICogIEByZXR1cm4gIHtCb29sZWFufVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wbGF5ZXJzLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBHZXQgYSBwbGF5ZXIgYnkgbmFtZS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgVGhlIHBsYXllcnMgbmFtZSBhcyBkZWZpbmVkIGluXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjb25zdHJ1Y3RvciBvYmplY3Qgb3IgYGFkZGAgbWV0aG9kLlxuXHRcdCAqICBAcmV0dXJuICB7VG9uZS5QbGF5ZXJ9XG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF5ZXJzW25hbWVdO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5QbGF5ZXJzOiBubyBwbGF5ZXIgbmFtZWQgJyArIG5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBwbGF5ZXJzXG5cdFx0ICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdFx0ICogQHJldHVybiB7VG9uZS5QbGF5ZXJzfSAgICAgICAgICAgIHRoaXNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHQgICAgVG9uZS5QbGF5ZXJzLnByb3RvdHlwZS5fZm9yRWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHQgICAgICAgIGZvciAodmFyIHBsYXllck5hbWUgaW4gdGhpcy5fcGxheWVycykge1xuXHQgICAgICAgICAgICBjYWxsYmFjayh0aGlzLl9wbGF5ZXJzW3BsYXllck5hbWVdLCBwbGF5ZXJOYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogSWYgYWxsIHRoZSBidWZmZXJzIGFyZSBsb2FkZWQgb3Igbm90XG5cdFx0ICogQG1lbWJlck9mIFRvbmUuUGxheWVycyNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAbmFtZSBsb2FkZWRcblx0XHQgKiBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlBsYXllcnMucHJvdG90eXBlLCAnbG9hZGVkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgaXNMb2FkZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB0aGlzLl9mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcblx0ICAgICAgICAgICAgICAgIGlzTG9hZGVkID0gaXNMb2FkZWQgJiYgcGxheWVyLmxvYWRlZDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBpc0xvYWRlZDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqICBBZGQgYSBwbGF5ZXIgYnkgbmFtZSBhbmQgdXJsIHRvIHRoZSBQbGF5ZXJzXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSAgICAgIEEgdW5pcXVlIG5hbWUgdG8gZ2l2ZSB0aGUgcGxheWVyXG5cdFx0ICogIEBwYXJhbSAge1N0cmluZ3xUb25lLkJ1ZmZlcnxBdWRpb2J1ZmZlcn0gIHVybCAgRWl0aGVyIHRoZSB1cmwgb2YgdGhlIGJ1ZmVyLFxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGEgYnVmZmVyIHdoaWNoIHdpbGwgYmUgYWRkZWRcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuXHRcdCAqICBAcGFyYW0gIHtGdW5jdGlvbj19ICBjYWxsYmFjayAgVGhlIGNhbGxiYWNrIHRvIGludm9rZVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiB0aGUgdXJsIGlzIGxvYWRlZC5cblx0XHQgKi9cblx0ICAgIFRvbmUuUGxheWVycy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIHVybCwgY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9wbGF5ZXJzW25hbWVdID0gbmV3IFRvbmUuUGxheWVyKHVybCwgY2FsbGJhY2spLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnNbbmFtZV0uZmFkZUluID0gdGhpcy5fZmFkZUluO1xuXHQgICAgICAgIHRoaXMuX3BsYXllcnNbbmFtZV0uZmFkZU91dCA9IHRoaXMuX2ZhZGVPdXQ7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogU3RvcCBhbGwgb2YgdGhlIHBsYXllcnMgYXQgdGhlIGdpdmVuIHRpbWVcblx0XHQgKiBAcGFyYW0ge1RpbWV9IHRpbWUgVGhlIHRpbWUgdG8gc3RvcCBhbGwgb2YgdGhlIHBsYXllcnMuXG5cdFx0ICogQHJldHVybiB7VG9uZS5QbGF5ZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAodGltZSkge1xuXHQgICAgICAgIHRoaXMuX2ZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuXHQgICAgICAgICAgICBwbGF5ZXIuc3RvcCh0aW1lKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgRGlzcG9zZSBhbmQgZGlzY29ubmVjdC5cblx0XHQgKiAgQHJldHVybiB7VG9uZS5QbGF5ZXJzfSB0aGlzXG5cdFx0ICovXG5cdCAgICBUb25lLlBsYXllcnMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl92b2x1bWUuZGlzcG9zZSgpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMudm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5fZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG5cdCAgICAgICAgICAgIHBsYXllci5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdGhpcy5fcGxheWVycyA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFRvbmUuUGxheWVycztcblx0fSk7XG5cdE1vZHVsZShmdW5jdGlvbiAoVG9uZSkge1xuXHQgICAgXG5cdCAgICAvKipcblx0XHQgKiAgQGNsYXNzICBUb25lLlVzZXJNZWRpYSB1c2VzIE1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgdG8gb3BlbiB1cFxuXHRcdCAqICAgICAgICAgIGFuZCBleHRlcm5hbCBtaWNyb3Bob25lIG9yIGF1ZGlvIGlucHV0LiBDaGVja1xuXHRcdCAqICAgICAgICAgIFtNZWRpYURldmljZXMgQVBJIFN1cHBvcnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhKVxuXHRcdCAqICAgICAgICAgIHRvIHNlZSB3aGljaCBicm93c2VycyBhcmUgc3VwcG9ydGVkLiBBY2Nlc3MgdG8gYW4gZXh0ZXJuYWwgaW5wdXRcblx0XHQgKiAgICAgICAgICBpcyBsaW1pdGVkIHRvIHNlY3VyZSAoSFRUUFMpIGNvbm5lY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogIEBjb25zdHJ1Y3RvclxuXHRcdCAqICBAZXh0ZW5kcyB7VG9uZS5BdWRpb05vZGV9XG5cdFx0ICogIEBwYXJhbSB7RGVjaWJlbHM9fSB2b2x1bWUgVGhlIGxldmVsIG9mIHRoZSBpbnB1dFxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIC8vbGlzdCB0aGUgaW5wdXRzIGFuZCBvcGVuIHRoZSB0aGlyZCBvbmVcblx0XHQgKiB2YXIgbW90dSA9IG5ldyBUb25lLlVzZXJNZWRpYSgpO1xuXHRcdCAqXG5cdFx0ICogLy9vcGVuaW5nIHRoZSBpbnB1dCBhc2tzIHRoZSB1c2VyIHRvIGFjdGl2YXRlIHRoZWlyIG1pY1xuXHRcdCAqIG1vdHUub3BlbigpLnRoZW4oZnVuY3Rpb24oKXtcblx0XHQgKiBcdC8vb3BlbmluZyBpcyBhY3RpdmF0ZXMgdGhlIG1pY3JvcGhvbmVcblx0XHQgKiBcdC8vc3RhcnRpbmcgbGV0cyBhdWRpbyB0aHJvdWdoXG5cdFx0ICogXHRtb3R1LnN0YXJ0KDEwKTtcblx0XHQgKiB9KTtcblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0gVG9uZS5kZWZhdWx0cyhhcmd1bWVudHMsIFsndm9sdW1lJ10sIFRvbmUuVXNlck1lZGlhKTtcblx0ICAgICAgICBUb25lLkF1ZGlvTm9kZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBNZWRpYVN0cmVhbU5vZGVcblx0XHRcdCAqICBAdHlwZSB7TWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGV9XG5cdFx0XHQgKiAgQHByaXZhdGVcblx0XHRcdCAqL1xuXHQgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gbnVsbDtcblx0ICAgICAgICAvKipcblx0XHRcdCAqICBUaGUgbWVkaWEgc3RyZWFtIGNyZWF0ZWQgYnkgZ2V0VXNlck1lZGlhLlxuXHRcdFx0ICogIEB0eXBlIHtMb2NhbE1lZGlhU3RyZWFtfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvcGVuIGRldmljZVxuXHRcdFx0ICogIEB0eXBlICB7TWVkaWFEZXZpY2VJbmZvfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xuXHQgICAgICAgIC8qKlxuXHRcdFx0ICogIFRoZSBvdXRwdXQgdm9sdW1lIG5vZGVcblx0XHRcdCAqICBAdHlwZSAge1RvbmUuVm9sdW1lfVxuXHRcdFx0ICogIEBwcml2YXRlXG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLl92b2x1bWUgPSB0aGlzLm91dHB1dCA9IG5ldyBUb25lLlZvbHVtZShvcHRpb25zLnZvbHVtZSk7XG5cdCAgICAgICAgLyoqXG5cdFx0XHQgKiBUaGUgdm9sdW1lIG9mIHRoZSBvdXRwdXQgaW4gZGVjaWJlbHMuXG5cdFx0XHQgKiBAdHlwZSB7RGVjaWJlbHN9XG5cdFx0XHQgKiBAc2lnbmFsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogaW5wdXQudm9sdW1lLnZhbHVlID0gLTY7XG5cdFx0XHQgKi9cblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZS52b2x1bWU7XG5cdCAgICAgICAgdGhpcy5fcmVhZE9ubHkoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMubXV0ZSA9IG9wdGlvbnMubXV0ZTtcblx0ICAgIH07XG5cdCAgICBUb25lLmV4dGVuZChUb25lLlVzZXJNZWRpYSwgVG9uZS5BdWRpb05vZGUpO1xuXHQgICAgLyoqXG5cdFx0ICogdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdCAgICBUb25lLlVzZXJNZWRpYS5kZWZhdWx0cyA9IHtcblx0ICAgICAgICAndm9sdW1lJzogMCxcblx0ICAgICAgICAnbXV0ZSc6IGZhbHNlXG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIE9wZW4gdGhlIG1lZGlhIHN0cmVhbS4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkIGluLCBpdCBpcyBhc3N1bWVkXG5cdFx0ICogIHRvIGJlIHRoZSBsYWJlbCBvciBpZCBvZiB0aGUgc3RyZWFtLCBpZiBhIG51bWJlciBpcyBwYXNzZWQgaW4sXG5cdFx0ICogIGl0IGlzIHRoZSBpbnB1dCBudW1iZXIgb2YgdGhlIHN0cmVhbS5cblx0XHQgKiAgQHBhcmFtICB7U3RyaW5nfE51bWJlcn0gW2xhYmVsT3JJZD1cImRlZmF1bHRcIl0gVGhlIGxhYmVsIG9yIGlkIG9mIHRoZSBhdWRpbyBpbnB1dCBtZWRpYSBkZXZpY2UuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaXRoIG5vIGFyZ3VtZW50LCB0aGUgZGVmYXVsdCBzdHJlYW0gaXMgb3BlbmVkLlxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aGVuIHRoZSBzdHJlYW0gaXMgb3Blbi5cblx0XHQgKi9cblx0ICAgIFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGxhYmVsT3JJZCkge1xuXHQgICAgICAgIGxhYmVsT3JJZCA9IFRvbmUuZGVmYXVsdEFyZyhsYWJlbE9ySWQsICdkZWZhdWx0Jyk7XG5cdCAgICAgICAgcmV0dXJuIFRvbmUuVXNlck1lZGlhLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXZpY2U7XG5cdCAgICAgICAgICAgIGlmIChUb25lLmlzTnVtYmVyKGxhYmVsT3JJZCkpIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXNbbGFiZWxPcklkXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRldmljZSA9IGRldmljZXMuZmluZChmdW5jdGlvbiAoZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5sYWJlbCA9PT0gbGFiZWxPcklkIHx8IGRldmljZS5kZXZpY2VJZCA9PT0gbGFiZWxPcklkO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAvL2RpZG4ndCBmaW5kIGEgbWF0Y2hpbmcgZGV2aWNlXG5cdCAgICAgICAgICAgICAgICBpZiAoIWRldmljZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9uZS5Vc2VyTWVkaWE6IG5vIG1hdGNoaW5nIGRldmljZTogJyArIGxhYmVsT3JJZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fZGV2aWNlID0gZGV2aWNlO1xuXHQgICAgICAgICAgICAvL2RvIGdldFVzZXJNZWRpYVxuXHQgICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSB7XG5cdCAgICAgICAgICAgICAgICBhdWRpbzoge1xuXHQgICAgICAgICAgICAgICAgICAgICdkZXZpY2VJZCc6IGRldmljZS5kZXZpY2VJZCxcblx0ICAgICAgICAgICAgICAgICAgICAnZWNob0NhbmNlbGxhdGlvbic6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgICdzYW1wbGVSYXRlJzogdGhpcy5jb250ZXh0LnNhbXBsZVJhdGVcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcblx0ICAgICAgICAgICAgICAgIC8vc3RhcnQgYSBuZXcgc291cmNlIG9ubHkgaWYgdGhlIHByZXZpb3VzIG9uZSBpcyBjbG9zZWRcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RyZWFtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vV3JhcCBhIE1lZGlhU3RyZWFtU291cmNlTm9kZSBhcm91bmQgdGhlIGxpdmUgaW5wdXQgc3RyZWFtLlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHN0cmVhbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9Db25uZWN0IHRoZSBNZWRpYVN0cmVhbVNvdXJjZU5vZGUgdG8gYSBnYXRlIGdhaW4gbm9kZVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmNvbm5lY3QodGhpcy5vdXRwdXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0XHQgKiAgQ2xvc2UgdGhlIG1lZGlhIHN0cmVhbVxuXHRcdCAqICBAcmV0dXJuIHtUb25lLlVzZXJNZWRpYX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XG5cdCAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBvbGQgbWVkaWEgc3RyZWFtXG5cdCAgICAgICAgICAgIHRoaXMuX21lZGlhU3RyZWFtLmRpc2Nvbm5lY3QoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW0gPSBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9kZXZpY2UgPSBudWxsO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSBsaXN0IG9mIGF1ZGlvIGlucHV0IGRldmljZXMgYXZhaWxhYmxlLlxuXHRcdCAqICBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIGRldmljZXNcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqIFRvbmUuVXNlck1lZGlhLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uKGRldmljZXMpe1xuXHRcdCAqIFx0Y29uc29sZS5sb2coZGV2aWNlcylcblx0XHQgKiB9KVxuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEuZW51bWVyYXRlRGV2aWNlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuXHQgICAgICAgICAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24gKGRldmljZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCc7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8qKlxuXHRcdCAqICBSZXR1cm5zIHRoZSBwbGF5YmFjayBzdGF0ZSBvZiB0aGUgc291cmNlLCBcInN0YXJ0ZWRcIiB3aGVuIHRoZSBtaWNyb3Bob25lIGlzIG9wZW5cblx0XHQgKiAgYW5kIFwic3RvcHBlZFwiIHdoZW4gdGhlIG1pYyBpcyBjbG9zZWQuXG5cdFx0ICogIEB0eXBlIHtUb25lLlN0YXRlfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBzdGF0ZVxuXHRcdCAqL1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRvbmUuVXNlck1lZGlhLnByb3RvdHlwZSwgJ3N0YXRlJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyZWFtICYmIHRoaXMuX3N0cmVhbS5hY3RpdmUgPyBUb25lLlN0YXRlLlN0YXJ0ZWQgOiBUb25lLlN0YXRlLlN0b3BwZWQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBcdFJldHVybnMgYW4gaWRlbnRpZmllciBmb3IgdGhlIHJlcHJlc2VudGVkIGRldmljZSB0aGF0IGlzXG5cdFx0ICogXHRwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zLiBJdCBpcyB1bi1ndWVzc2FibGUgYnkgb3RoZXIgYXBwbGljYXRpb25zIGFuZFxuXHRcdCAqIFx0dW5pcXVlIHRvIHRoZSBvcmlnaW4gb2YgdGhlIGNhbGxpbmcgYXBwbGljYXRpb24uIEl0IGlzIHJlc2V0IHdoZW4gdGhlXG5cdFx0ICogXHR1c2VyIGNsZWFycyBjb29raWVzIChmb3IgUHJpdmF0ZSBCcm93c2luZywgYSBkaWZmZXJlbnQgaWRlbnRpZmllciBpc1xuXHRcdCAqIFx0dXNlZCB0aGF0IGlzIG5vdCBwZXJzaXN0ZWQgYWNyb3NzIHNlc3Npb25zKS4gUmV0dXJucyB1bmRlZmluZWQgd2hlbiB0aGVcblx0XHQgKiBcdGRldmljZSBpcyBub3Qgb3Blbi5cblx0XHQgKiAgQHR5cGUge1N0cmluZ31cblx0XHQgKiAgQHJlYWRPbmx5XG5cdFx0ICogIEBtZW1iZXJPZiBUb25lLlVzZXJNZWRpYSNcblx0XHQgKiAgQG5hbWUgZGV2aWNlSWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdkZXZpY2VJZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RldmljZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZS5kZXZpY2VJZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLyoqXG5cdFx0ICogXHRSZXR1cm5zIGEgZ3JvdXAgaWRlbnRpZmllci4gVHdvIGRldmljZXMgaGF2ZSB0aGVcblx0XHQgKiBcdHNhbWUgZ3JvdXAgaWRlbnRpZmllciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBwaHlzaWNhbCBkZXZpY2UuXG5cdFx0ICogXHRSZXR1cm5zIHVuZGVmaW5lZCB3aGVuIHRoZSBkZXZpY2UgaXMgbm90IG9wZW4uXG5cdFx0ICogIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogIEByZWFkT25seVxuXHRcdCAqICBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogIEBuYW1lIGdyb3VwSWRcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYS5wcm90b3R5cGUsICdncm91cElkJywge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGV2aWNlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlLmdyb3VwSWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIFx0UmV0dXJucyBhIGxhYmVsIGRlc2NyaWJpbmcgdGhpcyBkZXZpY2UgKGZvciBleGFtcGxlIFwiQnVpbHQtaW4gTWljcm9waG9uZVwiKS5cblx0XHQgKiBcdFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdGhlIGRldmljZSBpcyBub3Qgb3BlbiBvciBsYWJlbCBpcyBub3QgYXZhaWxhYmxlXG5cdFx0ICogXHRiZWNhdXNlIG9mIHBlcm1pc3Npb25zLlxuXHRcdCAqICBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBncm91cElkXG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnbGFiZWwnLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2UubGFiZWw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8qKlxuXHRcdCAqIE11dGUgdGhlIG91dHB1dC5cblx0XHQgKiBAbWVtYmVyT2YgVG9uZS5Vc2VyTWVkaWEjXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQG5hbWUgbXV0ZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogLy9tdXRlIHRoZSBvdXRwdXRcblx0XHQgKiB1c2VyTWVkaWEubXV0ZSA9IHRydWU7XG5cdFx0ICovXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLCAnbXV0ZScsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZS5tdXRlO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAobXV0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl92b2x1bWUubXV0ZSA9IG11dGU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvKipcblx0XHQgKiBDbGVhbiB1cC5cblx0XHQgKiBAcmV0dXJuIHtUb25lLlVzZXJNZWRpYX0gdGhpc1xuXHRcdCAqL1xuXHQgICAgVG9uZS5Vc2VyTWVkaWEucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgVG9uZS5BdWRpb05vZGUucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fd3JpdGFibGUoJ3ZvbHVtZScpO1xuXHQgICAgICAgIHRoaXMuX3ZvbHVtZS5kaXNwb3NlKCk7XG5cdCAgICAgICAgdGhpcy5fdm9sdW1lID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgLyoqXG5cdFx0ICogIElmIGdldFVzZXJNZWRpYSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuXG5cdFx0ICogIEB0eXBlICB7Qm9vbGVhbn1cblx0XHQgKiAgQG1lbWJlck9mIFRvbmUuVXNlck1lZGlhI1xuXHRcdCAqICBAbmFtZSBzdXBwb3J0ZWRcblx0XHQgKiAgQHN0YXRpY1xuXHRcdCAqICBAcmVhZE9ubHlcblx0XHQgKi9cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUb25lLlVzZXJNZWRpYSwgJ3N1cHBvcnRlZCcsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICFUb25lLmlzVW5kZWYobmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgJiYgVG9uZS5pc0Z1bmN0aW9uKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBUb25lLlVzZXJNZWRpYTtcblx0fSk7XG5cdFxuXHRyZXR1cm4gVG9uZTtcbn0pKTsiLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50VmFyaWFibGUge1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBzaGFwZTogbnVtYmVyW107XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgdHlwZSBDaGVja3BvaW50TWFuaWZlc3QgPSB7XG4gIFt2YXJOYW1lOiBzdHJpbmddOiBDaGVja3BvaW50VmFyaWFibGVcbn07XG5cbmNvbnN0IE1BTklGRVNUX0ZJTEUgPSAnbWFuaWZlc3QuanNvbic7XG5cbmV4cG9ydCBjbGFzcyBDaGVja3BvaW50TG9hZGVyIHtcbiAgcHJpdmF0ZSBjaGVja3BvaW50TWFuaWZlc3Q6IENoZWNrcG9pbnRNYW5pZmVzdDtcbiAgcHJpdmF0ZSB2YXJpYWJsZXM6IHtbdmFyTmFtZTogc3RyaW5nXTogTkRBcnJheX07XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB1cmxQYXRoOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy51cmxQYXRoLmNoYXJBdCh0aGlzLnVybFBhdGgubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgdGhpcy51cmxQYXRoICs9ICcvJztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvYWRNYW5pZmVzdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgdGhpcy51cmxQYXRoICsgTUFOSUZFU1RfRklMRSk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke01BTklGRVNUX0ZJTEV9IG5vdCBmb3VuZCBhdCAke3RoaXMudXJsUGF0aH0uIGAgKyBlcnJvcik7XG4gICAgICB9O1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldENoZWNrcG9pbnRNYW5pZmVzdCgpOiBQcm9taXNlPENoZWNrcG9pbnRNYW5pZmVzdD4ge1xuICAgIGlmICh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8Q2hlY2twb2ludE1hbmlmZXN0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMubG9hZE1hbmlmZXN0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxDaGVja3BvaW50TWFuaWZlc3Q+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmUodGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWxsVmFyaWFibGVzKCk6IFByb21pc2U8e1t2YXJOYW1lOiBzdHJpbmddOiBOREFycmF5fT4ge1xuICAgIGlmICh0aGlzLnZhcmlhYmxlcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8e1t2YXJOYW1lOiBzdHJpbmddOiBOREFycmF5fT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlKHRoaXMudmFyaWFibGVzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx7W3Zhck5hbWU6IHN0cmluZ106IE5EQXJyYXl9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmdldENoZWNrcG9pbnRNYW5pZmVzdCgpLnRoZW4oXG4gICAgICAgICAgKGNoZWNrcG9pbnREZWZpbml0aW9uOiBDaGVja3BvaW50TWFuaWZlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlUHJvbWlzZXM6IEFycmF5PFByb21pc2U8TkRBcnJheT4+ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyaWFibGVQcm9taXNlcy5wdXNoKHRoaXMuZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lc1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBQcm9taXNlLmFsbCh2YXJpYWJsZVByb21pc2VzKS50aGVuKHZhcmlhYmxlcyA9PiB7XG4gICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzID0ge307XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVOYW1lc1tpXV0gPSB2YXJpYWJsZXNbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldFZhcmlhYmxlKHZhck5hbWU6IHN0cmluZyk6IFByb21pc2U8TkRBcnJheT4ge1xuICAgIGlmICghKHZhck5hbWUgaW4gdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIG5vbi1leGlzdGFudCB2YXJpYWJsZSAnICsgdmFyTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCA9XG4gICAgICAgIChyZXNvbHZlOiAobmRhcnJheTogTkRBcnJheSkgPT4gdm9pZCwgcmVqZWN0OiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgY29uc3QgZm5hbWUgPSB0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5maWxlbmFtZTtcbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdGhpcy51cmxQYXRoICsgZm5hbWUpO1xuXG4gICAgICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IG5kYXJyYXkgPVxuICAgICAgICAgICAgICAgIE5EQXJyYXkubWFrZSh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5zaGFwZSwge3ZhbHVlc30pO1xuICAgICAgICAgICAgcmVzb2x2ZShuZGFycmF5KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHhoci5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBmZXRjaCB2YXJpYWJsZSAnICsgdmFyTmFtZSArICc6ICcgKyBlcnJvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9O1xuXG4gICAgaWYgKHRoaXMuY2hlY2twb2ludE1hbmlmZXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxOREFycmF5PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMubG9hZE1hbmlmZXN0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgbmV3IFByb21pc2U8TkRBcnJheT4odmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPE5EQXJyYXk+KHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBTVEFUU19TQU1QTEVfUEVSQ0VOVEFHRSA9IDAuMTtcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhU3RhdHMge1xuICBleGFtcGxlQ291bnQ6IG51bWJlcjtcbiAgaW5wdXRNaW46IG51bWJlcjtcbiAgaW5wdXRNYXg6IG51bWJlcjtcbiAgc2hhcGU6IG51bWJlcltdO1xufVxuXG5pbnRlcmZhY2UgTm9ybWFsaXphdGlvbkluZm8ge1xuICBpc05vcm1hbGl6ZWQ6IGJvb2xlYW47XG4gIC8vIEJvdW5kcyBvZiB0aGUgbm9ybWFsaXphdGlvbiBpZiBub3JtYWxpemVkLlxuICBsb3dlckJvdW5kPzogbnVtYmVyO1xuICB1cHBlckJvdW5kPzogbnVtYmVyO1xuICAvLyBNaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBmb3IgZWFjaCBkaW1lbnNpb24gb2YgdGhlIG9yaWdpbmFsIGRhdGEuIFRoZXNlXG4gIC8vIGFyZSB0aGUgc2FtZSBzaXplIGFzIGFuIGlucHV0IGV4YW1wbGUuIFRoZXNlIGFyZSBjb21wdXRlZCBsYXppbHksIG9ubHkgaWZcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyByZXF1ZXN0ZWQuIElmIHRoZSBkYXRhIGlzIHVuLW5vcm1hbGl6ZWQsIHRoZXNlIGFyZSBrZXB0XG4gIC8vIGFyb3VuZCBzbyB0aGV5IGRvbid0IGhhdmUgdG8gYmUgcmVjb21wdXRlZC5cbiAgbWluVmFsdWVzOiBGbG9hdDMyQXJyYXk7XG4gIG1heFZhbHVlczogRmxvYXQzMkFycmF5O1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5NZW1vcnlEYXRhc2V0IHtcbiAgcHJvdGVjdGVkIGRhdGFzZXQ6IE5EQXJyYXlbXVtdfG51bGw7XG5cbiAgLy8gQ29udGFpbnMgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IGZvciByZWNvbnN0cnVjdGlvbiBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICAvLyBhZnRlciBub3JtYWxpemF0aW9uLlxuICBwcml2YXRlIG5vcm1hbGl6YXRpb25JbmZvOiB7W2RhdGFJbmRleDogbnVtYmVyXTogTm9ybWFsaXphdGlvbkluZm99O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkYXRhU2hhcGVzOiBudW1iZXJbXVtdKSB7XG4gICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mbyA9IHt9O1xuICB9XG5cbiAgZ2V0RGF0YVNoYXBlKGRhdGFJbmRleDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiB0aGlzLmRhdGFTaGFwZXNbZGF0YUluZGV4XTtcbiAgfVxuXG4gIGFic3RyYWN0IGZldGNoRGF0YSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGdldERhdGEoKTogTkRBcnJheVtdW118bnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXNldDtcbiAgfVxuXG4gIGdldFN0YXRzKCk6IERhdGFTdGF0c1tdIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFzZXQubWFwKGQgPT4gdGhpcy5nZXRTdGF0c0ZvckRhdGEoZCkpO1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgc3RhdHMgYWNyb3NzIGEgc2FtcGxlZCBwb3J0aW9uIG9mIHRoZSBkYXRhLlxuICBwcml2YXRlIGdldFN0YXRzRm9yRGF0YShkYXRhOiBOREFycmF5W10pOiBEYXRhU3RhdHMge1xuICAgIGxldCBpbnB1dE1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaW5wdXRNYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICBsZXQgZXhhbXBsZUluZGljZXMgPSBkYXRhLm1hcCgoZXhhbXBsZSwgaSkgPT4gaSk7XG4gICAgdXRpbC5zaHVmZmxlKGV4YW1wbGVJbmRpY2VzKTtcbiAgICBleGFtcGxlSW5kaWNlcyA9XG4gICAgICAgIGV4YW1wbGVJbmRpY2VzLnNsaWNlKGV4YW1wbGVJbmRpY2VzLmxlbmd0aCAqIFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhhbXBsZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWVzID0gZGF0YVtleGFtcGxlSW5kaWNlc1tpXV0uZ2V0VmFsdWVzKCk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0VmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlucHV0TWluID0gTWF0aC5taW4oaW5wdXRNaW4sIGlucHV0VmFsdWVzW2pdKTtcbiAgICAgICAgaW5wdXRNYXggPSBNYXRoLm1heChpbnB1dE1heCwgaW5wdXRWYWx1ZXNbal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbnB1dE1pbixcbiAgICAgIGlucHV0TWF4LFxuICAgICAgZXhhbXBsZUNvdW50OiBkYXRhLmxlbmd0aCxcbiAgICAgIHNoYXBlOiBkYXRhWzBdLnNoYXBlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGV4YW1wbGVzIE5EQXJyYXlzIHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEBwYXJhbSBjdXJMb3dlckJvdW5kcyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBtaW5pbXVtIHZhbHVlIGZvciBlYWNoXG4gICAqIGRpbWVuc2lvbiBvciBhIGZpeGVkIG1pbmltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSBjdXJVcHBlckJvdW5kcyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBtYXhpbXVtIHZhbHVlIGZvciBlYWNoXG4gICAqIGRpbWVuc2lvbiBvciBhIGZpeGVkIG1heGltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSBuZXdMb3dlckJvdW5kcyBBbiBhcnJheSBjb250YWluaW5nIG5ldyBtaW5pbXVtIHZhbHVlcyBmb3IgZWFjaFxuICAgKiBkaW1lbnNpb24sIG9yIGEgZml4ZWQgbWludW11bSB2YWx1ZSB0byBub3JtYWxpemUgdGhlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSBuZXdVcHBlckJvdW5kcyBBbiBhcnJheSBjb250YWluaW5nIG5ldyBtYXhpbXVtIHZhbHVlcyBmb3IgZWFjaFxuICAgKiBkaW1lbnNpb24sIG9yIGEgZml4ZWQgbWF4aW11bSB2YWx1ZSB0byBub3JtYWxpemUgdGhlIGRhdGEgdG8uXG4gICAqL1xuICBwcml2YXRlIG5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShcbiAgICAgIGV4YW1wbGVzOiBOREFycmF5W10sIGN1ckxvd2VyQm91bmRzOiBGbG9hdDMyQXJyYXl8bnVtYmVyLFxuICAgICAgY3VyVXBwZXJCb3VuZHM6IEZsb2F0MzJBcnJheXxudW1iZXIsIG5ld0xvd2VyQm91bmRzOiBGbG9hdDMyQXJyYXl8bnVtYmVyLFxuICAgICAgbmV3VXBwZXJCb3VuZHM6IEZsb2F0MzJBcnJheXxudW1iZXIpOiBOREFycmF5W10ge1xuICAgIGNvbnN0IGN1ckJvdW5kc0lzUGVyRGltZW5zaW9uID1cbiAgICAgICAgKGN1clVwcGVyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICBjdXJMb3dlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgY29uc3QgbmV3Qm91bmRzSXNQZXJEaW1lbnNpb24gPVxuICAgICAgICAobmV3TG93ZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgIG5ld1VwcGVyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcblxuICAgIGNvbnN0IGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShleGFtcGxlc1swXS5zaGFwZSk7XG4gICAgY29uc3QgbmV3RXhhbXBsZXM6IE5EQXJyYXlbXSA9IFtdO1xuXG4gICAgZXhhbXBsZXMuZm9yRWFjaChleGFtcGxlID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWVzID0gZXhhbXBsZS5nZXRWYWx1ZXMoKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGlucHV0U2l6ZTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvd2VyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAoY3VyTG93ZXJCb3VuZHMgYXMgRmxvYXQzMkFycmF5KVtqXSA6XG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyBhcyBudW1iZXI7XG4gICAgICAgIGNvbnN0IGN1clVwcGVyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAoY3VyVXBwZXJCb3VuZHMgYXMgRmxvYXQzMkFycmF5KVtqXSA6XG4gICAgICAgICAgICBjdXJVcHBlckJvdW5kcyBhcyBudW1iZXI7XG4gICAgICAgIGNvbnN0IGN1clJhbmdlID0gY3VyVXBwZXJCb3VuZCAtIGN1ckxvd2VyQm91bmQ7XG5cbiAgICAgICAgY29uc3QgbmV3TG93ZXJCb3VuZCA9IG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgIChuZXdMb3dlckJvdW5kcyBhcyBGbG9hdDMyQXJyYXkpW2pdIDpcbiAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3QgbmV3VXBwZXJCb3VuZCA9IG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID9cbiAgICAgICAgICAgIChuZXdVcHBlckJvdW5kcyBhcyBGbG9hdDMyQXJyYXkpW2pdIDpcbiAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzIGFzIG51bWJlcjtcbiAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSBuZXdVcHBlckJvdW5kIC0gbmV3TG93ZXJCb3VuZDtcblxuICAgICAgICBpZiAoY3VyUmFuZ2UgPT09IDApIHtcbiAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3JtYWxpemVkVmFsdWVzW2pdID0gbmV3TG93ZXJCb3VuZCArXG4gICAgICAgICAgICAgIG5ld1JhbmdlICogKGlucHV0VmFsdWVzW2pdIC0gY3VyTG93ZXJCb3VuZCkgLyBjdXJSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3RXhhbXBsZXMucHVzaChOREFycmF5Lm1ha2UoZXhhbXBsZS5zaGFwZSwge3ZhbHVlczogbm9ybWFsaXplZFZhbHVlc30pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3RXhhbXBsZXM7XG4gIH1cblxuICBwcml2YXRlIGNvbXB1dGVCb3VuZHMoZGF0YUluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5kYXRhc2V0W2RhdGFJbmRleF1bMF0uc2hhcGUpO1xuXG4gICAgLy8gQ29tcHV0ZSBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIGV2ZXJ5IGRpbWVuc2lvbi5cbiAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPSB7XG4gICAgICBpc05vcm1hbGl6ZWQ6IGZhbHNlLFxuICAgICAgbWluVmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpLFxuICAgICAgbWF4VmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1tpXSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XS5mb3JFYWNoKGV4YW1wbGUgPT4ge1xuICAgICAgY29uc3QgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmdldFZhbHVlcygpO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaXplOyBrKyspIHtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1trXSA9IE1hdGgubWluKFxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlc1trXSwgaW5wdXRWYWx1ZXNba10pO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdID0gTWF0aC5tYXgoXG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBub3JtYWxpemVXaXRoaW5Cb3VuZHMoXG4gICAgICBkYXRhSW5kZXg6IG51bWJlciwgbG93ZXJCb3VuZDogbnVtYmVyLCB1cHBlckJvdW5kOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBpcyBudWxsLicpO1xuICAgIH1cbiAgICBpZiAoZGF0YUluZGV4ID49IHRoaXMuZGF0YXNldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGF0YUluZGV4IG91dCBvZiBib3VuZHMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmNvbXB1dGVCb3VuZHMoZGF0YUluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBjdXJMb3dlci9VcHBlckJvdW5kcyBvZiB0aGUgY3VycmVudCBkYXRhIHNldCBjYW4gZWl0aGVyIGJlIGZpeGVkIG51bWJlcnNcbiAgICAvLyBpZiB0aGUgZGF0YSBoYXMgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQsIG9yIGN1ckxvd2VyL1VwcGVyIGZvciBlYWNoXG4gICAgLy8gZGltZW5zaW9uIGlmIGl0IGhhc24ndCBiZWVuIG5vcm1hbGl6ZWQgeWV0LlxuICAgIGxldCBjdXJMb3dlckJvdW5kczogRmxvYXQzMkFycmF5fG51bWJlcjtcbiAgICBsZXQgY3VyVXBwZXJCb3VuZHM6IEZsb2F0MzJBcnJheXxudW1iZXI7XG5cbiAgICBpZiAodGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZCkge1xuICAgICAgY3VyTG93ZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCE7XG4gICAgICBjdXJVcHBlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kITtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyTG93ZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzO1xuICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzO1xuICAgIH1cblxuICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UoXG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIGxvd2VyQm91bmQsXG4gICAgICAgIHVwcGVyQm91bmQpO1xuICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kID0gbG93ZXJCb3VuZDtcbiAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gIH1cblxuICBwcml2YXRlIGlzTm9ybWFsaXplZChkYXRhSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6YXRpb25JbmZvICE9IG51bGwgJiZcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZDtcbiAgfVxuXG4gIHJlbW92ZU5vcm1hbGl6YXRpb24oZGF0YUluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhaW5pbmcgb3IgdGVzdCBkYXRhIGlzIG51bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzTm9ybWFsaXplZChkYXRhSW5kZXgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0gPSB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShcbiAgICAgICAgdGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kISxcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLnVwcGVyQm91bmQhLFxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLFxuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkID0gZmFsc2U7XG4gIH1cblxuICB1bm5vcm1hbGl6ZUV4YW1wbGVzKGV4YW1wbGVzOiBOREFycmF5W10sIGRhdGFJbmRleDogbnVtYmVyKTogTkRBcnJheVtdIHtcbiAgICBpZiAoIXRoaXMuaXNOb3JtYWxpemVkKGRhdGFJbmRleCkpIHtcbiAgICAgIHJldHVybiBleGFtcGxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UoXG4gICAgICAgIGV4YW1wbGVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubG93ZXJCb3VuZCEsXG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kISxcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcyxcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcyk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuZGF0YXNldFtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzLmRhdGFzZXRbaV1bal0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhdGFzZXQgPSBbXTtcbiAgfVxufVxuXG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R3JhcGhMYXllcnN9IGZyb20gJy4vZ3JhcGhfbGF5ZXJzJztcbmltcG9ydCAqIGFzIGNvbmNhdDNkX3V0aWwgZnJvbSAnLi9tYXRoL2NvbmNhdDNkX3V0aWwnO1xuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4vbWF0aC9jb252X3V0aWwnO1xuaW1wb3J0IHtOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbWF0aC9uZGFycmF5JztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBHcmFwaCBpcyB0aGUgcHJpbWFyeSBjb250YWluZXIgc3RydWN0dXJlIGZvciBkZWVwbGVhcm4uanMgb3BlcmF0aW9ucy4gR3JhcGhcbiAqIGhvbGRzIHRoZSB0b3BvbG9neSBvZiBvcGVyYXRpb24gbm9kZXMgYW5kIHRoZSBjb25uZWN0aXZpdHkgYmV0d2VlbiB0aGVtLlxuICovXG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICBsYXllcnM6IEdyYXBoTGF5ZXJzO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGF5ZXJzID0gbmV3IEdyYXBoTGF5ZXJzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuYW1lZCB2YXJpYWJsZS4gVmFyaWFibGVzIGFyZSB0ZW5zb3JzIHRoYXQgbWFpbnRhaW4gc3RhdGUgYWNyb3NzXG4gICAqIHNlc3Npb24gY2FsbHMgYW5kIHdob3NlIHZhbHVlcyBhcmUgYWRqdXN0ZWQgZHVyaW5nIGJhY2twcm9wYWdhdGlvblxuICAgKiB0cmFpbmluZy5cbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhpcyB2YXJpYWJsZS5cbiAgICogQHBhcmFtIGRhdGEgVGhlIE5EQXJyYXkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyB2YXJpYWJsZSB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIHZhcmlhYmxlLlxuICAgKi9cbiAgdmFyaWFibGUobmFtZTogc3RyaW5nLCBkYXRhOiBOREFycmF5KTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBWYXJpYWJsZU5vZGUodGhpcywgbmFtZSwgZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBwbGFjZWhvbGRlciBmb3IgYSB0ZW5zb3IgdGhhdCB3aWxsIGJlIGFsd2F5cyBmZWQuIFBsYWNlaG9sZGVyc1xuICAgKiBhcmUgaW5wdXQgdGVuc29ycyB3aG9zZSB2YWx1ZXMgYXJlIHByb3ZpZGVkIGJ5IHRoZSBjbGllbnQgdmlhIGZlZWRcbiAgICogZGljdGlvbmFyaWVzLiBQbGFjZWhvbGRlcnMgYXJlIG5vdCB1cGRhdGVkIGFzIHBhcnQgb2YgdHJhaW5pbmc7IHRoZXkgYXJlXG4gICAqIG9ubHkgdXNlZCBhcyBpbW11dGFibGUgaW5wdXQuXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoaXMgcGxhY2Vob2xkZXIuXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgc2hhcGUgb2YgdGhlIHBsYWNlaG9sZGVyIHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgcGxhY2Vob2xkZXIuXG4gICAqL1xuICBwbGFjZWhvbGRlcihuYW1lOiBzdHJpbmcsIHNoYXBlOiBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUGxhY2Vob2xkZXJOb2RlKHRoaXMsIG5hbWUsIHNoYXBlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RhbnQgdmFsdWUgdGhhdCBwZXJzaXN0cyBhY3Jvc3Mgc2Vzc2lvbiBjYWxscy5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm4gQSBub2RlIG91dHB1dGluZyB0aGUgY29uc3RhbnQgdmFsdWUuXG4gICAqL1xuICBjb25zdGFudCh2YWx1ZTogQXJyYXlEYXRhKTogVGVuc29yIHtcbiAgICBsZXQgZmluYWxWYWx1ZTogTkRBcnJheTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgZmluYWxWYWx1ZSA9IFNjYWxhci5uZXcodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOREFycmF5KSB7XG4gICAgICBmaW5hbFZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBjb25zdCB2YWxzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLmZsYXR0ZW4odmFsdWUpKTtcbiAgICAgIGZpbmFsVmFsdWUgPSBOREFycmF5Lm1ha2UodXRpbC5pbmZlclNoYXBlKHZhbHVlKSwge3ZhbHVlczogdmFsc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgY29uc3RhbnQgdHlwZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uc3RhbnROb2RlKHRoaXMsIGZpbmFsVmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNoYXBlIHRoZSBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IgdG8gYmUgcmVzaGFwZWQuXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIHJlc2hhcGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgcmVzaGFwZSh4OiBUZW5zb3IsIHNoYXBlOiBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChcbiAgICAgICAgbmV3IFJlc2hhcGVOb2RlKHRoaXMsICdSZXNoYXBlJywgeCwgc2hhcGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIGZ1c2VkIGxpbmVhciBjb21iaW5hdGlvbiBvZiB0d28gdGVuc29ycy5cbiAgICogQHBhcmFtIHgxIFRoZSBmaXJzdCBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IHRlbnNvci4gU2FtZSBzaGFwZSBhcyB0MS5cbiAgICogQHBhcmFtIGMxIENvZWZmaWNpZW50IG9mIHQxLiBNdXN0IGJlIHNpemUgMS5cbiAgICogQHBhcmFtIGMyIENvZWZmaWNpZW50IG9mIHQyLiBNdXN0IGJlIHNpemUgMS5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyBjMSp0MStjMip0Mi5cbiAgICovXG4gIGZ1c2VkTGluZWFyQ29tYmluYXRpb24oeDE6IFRlbnNvciwgeDI6IFRlbnNvciwgYzE6IFRlbnNvciwgYzI6IFRlbnNvcik6XG4gICAgICBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQoXG4gICAgICAgIG5ldyBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSh0aGlzLCB4MSwgeDIsIGMxLCBjMikpO1xuICB9XG5cblxuICAvKipcbiAgICogQWRkcyB0d28gdGVuc29ycyAoZWxlbWVudHdpc2UpLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpcyBzY2FsYXIuXG4gICAqIEBwYXJhbSB4MSBUaGUgZmlyc3QgaW5wdXQgdGVuc29yLlxuICAgKiBAcGFyYW0geDIgVGhlIHNlY29uZCBpbnB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdDErdDIuXG4gICAqL1xuICBhZGQoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQWRkTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIHRlbnNvcnMgKGVsZW1lbnR3aXNlKS4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXNcbiAgICogc2NhbGFyLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHQxLXQyLlxuICAgKi9cbiAgc3VidHJhY3QoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU3VidHJhY3ROb2RlKHRoaXMsIHgxLCB4MikpO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IHR3byB0ZW5zb3JzIChlbGVtZW50d2lzZSkuIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzXG4gICAqIHNjYWxhci5cbiAgICogQHBhcmFtIHgxIFRoZSBmaXJzdCBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0MSp0Mi5cbiAgICovXG4gIG11bHRpcGx5KHgxOiBUZW5zb3IsIHgyOiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE11bHRpcGx5Tm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgdHdvIHRlbnNvcnMgKGVsZW1lbnR3aXNlKS4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXNcbiAgICogc2NhbGFyLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IHRlbnNvci5cbiAgICogQHBhcmFtIHgyIFRoZSBzZWNvbmQgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHQxIC8gdDIuXG4gICAqL1xuICBkaXZpZGUoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRGl2aWRlTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IuXG4gICAqL1xuICByZWR1Y2VTdW0oeDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZWR1Y2VTdW1Ob2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25jYXRzIHR3byAzRCB0ZW5zb3JzIGFsb25nIGEgZ2l2ZW4gYXhpcy5cbiAgICogQHBhcmFtIHgxIFRoZSBmaXJzdCBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyBjb25jYXQgb2YgdHdvIHRlbnNvcnMgYWxvbmcgYXhpcy5cbiAgICovXG4gIGNvbmNhdDNkKHgxOiBUZW5zb3IsIHgyOiBUZW5zb3IsIGF4aXM6IG51bWJlcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uY2F0M0ROb2RlKHRoaXMsIHgxLCB4MiwgYXhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIHR3byBtYXRyaWNlcy5cbiAgICogQHBhcmFtIHgxIFRoZSBmaXJzdCBpbnB1dCB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgZG90IHByb2R1Y3Qgb2YgeDEgYW5kIHgyLlxuICAgKi9cbiAgbWF0bXVsKHgxOiBUZW5zb3IsIHgyOiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1hdE11bE5vZGUodGhpcywgeDEsIHgyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSAyRCBjb252b2x1dGlvbi5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgY29udm9sdXRpb24gb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gdyBUaGUgd2VpZ2h0IHRlbnNvciB1c2VkIGJ5IHRoZSBjb252b2x1dGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBiIFRoZSBiaWFzIHRlbnNvciB1c2VkIGJ5IHRoZSBjb252b2x1dGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBmaWVsZFNpemUgVGhlIHNpemUgb2YgdGhlIGNvbnZvbHV0aW9uYWwga2VybmVsLlxuICAgKiBAcGFyYW0gb3V0cHV0RGVwdGggVGhlIG91dHB1dCBkZXB0aCBvZiB0aGUgY29udm9sdXRpb24gb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIGNvbnZvbHV0aW9uIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHplcm9QYWQgVGhlIGFtb3VudCBvZiB6ZXJvIHBhZGRpbmcgb24gYWxsIHNpZGVzIG9mIHRoZSBpbnB1dCB0ZW5zb3IuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIGNvbnZvbHV0aW9uIG9wZXJhdGlvbi5cbiAgICovXG4gIGNvbnYyZChcbiAgICAgIHg6IFRlbnNvciwgdzogVGVuc29yLCBiOiBUZW5zb3IsIGZpZWxkU2l6ZTogbnVtYmVyLCBvdXRwdXREZXB0aDogbnVtYmVyLFxuICAgICAgc3RyaWRlID0gMSwgemVyb1BhZD86IG51bWJlcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29udm9sdXRpb24yRE5vZGUoXG4gICAgICAgIHRoaXMsIHgsIHcsIGIsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgMkQgbWF4IHBvb2wgb2YgeC5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgbWF4IHBvb2wgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gZmllbGRTaXplIFRoZSBzaXplIG9mIHRoZSBjb252b2x1dGlvbmFsIGtlcm5lbC5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBjb252b2x1dGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB6ZXJvUGFkIFRoZSBhbW91bnQgb2YgemVybyBwYWRkaW5nIG9uIGFsbCBzaWRlcyBvZiB0aGUgaW5wdXQgdGVuc29yLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBtYXggcG9vbCBvcGVyYXRpb24uXG4gICAqL1xuICBtYXhQb29sKHg6IFRlbnNvciwgZmllbGRTaXplOiBudW1iZXIsIHN0cmlkZSA9IDEsIHplcm9QYWQ/OiBudW1iZXIpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQoXG4gICAgICAgIG5ldyBNYXhQb29sTm9kZSh0aGlzLCB4LCBmaWVsZFNpemUsIHN0cmlkZSwgemVyb1BhZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGV4cG9uZW50aWFsIG9mIHggZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBleHAuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIGUgXiB4IG9wZXJhdGlvbi5cbiAgICovXG4gIGV4cCh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEV4cE5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGxvZyBvZiB4IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgbG9nLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBsbih4KSBvcGVyYXRpb24uXG4gICAqL1xuICBsb2coeDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBMb2dOb2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBSZUxVIG9mIHggZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHRvIHRoZSBSZUxVLlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSBSZUxVIG9wZXJhdGlvbi5cbiAgICovXG4gIHJlbHUoeDogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBSZUxVTm9kZSh0aGlzLCB4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgVGFuSCBvZiB4IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byB0aGUgVGFuSC5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgVGFuSCBvcGVyYXRpb24uXG4gICAqL1xuICB0YW5oKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgVGFuSE5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIFNpZ21vaWQgb2YgeCBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IgdG8gdGhlIHNpZ21vaWQuXG4gICAqIEByZXR1cm4gVGhlIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIHNpZ21vaWQgb3BlcmF0aW9uLlxuICAgKi9cbiAgc2lnbW9pZCh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNpZ21vaWROb2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBzcXVhcmUgb2YgeCBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IgdG8gdGhlIHNxdWFyZS5cbiAgICovXG4gIHNxdWFyZSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNxdWFyZU5vZGUodGhpcywgeCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHNvZnRtYXggcHJvYmFiaWxpdGllcyBmcm9tIGxvZ2l0cy5cbiAgICpcbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGxvZ2l0cy5cbiAgICogQHJldHVybiBUaGUgc29mdG1heCBwcm9iYWJpbGl0aWVzLlxuICAgKi9cbiAgc29mdG1heCh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNvZnRtYXhOb2RlKHRoaXMsIHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc29mdG1heCBjcm9zcy1lbnRyb3B5IGNvc3Qgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciB0byBjbGFzc2lmeS5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgc29mdG1heCBjcm9zcy1lbnRyb3B5IGNvc3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgc29mdG1heENyb3NzRW50cm9weUNvc3QoeDogVGVuc29yLCB0YXJnZXQ6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChcbiAgICAgICAgbmV3IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSh0aGlzLCB4LCB0YXJnZXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWVhbi1zcXVhcmVkIGNvc3Qgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0ZW5zb3IuXG4gICAqIEBwYXJhbSBwcmVkaWN0aW9uIFRoZSBwcmVkaWN0aW9uIHRlbnNvci5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgbWVhbi1zcXVhcmVkIGNvc3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgbWVhblNxdWFyZWRDb3N0KGxhYmVsOiBUZW5zb3IsIHByZWRpY3Rpb246IFRlbnNvcikge1xuICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQoXG4gICAgICAgIG5ldyBNZWFuU3F1YXJlZENvc3ROb2RlKHRoaXMsIGxhYmVsLCBwcmVkaWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmxhdHRlbmVkIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVudHJ5IGluIHRoZSB0ZW5zb3IuXG4gICAqIEBwYXJhbSB4IFRoZSB0ZW5zb3Igd2l0aCB0aGUgdmFsdWUuXG4gICAqIEByZXR1cm4gQSBTY2FsYXIgdGVuc29yIHdpdGggdGhlIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVudHJ5LlxuICAgKi9cbiAgYXJnbWF4KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4Tm9kZSh0aGlzLCB4KSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcmdtYXggZXF1YWxzIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gICAqIEBwYXJhbSB4MSBGaXJzdCBpbnB1dCB0ZW5zb3IgdG8gY2hlY2sgYWdhaW5zdC5cbiAgICogQHBhcmFtIHgyIFNlY29uZCBpbnB1dCB0ZW5zb3IgdG8gY2hlY2sgYWdhaW5zdC5cbiAgICogQHJldHVybiBUaGUgdGVuc29yIHJlcHJlc2VudGluZyB0aGUgYXJnbWF4IGVxdWFscyBvcGVyYXRpb24uXG4gICAqL1xuICBhcmdtYXhFcXVhbHMoeDE6IFRlbnNvciwgeDI6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQXJnTWF4RXF1YWxzTm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkTm9kZUFuZFJldHVybk91dHB1dChub2RlOiBOb2RlKTogVGVuc29yIHtcbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgbm9kZS52YWxpZGF0ZSgpO1xuICAgIHJldHVybiBub2RlLm91dHB1dDtcbiAgfVxuXG4gIGdldE5vZGVzKCk6IE5vZGVbXSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXM7XG4gIH1cblxuICBwcml2YXRlIG5vZGVzOiBOb2RlW10gPSBbXTtcbn1cblxuLyoqXG4gKiBUZW5zb3IgcmVwcmVzZW50cyB0aGUgb3V0cHV0IG9mIGFuIG9wZXJhdGlvbiBub2RlIGluIHRoZSBncmFwaC5cbiAqIFRlbnNvcnMgaGF2ZSBubyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBidXQgbWFpbnRhaW4gYSBzaGFwZSBhcnJheVxuICogdG8gZGV0ZXJtaW5lIG9wZXJhdGlvbiBjb21wYXRpYmlsaXR5LiBBbGwgZ3JhcGggbWV0aG9kcyB0aGF0IGNyZWF0ZSBncmFwaFxuICogb3BlcmF0aW9ucyByZXR1cm4gVGVuc29yIG9iamVjdHMsIHdoaWNoIGNhbiBiZSB0aG91Z2h0IG9mIGFzICdoYW5kbGVzJyB0b1xuICogb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbnNvciB7XG4gIG5vZGU6IE5vZGU7XG4gIGlkOiBudW1iZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gc2hhcGUgVGhlIHNoYXBlIG9mIHRoaXMgdGVuc29yLCBpbiBkaW1lbnNpb24gc2l6ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2hhcGU6IG51bWJlcltdKSB7XG4gICAgdGhpcy5pZCA9IFRlbnNvci5uZXh0SUQrKztcbiAgfVxuICBwcml2YXRlIHN0YXRpYyBuZXh0SUQgPSAwO1xufVxuXG4vKipcbiAqIE5vZGUgaXMgdGhlIGNvbmNyZXRlIGJhc2UgY2xhc3MgZm9yIGFsbCBvcGVyYXRpb25zIGluIHRoZSBncmFwaC5cbiAqIFVzZXJzIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGludGVyYWN0IGRpcmVjdGx5IHdpdGggTm9kZSBpbnN0YW5jZXMsIGJ1dCB0aGV5XG4gKiBhcmUgcHJvdmlkZWQgZm9yIGluZm9ybWF0aW9uYWwgYW5kIGludHJvc3BlY3Rpb24gcHVycG9zZXMuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTm9kZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZ3JhcGggVGhlIGdyYXBoIGNvbnRhaW5pbmcgdGhpcyBub2RlXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0gaW5wdXRzIEEgZGljdGlvbmFyeSBvZiBuYW1lZCBUZW5zb3JzIHRoYXQgY29tcHJpc2UgdGhpcyBub2RlJ3NcbiAgICogaW5wdXRzLlxuICAgKiBAcGFyYW0gb3V0cHV0IFRoaXMgbm9kZSdzIG91dHB1dCBUZW5zb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGdyYXBoOiBHcmFwaCwgcHVibGljIG5hbWU6IHN0cmluZyxcbiAgICAgIHB1YmxpYyBpbnB1dHM6IHtbbmFtZTogc3RyaW5nXTogVGVuc29yfSwgcHVibGljIG91dHB1dDogVGVuc29yKSB7XG4gICAgdGhpcy5pZCA9IE5vZGUubmV4dElEKys7XG4gICAgb3V0cHV0Lm5vZGUgPSB0aGlzO1xuICB9XG4gIGFic3RyYWN0IHZhbGlkYXRlKCk6IHZvaWQ7XG4gIGlkOiBudW1iZXI7XG4gIHByaXZhdGUgc3RhdGljIG5leHRJRCA9IDA7XG59XG5cbi8qKlxuICogVmFyaWFibGVOb2RlIHJlcHJlc2VudHMgYSB2YXJpYWJsZSwgYSB1c2VyLXByb3ZpZGVkIE5EQXJyYXkgdGhhdCdzXG4gKiBhZGp1c3RlZCBkdXJpbmcgYmFja3Byb3BhZ2F0aW9uIHRyYWluaW5nLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhcmlhYmxlTm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIG5hbWU6IHN0cmluZywgcHVibGljIGRhdGE6IE5EQXJyYXkpIHtcbiAgICBzdXBlcihncmFwaCwgbmFtZSwge30sIG5ldyBUZW5zb3IoZGF0YS5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLmRhdGEgIT0gbnVsbCxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyB2YXJpYWJsZSBvcDogRGF0YSBmb3IgdmFyaWFibGUgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQbGFjZWhvbGRlck5vZGUgcmVwcmVzZW50cyBhIHBsYWNlaG9sZGVyLCBhIHVzZXItcHJvdmlkZWQgTkRBcnJheVxuICogdGhhdCdzIHVzZWQgYXMgaW1tdXRhYmxlIGlucHV0IGR1cmluZyBpbmZlcmVuY2UgYW5kIHRyYWluaW5nLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYWNlaG9sZGVyTm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIG5hbWU6IHN0cmluZywgc2hhcGU6IG51bWJlcltdKSB7XG4gICAgc3VwZXIoZ3JhcGgsIG5hbWUsIHt9LCBuZXcgVGVuc29yKHNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIENvbnN0YW50Tm9kZSByZXByZXNlbnRzIGEgY29uc3RhbnQgdmFsdWUgaW4gdGhlIGdyYXBoLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnN0YW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHB1YmxpYyBkYXRhOiBOREFycmF5KSB7XG4gICAgc3VwZXIoZ3JhcGgsICdDb25zdGFudCcsIHt9LCBuZXcgVGVuc29yKGRhdGEuc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy5kYXRhICE9IG51bGwsXG4gICAgICAgICdFcnJvciBhZGRpbmcgY29uc3RhbnQ6IGRhdGEgZm9yIHBsYWNlaG9sZGVyIFxcJycgKyB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgJ1xcJyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG59XG5cbi8qKlxuICogUmVzaGFwZU5vZGUgcmVwcmVzZW50cyBhIHJlc2hhcGUgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNoYXBlTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgY29uc3RydWN0b3IoXG4gICAgICBncmFwaDogR3JhcGgsIHB1YmxpYyBuYW1lOiBzdHJpbmcsIHByaXZhdGUgeDogVGVuc29yLFxuICAgICAgcHJpdmF0ZSBzaGFwZTogbnVtYmVyW10pIHtcbiAgICBzdXBlcihncmFwaCwgbmFtZSwge3h9LCBuZXcgVGVuc29yKHNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7XG4gICAgY29uc3QgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy54LnNoYXBlKTtcbiAgICBjb25zdCBzaGFwZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5zaGFwZSk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHhTaXplID09PSBzaGFwZVNpemUsXG4gICAgICAgICdFcnJvciBtYWtpbmcgcmVzaGFwZSBvcGVyYXRpb246IGlucHV0IFRlbnNvciB0byByZXNoYXBlIFxcJycgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICsgJ1xcJyBvZiBzaGFwZSAoJyArIHRoaXMueC5zaGFwZSArXG4gICAgICAgICAgICAnKSBkb2VzIG5vdCBtYXRjaCBzaXplIG9mIHJlcXVlc3RlZCBzaGFwZSAnICsgdGhpcy5zaGFwZSArICcuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBMaW5lYXJDb21iaW5hdGlvbk5vZGUgcmVwcmVzZW50cyBhIGxpbmVhciBjb21iaW5hdGlvbiBvZiB0d28gdGVuc29ycy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBUMSA9ICd0MSc7XG4gIHN0YXRpYyByZWFkb25seSBUMiA9ICd0Mic7XG4gIHN0YXRpYyByZWFkb25seSBDMSA9ICdjMSc7XG4gIHN0YXRpYyByZWFkb25seSBDMiA9ICdjMic7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHQxOiBUZW5zb3IsIHByaXZhdGUgdDI6IFRlbnNvciwgcHJpdmF0ZSBjMTogVGVuc29yLFxuICAgICAgcHJpdmF0ZSBjMjogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdMaW5lYXIgQ29tYmluYXRpb24nLCB7dDEsIHQyLCBjMSwgYzJ9LCBuZXcgVGVuc29yKHQxLnNoYXBlKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpO1xuICAgIGlmICghdXRpbC5pc1NjYWxhclNoYXBlKHRoaXMuYzEuc2hhcGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIGFkZGluZyBmdXNlZExpbmVhckNvbWJpbmF0aW9uOiBjMSBpcyBub3QgYSBzY2FsYXIsIGdvdCAnICtcbiAgICAgICAgICAnc2hhcGU6ICcgKyB0aGlzLmMxLnNoYXBlKTtcbiAgICB9XG4gICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMi5zaGFwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMyIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICdzaGFwZTogJyArIHRoaXMuYzIuc2hhcGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFkZE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFQxID0gJ3QxJztcbiAgc3RhdGljIHJlYWRvbmx5IFQyID0gJ3QyJztcblxuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnQWRkJywge3QxLCB0Mn0sXG4gICAgICAgIG5ldyBUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQyLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLnQxLnNoYXBlLCB0aGlzLnQyLnNoYXBlKSxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBhZGQgb3BlcmF0aW9uIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgICdzaGFwZXMgJyArIHRoaXMudDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy50Mi5zaGFwZSArXG4gICAgICAgICAgICAnIG11c3QgbWF0Y2guJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJ0cmFjdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFQxID0gJ3QxJztcbiAgc3RhdGljIHJlYWRvbmx5IFQyID0gJ3QyJztcblxuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnU3VidHJhY3QnLCB7dDEsIHQyfSxcbiAgICAgICAgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIHN1YnRyYWN0IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgICdzaGFwZXMgJyArIHRoaXMudDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy50Mi5zaGFwZSArXG4gICAgICAgICAgICAnIG11c3QgbWF0Y2guJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBseU5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFQxID0gJ3QxJztcbiAgc3RhdGljIHJlYWRvbmx5IFQyID0gJ3QyJztcblxuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgdDE6IFRlbnNvciwgcHJpdmF0ZSB0MjogVGVuc29yKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnTXVsdGlwbHknLCB7dDEsIHQyfSxcbiAgICAgICAgbmV3IFRlbnNvcih1dGlsLnNpemVGcm9tU2hhcGUodDEuc2hhcGUpID09PSAxID8gdDIuc2hhcGUgOiB0MS5zaGFwZSkpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIG11bHRpcGx5IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgICdzaGFwZXMgJyArIHRoaXMudDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy50Mi5zaGFwZSArXG4gICAgICAgICAgICAnIG11c3QgbWF0Y2guJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaXZpZGVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBUMSA9ICd0MSc7XG4gIHN0YXRpYyByZWFkb25seSBUMiA9ICd0Mic7XG5cbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHQxOiBUZW5zb3IsIHByaXZhdGUgdDI6IFRlbnNvcikge1xuICAgIHN1cGVyKFxuICAgICAgICBncmFwaCwgJ0RpdmlkZScsIHt0MSwgdDJ9LFxuICAgICAgICBuZXcgVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSk7XG4gIH1cblxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgZGl2aWRlIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgICdzaGFwZXMgJyArIHRoaXMudDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy50Mi5zaGFwZSArXG4gICAgICAgICAgICAnIG11c3QgbWF0Y2guJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWR1Y2VTdW1Ob2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdSZWR1Y2VTdW0nLCB7eH0sIG5ldyBUZW5zb3IoW10pKTtcbiAgfVxuXG4gIHZhbGlkYXRlKCkge31cbn1cblxuLyoqXG4gKiBDb25jYXQzRE5vZGUgcmVwcmVzZW50cyBhIDNEIGNvbmNhdGVuYXRpb24gb2YgdHdvIHRlbnNvcnMgYWxvbmcgYW4gYXhpcy5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbmNhdDNETm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWDEgPSAneDEnO1xuICBzdGF0aWMgcmVhZG9ubHkgWDIgPSAneDInO1xuICBzdGF0aWMgcmVhZG9ubHkgQVhJUyA9ICdheGlzJztcbiAgY29uc3RydWN0b3IoXG4gICAgICBncmFwaDogR3JhcGgsIHByaXZhdGUgeDE6IFRlbnNvciwgcHJpdmF0ZSB4MjogVGVuc29yLFxuICAgICAgcHVibGljIGF4aXM6IG51bWJlcikge1xuICAgIHN1cGVyKFxuICAgICAgICBncmFwaCwgJ0NvbmNhdDNEJywge3gxLCB4Mn0sXG4gICAgICAgIG5ldyBUZW5zb3IoY29uY2F0M2RfdXRpbC5jb21wdXRlQ29uY2F0M0RPdXRwdXRTaGFwZShcbiAgICAgICAgICAgIHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcykpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICBjb25jYXQzZF91dGlsLmFzc2VydENvbmNhdDNEU2hhcGVzTWF0Y2goXG4gICAgICAgIHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUsIHRoaXMuYXhpcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDFTaGFwZTogbnVtYmVyW10sIHgyU2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gWzFdO1xuICB9IGVsc2UgaWYgKHgxU2hhcGUubGVuZ3RoID09PSAxICYmIHgyU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFt4MlNoYXBlWzFdXTtcbiAgfSBlbHNlIGlmICh4MVNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbeDFTaGFwZVswXV07XG4gIH1cbiAgcmV0dXJuIFt4MVNoYXBlWzBdLCB4MlNoYXBlWzFdXTtcbn1cblxuLyoqXG4gKiBNYXRNdWxOb2RlIHJlcHJlc2VudHMgYSBmdWxseSBjb25uZWN0ZWQgbGF5ZXIgaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTWF0TXVsTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWDEgPSAneDEnO1xuICBzdGF0aWMgcmVhZG9ubHkgWDIgPSAneDInO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgeDE6IFRlbnNvciwgcHJpdmF0ZSB4MjogVGVuc29yKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnTWF0TXVsJywge3gxLCB4Mn0sXG4gICAgICAgIG5ldyBUZW5zb3IoZ2V0TWF0TXVsT3V0cHV0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlKSkpO1xuICB9XG5cbiAgdmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICB0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLFxuICAgICAgICAgICdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBpbm5lciBzaGFwZXMgb2YgbWF0cmljZXMgd2l0aCBzaGFwZXMgJyArXG4gICAgICAgICAgICAgIHRoaXMueDEuc2hhcGUgKyAnIGFuZCAnICsgdGhpcy54Mi5zaGFwZSArICcgbXVzdCBtYXRjaC4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICB0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLFxuICAgICAgICAgICdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBzZWNvbmQgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIHNoYXBlICcgK1xuICAgICAgICAgICAgICB0aGlzLngxLnNoYXBlICsgJyBtdXN0IG1hdGNoIHNpemUgb2YgdmVjdG9yIHdpdGggc2hhcGUgJyArXG4gICAgICAgICAgICAgIHRoaXMueDIuc2hhcGUgKyAnLicpO1xuICAgIH0gZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMueDEuc2hhcGVbMF0gPT09IHRoaXMueDIuc2hhcGVbMF0sXG4gICAgICAgICAgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNpemUgb2YgdmVjdG9yIHdpdGggc2hhcGUgJyArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgICAnIG11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoICcgK1xuICAgICAgICAgICAgICAnc2hhcGUgJyArIHRoaXMueDIuc2hhcGUgKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IGlucHV0cyBtdXN0IGJlIHZlY3RvcnMgb3IgbWF0cmljZXMuJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udm9sdXRpb24yRE5vZGUgcmVwcmVzZW50cyBhIDJkIGNvbnZvbHV0aW9uIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb252b2x1dGlvbjJETm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgc3RhdGljIHJlYWRvbmx5IFcgPSAndyc7XG4gIHN0YXRpYyByZWFkb25seSBCID0gJ2InO1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB4OiBUZW5zb3IsIHByaXZhdGUgdzogVGVuc29yLCBwcml2YXRlIGI6IFRlbnNvcixcbiAgICAgIHB1YmxpYyBmaWVsZFNpemU6IG51bWJlciwgcHVibGljIG91dHB1dERlcHRoOiBudW1iZXIsIHB1YmxpYyBzdHJpZGUgPSAxLFxuICAgICAgcHVibGljIHplcm9QYWQ/OiBudW1iZXIpIHtcbiAgICBzdXBlcihcbiAgICAgICAgZ3JhcGgsICdDb252b2x1dGlvbiAyRCcsIHt4LCB3LCBifSxcbiAgICAgICAgbmV3IFRlbnNvcihjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgICAgICB4LnNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLFxuICAgICAgICAgICAgemVyb1BhZCkpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGlucHV0IG11c3QgYmUgb2YgcmFuayAzLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgIHRoaXMueC5zaGFwZSArICcuJyk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMudy5zaGFwZS5sZW5ndGggPT09IDQsXG4gICAgICAgICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiB3ZWlnaHRzIG11c3QgYmUgb2YgcmFuayA0LCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgIHRoaXMudy5zaGFwZSArICcuJyk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHRoaXMuYi5zaGFwZS5sZW5ndGggPT09IDEsXG4gICAgICAgICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiBiaWFzZXMgbXVzdCBiZSBvZiByYW5rIDEsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgdGhpcy5iLnNoYXBlICsgJy4nKTtcblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnguc2hhcGVbMl0gPT09IHRoaXMudy5zaGFwZVsyXSxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBjb252MmQgb3A6IGRlcHRoIG9mIGlucHV0ICgnICsgdGhpcy54LnNoYXBlWzJdICtcbiAgICAgICAgICAgICcpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIHdlaWdodHMgKCcgKyB0aGlzLncuc2hhcGVbMl0gKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIE1heFBvb2xOb2RlIHJlcHJlc2VudHMgYSAyZCBtYXggcG9vbCBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTWF4UG9vbE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHg6IFRlbnNvciwgcHVibGljIGZpZWxkU2l6ZTogbnVtYmVyLFxuICAgICAgcHVibGljIHN0cmlkZSA9IDEsIHB1YmxpYyB6ZXJvUGFkPzogbnVtYmVyKSB7XG4gICAgc3VwZXIoXG4gICAgICAgIGdyYXBoLCAnTWF4IHBvb2wnLCB7eH0sXG4gICAgICAgIG5ldyBUZW5zb3IoY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICAgICAgeC5zaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZpZWxkU2l6ZSwgeC5zaGFwZVsyXSwgc3RyaWRlLFxuICAgICAgICAgICAgemVyb1BhZCkpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgJ0Vycm9yIGFkZGluZyBtYXhQb29sIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICB0aGlzLnguc2hhcGUgKyAnLicpO1xuICB9XG59XG5cbi8qKlxuICogUmVMVU5vZGUgcmVwcmVzZW50cyBhIFJlTFUgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlTFVOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnUmVMVScsIHt4fSwgbmV3IFRlbnNvcih4LnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIEV4cE5vZGUgcmVwcmVzZW50cyBhIEV4cG9uZW50aWF0aW9uIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHBOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnRXhwJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogTG9nTm9kZSByZXByZXNlbnRzIGEgRXhwb25lbnRpYXRpb24gb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIExvZ05vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdMb2cnLCB7eH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge31cbn1cblxuLyoqXG4gKiBUYW5ITm9kZSByZXByZXNlbnRzIGEgdGFuaCBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGFuSE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgeDogVGVuc29yKSB7XG4gICAgc3VwZXIoZ3JhcGgsICdUYW5IJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHt9XG59XG5cbi8qKlxuICogU2lnbW9pZE5vZGUgcmVwcmVzZW50cyBhIHNpZ21vaWQgb3BlcmF0aW9uIGluIHRoZSBncmFwaC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ21vaWROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnU2lnbW9pZCcsIHt4fSwgbmV3IFRlbnNvcih4LnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIFNxdWFyZSBub2RlIHJlcHJlc2VudHMgYW4gZWxlbWVudC13aXNlIHNxdWFyZSBvcGVyYXRpb24gaW4gdGhlIGdyYXBoLlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU3F1YXJlTm9kZSBleHRlbmRzIE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkgWCA9ICd4JztcbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ1NxdWFyZScsIHt4fSwgbmV3IFRlbnNvcih4LnNoYXBlKSk7XG4gIH1cbiAgdmFsaWRhdGUoKSB7fVxufVxuXG4vKipcbiAqIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSByZXByZXNlbnRzIGEgc29mdG1heCBjcm9zcy1lbnRyb3B5IGNvc3Qgb3BlcmF0aW9uXG4gKiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG4gIHN0YXRpYyByZWFkb25seSBUQVJHRVQgPSAndGFyZ2V0JztcbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCBwcml2YXRlIHg6IFRlbnNvciwgcHJpdmF0ZSB0YXJnZXQ6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnU29mdG1heENyb3NzRW50cm9weUNvc3QnLCB7eCwgdGFyZ2V0fSwgbmV3IFRlbnNvcihbXSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMueC5zaGFwZSwgdGhpcy50YXJnZXQuc2hhcGUpLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIHNvZnRtYXhDcm9zc0VudHJvcHlDb3N0IG9wOiB4IHNoYXBlICgnICsgdGhpcy54LnNoYXBlICtcbiAgICAgICAgICAgICcpIG11c3QgbWF0Y2ggdGFyZ2V0IHNoYXBlICgnICsgdGhpcy50YXJnZXQuc2hhcGUgKyAnKS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNvZnRtYXhOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuXG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ1NvZnRtYXgnLCB7eH0sIG5ldyBUZW5zb3IoeC5zaGFwZSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnguc2hhcGUubGVuZ3RoID09PSAxLFxuICAgICAgICAnVGhlIGlucHV0IHRvIGEgc29mdG1heCBtdXN0IGJlIGEgMS1EIHRlbnNvcicpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB0aGlzLnguc2hhcGVbMF0gPj0gMixcbiAgICAgICAgJ1RoZSBpbnB1dCB0byBhIHNvZnRtYXggbXVzdCBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZWFuU3F1YXJlZENvc3ROb2RlIHJlcHJlc2VudHMgYSBtZWFuIHNxdWFyZWQgY29zdCBvcGVyYXRpb25cbiAqIGluIHRoZSBncmFwaC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZWFuU3F1YXJlZENvc3ROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBMQUJFTCA9ICdsYWJlbCc7XG4gIHN0YXRpYyByZWFkb25seSBQUkVESUNUSU9OID0gJ3ByZWRpY3Rpb24nO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHByaXZhdGUgbGFiZWw6IFRlbnNvciwgcHJpdmF0ZSBwcmVkaWN0aW9uOiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ01lYW4gU3F1YXJlZCBDb3N0Jywge2xhYmVsLCBwcmVkaWN0aW9ufSwgbmV3IFRlbnNvcihbXSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMubGFiZWwuc2hhcGUsIHRoaXMucHJlZGljdGlvbi5zaGFwZSksXG4gICAgICAgICdFcnJvciBhZGRpbmcgbWVhblNxdWFyZWRDb3N0IG9wOiBsYWJlbCBzaGFwZSAoJyArIHRoaXMubGFiZWwuc2hhcGUgK1xuICAgICAgICAgICAgJykgbXVzdCBtYXRjaCBwcmVkaWN0aW9uIHNoYXBlICgnICsgdGhpcy5wcmVkaWN0aW9uLnNoYXBlICsgJykuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBcmdNYXhOb2RlIHJlcHJlc2VudHMgYW4gYXJnbWF4IG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmdNYXhOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYID0gJ3gnO1xuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHB1YmxpYyB4OiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ0FyZ01heCcsIHt4fSwgbmV3IFRlbnNvcihbMV0pKTtcbiAgfVxuICB2YWxpZGF0ZSgpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSkgPiAwLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIGFyZ21heCBvcDogaW5wdXQgdGVuc29yIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBcmdNYXhFcXVhbHNOb2RlIHJlcHJlc2VudHMgYSBhcmdtYXggZXF1YWxzIG9wZXJhdGlvbiBpbiB0aGUgZ3JhcGguXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmdNYXhFcXVhbHNOb2RlIGV4dGVuZHMgTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBYMSA9ICd4MSc7XG4gIHN0YXRpYyByZWFkb25seSBYMiA9ICd4Mic7XG4gIGNvbnN0cnVjdG9yKGdyYXBoOiBHcmFwaCwgcHJpdmF0ZSB4MTogVGVuc29yLCBwcml2YXRlIHgyOiBUZW5zb3IpIHtcbiAgICBzdXBlcihncmFwaCwgJ0FyZ01heEVxdWFscycsIHt4MSwgeDJ9LCBuZXcgVGVuc29yKFsxXSkpO1xuICB9XG4gIHZhbGlkYXRlKCkge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUpLFxuICAgICAgICAnRXJyb3IgYWRkaW5nIEFyZ01heEVxdWFscyBvcDogeDEgc2hhcGUgKCcgKyB0aGlzLngxLnNoYXBlICtcbiAgICAgICAgICAgICcpIG11c3QgbWF0Y2ggeDIgc2hhcGUgKCcgKyB0aGlzLngyLnNoYXBlICsgJykuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTcGxpdCBub2RlcyBhcmUgdXNlZCB0byBhY2N1bXVsYXRlIGJhY2twcm9wIGRlcml2YXRpdmVzIHdoZW4gYSBub2RlJ3Mgb3V0cHV0XG4gKiB0ZW5zb3IgaXMgY29uc3VtZWQgYnkgbXVsdGlwbGUgbm9kZXMuXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGxpdE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IFggPSAneCc7XG5cbiAgb3V0cHV0czogVGVuc29yW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihncmFwaDogR3JhcGgsIHg6IFRlbnNvcikge1xuICAgIHN1cGVyKGdyYXBoLCAnU3BsaXROb2RlJywge3h9LCBuZXcgVGVuc29yKHguc2hhcGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgY29uc3VtZXIgb2YgdGhpcyBzcGxpdCBub2RlLCBpLmUuIGEgbmV3IG5vZGUgdGhhdCB1c2VzIHRoZVxuICAgKiBub2RlJ3Mgb3V0cHV0IHRlbnNvci5cbiAgICovXG4gIGdldE5ld091dHB1dFRlbnNvcigpOiBUZW5zb3Ige1xuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBUZW5zb3IodGhpcy5pbnB1dHNbU3BsaXROb2RlLlhdLnNoYXBlKTtcbiAgICBvdXRwdXQubm9kZSA9IHRoaXM7XG4gICAgdGhpcy5vdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHZhbGlkYXRlKCkge31cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCB0eXBlIEFycmF5RGF0YSA9XG4gICAgTkRBcnJheXxudW1iZXJ8bnVtYmVyW118bnVtYmVyW11bXXxudW1iZXJbXVtdW118bnVtYmVyW11bXVtdW107XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R3JhcGgsIFRlbnNvcn0gZnJvbSAnLi9ncmFwaCc7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5pbXBvcnQge0luaXRpYWxpemVyLCBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciwgWmVyb3NJbml0aWFsaXplcn0gZnJvbSAnLi9pbml0aWFsaXplcnMnO1xuXG4vKipcbiAqIEEgbGF5ZXJzIHN1Z2FyIGNsYXNzIGFyb3VuZCB0aGUgZ3JhcGggdGhhdCBpbml0aWFsaXplcyB2YXJpYWJsZXNcbiAqIGF1dG9tYXRpY2FsbHkgZm9yIGxheWVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoTGF5ZXJzIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBnOiBHcmFwaCkge31cblxuICBkZW5zZShcbiAgICAgIG5hbWU6IHN0cmluZywgeDogVGVuc29yLCB1bml0czogbnVtYmVyLFxuICAgICAgYWN0aXZhdGlvbjogKCh4OiBUZW5zb3IpID0+IFRlbnNvcil8bnVsbCA9IG51bGwsIHVzZUJpYXMgPSB0cnVlLFxuICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyID0gbmV3IFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyKCksXG4gICAgICBiaWFzSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyID0gbmV3IFplcm9zSW5pdGlhbGl6ZXIoKSkge1xuICAgIGNvbnN0IHdlaWdodHMgPSB0aGlzLmcudmFyaWFibGUoXG4gICAgICAgIG5hbWUgKyAnLXdlaWdodHMnLFxuICAgICAgICBrZXJuZWxJbml0aWFsaXplci5pbml0aWFsaXplKFt4LnNoYXBlWzBdLCB1bml0c10sIHguc2hhcGVbMF0sIHVuaXRzKSk7XG5cbiAgICBsZXQgb3V0ID0gdGhpcy5nLm1hdG11bCh4LCB3ZWlnaHRzKTtcblxuICAgIGlmICh1c2VCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzID0gdGhpcy5nLnZhcmlhYmxlKFxuICAgICAgICAgIG5hbWUgKyAnLWJpYXMnLFxuICAgICAgICAgIGJpYXNJbml0aWFsaXplci5pbml0aWFsaXplKFt1bml0c10sIHguc2hhcGVbMF0sIHVuaXRzKSk7XG4gICAgICBvdXQgPSB0aGlzLmcuYWRkKG91dCwgYmlhcyk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgb3V0ID0gYWN0aXZhdGlvbihvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtJbnB1dFByb3ZpZGVyfSBmcm9tICcuL2lucHV0X3Byb3ZpZGVyJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge09wdGltaXplcn0gZnJvbSAnLi9vcHRpbWl6ZXInO1xuaW1wb3J0IHtDb3N0UmVkdWN0aW9uLCBGZWVkRW50cnksIFNlc3Npb259IGZyb20gJy4vc2Vzc2lvbic7XG5cbmNvbnN0IERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUyA9IDE1MDA7XG5jb25zdCBERUZBVUxUX0NPU1RfSU5URVJWQUxfTVMgPSA1MDA7XG5jb25zdCBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TID0gMzAwMDtcblxuZXhwb3J0IGludGVyZmFjZSBHcmFwaFJ1bm5lckV2ZW50T2JzZXJ2ZXIge1xuICBiYXRjaGVzVHJhaW5lZENhbGxiYWNrPzogKHRvdGFsQmF0Y2hlc1RyYWluZWQ6IG51bWJlcikgPT4gdm9pZDtcbiAgYXZnQ29zdENhbGxiYWNrPzogKGF2Z0Nvc3Q6IFNjYWxhcikgPT4gdm9pZDtcbiAgbWV0cmljQ2FsbGJhY2s/OiAobWV0cmljOiBOREFycmF5KSA9PiB2b2lkO1xuICBpbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrPzpcbiAgICAgIChmZWVkczogRmVlZEVudHJ5W11bXSwgaW5mZXJlbmNlVmFsdWVzOiBOREFycmF5W10pID0+IHZvaWQ7XG4gIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjQ2FsbGJhY2s/OiAoZXhhbXBsZXNQZXJTZWM6IG51bWJlcikgPT4gdm9pZDtcbiAgdHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrPzogKGV4YW1wbGVzUGVyU2VjOiBudW1iZXIpID0+IHZvaWQ7XG4gIHRvdGFsVGltZUNhbGxiYWNrPzogKHRvdGFsVGltZVNlYzogbnVtYmVyKSA9PiB2b2lkO1xuICBkb25lVHJhaW5pbmdDYWxsYmFjaz86ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBlbnVtIE1ldHJpY1JlZHVjdGlvbiB7XG4gIFNVTSxcbiAgTUVBTlxufVxuXG4vKipcbiAqIEEgY2xhc3MgdGhhdCBkcml2ZXMgdGhlIHRyYWluaW5nIG9mIGEgZ3JhcGggbW9kZWwgZ2l2ZW4gYSBkYXRhc2V0LiBJdCBhbGxvd3NcbiAqIHRoZSB1c2VyIHRvIHByb3ZpZGUgYSBzZXQgb2YgY2FsbGJhY2tzIGZvciBtZWFzdXJlbWVudHMgbGlrZSBjb3N0LCBhY2N1cmFjeSxcbiAqIGFuZCBzcGVlZCBvZiB0cmFpbmluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoUnVubmVyIHtcbiAgcHJpdmF0ZSBjb3N0VGVuc29yOiBUZW5zb3I7XG4gIHByaXZhdGUgdHJhaW5GZWVkRW50cmllczogRmVlZEVudHJ5W107XG4gIHByaXZhdGUgYmF0Y2hTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgb3B0aW1pemVyOiBPcHRpbWl6ZXI7XG4gIHByaXZhdGUgY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXM6IG51bWJlcnx1bmRlZmluZWQ7XG4gIHByaXZhdGUgY29zdEludGVydmFsTXM6IG51bWJlcjtcblxuICBwcml2YXRlIG1ldHJpY1RlbnNvcjogVGVuc29yfHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBtZXRyaWNGZWVkRW50cmllczogRmVlZEVudHJ5W118dW5kZWZpbmVkO1xuICBwcml2YXRlIG1ldHJpY0JhdGNoU2l6ZTogbnVtYmVyfHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBtZXRyaWNSZWR1Y3Rpb246IE1ldHJpY1JlZHVjdGlvbjtcbiAgcHJpdmF0ZSBtZXRyaWNJbnRlcnZhbE1zOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBpbmZlcmVuY2VUZW5zb3I6IFRlbnNvcjtcbiAgcHJpdmF0ZSBpbmZlcmVuY2VGZWVkRW50cmllczogRmVlZEVudHJ5W118dW5kZWZpbmVkO1xuICBwcml2YXRlIGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zOiBudW1iZXI7XG4gIHByaXZhdGUgaW5mZXJlbmNlRXhhbXBsZUNvdW50OiBudW1iZXI7XG5cbiAgLy8gUnVudGltZSBpbmZvcm1hdGlvbi5cbiAgcHJpdmF0ZSBpc1RyYWluaW5nOiBib29sZWFuO1xuICBwcml2YXRlIHRvdGFsQmF0Y2hlc1RyYWluZWQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBiYXRjaGVzVHJhaW5lZFRoaXNSdW46IG51bWJlcjtcbiAgcHJpdmF0ZSBsYXN0Q29tcHV0ZWRNZXRyaWM6IE5EQXJyYXk7XG5cbiAgcHJpdmF0ZSBpc0luZmVycmluZzogYm9vbGVhbjtcbiAgcHJpdmF0ZSBjdXJyZW50SW5mZXJlbmNlTG9vcE51bVBhc3NlczogbnVtYmVyfHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSBpbmZlcmVuY2VQYXNzZXNUaGlzUnVuOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSB0cmFpblN0YXJ0VGltZXN0YW1wOiBudW1iZXI7XG4gIHByaXZhdGUgbGFzdENvc3RUaW1lc3RhbXAgPSAwO1xuICBwcml2YXRlIGxhc3RFdmFsVGltZXN0YW1wID0gMDtcblxuICBwcml2YXRlIGxhc3RTdG9wVGltZXN0YW1wOiBudW1iZXJ8bnVsbDtcbiAgcHJpdmF0ZSB0b3RhbElkbGVUaW1lTXMgPSAwO1xuXG4gIHByaXZhdGUgemVyb1NjYWxhcjogU2NhbGFyO1xuICBwcml2YXRlIG1ldHJpY0JhdGNoU2l6ZVNjYWxhcjogU2NhbGFyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBtYXRoOiBOREFycmF5TWF0aCwgcHJpdmF0ZSBzZXNzaW9uOiBTZXNzaW9uLFxuICAgICAgcHJpdmF0ZSBldmVudE9ic2VydmVyOiBHcmFwaFJ1bm5lckV2ZW50T2JzZXJ2ZXIpIHtcbiAgICB0aGlzLnJlc2V0U3RhdGlzdGljcygpO1xuICAgIHRoaXMuemVyb1NjYWxhciA9IFNjYWxhci5uZXcoMCk7XG4gIH1cblxuICByZXNldFN0YXRpc3RpY3MoKSB7XG4gICAgdGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkID0gMDtcbiAgICB0aGlzLnRvdGFsSWRsZVRpbWVNcyA9IDA7XG4gICAgdGhpcy5sYXN0U3RvcFRpbWVzdGFtcCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRyYWluaW5nIGxvb3Agd2l0aCBhbiBvcHRpb25hbCBudW1iZXIgb2YgYmF0Y2hlcyB0byB0cmFpbiBmb3IuXG4gICAqIE9wdGlvbmFsbHkgdGFrZXMgYSBtZXRyaWMgdGVuc29yIGFuZCBmZWVkIGVudHJpZXMgdG8gY29tcHV0ZSBwZXJpb2RpY2FsbHkuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGNvbXB1dGluZyBhY2N1cmFjeSwgb3IgYSBzaW1pbGFyIG1ldHJpYy5cbiAgICovXG4gIHRyYWluKFxuICAgICAgY29zdFRlbnNvcjogVGVuc29yLCB0cmFpbkZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXSwgYmF0Y2hTaXplOiBudW1iZXIsXG4gICAgICBvcHRpbWl6ZXI6IE9wdGltaXplciwgbnVtQmF0Y2hlcz86IG51bWJlciwgbWV0cmljVGVuc29yPzogVGVuc29yLFxuICAgICAgbWV0cmljRmVlZEVudHJpZXM/OiBGZWVkRW50cnlbXSwgbWV0cmljQmF0Y2hTaXplPzogbnVtYmVyLFxuICAgICAgbWV0cmljUmVkdWN0aW9uID0gTWV0cmljUmVkdWN0aW9uLk1FQU4sXG4gICAgICBldmFsSW50ZXJ2YWxNcyA9IERFRkFVTFRfRVZBTF9JTlRFUlZBTF9NUyxcbiAgICAgIGNvc3RJbnRlcnZhbE1zID0gREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TKSB7XG4gICAgdGhpcy5jb3N0VGVuc29yID0gY29zdFRlbnNvcjtcbiAgICB0aGlzLnRyYWluRmVlZEVudHJpZXMgPSB0cmFpbkZlZWRFbnRyaWVzO1xuICAgIHRoaXMubWV0cmljVGVuc29yID0gbWV0cmljVGVuc29yO1xuICAgIHRoaXMubWV0cmljRmVlZEVudHJpZXMgPSBtZXRyaWNGZWVkRW50cmllcztcbiAgICBpZiAobWV0cmljQmF0Y2hTaXplICE9IG51bGwgJiYgdGhpcy5tZXRyaWNCYXRjaFNpemUgIT09IG1ldHJpY0JhdGNoU2l6ZSkge1xuICAgICAgaWYgKHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgPSBTY2FsYXIubmV3KG1ldHJpY0JhdGNoU2l6ZSk7XG4gICAgfVxuICAgIHRoaXMubWV0cmljQmF0Y2hTaXplID0gbWV0cmljQmF0Y2hTaXplO1xuICAgIHRoaXMubWV0cmljUmVkdWN0aW9uID0gbWV0cmljUmVkdWN0aW9uO1xuICAgIHRoaXMuYmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgIHRoaXMub3B0aW1pemVyID0gb3B0aW1pemVyO1xuXG4gICAgdGhpcy5tZXRyaWNJbnRlcnZhbE1zID0gZXZhbEludGVydmFsTXM7XG4gICAgdGhpcy5jb3N0SW50ZXJ2YWxNcyA9IGNvc3RJbnRlcnZhbE1zO1xuICAgIHRoaXMuY3VycmVudFRyYWluTG9vcE51bUJhdGNoZXMgPSBudW1CYXRjaGVzO1xuXG4gICAgdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4gPSAwO1xuICAgIHRoaXMuaXNUcmFpbmluZyA9IHRydWU7XG4gICAgdGhpcy50cmFpblN0YXJ0VGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgfVxuXG4gIHN0b3BUcmFpbmluZygpIHtcbiAgICB0aGlzLmlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RTdG9wVGltZXN0YW1wID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH1cblxuICByZXN1bWVUcmFpbmluZygpIHtcbiAgICB0aGlzLmlzVHJhaW5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmxhc3RTdG9wVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgIHRoaXMudG90YWxJZGxlVGltZU1zICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5sYXN0U3RvcFRpbWVzdGFtcDtcbiAgICB9XG4gICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgfVxuXG4gIHByaXZhdGUgdHJhaW5OZXR3b3JrKCkge1xuICAgIGlmICh0aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50VHJhaW5Mb29wTnVtQmF0Y2hlcykge1xuICAgICAgdGhpcy5zdG9wVHJhaW5pbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNUcmFpbmluZykge1xuICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5kb25lVHJhaW5pbmdDYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc2hvdWxkQ29tcHV0ZUNvc3QgPSB0aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgKHN0YXJ0IC0gdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA+IHRoaXMuY29zdEludGVydmFsTXMpO1xuICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGNvbnN0IGNvc3RSZWR1Y3Rpb24gPVxuICAgICAgICBzaG91bGRDb21wdXRlQ29zdCA/IENvc3RSZWR1Y3Rpb24uTUVBTiA6IENvc3RSZWR1Y3Rpb24uTk9ORTtcblxuICAgIHRoaXMubWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3QgYXZnQ29zdCA9IHRoaXMuc2Vzc2lvbi50cmFpbihcbiAgICAgICAgICB0aGlzLmNvc3RUZW5zb3IsIHRoaXMudHJhaW5GZWVkRW50cmllcywgdGhpcy5iYXRjaFNpemUsXG4gICAgICAgICAgdGhpcy5vcHRpbWl6ZXIsIGNvc3RSZWR1Y3Rpb24pO1xuXG4gICAgICBpZiAoc2hvdWxkQ29tcHV0ZUNvc3QpIHtcbiAgICAgICAgY29uc3QgdHJhaW5UaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcblxuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrIShhdmdDb3N0KTtcblxuICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLnRyYWluRXhhbXBsZXNQZXJTZWNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZXhhbXBsZXNQZXJTZWMgPSAodGhpcy5iYXRjaFNpemUgKiAxMDAwIC8gdHJhaW5UaW1lKTtcbiAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIudHJhaW5FeGFtcGxlc1BlclNlY0NhbGxiYWNrKGV4YW1wbGVzUGVyU2VjKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICB0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzICE9IG51bGwgJiZcbiAgICAgICAgICBzdGFydCAtIHRoaXMubGFzdEV2YWxUaW1lc3RhbXAgPiB0aGlzLm1ldHJpY0ludGVydmFsTXMpIHtcbiAgICAgICAgdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IHN0YXJ0O1xuXG4gICAgICAgIGlmICh0aGlzLmxhc3RDb21wdXRlZE1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdENvbXB1dGVkTWV0cmljID0gdGhpcy5jb21wdXRlTWV0cmljKCk7XG4gICAgICAgIHRoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayh0aGlzLmxhc3RDb21wdXRlZE1ldHJpYyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2soXG4gICAgICAgICAgICAoc3RhcnQgLSB0aGlzLnRyYWluU3RhcnRUaW1lc3RhbXApIC8gMTAwMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuKys7XG4gICAgICB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQrKztcblxuICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5iYXRjaGVzVHJhaW5lZENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5ldmVudE9ic2VydmVyLmJhdGNoZXNUcmFpbmVkQ2FsbGJhY2sodGhpcy50b3RhbEJhdGNoZXNUcmFpbmVkKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy50cmFpbk5ldHdvcmsoKSk7XG4gIH1cblxuICBpbmZlcihcbiAgICAgIGluZmVyZW5jZVRlbnNvcjogVGVuc29yLCBpbmZlcmVuY2VGZWVkRW50cmllczogRmVlZEVudHJ5W10sXG4gICAgICBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9IERFRkFVTFRfSU5GRVJFTkNFX0VYQU1QTEVfSU5URVJWQUxfTVMsXG4gICAgICBpbmZlcmVuY2VFeGFtcGxlQ291bnQgPSA1LCBudW1QYXNzZXM/OiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgPT0gbnVsbCAmJlxuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2UgbG9vcCwgbm8gaW5mZXJlbmNlIGV4YW1wbGUgb3IgJyArXG4gICAgICAgICAgJ2V4YW1wbGVzL3NlYyBvYnNlcnZlciBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGZlZWQgdmFsdWVzIGFyZSBwcm92aWRlcnMsIGFuZCBub3QgTkRBcnJheXMuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZlcmVuY2VGZWVkRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmVlZEVudHJ5ID0gaW5mZXJlbmNlRmVlZEVudHJpZXNbaV07XG5cbiAgICAgIGlmIChmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2Ugb24gdGhlIG1vZGVsIHJ1bm5lciB3aXRoIGZlZWQgZW50cmllcyBvZiAnICtcbiAgICAgICAgICAgICd0eXBlIE5EQXJyYXkuIFBsZWFzZSB1c2UgSW5wdXRQcm92aWRlcnMuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcyA9IGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zO1xuICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgIHRoaXMuaW5mZXJlbmNlRmVlZEVudHJpZXMgPSBpbmZlcmVuY2VGZWVkRW50cmllcztcbiAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCA9IGluZmVyZW5jZUV4YW1wbGVDb3VudDtcbiAgICB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzID0gbnVtUGFzc2VzO1xuICAgIGlmICghdGhpcy5pc0luZmVycmluZykge1xuICAgICAgdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuID0gMDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5pbmZlck5ldHdvcmsoKSk7XG4gICAgfVxuICAgIHRoaXMuaXNJbmZlcnJpbmcgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBpbmZlck5ldHdvcmsoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nIHx8XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9PT0gdGhpcy5jdXJyZW50SW5mZXJlbmNlTG9vcE51bVBhc3Nlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubWF0aC5zY29wZSgoa2VlcCwgdHJhY2spID0+IHtcbiAgICAgIGNvbnN0IGZlZWRzOiBGZWVkRW50cnlbXVtdID0gW107XG4gICAgICBjb25zdCBpbmZlcmVuY2VWYWx1ZXM6IE5EQXJyYXlbXSA9IFtdO1xuXG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudDsgaSsrKSB7XG4gICAgICAgIC8vIFBvcHVsYXRlIGEgbmV3IEZlZWRFbnRyeVtdIHBvcHVsYXRlZCB3aXRoIE5EQXJyYXlzLlxuICAgICAgICBjb25zdCBuZGFycmF5RmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllcyEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBmZWVkRW50cnkgPSB0aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzIVtqXTtcbiAgICAgICAgICBuZGFycmF5RmVlZEVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICB0ZW5zb3I6IGZlZWRFbnRyeS50ZW5zb3IsXG4gICAgICAgICAgICBkYXRhOlxuICAgICAgICAgICAgICAgIHRyYWNrKChmZWVkRW50cnkuZGF0YSBhcyBJbnB1dFByb3ZpZGVyKS5nZXROZXh0Q29weSh0aGlzLm1hdGgpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZlZWRzLnB1c2gobmRhcnJheUZlZWRFbnRyaWVzKTtcblxuICAgICAgICBpbmZlcmVuY2VWYWx1ZXMucHVzaChcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5ldmFsKHRoaXMuaW5mZXJlbmNlVGVuc29yLCBuZGFycmF5RmVlZEVudHJpZXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgLy8gRm9yY2UgYSBHUFUgZG93bmxvYWQsIHNpbmNlIGluZmVyZW5jZSByZXN1bHRzIGFyZSBnZW5lcmFsbHkgbmVlZGVkIG9uXG4gICAgICAgIC8vIHRoZSBDUFUgYW5kIGl0J3MgbW9yZSBmYWlyIHRvIGluY2x1ZGUgYmxvY2tpbmcgb24gdGhlIEdQVSB0byBjb21wbGV0ZVxuICAgICAgICAvLyBpdHMgd29yayBmb3IgdGhlIGluZmVyZW5jZSBtZWFzdXJlbWVudC5cbiAgICAgICAgaW5mZXJlbmNlVmFsdWVzW2luZmVyZW5jZVZhbHVlcy5sZW5ndGggLSAxXS5nZXRWYWx1ZXMoKTtcblxuICAgICAgICBjb25zdCBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGNvbnN0IGV4YW1wbGVzUGVyU2VjID1cbiAgICAgICAgICAgICh0aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCAqIDEwMDAgLyBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUpO1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayEoZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayhmZWVkcywgaW5mZXJlbmNlVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1bisrO1xuXG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluZmVyTmV0d29yaygpLCB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zKTtcbiAgfVxuXG4gIHN0b3BJbmZlcnJpbmcoKSB7XG4gICAgdGhpcy5pc0luZmVycmluZyA9IGZhbHNlO1xuICB9XG5cbiAgaXNJbmZlcmVuY2VSdW5uaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzSW5mZXJyaW5nO1xuICB9XG5cbiAgY29tcHV0ZU1ldHJpYygpOiBTY2FsYXIge1xuICAgIGlmICh0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgbWV0cmljLCBubyBtZXRyaWMgRmVlZEVudHJpZXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgbGV0IG1ldHJpYyA9IHRoaXMuemVyb1NjYWxhcjtcblxuICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZXRyaWNCYXRjaFNpemUhOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWV0cmljVmFsdWUgPVxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmV2YWwodGhpcy5tZXRyaWNUZW5zb3IhLCB0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzISk7XG5cbiAgICAgICAgbWV0cmljID0gdGhpcy5tYXRoLmFkZChtZXRyaWMsIG1ldHJpY1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWV0cmljUmVkdWN0aW9uID09PSBNZXRyaWNSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgICBtZXRyaWMgPSB0aGlzLm1hdGguZGl2aWRlKG1ldHJpYywgdGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWV0cmljO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0VG90YWxCYXRjaGVzVHJhaW5lZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQ7XG4gIH1cblxuICBnZXRMYXN0Q29tcHV0ZWRNZXRyaWMoKTogU2NhbGFyIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWM7XG4gIH1cblxuICBzZXRNYXRoKG1hdGg6IE5EQXJyYXlNYXRoKSB7XG4gICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgfVxuXG4gIHNldFNlc3Npb24oc2Vzc2lvbjogU2Vzc2lvbikge1xuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICBzZXRJbmZlcmVuY2VUZW5zb3IoaW5mZXJlbmNlVGVuc29yOiBUZW5zb3IpIHtcbiAgICB0aGlzLmluZmVyZW5jZVRlbnNvciA9IGluZmVyZW5jZVRlbnNvcjtcbiAgfVxuXG4gIHNldEluZmVyZW5jZUV4YW1wbGVDb3VudChpbmZlcmVuY2VFeGFtcGxlQ291bnQ6IG51bWJlcikge1xuICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7Q29uc3RhbnROb2RlLCBOb2RlLCBUZW5zb3J9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgcHJpb3JpdHlfcXVldWUgZnJvbSAnLi9wcmlvcml0eV9xdWV1ZSc7XG5pbXBvcnQge1ByaW9yaXR5UXVldWV9IGZyb20gJy4vcHJpb3JpdHlfcXVldWUnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuLyoqXG4gKiBHaXZlbiBhIHRhcmdldCBub2RlIGluIGEgZ3JhcGgsIGFjY3VtdWxhdGUgdGhlIHNldCBvZiBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvXG4gKiBiZSBldmFsdWF0ZWQgaW4gb3JkZXIgdG8gZXZhbHVhdGUgdGhlIHRhcmdldCBncmFwaC4gVHJhdmVyc2FsIHN0b3BzIGFueXdoZXJlXG4gKiBhIG5vZGUncyB2YWx1ZXMgYXJlIGZlZCBpbiBleHRlcm5hbGx5IHZpYSBcImZlZWQgZGljdHNcIi5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gYmUgZXZhbHVhdGVkLlxuICogQHBhcmFtIHRlcm1pbmF0aW5nTm9kZXMgVGhlIHNldCBvZiBub2RlcyB0aGF0IHN0b3AgdHJhdmVyc2FsLlxuICogQHJldHVybiBUaGUgdW5vcmRlcmVkIHNldCBvZiBub2RlcyB0aGF0IG5lZWQgdG8gYmUgZXZhbHVhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChcbiAgICBub2RlczogTm9kZVtdLCB0ZXJtaW5hdGluZ05vZGVzOiBOb2RlW10pOiBOb2RlW10ge1xuICBjb25zdCB0ZXJtaW5hdGluZ05vZGVNYXA6IHtbaWQ6IG51bWJlcl06IE5vZGV9ID0ge307XG4gIGNvbnN0IHNlZW46IHtbaWQ6IG51bWJlcl06IE5vZGV9ID0ge307XG4gIGNvbnN0IHNldDogTm9kZVtdID0gW107XG4gIGNvbnN0IHZpc2l0OiBOb2RlW10gPSBub2Rlcy5zbGljZSgpO1xuICB0ZXJtaW5hdGluZ05vZGVzLmZvckVhY2gobm9kZSA9PiB0ZXJtaW5hdGluZ05vZGVNYXBbbm9kZS5pZF0gPSBub2RlKTtcbiAgLyogRmxvb2QgZmlsbDogV2hpbGUgdGhlICd0byB2aXNpdCcgc3RhY2sgaXMgbm90IGVtcHR5LCBwb3AgYSBub2RlIG9mZiBvZiBpdC5cbiAgICogSWYgdGhlIG5vZGUgaGFzIG5vdCB5ZXQgYmVlbiB2aXNpdGVkLCBhZGQgaXQgdG8gdGhlIHNldCwgbWFyayBpdCBhcyBzZWVuLFxuICAgKiBhbmQgZW5xdWV1ZSBhbGwgb2YgaXRzIGFuY2VzdG9yIChpbnB1dCkgbm9kZXMuICovXG4gIHdoaWxlICh2aXNpdC5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXIgPSB2aXNpdC5wb3AoKSE7XG4gICAgaWYgKHNlZW5bY3VyLmlkXSA9PSBudWxsKSB7XG4gICAgICBpZiAodGVybWluYXRpbmdOb2RlTWFwW2N1ci5pZF0gPT0gbnVsbCkge1xuICAgICAgICBPYmplY3Qua2V5cyhjdXIuaW5wdXRzKVxuICAgICAgICAgICAgLm1hcChpbnB1dE5hbWUgPT4gY3VyLmlucHV0c1tpbnB1dE5hbWVdKVxuICAgICAgICAgICAgLmZvckVhY2goaW5wdXQgPT4gdmlzaXQucHVzaChpbnB1dC5ub2RlKSk7XG4gICAgICB9XG4gICAgICBzZXQucHVzaChjdXIpO1xuICAgICAgc2VlbltjdXIuaWRdID0gY3VyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2V0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc2V0IG9mIG5vZGVzLCBjb21wdXRlIHRoZWlyIG9yZGVyIHN1Y2ggdGhhdCBhbGwgZGVwZW5kZW50IG5vZGVzIGFyZVxuICogZXZhbHVhdGVkIGFmdGVyIHRoZWlyIGRlcGVuZGVlcy4gVGhpcyBpcyB0aGUgJ2luZmVyZW5jZSBvcmRlcicgZm9yIG5vZGVzIGluXG4gKiB0aGUgb3BlcmF0aW9uIGdyYXBoLlxuICogQHBhcmFtIHVub3JkZXJlZEV2YWx1YXRpb25TZXQgVGhlIHVub3JkZXJlZCBzZXQgb2Ygbm9kZXMgdGhhdCBuZWVkIHRvIGJlXG4gKiBldmFsdWF0ZWQuXG4gKiBAcmV0dXJuIFRoZSBpbnB1dCBub2RlcyBpbiBmb3J3YXJkIGV2YWx1YXRpb24gb3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldCh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0OiBOb2RlW10pOlxuICAgIE5vZGVbXSB7XG4gIC8qIEEgcHJpb3JpdHkgcXVldWUgaXMgdXNlZCwgd2hlcmUgdGhlIHByaW9yaXR5IGlzIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mXG4gICAqIHVuZXZhbHVhdGVkIG5vZGVzIHdob3NlIGlucHV0cyBjb21lIGZyb20gdGhlIGVsZW1lbnQgbm9kZS4gVGhpcyBndWFyYW50ZWVzXG4gICAqIHRoYXQgYWxsIGRvd25zdHJlYW0gbm9kZXMgd2lsbCBiZSBkZXF1ZXVlZCBiZWZvcmUgdGhlaXIgYW5jZXN0b3JzLiAqL1xuICBjb25zdCBzZXQ6IE5vZGVbXSA9IFtdO1xuICBjb25zdCBub2RlSW5kaWNlczoge1tpZDogbnVtYmVyXTogbnVtYmVyfSA9IHt9O1xuICBjb25zdCBwZW5kaW5nRGVwZW5kZW5jaWVzOiB7W2lkOiBudW1iZXJdOiBudW1iZXJ9ID0ge307XG5cbiAgLyogVGhlIHF1ZXVlIHByaW9yaXR5IGNhbGxiYWNrIGxvb2tzIGF0IHRoZSBudW1iZXIgb2YgcGVuZGluZyBkZXBlbmRlbmNpZXMgb2ZcbiAgICogYSBnaXZlbiBub2RlLiBUaGUgcXVldWUgaW5kZXggb2JzZXJ2ZXIgY2FsbGJhY2sgbWFpbnRhaW5zIHRoZSBsb2NhdGlvbiBvZlxuICAgKiBlYWNoIG5vZGUgaW4gdGhlIGFycmF5LCBmb3IgcHJpb3JpdHkgdXBkYXRlcy4gKi9cbiAgY29uc3Qgbm9kZVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWU8Tm9kZT4oXG4gICAgICAoYTogTm9kZSwgYjogTm9kZSkgPT4gcHJpb3JpdHlfcXVldWUuZGVmYXVsdENvbXBhcmUoXG4gICAgICAgICAgcGVuZGluZ0RlcGVuZGVuY2llc1thLmlkXSwgcGVuZGluZ0RlcGVuZGVuY2llc1tiLmlkXSksXG4gICAgICAobm9kZTogTm9kZSwgbmV3SW5kZXg6IG51bWJlcikgPT4gbm9kZUluZGljZXNbbm9kZS5pZF0gPSBuZXdJbmRleCk7XG5cbiAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKG5vZGUgPT4gcGVuZGluZ0RlcGVuZGVuY2llc1tub2RlLmlkXSA9IDApO1xuXG4gIC8qIEZvciBldmVyeSBkZXNjZW5kZW50IG9mIGEgbm9kZSAob3V0cHV0IG9mIGFuY2VzdG9yIGlzIGlucHV0IHRvIGRlc2NlbmRhbnQpLFxuICAgKiBpbmNyZW1lbnQgdGhlICdwZW5kaW5nIGRlcGVuZGVuY3kgY291bnQnIGZvciB0aGUgYW5jZXN0b3IuIFRoaXMgcHJlcGFyZXNcbiAgICogdGhlICdwZW5kaW5nIGRlcGVuZGVuY3kgY291bnQnIGFzIGEgcHJpb3JpdHkgbWFwLiAqL1xuICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goXG4gICAgICBub2RlID0+IE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKVxuICAgICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gbm9kZS5pbnB1dHNba2V5XSlcbiAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2lucHV0Lm5vZGUuaWRdKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2gobm9kZSA9PiBub2RlUXVldWUuZW5xdWV1ZShub2RlKSk7XG5cbiAgd2hpbGUgKCFub2RlUXVldWUuZW1wdHkoKSkge1xuICAgIHNldC51bnNoaWZ0KG5vZGVRdWV1ZS5kZXF1ZXVlKCkpO1xuICAgIC8qIEFzIGVhY2ggbm9kZSBpcyB2aXNpdGVkLCBkZWNyZW1lbnQgdGhlICdwZW5kaW5nIGRlcGVuZGVuY3kgY291bnQnIG9mXG4gICAgICogZWFjaCBhbmNlc3RvciwgYW5kIHRlbGwgdGhlIHByaW9yaXR5IHF1ZXVlIHRoYXQgdGhlIHByaW9yaXR5IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIE9iamVjdC5rZXlzKHNldFswXS5pbnB1dHMpLm1hcChrZXkgPT4gc2V0WzBdLmlucHV0c1trZXldKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmICh1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmluZGV4T2YoaW5wdXQubm9kZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0tLTtcbiAgICAgIG5vZGVRdWV1ZS51cGRhdGUoaW5wdXQubm9kZSwgbm9kZUluZGljZXNbaW5wdXQubm9kZS5pZF0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBAcmV0dXJuIFRydWUgaWZmIHRoZSBub2RlIGlzIGFuIGlucHV0IG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lucHV0Tm9kZShub2RlOiBOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhub2RlLmlucHV0cykubGVuZ3RoID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkQmFja1Byb3AodDogVGVuc29yKTogYm9vbGVhbiB7XG4gIHJldHVybiAhKHQubm9kZSBpbnN0YW5jZW9mIENvbnN0YW50Tm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Bhc3N0aHJvdWdoTm9kZShub2RlOiBOb2RlLCBtYXA6IFRlbnNvckFycmF5TWFwKTogYm9vbGVhbiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmlucHV0cyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGlucHV0ID0gbm9kZS5pbnB1dHNba2V5c1tpXV07XG4gICAgaWYgKG1hcC5nZXQoaW5wdXQsIHRydWUpID09PSBtYXAuZ2V0KG5vZGUub3V0cHV0LCB0cnVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4vbWF0aC9jb252X3V0aWwnO1xuaW1wb3J0ICogYXMgZ3BncHVfdXRpbCBmcm9tICcuL21hdGgvd2ViZ2wvZ3BncHVfdXRpbCc7XG5pbXBvcnQgKiBhcyByZW5kZXJfbmRhcnJheV9ncHVfdXRpbCBmcm9tICcuL21hdGgvd2ViZ2wvcmVuZGVyX25kYXJyYXlfZ3B1X3V0aWwnO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuL21hdGgvd2ViZ2wvd2ViZ2xfdXRpbCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCB7Q2hlY2twb2ludExvYWRlcn0gZnJvbSAnLi9jaGVja3BvaW50X2xvYWRlcic7XG5leHBvcnQge0RhdGFTdGF0cywgSW5NZW1vcnlEYXRhc2V0fSBmcm9tICcuL2RhdGFzZXQnO1xuZXhwb3J0IHtHcmFwaCwgVGVuc29yfSBmcm9tICcuL2dyYXBoJztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmV4cG9ydCB7R3JhcGhSdW5uZXIsIEdyYXBoUnVubmVyRXZlbnRPYnNlcnZlciwgTWV0cmljUmVkdWN0aW9ufSBmcm9tICcuL2dyYXBoX3J1bm5lcic7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5leHBvcnQge0NvbnN0YW50SW5pdGlhbGl6ZXIsIEluaXRpYWxpemVyLCBOREFycmF5SW5pdGlhbGl6ZXIsIE9uZXNJbml0aWFsaXplciwgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIsIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyLCBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIsIFZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyLCBaZXJvc0luaXRpYWxpemVyfSBmcm9tICcuL2luaXRpYWxpemVycyc7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5leHBvcnQge0luQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciwgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBJbnB1dFByb3ZpZGVyfSBmcm9tICcuL2lucHV0X3Byb3ZpZGVyJztcbmV4cG9ydCB7TWF0cml4T3JpZW50YXRpb24sIE5EQXJyYXlNYXRofSBmcm9tICcuL21hdGgvbWF0aCc7XG5leHBvcnQge05EQXJyYXlNYXRoQ1BVfSBmcm9tICcuL21hdGgvbWF0aF9jcHUnO1xuZXhwb3J0IHtOREFycmF5TWF0aEdQVX0gZnJvbSAnLi9tYXRoL21hdGhfZ3B1Jztcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmV4cG9ydCB7QXJyYXkxRCwgQXJyYXkyRCwgQXJyYXkzRCwgQXJyYXk0RCwgTkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL21hdGgvbmRhcnJheSc7XG5leHBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9tYXRoL3dlYmdsL2dwZ3B1X2NvbnRleHQnO1xuZXhwb3J0IHtPcHRpbWl6ZXJ9IGZyb20gJy4vb3B0aW1pemVyJztcbmV4cG9ydCB7Q29zdFJlZHVjdGlvbiwgRmVlZEVudHJ5LCBTZXNzaW9ufSBmcm9tICcuL3Nlc3Npb24nO1xuZXhwb3J0IHtTR0RPcHRpbWl6ZXJ9IGZyb20gJy4vc2dkX29wdGltaXplcic7XG4vLyBTZWNvbmQgbGV2ZWwgZXhwb3J0cy5cbmV4cG9ydCB7Y29udl91dGlsLCBncGdwdV91dGlsLCByZW5kZXJfbmRhcnJheV9ncHVfdXRpbCwgdXRpbCwgd2ViZ2xfdXRpbH07XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuXG4vKipcbiAqIEluaXRpYWxpemVyIGludGVyZmFjZSwgYWxsIGluaXRpYWxpemVyIGltcGxlbWVudCB0aGlzIGludGVyZmFjZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gIGluaXRpYWxpemUod2VpZ2h0c1NoYXBlOiBudW1iZXJbXSwgaW5wdXRVbml0czogbnVtYmVyLCBvdXRwdXRVbml0czogbnVtYmVyKTpcbiAgICAgIE5EQXJyYXk7XG59XG5cbmV4cG9ydCBjbGFzcyBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciBpbXBsZW1lbnRzIEluaXRpYWxpemVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHNjYWxlID0gMS4wLFxuICAgICAgcHJpdmF0ZSBtb2RlOiAnZmFuX2luJ3wnZmFuX291dCd8J2Zhbl9hdmcnID0gJ2Zhbl9pbicsXG4gICAgICBwcml2YXRlIGRpc3RyaWJ1dGlvbjogJ3VuaWZvcm0nfCdub3JtYWwnID0gJ25vcm1hbCcpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdmYW5faW4nKSB7XG4gICAgICBuID0gaW5wdXRVbml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9vdXQnKSB7XG4gICAgICBuID0gb3V0cHV0VW5pdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdmYW5fYXZnJykge1xuICAgICAgbiA9IChpbnB1dFVuaXRzICsgb3V0cHV0VW5pdHMpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdVbmV4cGVjdGVkIG1vZGUgZm9yIHZhcmlhbmNlIHNjYWxpbmcgaW5pdGlhbGl6ZXI6ICcgKyB0aGlzLm1vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc3RyaWJ1dGlvbiA9PT0gJ25vcm1hbCcpIHtcbiAgICAgIHJldHVybiBOREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwoXG4gICAgICAgICAgd2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCh0aGlzLnNjYWxlIC8gbikpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICd1bmlmb3JtJykge1xuICAgICAgcmV0dXJuIE5EQXJyYXkucmFuZFVuaWZvcm0oXG4gICAgICAgICAgd2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCgzICogdGhpcy5zY2FsZSAvIG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdVbmV4cGVjdGVkIGRpc3RyaWJ1dGlvbiBmb3IgdmFyaWFuY2Ugc2NhbGluZyBpbml0aWFsaXplcjogJyArXG4gICAgICAgICAgdGhpcy5kaXN0cmlidXRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWmVyb3NJbml0aWFsaXplciBpbXBsZW1lbnRzIEluaXRpYWxpemVyIHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIGluaXRpYWxpemUod2VpZ2h0c1NoYXBlOiBudW1iZXJbXSwgaW5wdXRVbml0czogbnVtYmVyLCBvdXRwdXRVbml0czogbnVtYmVyKTpcbiAgICAgIE5EQXJyYXkge1xuICAgIHJldHVybiBOREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE9uZXNJbml0aWFsaXplciBpbXBsZW1lbnRzIEluaXRpYWxpemVyIHtcbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIGluaXRpYWxpemUod2VpZ2h0c1NoYXBlOiBudW1iZXJbXSwgaW5wdXRVbml0czogbnVtYmVyLCBvdXRwdXRVbml0czogbnVtYmVyKTpcbiAgICAgIE5EQXJyYXkge1xuICAgIGNvbnN0IHZhbHVlcyA9IE5EQXJyYXkuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICB2YWx1ZXMuZmlsbCgxKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25zdGFudEluaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZhbHVlID0gMCkge31cblxuICBpbml0aWFsaXplKHdlaWdodHNTaGFwZTogbnVtYmVyW10sIGlucHV0VW5pdHM6IG51bWJlciwgb3V0cHV0VW5pdHM6IG51bWJlcik6XG4gICAgICBOREFycmF5IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBOREFycmF5Lnplcm9zKHdlaWdodHNTaGFwZSk7XG4gICAgdmFsdWVzLmZpbGwodGhpcy52YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTkRBcnJheUluaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5kYXJyYXk6IE5EQXJyYXkpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMubmRhcnJheTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgaW1wbGVtZW50cyBJbml0aWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbWVhbiA9IDAsIHByaXZhdGUgc3RkZXYgPSAuMDUpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgcmV0dXJuIE5EQXJyYXkucmFuZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyIGltcGxlbWVudHMgSW5pdGlhbGl6ZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1lYW4gPSAwLCBwcml2YXRlIHN0ZGV2ID0gLjA1KSB7fVxuXG4gIGluaXRpYWxpemUod2VpZ2h0c1NoYXBlOiBudW1iZXJbXSwgaW5wdXRVbml0czogbnVtYmVyLCBvdXRwdXRVbml0czogbnVtYmVyKTpcbiAgICAgIE5EQXJyYXkge1xuICAgIHJldHVybiBOREFycmF5LnJhbmRUcnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCB0aGlzLm1lYW4sIHRoaXMuc3RkZXYpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIgaW1wbGVtZW50cyBJbml0aWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbWludmFsID0gLS4wNSwgcHJpdmF0ZSBtYXh2YWwgPSAuMDUpIHt9XG5cbiAgaW5pdGlhbGl6ZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdLCBpbnB1dFVuaXRzOiBudW1iZXIsIG91dHB1dFVuaXRzOiBudW1iZXIpOlxuICAgICAgTkRBcnJheSB7XG4gICAgcmV0dXJuIE5EQXJyYXkucmFuZFVuaWZvcm0od2VpZ2h0c1NoYXBlLCB0aGlzLm1pbnZhbCwgdGhpcy5tYXh2YWwpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFRoZSBpbnRlcmZhY2UgZm9yIGlucHV0IHByb3ZpZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBpbnB1dCBhcyBhIGNvcHkuIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIGRhdGEgbWlnaHRcbiAgICogZ2V0IHVwbG9hZGVkIHRvIHRoZSBHUFUgYW5kIG1vZGlmeSB0aGUgb3JpZ2luYWwgZGF0YS5cbiAgICogQHBhcmFtIG1hdGggTkRBcnJheU1hdGhcbiAgICovXG4gIGdldE5leHRDb3B5KG1hdGg6IE5EQXJyYXlNYXRoKTogTkRBcnJheTtcbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIGlucHV0IGNvcHkuXG4gICAqIEBwYXJhbSBtYXRoIE5EQXJyYXlNYXRoXG4gICAqIEBwYXJhbSBjb3B5IFRoZSBjb3B5IHByb3ZpZGVkIGZyb20gZ2V0TmV4dENvcHlcbiAgICovXG4gIGRpc3Bvc2VDb3B5KG1hdGg6IE5EQXJyYXlNYXRoLCBjb3B5OiBOREFycmF5KTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIGNvbW1vbiBpbnRlcmZhY2UgZm9yIHNodWZmbGVkIGlucHV0IHByb3ZpZGVyIGJ1aWxkZXJzLiBUaGlzIHJldHVybnNcbiAqIElucHV0UHJvdmlkZXJzIHRoYXQgYXJlIHN5bmNocm9uaXplZC5cbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyIHtcbiAgZ2V0SW5wdXRQcm92aWRlcnMoKTogSW5wdXRQcm92aWRlcltdO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciBpbXBsZW1lbnRzXG4gICAgU2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciB7XG4gIHByb3RlY3RlZCBzaHVmZmxlZEluZGljZXM6IFVpbnQzMkFycmF5O1xuICBwcm90ZWN0ZWQgbnVtSW5wdXRzOiBudW1iZXI7XG5cbiAgcHJvdGVjdGVkIGlkeCA9IDA7XG4gIC8vIENvdW50ZXIgZm9yIGhvdyBtYW55IHRpbWVzIHRoZSBjdXJyZW50IGluZGV4IGhhcyBiZWVuIGNhbGxlZC4gUmVzZXRzIHRvIDBcbiAgLy8gd2hlbiBpdCByZWFjaGVzIHRoZSBudW1iZXIgb2YgaW5wdXRzLlxuICBwcm90ZWN0ZWQgaW5wdXRDb3VudGVyID0gMDtcbiAgcHJvdGVjdGVkIGVwb2NoID0gMDtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJgLiBBbGwgb2YgdGhlIGlucHV0cyBtdXN0IGJlXG4gICAqIGluIG1lbW9yeS5cbiAgICogQHBhcmFtIGlucHV0cyBBbGwgb2YgdGhlIGlucHV0cywgc2l6ZTogW251bWJlciBvZiBpbnB1dHNdW251bWJlciBvZlxuICAgKiBleGFtcGxlc10uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgaW5wdXRzOiBOREFycmF5W11bXSkge1xuICAgIHRoaXMuc2h1ZmZsZWRJbmRpY2VzID0gdXRpbC5jcmVhdGVTaHVmZmxlZEluZGljZXMoaW5wdXRzWzBdLmxlbmd0aCk7XG4gICAgdGhpcy5udW1JbnB1dHMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBudW1iZXIgb2YgZXhhbXBsZXMgaW4gZWFjaCBpbnB1dCBtYXRjaGVzLlxuICAgIGNvbnN0IG51bUV4YW1wbGVzID0gdGhpcy5pbnB1dHNbMF0ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgdGhpcy5pbnB1dHNbaV0ubGVuZ3RoID09PSBudW1FeGFtcGxlcyxcbiAgICAgICAgICAnTnVtYmVyIG9mIGV4YW1wbGVzIG11c3QgbWF0Y2ggYWNyb3NzIGRpZmZlcmVudCBpbnB1dHMuJyk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBzaGFwZXMgd2l0aGluIGlucHV0cyBhbGwgbWF0Y2guXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUlucHV0czsgaSsrKSB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gdGhpcy5pbnB1dHNbaV1bMF0uc2hhcGU7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuaW5wdXRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goaW5wdXRTaGFwZSwgdGhpcy5pbnB1dHNbaV1bal0uc2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRDdXJyZW50RXhhbXBsZUluZGV4KCk6IG51bWJlciB7XG4gICAgY29uc3QgcmV0dXJuSWR4ID0gdGhpcy5pZHg7XG5cbiAgICB0aGlzLmlucHV0Q291bnRlcisrO1xuICAgIGlmICh0aGlzLmlucHV0Q291bnRlciA+PSB0aGlzLm51bUlucHV0cykge1xuICAgICAgdGhpcy5pZHgrKztcbiAgICAgIHRoaXMuaW5wdXRDb3VudGVyID0gMDtcblxuICAgICAgaWYgKHRoaXMuaWR4ID49IHRoaXMuaW5wdXRzWzBdLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIHRoaXMuZXBvY2grKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybklkeDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXROZXh0SW5wdXQoaW5wdXRJZDogbnVtYmVyKTogTkRBcnJheSB7XG4gICAgY29uc3QgY3VycmVudEV4YW1wbGVJbmRleCA9IHRoaXMuZ2V0Q3VycmVudEV4YW1wbGVJbmRleCgpO1xuXG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW2lucHV0SWRdW3RoaXMuc2h1ZmZsZWRJbmRpY2VzW2N1cnJlbnRFeGFtcGxlSW5kZXhdXTtcbiAgfVxuXG4gIGdldEVwb2NoKCkge1xuICAgIHJldHVybiB0aGlzLmVwb2NoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5wdXQgcHJvdmlkZXJzIHdoaWNoIHNodWZmbGUgdGhlIGlucHV0cyBhbmQgc3RheSBpbiBzeW5jLlxuICAgKi9cbiAgZ2V0SW5wdXRQcm92aWRlcnMoKTogSW5wdXRQcm92aWRlcltdIHtcbiAgICBjb25zdCBpbnB1dFByb3ZpZGVyczogSW5wdXRQcm92aWRlcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtSW5wdXRzOyBpKyspIHtcbiAgICAgIGlucHV0UHJvdmlkZXJzLnB1c2godGhpcy5nZXRJbnB1dFByb3ZpZGVyKGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvdmlkZXJzO1xuICB9XG5cbiAgYWJzdHJhY3QgZ2V0SW5wdXRQcm92aWRlcihpbnB1dElkOiBudW1iZXIpOiBJbnB1dFByb3ZpZGVyO1xufVxuXG4vKipcbiAqIEFuIGluIENQVSBtZW1vcnkgU2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciB0aGF0IHNodWZmbGVzIE5EQXJyYXlzIG9uIHRoZVxuICogQ1BVIGFuZCBrZWVwcyB0aGVtIG11dHVhbGx5IGluIHN5bmMuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgZXh0ZW5kc1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciB7XG4gIGdldElucHV0UHJvdmlkZXIoaW5wdXRJZDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBnZXROZXh0Q29weShtYXRoOiBOREFycmF5TWF0aCk6IE5EQXJyYXkge1xuICAgICAgICByZXR1cm4gTkRBcnJheS5saWtlKHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkpO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2VDb3B5KG1hdGg6IE5EQXJyYXlNYXRoLCBjb3B5OiBOREFycmF5KSB7XG4gICAgICAgIGNvcHkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbiBHUFUgbWVtb3J5IFNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgdGhhdCBzaHVmZmxlcyBOREFycmF5cyBvbiB0aGVcbiAqIEdQVSBhbmQga2VlcHMgdGhlbSBtdXR1YWxseSBpbiBzeW5jLiBUaGlzIGlzIG1vcmUgcGVyZm9ybWFudCB0aGFuIHRoZSBDUFVcbiAqIHZlcnNpb24gYXMgdGV4dHVyZXMgd2lsbCBzdGF5IGluIG1lbW9yeSwgaG93ZXZlciB0aGlzIGlzIG1vcmUgR1BVIG1lbW9yeVxuICogaW50ZW5zaXZlIGFzIGl0IGtlZXBzIHRleHR1cmVzIHJlc2lkZW50IGluIEdQVSBtZW1vcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgZXh0ZW5kc1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlciB7XG4gIGdldElucHV0UHJvdmlkZXIoaW5wdXRJZDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBnZXROZXh0Q29weShtYXRoOiBOREFycmF5TWF0aCk6IE5EQXJyYXkge1xuICAgICAgICByZXR1cm4gbWF0aC5jbG9uZShzaHVmZmxlZElucHV0UHJvdmlkZXIuZ2V0TmV4dElucHV0KGlucHV0SWQpKTtcbiAgICAgIH0sXG4gICAgICBkaXNwb3NlQ29weShtYXRoOiBOREFycmF5TWF0aCwgY29weTogTkRBcnJheSkge1xuICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9uZGFycmF5JztcblxuLyoqIEEgbm9kZSdzIGFjdGl2YXRpb24gZnVuY3Rpb24gYW5kIGl0cyBkZXJpdmF0aXZlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBvdXRwdXQ8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCBpbnB1dDogVCk6IFQ7XG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIGlucHV0OiBULCBvdXRwdXQ6IFQpOiBUO1xufVxuXG5leHBvcnQgY2xhc3MgVGFuSEZ1bmMgaW1wbGVtZW50cyBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBvdXRwdXQ8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIG1hdGgudGFuaCh4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQsIHk6IFQpIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICBjb25zdCB5U3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoeSwgeSk7XG4gICAgICAvLyAxIC0geV4yLlxuICAgICAgcmV0dXJuIG1hdGguc2NhbGFyTWludXNBcnJheShTY2FsYXIuT05FLCB5U3F1YXJlZCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlTFVGdW5jIGltcGxlbWVudHMgQWN0aXZhdGlvbkZ1bmN0aW9uIHtcbiAgb3V0cHV0PFQgZXh0ZW5kcyBOREFycmF5PihtYXRoOiBOREFycmF5TWF0aCwgeDogVCkge1xuICAgIHJldHVybiBtYXRoLnNjb3BlKCgpID0+IHtcbiAgICAgIHJldHVybiBtYXRoLnJlbHUoeCk7XG4gICAgfSk7XG4gIH1cblxuICBkZXI8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBULCB5OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIG1hdGguc3RlcCh4KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2lnbW9pZEZ1bmMgaW1wbGVtZW50cyBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBvdXRwdXQ8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIG1hdGguc2lnbW9pZCh4KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHg6IFQsIHk6IFQpOiBUIHtcbiAgICByZXR1cm4gbWF0aC5zY29wZSgoKSA9PiB7XG4gICAgICAvLyB5ICogKDEgLSB5KSA9IHkgLSB5XjJcbiAgICAgIGNvbnN0IHlTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh5LCB5KTtcbiAgICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh5LCB5U3F1YXJlZCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNxdWFyZUZ1bmMgaW1wbGVtZW50cyBBY3RpdmF0aW9uRnVuY3Rpb24ge1xuICBvdXRwdXQ8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgcmV0dXJuIG1hdGguZWxlbWVudFdpc2VNdWwoeCwgeCk7XG4gICAgfSk7XG4gIH1cblxuICBkZXI8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4OiBULCB5OiBUKSB7XG4gICAgcmV0dXJuIG1hdGguc2NvcGUoKCkgPT4ge1xuICAgICAgLy8gZHkvZHggPSAyKnguXG4gICAgICByZXR1cm4gbWF0aC5zY2FsYXJUaW1lc0FycmF5KFNjYWxhci5UV08sIHgpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRDb25jYXQzRFNoYXBlc01hdGNoKFxuICAgIHgxU2hhcGU6IG51bWJlcltdLCB4MlNoYXBlOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLFxuICAgIGVycm9yTWVzc2FnZVByZWZpeCA9ICcnKSB7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgeDFTaGFwZS5sZW5ndGggPT09IDMsXG4gICAgICBlcnJvck1lc3NhZ2VQcmVmaXggKyAnQ29uY2F0M0QgeDEgc2hhcGUgc2hvdWxkIGJlIG9mIHJhbmsgMy4nKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB4MlNoYXBlLmxlbmd0aCA9PT0gMyxcbiAgICAgIGVycm9yTWVzc2FnZVByZWZpeCArICdDb25jYXQzRCB4MiBzaGFwZSBzaG91bGQgYmUgb2YgcmFuayAzLicpO1xuXG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgYXhpcyA+PSAwICYmIGF4aXMgPCAzLCAnQXhpcyBmb3IgY29uY2F0M0QgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIuJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgKGkgPT09IGF4aXMpIHx8ICh4MVNoYXBlW2ldID09PSB4MlNoYXBlW2ldKSxcbiAgICAgICAgZXJyb3JNZXNzYWdlUHJlZml4ICtcbiAgICAgICAgICAgIGBTaGFwZSAoJHt4MVNoYXBlfSkgZG9lcyBub3QgbWF0Y2ggKCR7eDJTaGFwZX0pIGFsb25nIGAgK1xuICAgICAgICAgICAgYG5vbi1jb25jYXRlbmF0ZWQgYXhpcy5gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNvbmNhdDNET3V0cHV0U2hhcGUoXG4gICAgeDFTaGFwZTogbnVtYmVyW10sIHgyU2hhcGU6IG51bWJlcltdLFxuICAgIGF4aXM6IG51bWJlcik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIHV0aWwuYXNzZXJ0KHgxU2hhcGUubGVuZ3RoID09PSAzLCAnQ29uY2F0M0QgeDEgc2hhcGUgc2hvdWxkIGJlIG9mIHJhbmsgMy4nKTtcbiAgdXRpbC5hc3NlcnQoeDJTaGFwZS5sZW5ndGggPT09IDMsICdDb25jYXQzRCB4MnNoYXBlIHNob3VsZCBiZSBvZiByYW5rIDMuJyk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4MVNoYXBlLnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlW2F4aXNdICs9IHgyU2hhcGVbYXhpc107XG4gIHJldHVybiBvdXRwdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgaW5wdXRTaGFwZVJvd0NvbERlcHRoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZpZWxkU2l6ZTogbnVtYmVyLFxuICAgIGRlcHRoOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCB6ZXJvUGFkPzogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpbnB1dFNoYXBlUm93Q29sRGVwdGgsIGZpZWxkU2l6ZSwgc3RyaWRlKTtcbiAgfVxuICBjb25zdCBpbnB1dFJvd3MgPSBpbnB1dFNoYXBlUm93Q29sRGVwdGhbMF07XG4gIGNvbnN0IGlucHV0Q29scyA9IGlucHV0U2hhcGVSb3dDb2xEZXB0aFsxXTtcbiAgY29uc3Qgb3V0cHV0Um93cyA9IChpbnB1dFJvd3MgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICB1dGlsLmFzc2VydChcbiAgICAgIHV0aWwuaXNJbnQob3V0cHV0Um93cyksXG4gICAgICBgVGhlIG91dHB1dCAjIG9mIHJvd3MgKCR7b3V0cHV0Um93c30pIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBgICtcbiAgICAgICAgICBgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzYCk7XG5cbiAgY29uc3Qgb3V0cHV0Q29scyA9IChpbnB1dENvbHMgLSBmaWVsZFNpemUgKyAyICogemVyb1BhZCkgLyBzdHJpZGUgKyAxO1xuICB1dGlsLmFzc2VydChcbiAgICAgIHV0aWwuaXNJbnQob3V0cHV0Q29scyksXG4gICAgICBgVGhlIG91dHB1dCAjIG9mIGNvbHVtbnMgKCR7b3V0cHV0Q29sc30pIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIGAgK1xuICAgICAgICAgIGB0aGUgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzYCk7XG5cbiAgcmV0dXJuIFtvdXRwdXRSb3dzLCBvdXRwdXRDb2xzLCBkZXB0aF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRGVmYXVsdFBhZChcbiAgICBpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZpZWxkU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBmaWVsZFNpemUpIC8gMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlVGV4U2hhcGVGcm9tM0QoXG4gICAgc2hhcGVSb3dDb2xEZXB0aDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXSB7XG4gIHJldHVybiBbc2hhcGVSb3dDb2xEZXB0aFswXSwgc2hhcGVSb3dDb2xEZXB0aFsxXSAqIHNoYXBlUm93Q29sRGVwdGhbMl1dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdlaWdodHNTaGFwZTREKFxuICAgIGlucHV0RGVwdGg6IG51bWJlciwgb3V0cHV0RGVwdGg6IG51bWJlcixcbiAgICBmU2l6ZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gW2ZTaXplLCBmU2l6ZSwgaW5wdXREZXB0aCwgb3V0cHV0RGVwdGhdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdlaWdodHNUZXhTaGFwZShcbiAgICBpbnB1dERlcHRoOiBudW1iZXIsIG91dHB1dERlcHRoOiBudW1iZXIsXG4gICAgZmllbGRTaXplOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgcmV0dXJuIFtmaWVsZFNpemUgKiBmaWVsZFNpemUgKiBpbnB1dERlcHRoLCBvdXRwdXREZXB0aF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmlhc2VzVGV4U2hhcGUob3V0cHV0RGVwdGg6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gWzEsIG91dHB1dERlcHRoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVEaWxhdGVkUkMoXG4gICAgcmM6IFtudW1iZXIsIG51bWJlcl0sIG9yaWdTdHJpZGU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCByb3dzRGlsYXRlZCA9IChyY1swXSAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gIGNvbnN0IGNvbHNEaWxhdGVkID0gKHJjWzFdIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgcmV0dXJuIFtyb3dzRGlsYXRlZCwgY29sc0RpbGF0ZWRdO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTaGFwZXMoXG4gICAgc291cmNlU2l6ZTogW251bWJlciwgbnVtYmVyXSwgZGVzdFNpemU6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgY29uc3Qgc3JjQXJlYSA9IHNvdXJjZVNpemVbMF0gKiBzb3VyY2VTaXplWzFdO1xuICBjb25zdCBkc3RBcmVhID0gZGVzdFNpemVbMF0gKiBkZXN0U2l6ZVsxXTtcbiAgaWYgKHNyY0FyZWEgIT09IGRzdEFyZWEpIHtcbiAgICBjb25zdCBzcmNTdHIgPSAnWycgKyBzb3VyY2VTaXplWzBdICsgJywgJyArIHNvdXJjZVNpemVbMV0gKyAnXSc7XG4gICAgY29uc3QgZHN0U3RyID0gJ1snICsgZGVzdFNpemVbMF0gKyAnLCAnICsgZGVzdFNpemVbMV0gKyAnXSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY29weTJEIHNoYXBlcyBoYXZlIGRpZmZlcmVudCBhcmVhczpcXG4gIHNvdXJjZVNpemUgJyArIHNyY1N0ciArXG4gICAgICAgICcsIGFyZWEgJyArIHNyY0FyZWEgKyAnXFxuICBkZXN0U2l6ZSAnICsgZHN0U3RyICsgJywgYXJlYSAnICsgZHN0QXJlYSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoJztcbmltcG9ydCB7TkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL25kYXJyYXknO1xuXG4vKipcbiAqIEFuIGVycm9yIGZ1bmN0aW9uIGFuZCBpdHMgZGVyaXZhdGl2ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50V2lzZUNvc3RGdW5jdGlvbiB7XG4gIGNvc3Q8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4MTogVCwgeDI6IFQpOiBUO1xuICBkZXI8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4MTogVCwgeDI6IFQpOiBUO1xuICBkaXNwb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBTcXVhcmVDb3N0RnVuYyBpbXBsZW1lbnRzIEVsZW1lbnRXaXNlQ29zdEZ1bmN0aW9uIHtcbiAgcHJpdmF0ZSBoYWxmT25lID0gU2NhbGFyLm5ldygwLjUpO1xuXG4gIGNvc3Q8VCBleHRlbmRzIE5EQXJyYXk+KG1hdGg6IE5EQXJyYXlNYXRoLCB4MTogVCwgeDI6IFQpOiBUIHtcbiAgICBjb25zdCBkaWZmID0gbWF0aC5zdWJTdHJpY3QoeDEsIHgyKTtcbiAgICBjb25zdCBkaWZmU3F1YXJlZCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZGlmZiwgZGlmZik7XG4gICAgY29uc3QgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHRoaXMuaGFsZk9uZSwgZGlmZlNxdWFyZWQpO1xuXG4gICAgZGlmZi5kaXNwb3NlKCk7XG4gICAgZGlmZlNxdWFyZWQuZGlzcG9zZSgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGRlcjxUIGV4dGVuZHMgTkRBcnJheT4obWF0aDogTkRBcnJheU1hdGgsIHgxOiBULCB4MjogVCk6IFQge1xuICAgIHJldHVybiBtYXRoLnN1YlN0cmljdCh4MSwgeDIpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmhhbGZPbmUuZGlzcG9zZSgpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgKiBhcyBjb25jYXQzZF91dGlsIGZyb20gJy4vY29uY2F0M2RfdXRpbCc7XG5pbXBvcnQgKiBhcyBjb3B5MmRfdXRpbCBmcm9tICcuL2NvcHkyZF91dGlsJztcblxuaW1wb3J0IHtBcnJheTFELCBBcnJheTJELCBBcnJheTNELCBBcnJheTRELCBOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4vbmRhcnJheSc7XG5cbmV4cG9ydCB0eXBlIFNjb3BlUmVzdWx0ID0gTkRBcnJheVtdfE5EQXJyYXl8dm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBMU1RNQ2VsbCB7XG4gIChkYXRhOiBBcnJheTJELCBjOiBBcnJheTJELCBoOiBBcnJheTJEKTogW0FycmF5MkQsIEFycmF5MkRdO1xufVxuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOREFycmF5TWF0aCB7XG4gIHByaXZhdGUgbmRhcnJheVNjb3BlczogTkRBcnJheVtdW10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmVTY29wZTogTkRBcnJheVtdO1xuXG4gIHByaXZhdGUgbmRhcnJheXNUb0tlZXA6IE5EQXJyYXlbXVtdID0gW107XG4gIHByaXZhdGUgYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcDogTkRBcnJheVtdID0gW107XG5cbiAgcHJpdmF0ZSBkZWJ1Z01vZGUgPSBmYWxzZTtcblxuICAvKipcbiAgICogQHBhcmFtIHNhZmVNb2RlIEluIHNhZmUgbW9kZSwgeW91IG11c3QgdXNlIG1hdGggb3BlcmF0aW9ucyBpbnNpZGVcbiAgICogICAgIGEgbWF0aC5zY29wZSgpIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBjbGVhbiB1cCBpbnRlcm1lZGlhdGUgTkRBcnJheXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNhZmVNb2RlOiBib29sZWFuKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgbWF0aCBzY29wZS4gUHV0IGNoYWluZWQgbWF0aCBvcGVyYXRpb25zIGluc2lkZSBhIHNjb3BlXG4gICAqIGZ1bmN0aW9uIGNsb3N1cmUgc28gdGhhdCB0aGUgbGlicmFyeSBhdXRvbWF0aWNhbGx5IGNsZWFucyB1cCBOREFycmF5c1xuICAgKiBmcm9tIGludGVybWVkaWF0ZSBtYXRoIG9wZXJhdGlvbnMuIFlvdSBtdXN0IGNyZWF0ZSBhIHNjb3BlIGluIHNhZmUgbW9kZVxuICAgKiB0byBjYWxsIG1hdGggb3BlcmF0aW9ucy4gSWYgYSByZXN1bHQgaXMgcmV0dXJuZWQgZnJvbSB0aGUgc2NvcGUsIGl0IHdpbGxcbiAgICogYWxzbyBiZSB0cmFja2VkLCB3aGljaCBtZWFucyB0aGVyZSBtdXN0IGJlIHlldCBhbm90aGVyIHdyYXBwaW5nIHNjb3BlLlxuICAgKiBAcGFyYW0gc2NvcGVGbiBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIGNoYWluZWQgbWF0aCBvcGVyYXRpb25zLlxuICAgKi9cbiAgc2NvcGU8VCBleHRlbmRzIFNjb3BlUmVzdWx0PihcbiAgICAgIHNjb3BlRm46XG4gICAgICAgICAgKGtlZXA6IDxUMSBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQxKSA9PiBUMSxcbiAgICAgICAgICAgdHJhY2s6IDxUMiBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQyKSA9PiBUMikgPT4gVCkge1xuICAgIHRoaXMuc3RhcnRTY29wZSgpO1xuXG4gICAgY29uc3Qga2VlcEZuID0gPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCA9PiB0aGlzLmtlZXAobmRhcnJheSk7XG4gICAgY29uc3QgdHJhY2tGbiA9IDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQgPT4gdGhpcy50cmFjayhuZGFycmF5KTtcbiAgICBjb25zdCByZXN1bHQgPSBzY29wZUZuKGtlZXBGbiwgdHJhY2tGbik7XG5cbiAgICB0aGlzLmVuZFNjb3BlKHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cblxuICAvKipcbiAgICogSW4gZGVidWcgbW9kZSwgdGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCBiZSBkb3dubG9hZGVkIHRvIHRoZSBDUFVcbiAgICogYW5kIGNoZWNrZWQgZm9yIE5hTnMuIFRoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLlxuICAgKi9cbiAgZW5hYmxlRGVidWdNb2RlKCkge1xuICAgIHRoaXMuZGVidWdNb2RlID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oJ0RlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsICcgK1xuICAgICAgICAgICAgICAgICAgJ2JlIGRvd25sb2FkZWQgdG8gQ1BVIGFuZCBjaGVja2VkIGZvciBOYU5zLiAnICtcbiAgICAgICAgICAgICAgICAgICdUaGlzIHNpZ25pZmljYW50bHkgaW1wYWN0cyBwZXJmb3JtYW5jZS4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIHNjb3BlLiBVc2UgdGhpcyB3aXRoIGVuZFNjb3BlKCkgdG8gYWNoaWV2ZSB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5XG4gICAqIGFzIHNjb3BlKCkgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBmdW5jdGlvbiBjbG9zdXJlLlxuICAgKi9cbiAgc3RhcnRTY29wZSgpIHtcbiAgICBjb25zdCBuZXdTY29wZTogTkRBcnJheVtdID0gW107XG4gICAgdGhpcy5uZGFycmF5U2NvcGVzLnB1c2gobmV3U2NvcGUpO1xuICAgIHRoaXMuYWN0aXZlU2NvcGUgPSBuZXdTY29wZTtcblxuICAgIGNvbnN0IG5ld05EQXJyYXlzVG9LZWVwOiBOREFycmF5W10gPSBbXTtcbiAgICB0aGlzLm5kYXJyYXlzVG9LZWVwLnB1c2gobmV3TkRBcnJheXNUb0tlZXApO1xuICAgIHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcCA9IG5ld05EQXJyYXlzVG9LZWVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBhIHNjb3BlLiBVc2UgdGhpcyB3aXRoIHN0YXJ0U2NvcGUoKSB0byBhY2hpZXZlIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHlcbiAgICogYXMgc2NvcGUoKSB3aXRob3V0IHRoZSBuZWVkIGZvciBhIGZ1bmN0aW9uIGNsb3N1cmUuXG4gICAqL1xuICBlbmRTY29wZShyZXN1bHQ6IFNjb3BlUmVzdWx0KSB7XG4gICAgbGV0IGFycmF5c1RvS2VlcCA9IHRoaXMuYWN0aXZlU2NvcGVOREFycmF5c1RvS2VlcDtcbiAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgIGFycmF5c1RvS2VlcCA9IGFycmF5c1RvS2VlcC5jb25jYXQocmVzdWx0IGFzIE5EQXJyYXl8TkRBcnJheVtdKTtcbiAgICB9XG4gICAgLy8gRGlzcG9zZSB0aGUgY3VycmVudCBzY29wZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWN0aXZlU2NvcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5kYXJyYXkgPSB0aGlzLmFjdGl2ZVNjb3BlW2ldO1xuICAgICAgaWYgKHRoaXMuaXNOREFycmF5RGF0YUluTGlzdChuZGFycmF5LCBhcnJheXNUb0tlZXApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmRhcnJheS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gUG9wIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgIHRoaXMubmRhcnJheVNjb3Blcy5wb3AoKTtcbiAgICB0aGlzLmFjdGl2ZVNjb3BlID0gdGhpcy5uZGFycmF5U2NvcGVzLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIG51bGwhIDpcbiAgICAgICAgdGhpcy5uZGFycmF5U2NvcGVzW3RoaXMubmRhcnJheVNjb3Blcy5sZW5ndGggLSAxXTtcblxuICAgIC8vIFRyYWNrIHRoZSBjdXJyZW50IHJlc3VsdCBpbiB0aGUgcGFyZW50IHNjb3BlLlxuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBOREFycmF5ICYmXG4gICAgICAgICF0aGlzLmlzTkRBcnJheURhdGFJbkxpc3QocmVzdWx0LCB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXApKSB7XG4gICAgICB0aGlzLnRyYWNrKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdC5mb3JFYWNoKHIgPT4ge1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIE5EQXJyYXkgJiZcbiAgICAgICAgICAgICF0aGlzLmlzTkRBcnJheURhdGFJbkxpc3QociwgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwKSkge1xuICAgICAgICAgIHRoaXMudHJhY2socik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubmRhcnJheXNUb0tlZXAucG9wKCk7XG4gICAgdGhpcy5hY3RpdmVTY29wZU5EQXJyYXlzVG9LZWVwID0gdGhpcy5uZGFycmF5c1RvS2VlcC5sZW5ndGggPT09IDAgP1xuICAgICAgICBudWxsISA6XG4gICAgICAgIHRoaXMubmRhcnJheXNUb0tlZXBbdGhpcy5uZGFycmF5c1RvS2VlcC5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHByaXZhdGUgaXNOREFycmF5RGF0YUluTGlzdChuZGFycmF5OiBOREFycmF5LCBuZGFycmF5TGlzdDogTkRBcnJheVtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZGFycmF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5kYXJyYXlMaXN0W2ldLmdldERhdGEoKSA9PT0gbmRhcnJheS5nZXREYXRhKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyBhbiBOREFycmF5IGluIHRoZSBjdXJyZW50IHNjb3BlIGZyb20gYmVpbmcgZGlzcG9zZWQgYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHJlc3VsdCBUaGUgTkRBcnJheSB0byBrZWVwIGZyb20gYmVpbmcgZGlzcG9zZWQuXG4gICAqL1xuICBrZWVwPFQgZXh0ZW5kcyBOREFycmF5PihyZXN1bHQ6IFQpOiBUIHtcbiAgICBpZiAodGhpcy5hY3RpdmVTY29wZSA9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5zYWZlTW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnWW91IGFyZSB1c2luZyBtYXRoIGluIHNhZmUgbW9kZS4gRW5jbG9zZSBhbGwgJyArXG4gICAgICAgICAgICAnbWF0aC5tZXRob2QoKSBjYWxscyBpbnNpZGUgYSBzY29wZTogJyArXG4gICAgICAgICAgICAnbWF0aC5zY29wZSgoKSA9PiB7bWF0aC5tZXRob2QoKTsuLi59KSB0byBhdm9pZCBtZW1vcnkgJyArXG4gICAgICAgICAgICAnbGVha3MuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVNjb3BlTkRBcnJheXNUb0tlZXAucHVzaChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrRm9yTmFOKGFycjogTkRBcnJheSk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHMgPSBhcnIuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXNOYU4odmFsc1tpXSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RoZSByZXN1bHQgTkRBcnJheSBvZiB0aGUgbGFzdCBtYXRoIGNhbGwgaGFzIE5hTnMuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBhbiBOREFycmF5IGluIHRoZSBjdXJyZW50IHNjb3BlIHRvIGJlIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCB3aGVuXG4gICAqIHRoZSBjdXJyZW50IHNjb3BlIGVuZHMsIGFuZCByZXR1cm5zIHRoZSB2YWx1ZS5cbiAgICogQHBhcmFtIHJlc3VsdCBUaGUgTkRBcnJheSB0byB0cmFjayBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICovXG4gIHRyYWNrPFQgZXh0ZW5kcyBOREFycmF5PihyZXN1bHQ6IFQpOiBUIHtcbiAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHtcbiAgICAgIHRoaXMuY2hlY2tGb3JOYU4ocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWN0aXZlU2NvcGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuc2FmZU1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgbWF0aCBpbiBzYWZlIG1vZGUuIEVuY2xvc2UgYWxsICcgK1xuICAgICAgICAgICAgJ21hdGgubWV0aG9kKCkgY2FsbHMgaW5zaWRlIGEgc2NvcGU6ICcgK1xuICAgICAgICAgICAgJ21hdGguc2NvcGUoKCkgPT4ge21hdGgubWV0aG9kKCk7Li4ufSkgdG8gYXZvaWQgbWVtb3J5ICcgK1xuICAgICAgICAgICAgJ2xlYWtzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmVTY29wZS5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIG1hdHJpY2VzLCBBICogQi4gVGhlc2UgbXVzdCBiZSBtYXRyaWNlcyxcbiAgICogdXNlIG1hdHJpeFRpbWVzVmVjdG9yIGFuZCB2ZWN0b3JUaW1lc01hdHJpeCwgZG90UHJvZHVjdCwgYW5kIG91dGVyUHJvZHVjdFxuICAgKiBpbiBvdGhlciBjYXNlcy5cbiAgICogQHBhcmFtIGEgRmlyc3QgbWF0cml4IGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGIgU2Vjb25kIG1hdHJpeCBpbiBkb3QgcHJvZHVjdCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBhT3JpZW50YXRpb24gVGhlIE1hdHJpeE9yaWVudGF0aW9uIG9mIEEuIElmIHVzaW5nIFRSQU5TUE9TRUQsIHdpbGxcbiAgICogY29tcHV0ZSBBXlQgKiBCLlxuICAgKiBAcGFyYW0gYk9yaWVudGF0aW9uIFRoZSBNYXRyaXhPcmllbnRhdGlvbiBvZiBCLiBJZiB1c2luZyBUUkFOU1BPU0VELCB3aWxsXG4gICAqIGNvbXB1dGUgQSAqIEJeVC5cbiAgICovXG4gIG1hdE11bChcbiAgICAgIGE6IEFycmF5MkQsIGI6IEFycmF5MkQsIGFPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIsXG4gICAgICBiT3JpZW50YXRpb24gPSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKTogQXJyYXkyRCB7XG4gICAgY29uc3QgaW5uZXJTaGFwZUEgPVxuICAgICAgICAoYU9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMV0gOiBhLnNoYXBlWzBdO1xuICAgIGNvbnN0IGlubmVyU2hhcGVCID1cbiAgICAgICAgKGJPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiLnNoYXBlWzBdIDogYi5zaGFwZVsxXTtcblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBhLnJhbmsgPT09IDIgJiYgYi5yYW5rID09PSAyLFxuICAgICAgICBgRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBiZSByYW5rIDIsIGdvdCByYW5rcyAke2EucmFua31gICtcbiAgICAgICAgICAgIGBhbmQgJHtiLnJhbmt9LmApO1xuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGlubmVyU2hhcGVBID09PSBpbm5lclNoYXBlQixcbiAgICAgICAgYEVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzICgke2lubmVyU2hhcGVBfSkgYW5kIChgICtcbiAgICAgICAgICAgIGAke2lubmVyU2hhcGVCfSkgb2YgTkRBcnJheXMgd2l0aCBzaGFwZXMgJHthLnNoYXBlfSBhbmQgYCArXG4gICAgICAgICAgICBgJHtiLnNoYXBlfSBhbmQgb3JpZW50YXRpb25zICR7TWF0cml4T3JpZW50YXRpb25bYU9yaWVudGF0aW9uXX1gICtcbiAgICAgICAgICAgIGAgYW5kICR7TWF0cml4T3JpZW50YXRpb25bYk9yaWVudGF0aW9uXX0gbXVzdCBtYXRjaC5gKTtcblxuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubWF0TXVsSW50ZXJuYWwoYSwgYiwgYU9yaWVudGF0aW9uLCBiT3JpZW50YXRpb24pKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWF0TXVsSW50ZXJuYWwoXG4gICAgICBhOiBBcnJheTJELCBiOiBBcnJheTJELCBhT3JpZW50YXRpb246IE1hdHJpeE9yaWVudGF0aW9uLFxuICAgICAgYk9yaWVudGF0aW9uOiBNYXRyaXhPcmllbnRhdGlvbik6IEFycmF5MkQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiBhIHZlY3RvciBhbmQgYSBtYXRyaXgsIHYgKiBCLlxuICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIG1hdHJpeCBUaGUgbWF0cml4IGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICovXG4gIHZlY3RvclRpbWVzTWF0cml4KHY6IEFycmF5MUQsIG1hdHJpeDogQXJyYXkyRCk6IEFycmF5MUQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2LnJhbmsgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogZmlyc3QgaW5wdXQgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgcmFuayAke3YucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIG1hdHJpeC5yYW5rID09PSAyLFxuICAgICAgICBgRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNlY29uZCBpbnB1dCBtdXN0IGJlIHJhbmsgMiwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7bWF0cml4LnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2LnNpemUgPT09IG1hdHJpeC5zaGFwZVswXSxcbiAgICAgICAgYEVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCAoJHt2LnNpemV9KSBgICtcbiAgICAgICAgICAgIGBtdXN0IG1hdGNoIGlubmVyIGRpbWVuc2lvbiBvZiBzZWNvbmQgcmFuayAyIGlucHV0LCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHttYXRyaXgucmFua30uYCk7XG5cbiAgICByZXR1cm4gdGhpcy5tYXRNdWwodi5hczJEKDEsIHYuc2l6ZSksIG1hdHJpeCkuYXMxRCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiBhIG1hdHJpeCBhbmQgdmVjdG9yLCBBICogdi5cbiAgICogQHBhcmFtIG1hdHJpeCBUaGUgbWF0cml4IGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHYgVGhlIHZlY3RvciBpbiBkb3QgcHJvZHVjdCBvcGVyYXRpb24uXG4gICAqL1xuICBtYXRyaXhUaW1lc1ZlY3RvcihtYXRyaXg6IEFycmF5MkQsIHY6IEFycmF5MUQpOiBBcnJheTFEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdi5yYW5rID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IHNlY29uZCBpbnB1dCBtdXN0IHJhbmsgMSwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7di5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgbWF0cml4LnJhbmsgPT09IDIsXG4gICAgICAgIGBFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogZmlyc3QgaW5wdXQgbXVzdCBiZSBhIHJhbmsgMiwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7bWF0cml4LnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2LnNpemUgPT09IG1hdHJpeC5zaGFwZVsxXSxcbiAgICAgICAgYEVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCAke3Yuc2l6ZX0gYCArXG4gICAgICAgICAgICBgbXVzdCBtYXRjaCBpbm5lciBkaW1lbnNpb24gb2Ygc2Vjb25kIHJhbmsgMiBpbnB1dCwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGBzaGFwZSAke21hdHJpeC5zaGFwZX0uYCk7XG5cbiAgICByZXR1cm4gdGhpcy5tYXRNdWwobWF0cml4LCB2LmFzMkQodi5zaXplLCAxKSkuYXMxRCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9ycywgdjEgKiB2Mi5cbiAgICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IgaW4gdGhlIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yIGluIHRoZSBkb3QgcHJvZHVjdCBvcGVyYXRpb24uXG4gICAqL1xuICBkb3RQcm9kdWN0KHYxOiBBcnJheTFELCB2MjogQXJyYXkxRCk6IFNjYWxhciB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIGRvdFByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBgICtcbiAgICAgICAgICAgIGAke3YxLnJhbmt9IGFuZCAke3YyLnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2MS5zaXplID09PSB2Mi5zaXplLFxuICAgICAgICBgRXJyb3IgaW4gZG90UHJvZHVjdDogc2l6ZSBvZiBpbnB1dHMgKCR7djEuc2l6ZX0pIGFuZCAoYCArXG4gICAgICAgICAgICBgJHt2Mi5zaXplfSkgbXVzdCBtYXRjaC5gKTtcbiAgICByZXR1cm4gdGhpcy5tYXRNdWwodjEuYXMyRCgxLCB2MS5zaXplKSwgdjIuYXMyRCh2Mi5zaXplLCAxKSkuYXNTY2FsYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgb3V0ZXIgcHJvZHVjdCBvZiB0d28gdmVjdG9ycywgdjEgYW5kIHYyLlxuICAgKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3RvciBpbiB0aGUgb3V0ZXIgcHJvZHVjdCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3RvciBpbiB0aGUgZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgb3V0ZXJQcm9kdWN0KHYxOiBBcnJheTFELCB2MjogQXJyYXkxRCk6IEFycmF5MkQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBgICtcbiAgICAgICAgICAgIGAke3YxLnJhbmt9IGFuZCAke3YyLnJhbmt9LmApO1xuXG4gICAgcmV0dXJuIHRoaXMubWF0TXVsKHYxLmFzMkQodjEuc2l6ZSwgMSksIHYyLmFzMkQoMSwgdjIuc2l6ZSkpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFNoYXBlIG9wcyAvL1xuICAvLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQ2xvbmVzIGFuIE5EQXJyYXkgb2YgYW55IHNoYXBlLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgTkRBcnJheSB0byBjbG9uZS5cbiAgICovXG4gIGNsb25lPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5jbG9uZUludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY2xvbmVJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIFJlc2hhcGVzIGFuIE5EQXJyYXkgdG8gYSBuZXcgc2hhcGUuIFRoZSBzaXplIG9mIHRoZSBpbnB1dCBOREFycmF5IG11c3RcbiAgICogbWF0Y2ggdGhlIHNpemUgb2YgdGhlIHJlcXVlc3RlZCBzaGFwZS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSBuZXdTaGFwZSBUaGUgbmV3IHNoYXBlIHRvIHJlc2hhcGUgdGhlIE5EQXJyYXkgdG8uIE11c3QgYmUgdGhlIHNhbWVcbiAgICogc2l6ZSBhcyB0aGUgTkRBcnJheS5cbiAgICovXG4gIHJlc2hhcGU8VDEgZXh0ZW5kcyBOREFycmF5LCBUMiBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgbmRhcnJheTogVDEsIG5ld1NoYXBlOiBudW1iZXJbXSk6IFQyIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgbmRhcnJheS5zaXplID09PSB1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpLFxuICAgICAgICBgRXJyb3IgaW4gcmVzaGFwZTogb2xkIHNpemUgJHtuZGFycmF5LnNpemV9IG11c3QgbWF0Y2ggbmV3IHNpemUgYCArXG4gICAgICAgICAgICBgJHt1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpfS5gKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLnJlc2hhcGVJbnRlcm5hbDxUMSwgVDI+KG5kYXJyYXksIG5ld1NoYXBlKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlc2hhcGVJbnRlcm5hbDxUMSBleHRlbmRzIE5EQXJyYXksIFQyIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBuZGFycmF5OiBUMSwgbmV3U2hhcGU6IG51bWJlcltdKTogVDI7XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgc2xpY2UgZnJvbSBhIG1hdHJpeC4gVGhlIG9wZXJhdGlvbiBleHRyYWNlcyBhIHNsaWNlIGZyb20gaW5wdXRcbiAgICogdGhhdCBzdGFydHMgYXQgY29vcmRpbmF0ZXMgYGJlZ2luYCBhbmQgaXMgb2Ygc2l6ZSBgc2l6ZWAuXG4gICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgbWF0cml4IHRvIHNsaWNlIGZyb20uXG4gICAqIEBwYXJhbSBiZWdpbiBUaGUgMkQgY29vcmRpbmF0ZXMgaW4gdGhlIGlucHV0IG1hdHJpeCB0byBzdGFydCB0aGUgc2xpY2VcbiAgICogZnJvbS5cbiAgICogQHBhcmFtIHNpemUgVGhlIHNpY2Ugb2YgdGhlIDJEIHdpbmRvdyB0byBzbGljZS5cbiAgICovXG4gIHNsaWNlMkQoaW5wdXQ6IEFycmF5MkQsIGJlZ2luOiBbbnVtYmVyLCBudW1iZXJdLCBzaXplOiBbbnVtYmVyLCBudW1iZXJdKTpcbiAgICAgIEFycmF5MkQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBiZWdpblswXSArIHNpemVbMF0gPD0gaW5wdXQuc2hhcGVbMF0gJiZcbiAgICAgICAgICAgIGJlZ2luWzFdICsgc2l6ZVsxXSA8PSBpbnB1dC5zaGFwZVsxXSxcbiAgICAgICAgYEVycm9yIGluIHNsaWNlMkQ6IHJlcXVlc3RlZCBzdGFydCBwb3NpdGlvbiAke2JlZ2lufSBhbmQgc2l6ZSBgICtcbiAgICAgICAgICAgIGAke3NpemV9IHdvdWxkIG92ZXJmbG93IGlucHV0IG9mIHNoYXBlICR7aW5wdXQuc2hhcGV9LmApO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc2xpY2UyREludGVybmFsKGlucHV0LCBiZWdpbiwgc2l6ZSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzbGljZTJESW50ZXJuYWwoXG4gICAgICBpbnB1dDogQXJyYXkyRCwgYmVnaW46IFtudW1iZXIsIG51bWJlcl0sIHNpemU6IFtudW1iZXIsIG51bWJlcl0pOiBBcnJheTJEO1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgYSB3aW5kb3cgZnJvbSB0aGUgYHNvdXJjZWAgbWF0cml4IHN0YXJ0aW5nIGF0IGBzb3VyY2VCZWdpbmAgYW5kIGlzXG4gICAqIG9mIHNpemUgYHNvdXJjZVNpemVgIHRvIGEgd2luZG93IGluIHRoZSBgZGVzdGAgbWF0cml4IHN0YXJ0aW5nIGF0XG4gICAqIGBkZXN0QmVnaW5gIGFuZCBpcyBvZiBzaXplIGBkZXN0U2l6ZWAvXG4gICAqIEBwYXJhbSBzb3VyY2UgVGhlIHNvdXJjZSBtYXRyaXggdG8gY29weSBmcm9tLlxuICAgKiBAcGFyYW0gc291cmNlQmVnaW4gVGhlIGNvb3JkaW5hdGVzIHRvIHN0YXJ0IHRoZSBjb3B5IGZyb20uXG4gICAqIEBwYXJhbSBzb3VyY2VTaXplIFRoZSBzaXplIG9mIHRoZSBjb3B5IHdpbmRvdy5cbiAgICogQHBhcmFtIGRlc3QgVGhlIGRlc3RpbmF0aW9uIG1hdHJpeCB0byBjb3B5IHRvLlxuICAgKiBAcGFyYW0gZGVzdEJlZ2luIFRoZSBjb29yZGluYXRlcyBpbiBgZGVzdGAgdG8gY29weSB0by5cbiAgICogQHBhcmFtIGRlc3RTaXplIFRoZSBzaXplIG9mIHRoZSBkZXN0aW5hdGlvbiB3aW5kb3cuXG4gICAqL1xuICBjb3B5MkQoXG4gICAgICBzb3VyY2U6IEFycmF5MkQsIHNvdXJjZUJlZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc291cmNlU2l6ZTogW251bWJlciwgbnVtYmVyXSwgZGVzdDogQXJyYXkyRCwgZGVzdEJlZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgZGVzdFNpemU6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgc291cmNlQmVnaW5bMF0gKyBzb3VyY2VTaXplWzBdIDw9IHNvdXJjZS5zaGFwZVswXSAmJlxuICAgICAgICAgICAgc291cmNlQmVnaW5bMV0gKyBzb3VyY2VTaXplWzFdIDw9IHNvdXJjZS5zaGFwZVsxXSxcbiAgICAgICAgYEVycm9yIGluIGNvcHkyRDogcmVxdWVzdGVkIHNvdXJjZSBzdGFydCBwb3NpdGlvbiAke3NvdXJjZUJlZ2lufSBgICtcbiAgICAgICAgICAgIGBhbmQgc291cmNlIHNpemUgJHtzb3VyY2VTaXplfSB3b3VsZCBvdmVyZmxvdyBzb3VyY2UgTkRBcnJheWAgK1xuICAgICAgICAgICAgYG9mIHNoYXBlICR7c291cmNlLnNoYXBlfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZGVzdEJlZ2luWzBdICsgZGVzdFNpemVbMF0gPD0gZGVzdC5zaGFwZVswXSAmJlxuICAgICAgICAgICAgZGVzdEJlZ2luWzFdICsgZGVzdFNpemVbMV0gPD0gZGVzdC5zaGFwZVsxXSxcbiAgICAgICAgYEVycm9yIGluIGNvcHkyRDogcmVxdWVzdGVkIGRlc3Qgc3RhcnQgcG9zaXRpb24gJHtkZXN0QmVnaW59IGAgK1xuICAgICAgICAgICAgYGFuZCBzb3VyY2Ugc2l6ZSAke2Rlc3RTaXplfSB3b3VsZCBvdmVyZmxvdyBkZXN0IE5EQXJyYXkgb2ZgICtcbiAgICAgICAgICAgIGBzaGFwZSAke2Rlc3Quc2hhcGV9LmApO1xuICAgIGNvcHkyZF91dGlsLnZhbGlkYXRlU2hhcGVzKHNvdXJjZVNpemUsIGRlc3RTaXplKTtcblxuICAgIHJldHVybiB0aGlzLmNvcHkyREludGVybmFsKFxuICAgICAgICBzb3VyY2UsIHNvdXJjZUJlZ2luLCBzb3VyY2VTaXplLCBkZXN0LCBkZXN0QmVnaW4sIGRlc3RTaXplKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY29weTJESW50ZXJuYWwoXG4gICAgICBzb3VyY2U6IEFycmF5MkQsIHNvdXJjZUJlZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc291cmNlU2l6ZTogW251bWJlciwgbnVtYmVyXSwgZGVzdDogQXJyYXkyRCwgZGVzdEJlZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgZGVzdFNpemU6IFtudW1iZXIsIG51bWJlcl0pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDb25jYXRlbmF0ZXMgdHdvIDNEIG5kYXJyYXlzIGFsb25nIGEgZ2l2ZW4gYXhpcy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGlmOlxuICAgKiBBOiBzaGFwZSgyLCAxLCAzKSA9IHwgcjEsIGcxLCBiMSB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgfCByMiwgZzIsIGIyIHxcbiAgICpcbiAgICogQjogc2hhcGUoMiwgMSwgMykgPSB8IHIzLCBnMywgYjMgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHwgcjQsIGc0LCBiNCB8XG4gICAqXG4gICAqIEMgPSBjb25jYXQzRChBLCBCLCBheGlzKVxuICAgKlxuICAgKiBpZiBheGlzID0gMDpcbiAgICogQzogc2hhcGUoNCwgMSwgMykgPSB8IHIxLCBnMSwgYjEgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHwgcjIsIGcyLCBiMiB8XG4gICAqICAgICAgICAgICAgICAgICAgICAgfCByMywgZzMsIGIzIHxcbiAgICogICAgICAgICAgICAgICAgICAgICB8IHI0LCBnNCwgYjQgfFxuICAgKlxuICAgKiBpZiBheGlzID0gMTpcbiAgICogQzogc2hhcGUoMiwgMiwgMykgPSB8IHIxLCBnMSwgYjEsIHIzLCBnMywgYjMgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHwgcjIsIGcyLCBiMiwgcjQsIGc0LCBiNCB8XG4gICAqXG4gICAqIGlmIGF4aXMgPSAyOlxuICAgKiBDID0gc2hhcGUoMiwgMSwgNikgPSB8IHIxLCBnMSwgYjEsIHIzLCBnMywgYjMgfFxuICAgKiAgICAgICAgICAgICAgICAgICAgICB8IHIyLCBnMiwgYjIsIHI0LCBnNCwgYjQgfFxuICAgKlxuICAgKiBAcGFyYW0gbmRhcnJheTEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbmNhdC5cbiAgICogQHBhcmFtIG5kYXJyYXkyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uYXQuXG4gICAqIEBwYXJhbSBheGlzIFRoZSBheGlzIHRvIGNvbmNhdGUgYWxvbmcuXG4gICAqL1xuICBjb25jYXQzRChuZGFycmF5MTogQXJyYXkzRCwgbmRhcnJheTI6IEFycmF5M0QsIGF4aXM6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbmNhdDNkX3V0aWwuYXNzZXJ0Q29uY2F0M0RTaGFwZXNNYXRjaChcbiAgICAgICAgbmRhcnJheTEuc2hhcGUsIG5kYXJyYXkyLnNoYXBlLCBheGlzLCAnRXJyb3IgaW4gY29uY2F0M2Q6ICcpO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuY29uY2F0M0RJbnRlcm5hbChuZGFycmF5MSwgbmRhcnJheTIsIGF4aXMpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgY29uY2F0M0RJbnRlcm5hbChcbiAgICAgIG5kYXJyYXkxOiBBcnJheTNELCBuZGFycmF5MjogQXJyYXkzRCwgYXhpczogbnVtYmVyKTogQXJyYXkzRDtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFJlZHVjdGlvbiBvcHMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgdGhlIGxvZyhzdW0oZSBeIHgpKSBmb3IgZWFjaCB4IGluIHRoZSBpbnB1dCBuZGFycmF5LlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheSB0byBjb21wdXRlIHRoZSBsb2dTdW1FeHAgb3Zlci5cbiAgICovXG4gIGxvZ1N1bUV4cChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmxvZ1N1bUV4cEludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbG9nU3VtRXhwSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhcjtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBhbGwgdGhlIGVudHJpZXMgaW4gdGhlIGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5IHRvIGNvbXB1dGUgdGhlIHN1bSBvdmVyLlxuICAgKi9cbiAgc3VtKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc3VtSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzdW1JbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIGluZGV4IG9mIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gdGhlIG5kYXJyYXkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgYXJnTWluKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuYXJnTWluSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBhcmdNaW5JbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIGluZGV4IG9mIHRoZSBtYXhpbXVtIGVsZW1lbnQgaW4gdGhlIG5kYXJyYXkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgYXJnTWF4KG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuYXJnTWF4SW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBhcmdNYXhJbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMSBpZiB0aGUgYXJnTWF4IG9mIHgxIGFuZCB4MiBhcmUgdGhlIHNhbWUsIG90aGVyd2lzZSAwLlxuICAgKiBAcGFyYW0geDEgVGhlIGZpcnN0IGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSB4MiBUaGUgc2Vjb25kIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBhcmdNYXhFcXVhbHMoeDE6IE5EQXJyYXksIHgyOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHgxLnNoYXBlLCB4Mi5zaGFwZSwgJ0Vycm9yIGluIGFyZ01heEVxdWFsczogJyk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5hcmdNYXhFcXVhbHNJbnRlcm5hbCh4MSwgeDIpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYXJnTWF4RXF1YWxzSW50ZXJuYWwoeDE6IE5EQXJyYXksIHgyOiBOREFycmF5KTogU2NhbGFyO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgdG9wIEsgdmFsdWVzIGFuZCBmbGF0dGVuZWQgaW5kaWNlcy5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSBrIEhvdyBtYW55IHRvcCB2YWx1ZXMgdG8gY29tcHV0ZS5cbiAgICovXG4gIHRvcEsobmRhcnJheTogTkRBcnJheSwgazogbnVtYmVyKToge3ZhbHVlczogQXJyYXkxRCwgaW5kaWNlczogQXJyYXkxRH0ge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBrIDw9IG5kYXJyYXkuc2l6ZSxcbiAgICAgICAgYEVycm9yIGluIHRvcEs6IGsgdmFsdWUgKCR7a30pIG11c3QgYmUgbGVzcyB0aGFuIHNpemUgb2YgaW5wdXQgYCArXG4gICAgICAgICAgICBgbmRhcnJheSwgZ290IHNoYXBlICR7bmRhcnJheS5zaGFwZX0uYCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50b3BLSW50ZXJuYWwobmRhcnJheSwgayk7XG4gICAgdGhpcy50cmFjayhyZXN1bHQudmFsdWVzKTtcbiAgICB0aGlzLnRyYWNrKHJlc3VsdC5pbmRpY2VzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCB0b3BLSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSwgazogbnVtYmVyKTpcbiAgICAgIHt2YWx1ZXM6IEFycmF5MUQsIGluZGljZXM6IEFycmF5MUR9O1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBmcm9tIHRoZSBpbnB1dC5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBtaW4obmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5taW5JbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG1pbkludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXI7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIGZyb20gdGhlIGlucHV0LlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIG1heChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLm1heEludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWF4SW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhcjtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHNvZnRtYXggbm9ybWFsaXplZCB2ZWN0b3IgZnJvbSB0aGUgaW5wdXQgdmVjdG9yLlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgdmVjdG9yLlxuICAgKi9cbiAgc29mdG1heCh4OiBBcnJheTFEKTogQXJyYXkxRCB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUoKCkgPT4ge1xuICAgICAgLy8gRG8gaXQgaW4gbG9nIHNwYWNlIGZvciBudW1lcmljYWwgc3RhYmlsaXR5LlxuICAgICAgLy8gZXhwKFggLSBsb2dTdW1FeHAoWCkpXG4gICAgICBjb25zdCBsc2UgPSB0aGlzLmxvZ1N1bUV4cCh4KTtcbiAgICAgIGNvbnN0IGxvZ1Jlc3VsdCA9IHRoaXMuYXJyYXlNaW51c1NjYWxhcih4LCBsc2UpO1xuICAgICAgcmV0dXJuIHRoaXMuZXhwKGxvZ1Jlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEVsZW1lbnQtd2lzZSBvcHMgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBOREFycmF5LlxuICAgKiBAcGFyYW0gYSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICogQHBhcmFtIG5ld0RpbSBUaGUgbmV3IGluZGljZXMgdGhhdCBkZWZpbmUgd2hpY2ggc2hhcGVzIHZhbHVlcyB0byBzd2l0Y2guXG4gICAqL1xuICBzd2l0Y2hEaW08VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIG5ld0RpbTogbnVtYmVyW10pOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYS5yYW5rID09PSBuZXdEaW0ubGVuZ3RoLFxuICAgICAgICBgRXJyb3IgaW4gc3dpdGNoRGltOiBsZW5ndGggb2YgaW5wdXQgc2hhcGUgJHthLnNoYXBlfSBgICtcbiAgICAgICAgICAgIGBtdXN0IG1hdGNoIHNpemUgb2YgbmV3RGltIGFycmF5ICR7bmV3RGltfS5gKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLnN3aXRjaERpbUludGVybmFsKGEsIG5ld0RpbSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzd2l0Y2hEaW1JbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBhOiBULCBuZXdEaW06IG51bWJlcltdKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSBzY2FsYXIgcGx1cyBOREFycmF5LCBjICsgQS5cbiAgICogQHBhcmFtIGMgVGhlIHNjYWxhciBjIGluIGMgKyBBLlxuICAgKiBAcGFyYW0gYSBUaGUgTkRBcnJheSBBIGluIGMgKyBBLlxuICAgKi9cbiAgc2NhbGFyUGx1c0FycmF5PFQgZXh0ZW5kcyBOREFycmF5PihjOiBTY2FsYXIsIGE6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYy5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gc2NhbGFyUGx1c0FycmF5OiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7Yy5yYW5rfS5gKTtcbiAgICByZXR1cm4gdGhpcy5hZGQoYywgYSkgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIHNjYWxhciBtaW51cyBOREFycmF5LCBjIC0gQS5cbiAgICogQHBhcmFtIGMgVGhlIHNjYWxhciBjIGluIGMgLSBBLlxuICAgKiBAcGFyYW0gYSBUaGUgTkRBcnJheSBBIGluIGMgLSBBLlxuICAgKi9cbiAgc2NhbGFyTWludXNBcnJheTxUIGV4dGVuZHMgTkRBcnJheT4oYzogU2NhbGFyLCBhOiBUKTogVCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGMuc2l6ZSA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIHNjYWxhck1pbnVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IGAgK1xuICAgICAgICAgICAgYHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLnN1YihjLCBhKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIEEgLSBjLiBBIGlzIE5EQXJyYXksIGMgaXMgU2NhbGFyLlxuICAgKiBAcGFyYW0gYSBUaGUgTkRBcnJheSBBIGluIEEgLSBjLlxuICAgKiBAcGFyYW0gYyBUaGUgU2NhbGFyIGMgaW4gQSAtIGMuXG4gICAqL1xuICBhcnJheU1pbnVzU2NhbGFyPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBjOiBTY2FsYXIpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYy5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gYXJyYXlNaW51c1NjYWxhcjogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgYCArXG4gICAgICAgICAgICBgZ290IHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLnN1YihhLCBjKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIC0xICogQSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBhIFRoZSBpbnB1dCBhcnJheS5cbiAgICovXG4gIG5lZzxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubmVnSW50ZXJuYWwoYSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBuZWdJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIEFkZHMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSArIEIuIFN1cHBvcnRzIGJyb2FkY2FzdGluZy5cbiAgICogRm9yIGEgc3RyaWN0ZXIgdmVyc2lvbiB3aXRob3V0IGJyb2FkY2FzdGluZyB1c2UgbWF0aC5hZGRTdHJpY3QoKS5cbiAgICpcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgdG8gYWRkIGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIGFkZCBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBhZGQoYTogTkRBcnJheSwgYjogTkRBcnJheSk6IE5EQXJyYXkge1xuICAgIHV0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmFkZEludGVybmFsKGEsIGIpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYWRkSW50ZXJuYWwoYTogTkRBcnJheSwgYjogTkRBcnJheSk6IE5EQXJyYXk7XG5cbiAgLyoqXG4gICAqIEFkZHMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSArIEIuIElucHV0cyBtdXN0XG4gICAqIGJlIHRoZSBzYW1lIHNoYXBlLiBGb3IgYnJvYWRjYXN0aW5nIHN1cHBvcnQsIHVzZSBtYXRoLmFkZCgpIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIG11bHRpcGx5IGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIGFkZFN0cmljdDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGFkZFN0cmljdDogJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkKGEsIGIpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIHR3byBOREFycmF5cyBlbGVtZW50LXdpc2UsIEEgLSBCLiBTdXBwb3J0cyBicm9hZGNhc3RpbmcuXG4gICAqIEZvciBhIHN0cmljdGVyIHZlcnNpb24gd2l0aG91dCBicm9hZGNhc3RpbmcgdXNlIG1hdGguc3ViU3RyaWN0KCkuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIHN1YnRyYWN0IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIGIgVGhlIHNlY29uZCBOREFycmF5IHRvIHN1YnRyYWN0IGVsZW1lbnQtd2lzZS5cbiAgICovXG4gIHN1YihhOiBOREFycmF5LCBiOiBOREFycmF5KTogTkRBcnJheSB7XG4gICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc3ViSW50ZXJuYWwoYSwgYikpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzdWJJbnRlcm5hbChhOiBOREFycmF5LCBiOiBOREFycmF5KTogTkRBcnJheTtcblxuICAvKipcbiAgICogU3VidHJhY3RzIHR3byBOREFycmF5cyBlbGVtZW50LXdpc2UsIEEgLSBCLiBJbnB1dHMgbXVzdFxuICAgKiBiZSB0aGUgc2FtZSBzaGFwZS4gRm9yIGJyb2FkY2FzdGluZyBzdXBwb3J0LCB1c2UgbWF0aC5zdWIoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBzdWJTdHJpY3Q8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzdWJTdHJpY3Q6ICcpO1xuICAgIHJldHVybiB0aGlzLnN1YihhLCBiKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAqIEIuIFN1cHBvcnRzIGJyb2FkY2FzdGluZy5cbiAgICogRm9yIGEgc3RyaWN0ZXIgdmVyc2lvbiB3aXRob3V0IGJyb2FkY2FzdGluZyB1c2UgbWF0aC5tdWx0aXBseVN0cmljdCgpLlxuICAgKlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBtdWx0aXBseShhOiBOREFycmF5LCBiOiBOREFycmF5KTogTkRBcnJheSB7XG4gICAgdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubXVsdGlwbHlJbnRlcm5hbChhLCBiKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG11bHRpcGx5SW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgbWF0aC5tdWx0aXBseVN0cmljdCgpIGluc3RlYWQuXG4gICAqL1xuICBlbGVtZW50V2lzZU11bDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U3RyaWN0KGEsIGIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdHdvIE5EQXJyYXlzIGVsZW1lbnQtd2lzZSwgQSAqIEIuIElucHV0cyBtdXN0XG4gICAqIGJlIHRoZSBzYW1lIHNoYXBlLiBGb3IgYnJvYWRjYXN0aW5nIHN1cHBvcnQsIHVzZSBtYXRoLm11bHRpcGx5KCkgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgdG8gbXVsdGlwbHkgZWxlbWVudC13aXNlLlxuICAgKiBAcGFyYW0gYiBUaGUgc2Vjb25kIE5EQXJyYXkgdG8gbXVsdGlwbHkgZWxlbWVudC13aXNlLlxuICAgKi9cbiAgbXVsdGlwbHlTdHJpY3Q8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtdWx0aXBseVN0cmljdDogJyk7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYSwgYikgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHR3byBOREFycmF5cyBlbGVtZW50LXdpc2UsIEEgLyBCLiBTdXBwb3J0cyBicm9hZGNhc3RpbmcuXG4gICAqIEZvciBhIHN0cmljdGVyIHZlcnNpb24gd2l0aG91dCBicm9hZGNhc3RpbmcgdXNlIG1hdGguZGl2aWRlU3RyaWN0KCkuXG4gICAqXG4gICAqIEBwYXJhbSBhIFRoZSBmaXJzdCBOREFycmF5IHRvIGRpdmlkZSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgTkRBcnJheSB0byBkaXZpZGUgZWxlbWVudC13aXNlLlxuICAgKi9cbiAgZGl2aWRlKGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBOREFycmF5IHtcbiAgICB1dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdGVkU2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5kaXZpZGVJbnRlcm5hbChhLCBiKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGRpdmlkZUludGVybmFsKGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBOREFycmF5O1xuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHR3byBOREFycmF5cyBlbGVtZW50LXdpc2UsIEEgLyBCLiBJbnB1dHMgbXVzdFxuICAgKiBiZSB0aGUgc2FtZSBzaGFwZS4gRm9yIGJyb2FkY2FzdGluZyBzdXBwb3J0LCB1c2UgbWF0aC5kaXZpZGUoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0gYSBUaGUgZmlyc3QgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgTkRBcnJheSB0byBtdWx0aXBseSBlbGVtZW50LXdpc2UuXG4gICAqL1xuICBkaXZpZGVTdHJpY3Q8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBkaXZpZGVTdHJpY3Q6ICcpO1xuICAgIHJldHVybiB0aGlzLmRpdmlkZShhLCBiKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgc2NhbGFyIGRpdmlkZWQgYnkgYW4gTkRBcnJheSwgYnJvYWRjYXN0ZWQgb3ZlciB0aGUgTkRBcnJheSwgYyAvXG4gICAqIEEuXG4gICAqIEBwYXJhbSBjIFRoZSBzY2FsYXIgdmFsdWUgaW4gYyAvIEEuXG4gICAqIEBwYXJhbSBhIFRoZSBOREFycmF5IHZhbHVlIGluIGMgLyBBLlxuICAgKi9cbiAgc2NhbGFyRGl2aWRlZEJ5QXJyYXk8VCBleHRlbmRzIE5EQXJyYXk+KGM6IFNjYWxhciwgYTogVCk6IFQge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjLnNpemUgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBzY2FsYXJEaXZpZGVkQnlBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBgICtcbiAgICAgICAgICAgIGBnb3QgTkRBcnJheSBvZiByYW5rICR7Yy5yYW5rfS5gKTtcbiAgICByZXR1cm4gdGhpcy5kaXZpZGUoYywgYSkgYXMgVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhbiBOREFycmF5IGRpdmlkZWQgYnkgYSBzY2FsYXIsIGJyb2FkY2FzdGVkIG92ZXIgdGhlIE5EQXJyYXksIEEgL1xuICAgKiBjLlxuICAgKiBAcGFyYW0gYSBUaGUgTkRBcnJheSB2YWx1ZSBpbiBBIC8gYy5cbiAgICogQHBhcmFtIGMgVGhlIHNjYWxhciB2YWx1ZSBpbiBBIC8gYy5cbiAgICovXG4gIGFycmF5RGl2aWRlZEJ5U2NhbGFyPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBjOiBTY2FsYXIpOiBUIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYy5zaXplID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCBOREFycmF5IG9mIHJhbmsgJHtjLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLmRpdmlkZShhLCBjKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGV4cG9uZW50aWFsIG9mIHRoZSBpbnB1dCBOREFycmF5IGVsZW1lbnQtd2lzZS4geSA9IGUgXiB4XG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgZXhwPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5leHBJbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGV4cEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgbmF0dXJhbCBsb2dhcml0aG0gb2YgdGhlIGlucHV0IE5EQXJyYXkgZWxlbWVudC13aXNlLiB5ID0gbG4oeClcbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICBsb2c8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmxvZ0ludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbG9nSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyByZWN0aWZpZWQgbGluZWFyIGVsZW1lbnQtd2lzZSwgbWF4KHgsIDApLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIHJlbHU8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLnJlbHVJbnRlcm5hbChuZGFycmF5KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHJlbHVJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHNpZ21vaWQgZWxlbWVudC13aXNlLCB5ID0gMSAvICgxICsgZXhwKC14KSkuXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgc2lnbW9pZDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc2lnbW9pZEludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2lnbW9pZEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgaHlwZXJib2xpYyB0YW5nZW50IG9mIHRoZSBpbnB1dCBOREFycmF5IGVsZW1lbnQtd2lzZS5cbiAgICogQHBhcmFtIG5kYXJyYXkgVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqL1xuICB0YW5oPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy50YW5oSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCB0YW5oSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBzaW4gb2YgdGhlIGlucHV0IE5EQXJyYXkgZWxlbWVudC13aXNlLCB5ID0gc2luKHgpLlxuICAgKiBAcGFyYW0gbmRhcnJheSBUaGUgaW5wdXQgTkRBcnJheS5cbiAgICovXG4gIHNpbjxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc2luSW50ZXJuYWwobmRhcnJheSkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzaW5JbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHN0ZXAgb2YgdGhlIGlucHV0IE5EQXJyYXkgZWxlbWVudC13aXNlLCB5ID0gMSBpZiB4ID4gMCB8IDAgaWYgeCA8PVxuICAgKiAwXG4gICAqIEBwYXJhbSBuZGFycmF5IFRoZSBpbnB1dCBOREFycmF5LlxuICAgKi9cbiAgc3RlcDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuc3RlcEludGVybmFsKG5kYXJyYXkpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc3RlcEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSBzY2FsZWQgYXJyYXkgYWRkIG9wZXJhdGlvbiwgYzEgKiBBICsgYzIgKiBCLlxuICAgKiBAcGFyYW0gYzEgVGhlIGZpcnN0IHNjYWxhciBpbiB0aGUgc2NhbGVkIGFycmF5IGFkZCBjb21wdXRhdGlvbi5cbiAgICogQHBhcmFtIGEgVGhlIGZpcnN0IE5EQXJyYXkgaW4gdGhlIHNjYWxlZCBhcnJheSBhZGQgY29tcHV0YXRpb24uXG4gICAqIEBwYXJhbSBjMiBUaGUgc2Vjb25kIHNjYWxhciBpbiB0aGUgc2NhbGVkIGFycmF5IGFkZCBjb21wdXRhdGlvbi5cbiAgICogQHBhcmFtIGNiIFRoZSBzZWNvbmQgTkRBcnJheSBpbiB0aGUgc2NhbGVkIGFycmF5IGFkZCBjb21wdXRhdGlvbi5cbiAgICovXG4gIHNjYWxlZEFycmF5QWRkPFQgZXh0ZW5kcyBOREFycmF5PihjMTogU2NhbGFyLCBhOiBULCBjMjogU2NhbGFyLCBiOiBUKTogVCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGMxLnNpemUgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogZmlyc3QgYXJndW1lbnQgbXVzdCByYW5rIDAsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgIHJhbmsgJHtjMS5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYzIuc2l6ZSA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIHNjYWxlZEFycmF5QWRkOiB0aGlyZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGBOREFycmF5IG9mIHJhbmsgJHtjMi5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzY2FsZWRBcnJheUFkZDogJyk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWwoYzEsIGEsIGMyLCBiKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHNjYWxlZEFycmF5QWRkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgYzE6IFNjYWxhciwgYTogVCwgYzI6IFNjYWxhciwgYjogVCk6IFQ7XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGEgc2NhbGFyIHRpbWVzIGFycmF5IG9wZXJhdGlvbiBicm9hZGNhc3RlZCBvdmVyIHRoZSBOREFycmF5LCBjICpcbiAgICogQS5cbiAgICogQHBhcmFtIGMgVGhlIHNjYWxhciBpbiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gQSB0aGUgTkRBcnJheSBpbiB0aGUgb3BlcmF0aW9uIHRoYXQgd2lsbCBiZSBicm9hZGNhc3RlZCBvdmVyLlxuICAgKi9cbiAgc2NhbGFyVGltZXNBcnJheTxUIGV4dGVuZHMgTkRBcnJheT4oYzogU2NhbGFyLCBhOiBUKTogVCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGMuc2l6ZSA9PT0gMSxcbiAgICAgICAgYEVycm9yIGluIGFycmF5RGl2aWRlZEJ5U2NhbGFyOiBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IGAgK1xuICAgICAgICAgICAgYGdvdCByYW5rICR7Yy5yYW5rfS5gKTtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseShjLCBhKSBhcyBUO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBtYXRoLm11bHRpcGx5KCkgaW5zdGVhZC5cbiAgICovXG4gIGVsZW1lbnRXaXNlTXVsQnJvYWRjYXN0KGE6IEFycmF5MkQsIGI6IEFycmF5MkQpOiBBcnJheTJEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgYS5yYW5rID09PSAyLFxuICAgICAgICBgRXJyb3IgaW4gZWxlbWVudFdpc2VNdWxCcm9hZGNhc3Q6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYCArXG4gICAgICAgICAgICBgcmFuayAyLCBidXQgZ290IHJhbmsgJHthLnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBiLnJhbmsgPT09IDIsXG4gICAgICAgIGBFcnJvciBpbiBlbGVtZW50V2lzZU11bEJyb2FkY2FzdDogc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYCArXG4gICAgICAgICAgICBgcmFuayAyLCBidXQgZ290IHJhbmsgJHtiLnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGEsIGIpIGFzIEFycmF5MkQ7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gQ29udm9sdXRpb24gb3BzIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhIDJEIGNvbnZvbHV0aW9uIG92ZXIgdGhlIGlucHV0IHguXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCBpbWFnZSwgbXVzdCBiZSByYW5rIDMsIG9mIHNoYXBlIFtyb3dzLCBjb2xzLCBkZXB0aDFdLlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBUaGUgd2VpZ2h0cyBOREFycmF5LCBtdXN0IGJlIHJhbmsgNCwgb2Ygc2hhcGUgW2YsIGYsIGRlcHRoMSxcbiAgICogZGVwdGgyXS5cbiAgICogQHBhcmFtIGJpYXNlcyBPcHRpb25hbCBiaWFzZXMgTkRBcnJheSwgbXVzdCBiZSByYW5rIDEgb2Ygc2hhcGUgW2RlcHRoMl0uXG4gICAqIEBwYXJhbSBzdHJpZGUgVGhlIHN0cmlkZSBvZiB0aGUgY29udm9sdXRpb24uXG4gICAqIEBwYXJhbSB6ZXJvUGFkIFRoZSB6ZXJvIHBhZGRpbmcgb2YgZWFjaCBzaWRlIG9mIHRoZSBpbnB1dCBOREFycmF5LiBXaWxsIHBhZFxuICAgKiBlcXVhbGx5IG9uIGFsbCBzaWRlcy5cbiAgICovXG4gIGNvbnYyZChcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHplcm9QYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnJhbmsgPT09IDMsXG4gICAgICAgIGBFcnJvciBpbiBjb252MmQ6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayAke3gucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHdlaWdodHMucmFuayA9PT0gNCxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZDogd2VpZ2h0cyBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgICAgYCR7d2VpZ2h0cy5yYW5rfS5gKTtcbiAgICBpZiAoYmlhc2VzICE9IG51bGwpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGJpYXNlcy5yYW5rID09PSAxLFxuICAgICAgICAgIGBFcnJvciBpbiBjb252MmQ6IGJpYXNlcyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgICAgICBgJHtiaWFzZXMucmFua30uYCk7XG4gICAgfVxuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHguc2hhcGVbMl0gPT09IHdlaWdodHMuc2hhcGVbMl0sXG4gICAgICAgIGBFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0ICgke3guc2hhcGVbMl19KSBtdXN0IG1hdGNoICBgICtcbiAgICAgICAgICAgIGBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAke3dlaWdodHMuc2hhcGVbMl19LmApO1xuXG5cbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLmNvbnYyZEludGVybmFsKHgsIHdlaWdodHMsIGJpYXNlcywgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbnYyZEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgemVyb1BhZDogbnVtYmVyKTogQXJyYXkzRDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGJhY2twcm9wIG9mIGEgMkQgY29udm9sdXRpb24uXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCBpbWFnZSwgbXVzdCBiZSByYW5rIDMsIG9mIHNoYXBlIFt4cm93cywgeGNvbHMsIGRlcHRoMV0uXG4gICAqIEBwYXJhbSBkeSBUaGUgZHkgaW1hZ2UsIG11c3QgYmUgcmFuayAzLCBvZiBzaGFwZSBbeXJvd3MsIHljb2xzLCBkZXB0aDJdLlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBUaGUgd2VpZ2h0cyBOREFycmF5LCBtdXN0IGJlIHJhbmsgNCwgb2Ygc2hhcGUgW2YsIGYsIGRlcHRoMSxcbiAgICogZGVwdGgyXS5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBvcmlnaW5hbCBjb252b2x1dGlvbi5cbiAgICogQHBhcmFtIHBhZCBUaGUgcGFkZGluZyBvZiB0aGUgb3JpZ2luYWwgY29udm9sdXRpb24uXG4gICAqL1xuICBjb252MmRCYWNrUHJvcChcbiAgICAgIHg6IEFycmF5M0QsIGR5OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHBhZDogbnVtYmVyKToge2R4OiBBcnJheTNELCBkdzogQXJyYXk0RCwgZGI6IEFycmF5MUR9IHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkQmFja1Byb3A6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3Qgc2hhcGUgYCArXG4gICAgICAgICAgICBgJHt4LnNoYXBlfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZHkucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZEJhY2tQcm9wOiBkeSBtdXN0IGJlIHJhbmsgMywgYnV0IGdvdCBzaGFwZSBgICtcbiAgICAgICAgICAgIGAke2R5LnNoYXBlfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgd2VpZ2h0cy5yYW5rID09PSA0LFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkQmFja1Byb3A6IHdlaWdodHMgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgYCArXG4gICAgICAgICAgICBgJHt3ZWlnaHRzLnNoYXBlfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5zaGFwZVsyXSA9PT0gd2VpZ2h0cy5zaGFwZVsyXSxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZEJhY2tQcm9wOiBkZXB0aCBvZiB4ICR7eC5zaGFwZVsyXX0pIG11c3QgYCArXG4gICAgICAgICAgICBgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIHdlaWdodHMgKCR7d2VpZ2h0cy5zaGFwZVsyXX0uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGR5LnNoYXBlWzJdID09PSB3ZWlnaHRzLnNoYXBlWzNdLFxuICAgICAgICBgRXJyb3IgaW4gY29udjJkQmFja1Byb3A6IGRlcHRoIG9mIGR5ICgke2R5LnNoYXBlWzJdfSkgbXVzdCBgICtcbiAgICAgICAgICAgIGBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIHdlaWdodHMgKCR7d2VpZ2h0cy5zaGFwZVszXX0pLmApO1xuXG4gICAgY29uc3QgYmFja3Byb3BSZXN1bHQgPVxuICAgICAgICB0aGlzLmNvbnYyZEJhY2tQcm9wSW50ZXJuYWwoeCwgZHksIHdlaWdodHMsIHN0cmlkZSwgcGFkKTtcblxuICAgIHRoaXMudHJhY2soYmFja3Byb3BSZXN1bHQuZGIpO1xuICAgIHRoaXMudHJhY2soYmFja3Byb3BSZXN1bHQuZHcpO1xuICAgIHRoaXMudHJhY2soYmFja3Byb3BSZXN1bHQuZHgpO1xuXG4gICAgcmV0dXJuIGJhY2twcm9wUmVzdWx0O1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBjb252MmRCYWNrUHJvcEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZHk6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiB7ZHg6IEFycmF5M0QsIGR3OiBBcnJheTRELCBkYjogQXJyYXkxRH07XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB0cmFuc3Bvc2VkIDJEIGNvbnZvbHV0aW9uIG9mIGFuIGltYWdlLCBhbHNvIGtub3duIGFzIGFcbiAgICogZGVjb252b2x1dGlvbi5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMywgb2Ygc2hhcGUgW3hyb3dzLCB4Y29scywgZGVwdGgxXS5cbiAgICogQHBhcmFtIHdlaWdodHMgVGhlIHdlaWdodHMgTkRBcnJheSwgbXVzdCBiZSByYW5rIDQsIG9mIHNoYXBlIFtmLCBmLCBkZXB0aDEsXG4gICAqIGRlcHRoMl0uXG4gICAqIEBwYXJhbSBiaWFzZXMgT3B0aW9uYWwgYmlhc2VzIE5EQXJyYXksIG11c3QgYmUgcmFuayAxIG9mIHNoYXBlIFtkZXB0aDJdLlxuICAgKiBAcGFyYW0gc3RyaWRlIFRoZSBzdHJpZGUgb2YgdGhlIGNvbnZvbHV0aW9uLlxuICAgKiBAcGFyYW0gcGFkIFRoZSBwYWRkaW5nIG9mIGVhY2ggc2lkZSBvZiB0aGUgaW5wdXQgTkRBcnJheS4gV2lsbCBwYWQgZXF1YWxseVxuICAgKiBvbiBhbGwgc2lkZXMuXG4gICAqL1xuICBjb252MmRUcmFuc3Bvc2UoXG4gICAgICB4OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBiaWFzZXM6IEFycmF5MUR8bnVsbCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB4LnJhbmsgPT09IDMsXG4gICAgICAgIGBFcnJvciBpbiBjb252MmRUcmFuc3Bvc2U6IHggbXVzdCBiZSByYW5rIDMsIGJ1dCBnb3QgcmFuayBgICtcbiAgICAgICAgICAgIGAke3gucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHdlaWdodHMucmFuayA9PT0gNCxcbiAgICAgICAgYEVycm9yIGluIGNvbnYyZFRyYW5zcG9zZTogd2VpZ2h0cyBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBgICtcbiAgICAgICAgICAgIGByYW5rICR7d2VpZ2h0cy5yYW5rfWApO1xuICAgIGlmIChiaWFzZXMgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgYmlhc2VzLnJhbmsgPT09IDEsXG4gICAgICAgICAgYEVycm9yIGluIGNvbnYyZFRyYW5zcG9zZTogYmlhc2VzIG11c3QgYmUgcmFuayAxLCBidXQgZ290ICcgK1xuICAgICAgICAgICAgICAncmFuayAke2JpYXNlcy5yYW5rfS5gKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHguc2hhcGVbMl0gPT09IHdlaWdodHMuc2hhcGVbM10sXG4gICAgICAgIGBFcnJvciBpbiBjb252MmRUcmFuc3Bvc2U6IGRlcHRoIG9mIGlucHV0ICgke3guc2hhcGVbMl19KSBtdXN0IGAgK1xuICAgICAgICAgICAgYG1hdGNoIGlucHV0IGRlcHRoIGZvciB3ZWlnaHRzICR7d2VpZ2h0cy5zaGFwZVszXX0uYCk7XG5cbiAgICByZXR1cm4gdGhpcy50cmFjayhcbiAgICAgICAgdGhpcy5jb252MmRUcmFuc3Bvc2VJbnRlcm5hbCh4LCB3ZWlnaHRzLCBiaWFzZXMsIHN0cmlkZSwgcGFkKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGNvbnYyZFRyYW5zcG9zZUludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgYmlhc2VzOiBBcnJheTFEfG51bGwsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgMkQgbWF4IHBvb2xpbmcgb2YgYW4gaW1hZ2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCBpbWFnZSwgbXVzdCBiZSByYW5rIDMuXG4gICAqIEBwYXJhbSBmU2l6ZSBUaGUgZmllbGQgc2l6ZSBvZiB0aGUgbWF4IHBvb2wuXG4gICAqIEBwYXJhbSBzdHJpZGUgVGhlIHN0cmlkZSBvZiB0aGUgbWF4IHBvb2wuXG4gICAqIEBwYXJhbSBwYWQgVGhlIHBhZGRpbmcgb2YgZWFjaCBzaWRlIG9mIHRoZSBpbnB1dCBOREFycmF5LiBXaWxsIHBhZCBlcXVhbGx5XG4gICAqIG9uIGFsbCBzaWRlcy5cbiAgICovXG4gIG1heFBvb2woeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgJ0Vycm9yIGluIG1heFBvb2w6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rICcgKyB4LnJhbmsgKyAnLicpO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMubWF4UG9vbEludGVybmFsKHgsIGZTaXplLCBzdHJpZGUsIHBhZCkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBtYXhQb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgYmFja3Byb3Agb2YgYSBtYXggcG9vbC5cbiAgICogQHBhcmFtIGR5IFRoZSBkeSBlcnJvci5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMy5cbiAgICogQHBhcmFtIGZTaXplIFRoZSBmaWVsZCBzaXplIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHBhZCBUaGUgcGFkZGluZyBvZiBlYWNoIHNpZGUgb2YgdGhlIGlucHV0IE5EQXJyYXkuIFdpbGwgcGFkIGVxdWFsbHlcbiAgICogb24gYWxsIHNpZGVzLlxuICAgKi9cbiAgbWF4UG9vbEJhY2twcm9wKFxuICAgICAgZHk6IEFycmF5M0QsIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZHkucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgICAgYCR7ZHkucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgYCArXG4gICAgICAgICAgICBgJHt4LnJhbmt9LmApO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5tYXhQb29sQmFja3Byb3BJbnRlcm5hbChkeSwgeCwgZlNpemUsIHN0cmlkZSwgcGFkKSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IG1heFBvb2xCYWNrcHJvcEludGVybmFsKFxuICAgICAgZHk6IEFycmF5M0QsIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgMkQgbWluIHBvb2xpbmcgb2YgYW4gaW1hZ2UuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCBpbWFnZSwgbXVzdCBiZSByYW5rIDMuXG4gICAqIEBwYXJhbSBmU2l6ZSBUaGUgZmllbGQgc2l6ZSBvZiB0aGUgbWF4IHBvb2wuXG4gICAqIEBwYXJhbSBzdHJpZGUgVGhlIHN0cmlkZSBvZiB0aGUgbWF4IHBvb2wuXG4gICAqIEBwYXJhbSBwYWQgVGhlIHBhZGRpbmcgb2YgZWFjaCBzaWRlIG9mIHRoZSBpbnB1dCBOREFycmF5LiBXaWxsIHBhZCBlcXVhbGx5XG4gICAqIG9uIGFsbCBzaWRlcy5cbiAgICovXG4gIG1pblBvb2woeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIG1pblBvb2w6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rICR7eC5yYW5rfS5gKTtcbiAgICByZXR1cm4gdGhpcy50cmFjayh0aGlzLm1pblBvb2xJbnRlcm5hbCh4LCBmU2l6ZSwgc3RyaWRlLCBwYWQpKTtcbiAgfVxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgbWluUG9vbEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRDtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIDJEIGF2ZXJhZ2UgcG9vbGluZyBvZiBhbiBpbWFnZS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGltYWdlLCBtdXN0IGJlIHJhbmsgMy5cbiAgICogQHBhcmFtIGZTaXplIFRoZSBmaWVsZCBzaXplIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHN0cmlkZSBUaGUgc3RyaWRlIG9mIHRoZSBtYXggcG9vbC5cbiAgICogQHBhcmFtIHBhZCBUaGUgcGFkZGluZyBvZiBlYWNoIHNpZGUgb2YgdGhlIGlucHV0IE5EQXJyYXkuIFdpbGwgcGFkIGVxdWFsbHlcbiAgICogb24gYWxsIHNpZGVzLlxuICAgKi9cbiAgYXZnUG9vbCh4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gYXZnUG9vbDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJHt4LnJhbmt9LmApO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKHRoaXMuYXZnUG9vbEludGVybmFsKHgsIGZTaXplLCBzdHJpZGUsIHBhZCkpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBhdmdQb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEO1xuXG4gIC8qXG4gICAqIEJpbGluZWFyIHJlc2l6ZSBhIDNEIGFycmF5IHBlciBlYWNoIGNoYW5uZWwgdG8gYSBuZXcgMkQgc2hhcGUuXG4gICAqIEBwYXJhbSB4IFRoZSBpbnB1dCBBcnJheTNELlxuICAgKiBAcGFyYW0gbmV3U2hhcGUyRCBUaGUgbmV3IHNoYXBlIHRvIHJlc2l6ZSB0aGUgQXJyYXkzRCB0by4gRWFjaCBjaGFubmVsIGlzXG4gICAqIHJlc2l6ZWQgaW5kaXZpZHVhbGx5LlxuICAgKiBAcGFyYW0gYWxpZ25Db3JuZXJzIEFuIG9wdGlvbmFsIGJvb2wuIERlZmF1bHRzIHRvIEZhbHNlLiBJZiB0cnVlLCByZXNjYWxlXG4gICAqIGlucHV0IGJ5IChuZXdfaGVpZ2h0IC0gMSkgLyAoaGVpZ2h0IC0gMSksIHdoaWNoIGV4YWN0bHkgYWxpZ25zIHRoZSA0XG4gICAqIGNvcm5lcnMgb2YgaW1hZ2VzIGFuZCByZXNpemVkIGltYWdlcy4gSWYgZmFsc2UsIHJlc2NhbGUgYnkgbmV3X2hlaWdodCAvXG4gICAqIGhlaWdodC4gVHJlYXQgc2ltaWxhcmx5IHRoZSB3aWR0aCBkaW1lbnNpb24uXG4gICAqL1xuICByZXNpemVCaWxpbmVhcjNEKFxuICAgICAgeDogQXJyYXkzRCwgbmV3U2hhcGUyRDogW251bWJlciwgbnVtYmVyXSwgYWxpZ25Db3JuZXJzID0gZmFsc2UpOiBBcnJheTNEIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgeC5yYW5rID09PSAzLFxuICAgICAgICBgRXJyb3IgaW4gcmVzaXplQmlsaW5lYXIzRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgJHt4LnJhbmt9LmApO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBuZXdTaGFwZTJELmxlbmd0aCA9PT0gMixcbiAgICAgICAgYEVycm9yIGluIHJlc2l6ZUJpbGluZWFyM0Q6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIGAgK1xuICAgICAgICAgICAgYCR7bmV3U2hhcGUyRH0uYCk7XG4gICAgcmV0dXJuIHRoaXMudHJhY2soXG4gICAgICAgIHRoaXMucmVzaXplQmlsaW5lYXIzREludGVybmFsKHgsIG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykpO1xuICB9XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZXNpemVCaWxpbmVhcjNESW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBuZXdTaGFwZTJEOiBbbnVtYmVyLCBudW1iZXJdLCBhbGlnbkNvcm5lcnM6IGJvb2xlYW4pOiBBcnJheTNEO1xuXG4gIC8qKlxuICAgKiBCYXRjaCBub3JtYWxpemF0aW9uIDNELiBNZWFuLCB2YXJpYW5jZSwgc2NhbGUsIGFuZCBvZmZzZXQgY2FuIGJlIG9mIHR3b1xuICAgKiBzaGFwZXM6IDEpIFRoZSBzYW1lIHNoYXBlIGFzIHRoZSBpbnB1dDogYW4gQXJyYXkzRC4gMikgSW4gdGhlIGNvbW1vbiBjYXNlLFxuICAgKiB0aGUgZGVwdGggZGltZW5zaW9uIGlzIHRoZSBsYXN0IGRpbWVuc2lvbiBvZiB4LCBzbyB0aGUgdmFsdWVzIHdvdWxkIGJlIGFuXG4gICAqIEFycmF5MUQgb2Ygc2hhcGUgW2RlcHRoXS5cbiAgICogQHBhcmFtIHggVGhlIGlucHV0IE5EQXJyYXkuXG4gICAqIEBwYXJhbSBtZWFuIEEgbWVhbiBOREFycmF5LlxuICAgKiBAcGFyYW0gdmFyaWFuY2UgQSB2YXJpYW5jZSBOREFycmF5LlxuICAgKiBAcGFyYW0gdmFyaWFuY2VFcHNpbG9uIEEgc21hbGwgZmxvYXQgbnVtYmVyIHRvIGF2b2lkIGRpdmlkaW5nIGJ5IDAuXG4gICAqIEBwYXJhbSBzY2FsZSBBIHNjYWxlIE5EQXJyYXkuXG4gICAqIEBwYXJhbSBvZmZzZXQgQW4gb2Zmc2V0IE5EQXJyYXkuXG4gICAqL1xuICBiYXRjaE5vcm1hbGl6YXRpb24zRChcbiAgICAgIHg6IEFycmF5M0QsIG1lYW46IEFycmF5M0R8QXJyYXkxRCwgdmFyaWFuY2U6IEFycmF5M0R8QXJyYXkxRCxcbiAgICAgIHZhcmlhbmNlRXBzaWxvbiA9IC4wMDEsIHNjYWxlPzogQXJyYXkzRHxBcnJheTFELFxuICAgICAgb2Zmc2V0PzogQXJyYXkzRHxBcnJheTFEKTogQXJyYXkzRCB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHgucmFuayA9PT0gMyxcbiAgICAgICAgYEVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiB4IG11c3QgYmUgcmFuayAzIGJ1dCBnb3QgcmFuayBgICtcbiAgICAgICAgICAgIGAke3gucmFua30uYCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIG1lYW4ucmFuayA9PT0gMyB8fCBtZWFuLnJhbmsgPT09IDEsXG4gICAgICAgIGBFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGAgK1xuICAgICAgICAgICAgYGdvdCByYW5rICR7bWVhbi5yYW5rfS5gKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdmFyaWFuY2UucmFuayA9PT0gMyB8fCB2YXJpYW5jZS5yYW5rID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IHZhcmlhbmNlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBgICtcbiAgICAgICAgICAgIGBidXQgZ290IHJhbmsgJHt2YXJpYW5jZS5yYW5rfS5gKTtcbiAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgc2NhbGUucmFuayA9PT0gMyB8fCBzY2FsZS5yYW5rID09PSAxLFxuICAgICAgICAgIGBFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogc2NhbGUgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGAgK1xuICAgICAgICAgICAgICBgYnV0IGdvdCByYW5rICR7c2NhbGUhLnJhbmt9LmApO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIG9mZnNldC5yYW5rID09PSAzIHx8IG9mZnNldC5yYW5rID09PSAxLFxuICAgICAgICAgIGBFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogb2Zmc2V0IG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBgICtcbiAgICAgICAgICAgICAgYGJ1dCBnb3QgcmFuayAke29mZnNldCEucmFua30uYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudHJhY2sodGhpcy5iYXRjaE5vcm1hbGl6YXRpb24zREludGVybmFsKFxuICAgICAgICB4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSk7XG4gIH1cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBtZWFuOiBBcnJheTNEfEFycmF5MUQsIHZhcmlhbmNlOiBBcnJheTNEfEFycmF5MUQsXG4gICAgICB2YXJpYW5jZUVwc2lsb246IG51bWJlciwgc2NhbGU/OiBBcnJheTNEfEFycmF5MUQsXG4gICAgICBvZmZzZXQ/OiBBcnJheTNEfEFycmF5MUQpOiBBcnJheTNEO1xuXG4gIC8vLy8vLy8vLy8vLy8vXG4gIC8vIExTVE0gb3BzIC8vXG4gIC8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBuZXh0IHN0YXRlcyBhbmQgb3V0cHV0cyBvZiBhIHN0YWNrIG9mIExTVE1DZWxscy5cbiAgICogRWFjaCBjZWxsIG91dHB1dCBpcyB1c2VkIGFzIGlucHV0IHRvIHRoZSBuZXh0IGNlbGwuXG4gICAqIFRoaXMgaXMgb25seSB0aGUgZm9yd2FyZCBtb2RlLlxuICAgKiBEZXJpdmVkIGZyb20gdGYuY29udHJpYi5ybi5NdWx0aVJOTkNlbGwuXG4gICAqIEBwYXJhbSBsc3RtQ2VsbHMgQXJyYXkgb2YgTFNUTUNlbGwgZnVuY3Rpb25zLlxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaW5wdXQgdG8gdGhlIGNlbGwuXG4gICAqIEBwYXJhbSBjIEFycmF5IG9mIHByZXZpb3VzIGNlbGwgc3RhdGVzLlxuICAgKiBAcGFyYW0gaCBBcnJheSBvZiBwcmV2aW91cyBjZWxsIG91dHB1dHMuXG4gICAqIEByZXR1cm4gVHVwbGUgW25leHRDZWxsU3RhdGVzLCBjZWxsT3V0cHV0c11cbiAgICovXG4gIG11bHRpUk5OQ2VsbChsc3RtQ2VsbHM6IExTVE1DZWxsW10sIGRhdGE6IEFycmF5MkQsIGM6IEFycmF5MkRbXSxcbiAgICAgIGg6IEFycmF5MkRbXSk6IFtBcnJheTJEW10sIEFycmF5MkRbXV0ge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkYXRhLnNoYXBlWzBdID09PSAxLFxuICAgICAgICBgRXJyb3IgaW4gbXVsdGlSTk5DZWxsOiBmaXJzdCBkaW1lbnNpb24gb2YgZGF0YSBpcyAke2RhdGEuc2hhcGVbMF19LCBgICtcbiAgICAgICAgICAgIGBidXQgYmF0Y2ggc2l6ZXMgPiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC5gKTtcbiAgICBjb25zdCByZXMgPSB0aGlzLnNjb3BlKCgpID0+IHtcbiAgICAgIGxldCBpbnB1dCA9IGRhdGE7XG4gICAgICBjb25zdCBuZXdTdGF0ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0bUNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGxzdG1DZWxsc1tpXShpbnB1dCwgY1tpXSwgaFtpXSk7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFswXSk7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFsxXSk7XG4gICAgICAgIGlucHV0ID0gb3V0cHV0WzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3RhdGVzO1xuICAgIH0pO1xuICAgIGNvbnN0IG5ld0M6IEFycmF5MkRbXSA9IFtdO1xuICAgIGNvbnN0IG5ld0g6IEFycmF5MkRbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBuZXdDLnB1c2gocmVzW2ldIGFzIEFycmF5MkQpO1xuICAgICAgbmV3SC5wdXNoKHJlc1tpICsgMV0gYXMgQXJyYXkyRCk7XG4gICAgfVxuICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIG5leHQgc3RhdGUgYW5kIG91dHB1dCBvZiBhIEJhc2ljTFNUTUNlbGwuXG4gICAqIFRoaXMgaXMgb25seSB0aGUgZm9yd2FyZCBtb2RlLlxuICAgKiBEZXJpdmVkIGZyb20gdGYuY29udHJpYi5ybm4uQmFzaWNMU1RNQ2VsbC5cbiAgICogQHBhcmFtIGZvcmdldEJpYXMgRm9yZ2V0IGJpYXMgZm9yIHRoZSBjZWxsLlxuICAgKiBAcGFyYW0gbHN0bUtlcm5lbCBUaGUgd2VpZ2h0cyBmb3IgdGhlIGNlbGwuXG4gICAqIEBwYXJhbSBsc3RtQmlhcyBUaGUgYmlhc2VzIGZvciB0aGUgY2VsbC5cbiAgICogQHBhcmFtIGRhdGEgVGhlIGlucHV0IHRvIHRoZSBjZWxsLlxuICAgKiBAcGFyYW0gYyBQcmV2aW91cyBjZWxsIHN0YXRlLlxuICAgKiBAcGFyYW0gaCBQcmV2aW91cyBjZWxsIG91dHB1dC5cbiAgICogQHJldHVybiBUdXBsZSBbbmV4dENlbGxTdGF0ZSwgY2VsbE91dHB1dF1cbiAgICovXG4gIGJhc2ljTFNUTUNlbGwoZm9yZ2V0QmlhczogU2NhbGFyLCBsc3RtS2VybmVsOiBBcnJheTJELCBsc3RtQmlhczogQXJyYXkxRCxcbiAgICAgIGRhdGE6IEFycmF5MkQsIGM6IEFycmF5MkQsIGg6IEFycmF5MkQpOiBbQXJyYXkyRCwgQXJyYXkyRF0ge1xuICAgIGNvbnN0IHJlcyA9IHRoaXMuc2NvcGUoKCkgPT4ge1xuICAgICAgdXRpbC5hc3NlcnQoXG4gICAgICAgICAgZGF0YS5zaGFwZVswXSA9PT0gMSxcbiAgICAgICAgICBgRXJyb3IgaW4gbXVsdGlSTk5DZWxsOiBmaXJzdCBkaW1lbnNpb24gb2YgZGF0YSBpcyBgICtcbiAgICAgICAgICAgICAgYCR7ZGF0YS5zaGFwZVswXX0sIGJ1dCBiYXRjaCBzaXplcyA+IDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkLmApO1xuICAgICAgLy8gY29uY2F0KGlucHV0cywgaCwgMSlcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbmNhdDFkLCBzbyByZXNoYXBlIGlucHV0cyBhbmQgaCB0byAzZCwgY29uY2F0LCB0aGVuXG4gICAgICAvLyByZXNoYXBlIGJhY2sgdG8gMmQuXG4gICAgICBjb25zdCBkYXRhM0QgPSBkYXRhLmFzM0QoMSwgMSwgZGF0YS5zaGFwZVsxXSk7XG4gICAgICBjb25zdCBoM0QgPSBoLmFzM0QoMSwgMSwgaC5zaGFwZVsxXSk7XG4gICAgICBjb25zdCBjb21iaW5lZDNEID0gdGhpcy5jb25jYXQzRChkYXRhM0QsIGgzRCwgMik7XG4gICAgICBjb25zdCBjb21iaW5lZDJEID0gY29tYmluZWQzRC5hczJEKDEsIGRhdGEuc2hhcGVbMV0gKyBoLnNoYXBlWzFdKTtcblxuICAgICAgY29uc3Qgd2VpZ2h0ZWQgPSB0aGlzLm1hdE11bChjb21iaW5lZDJELCBsc3RtS2VybmVsKTtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMuYWRkKHdlaWdodGVkLCBsc3RtQmlhcykgYXMgQXJyYXkyRDtcblxuICAgICAgLy8gaSA9IGlucHV0X2dhdGUsIGogPSBuZXdfaW5wdXQsIGYgPSBmb3JnZXRfZ2F0ZSwgbyA9IG91dHB1dF9nYXRlXG4gICAgICBjb25zdCBpID0gdGhpcy5zbGljZTJEKHJlcywgWzAsIDBdLCBbcmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMV0gLyA0XSk7XG4gICAgICBjb25zdCBqID0gdGhpcy5zbGljZTJEKHJlcywgWzAsIHJlcy5zaGFwZVsxXSAvIDQgKiAxXSxcbiAgICAgICAgICBbcmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMV0gLyA0XSk7XG4gICAgICBjb25zdCBmID0gdGhpcy5zbGljZTJEKHJlcywgWzAsIHJlcy5zaGFwZVsxXSAvIDQgKiAyXSxcbiAgICAgICAgICBbcmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMV0gLyA0XSk7XG4gICAgICBjb25zdCBvID0gdGhpcy5zbGljZTJEKHJlcywgWzAsIHJlcy5zaGFwZVsxXSAvIDQgKiAzXSxcbiAgICAgICAgICBbcmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMV0gLyA0XSk7XG5cbiAgICAgIGNvbnN0IG5ld0MgPSB0aGlzLmFkZChcbiAgICAgICAgICB0aGlzLm11bHRpcGx5U3RyaWN0KGMsXG4gICAgICAgICAgICAgIHRoaXMuc2lnbW9pZCh0aGlzLnNjYWxhclBsdXNBcnJheShmb3JnZXRCaWFzLCBmKSkpLFxuICAgICAgICAgIHRoaXMubXVsdGlwbHlTdHJpY3QodGhpcy5zaWdtb2lkKGkpLCB0aGlzLnRhbmgoaikpKSBhcyBBcnJheTJEO1xuICAgICAgY29uc3QgbmV3SCA9IHRoaXMubXVsdGlwbHlTdHJpY3QoXG4gICAgICAgICAgdGhpcy50YW5oKG5ld0MpLCB0aGlzLnNpZ21vaWQobykpIGFzIEFycmF5MkQ7XG5cbiAgICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gICAgfSk7XG4gICAgcmV0dXJuIFtyZXNbMF0sIHJlc1sxXV07XG4gIH1cblxufVxuXG5leHBvcnQgZW51bSBNYXRyaXhPcmllbnRhdGlvbiB7XG4gIFJFR1VMQVIsXG4gIFRSQU5TUE9TRURcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL21hdGgvY29udl91dGlsJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCAqIGFzIGNvbmNhdDNkX3V0aWwgZnJvbSAnLi9jb25jYXQzZF91dGlsJztcbmltcG9ydCAqIGFzIGNvcHkyRF91dGlsIGZyb20gJy4vY29weTJkX3V0aWwnO1xuaW1wb3J0IHtNYXRyaXhPcmllbnRhdGlvbiwgTkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aCc7XG5pbXBvcnQge0FycmF5MUQsIEFycmF5MkQsIEFycmF5M0QsIEFycmF5NEQsIE5EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9uZGFycmF5JztcblxuZXhwb3J0IGNsYXNzIE5EQXJyYXlNYXRoQ1BVIGV4dGVuZHMgTkRBcnJheU1hdGgge1xuICBjb25zdHJ1Y3RvcihzYWZlTW9kZSA9IGZhbHNlKSB7XG4gICAgc3VwZXIoc2FmZU1vZGUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNsb25lSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KFxuICAgICAgICBuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuZ2V0VmFsdWVzKCkpfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzaGFwZUludGVybmFsPFQxIGV4dGVuZHMgTkRBcnJheSwgVDIgZXh0ZW5kcyBOREFycmF5PihcbiAgICAgIG5kYXJyYXk6IFQxLCBuZXdTaGFwZTogbnVtYmVyW10pOiBUMiB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmVJbnRlcm5hbChuZGFycmF5KS5yZXNoYXBlPFQyPihuZXdTaGFwZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2xpY2UyREludGVybmFsKFxuICAgICAgaW5wdXQ6IEFycmF5MkQsIGJlZ2luUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSk6IEFycmF5MkQge1xuICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5MkQuemVyb3Moc2l6ZVJvd0NvbCk7XG4gICAgdGhpcy5jb3B5MkRJbnRlcm5hbChcbiAgICAgICAgaW5wdXQsIGJlZ2luUm93Q29sLCBzaXplUm93Q29sLCByZXN1bHQsIFswLCAwXSwgc2l6ZVJvd0NvbCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb3B5MkRJbnRlcm5hbChcbiAgICAgIHNvdXJjZTogQXJyYXkyRCwgc291cmNlQmVnaW5Sb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzb3VyY2VTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBkZXN0OiBBcnJheTJELFxuICAgICAgZGVzdEJlZ2luUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgZGVzdFNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pOiB2b2lkIHtcbiAgICBjb3B5MkRfdXRpbC52YWxpZGF0ZVNoYXBlcyhzb3VyY2VTaXplUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCk7XG4gICAgY29uc3Qgc3JjVmFsdWVzID0gc291cmNlLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IGRzdFZhbHVlcyA9IGRlc3QuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3QgbiA9IHNvdXJjZVNpemVSb3dDb2xbMF0gKiBzb3VyY2VTaXplUm93Q29sWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzcmNSb3cgPSBzb3VyY2VCZWdpblJvd0NvbFswXSArIE1hdGguZmxvb3IoaSAvIHNvdXJjZVNpemVSb3dDb2xbMV0pO1xuICAgICAgY29uc3Qgc3JjQ29sID0gc291cmNlQmVnaW5Sb3dDb2xbMV0gKyAoaSAlIHNvdXJjZVNpemVSb3dDb2xbMV0pO1xuICAgICAgY29uc3Qgc3JjT2ZmID0gc3JjUm93ICogc291cmNlLnNoYXBlWzFdICsgc3JjQ29sO1xuICAgICAgY29uc3QgZHN0Um93ID0gZGVzdEJlZ2luUm93Q29sWzBdICsgTWF0aC5mbG9vcihpIC8gZGVzdFNpemVSb3dDb2xbMV0pO1xuICAgICAgY29uc3QgZHN0Q29sID0gZGVzdEJlZ2luUm93Q29sWzFdICsgKGkgJSBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gICAgICBjb25zdCBkc3RPZmYgPSBkc3RSb3cgKiBkZXN0LnNoYXBlWzFdICsgZHN0Q29sO1xuICAgICAgZHN0VmFsdWVzW2RzdE9mZl0gPSBzcmNWYWx1ZXNbc3JjT2ZmXTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgY29uY2F0M0RJbnRlcm5hbCh4MTogQXJyYXkzRCwgeDI6IEFycmF5M0QsIGF4aXM6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgY29uY2F0M2RfdXRpbC5jb21wdXRlQ29uY2F0M0RPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpO1xuXG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFNoYXBlWzBdOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3V0cHV0U2hhcGVbMV07IGorKykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG91dHB1dFNoYXBlWzJdOyBrKyspIHtcbiAgICAgICAgICAvLyBTaGFkZXIgYmVnaW5zLlxuICAgICAgICAgIGNvbnN0IGluZGV4OiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbaSwgaiwga107XG4gICAgICAgICAgbGV0IHZhbHVlOiBudW1iZXI7XG4gICAgICAgICAgaWYgKGluZGV4W2F4aXNdIDwgeDEuc2hhcGVbYXhpc10pIHtcbiAgICAgICAgICAgIHZhbHVlID0geDEuZ2V0KGksIGosIGspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFtheGlzXSAtPSB4MS5zaGFwZVtheGlzXTtcbiAgICAgICAgICAgIGNvbnN0IFtpMiwgajIsIGsyXSA9IGluZGV4O1xuICAgICAgICAgICAgdmFsdWUgPSB4Mi5nZXQoaTIsIGoyLCBrMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWVzLnNldCh2YWx1ZSwgaSwgaiwgayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNjYWxlZEFycmF5QWRkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgYzE6IFNjYWxhciwgYTogVCwgYzI6IFNjYWxhciwgYjogVCkge1xuICAgIGNvbnN0IG5ld1NoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG5cbiAgICBjb25zdCBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBjMVZhbCA9IGMxLmdldCgpO1xuICAgIGNvbnN0IGMyVmFsID0gYzIuZ2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5ld1ZhbHVlc1tpXSA9IGMxVmFsICogYVZhbHVlc1tpICUgYS5zaXplXSArIGMyVmFsICogYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZXdTaGFwZSwge3ZhbHVlczogbmV3VmFsdWVzfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbmVnSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsYXJUaW1lc0FycmF5KFNjYWxhci5ORUdfT05FLCBhKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIHJldHVybiB0aGlzLnNjYWxlZEFycmF5QWRkSW50ZXJuYWw8VD4oU2NhbGFyLk9ORSwgYSwgU2NhbGFyLk9ORSwgYik7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3ViSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZWRBcnJheUFkZEludGVybmFsPFQ+KFNjYWxhci5PTkUsIGEsIFNjYWxhci5ORUdfT05FLCBiKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXRNdWxJbnRlcm5hbChcbiAgICAgIGE6IEFycmF5MkQsIGI6IEFycmF5MkQsIGFPcmllbnRhdGlvbiA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIsXG4gICAgICBiT3JpZW50YXRpb24gPSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKTogQXJyYXkyRCB7XG4gICAgY29uc3Qgc2hhcmVkRGltID1cbiAgICAgICAgKGFPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcblxuICAgIGNvbnN0IGxlZnREaW0gPVxuICAgICAgICAoYU9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/IGEuc2hhcGVbMF0gOiBhLnNoYXBlWzFdO1xuICAgIGNvbnN0IHJpZ2h0RGltID1cbiAgICAgICAgKGJPcmllbnRhdGlvbiA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiLnNoYXBlWzFdIDogYi5zaGFwZVswXTtcblxuICAgIGNvbnN0IG5vcm1hbEdldHRlciA9IChtYXRyaXg6IEFycmF5MkQsIGk6IG51bWJlciwgajogbnVtYmVyKSA9PlxuICAgICAgICBtYXRyaXguZ2V0KGksIGopO1xuICAgIGNvbnN0IHRyYW5zcG9zZWRHZXR0ZXIgPSAobWF0cml4OiBBcnJheTJELCBpOiBudW1iZXIsIGo6IG51bWJlcikgPT5cbiAgICAgICAgbWF0cml4LmdldChqLCBpKTtcblxuICAgIGNvbnN0IGFHZXR0ZXIgPSAoYU9yaWVudGF0aW9uID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgIG5vcm1hbEdldHRlciA6XG4gICAgICAgIHRyYW5zcG9zZWRHZXR0ZXI7XG4gICAgY29uc3QgYkdldHRlciA9IChiT3JpZW50YXRpb24gPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpID9cbiAgICAgICAgbm9ybWFsR2V0dGVyIDpcbiAgICAgICAgdHJhbnNwb3NlZEdldHRlcjtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGxlZnREaW0gKiByaWdodERpbSk7XG4gICAgbGV0IGluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdERpbTsgKytpKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJpZ2h0RGltOyArK2opIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hhcmVkRGltOyArK2spIHtcbiAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBDUFUgbWF0bXVsLlxuICAgICAgICAgIHN1bSArPSBhR2V0dGVyKGEsIGksIGspICogYkdldHRlcihiLCBrLCBqKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXgrK10gPSBzdW07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheTJELm5ldyhbbGVmdERpbSwgcmlnaHREaW1dLCB2YWx1ZXMpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG11bHRpcGx5SW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHV0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHV0aWwuc2l6ZUZyb21TaGFwZShuZXdTaGFwZSkpO1xuXG4gICAgY29uc3QgYVZhbHVlcyA9IGEuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3QgYlZhbHVlcyA9IGIuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdWYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5ld1ZhbHVlc1tpXSA9IGFWYWx1ZXNbaSAlIGEuc2l6ZV0gKiBiVmFsdWVzW2kgJSBiLnNpemVdO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KG5ld1NoYXBlLCB7dmFsdWVzOiBuZXdWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXZpZGVJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIGNvbnN0IG5ld1NoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKG5ld1NoYXBlKSk7XG5cbiAgICBjb25zdCBhVmFsdWVzID0gYS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBiVmFsdWVzID0gYi5nZXRWYWx1ZXMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3VmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBuZXdWYWx1ZXNbaV0gPSBhVmFsdWVzW2kgJSBhLnNpemVdIC8gYlZhbHVlc1tpICUgYi5zaXplXTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZXdTaGFwZSwge3ZhbHVlczogbmV3VmFsdWVzfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3VtSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3VtICs9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIFNjYWxhci5uZXcoc3VtKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcmdNaW5JbnRlcm5hbChuZGFycmF5OiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgbWluSW5kZXggPSAtMTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5uZXcoTmFOKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU2NhbGFyLm5ldyhtaW5JbmRleCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXJnTWF4SW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4SW5kZXggPSAtMTtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZGFycmF5LmdldFZhbHVlcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5uZXcoTmFOKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU2NhbGFyLm5ldyhtYXhJbmRleCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXJnTWF4RXF1YWxzSW50ZXJuYWwoeDE6IE5EQXJyYXksIHgyOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCBhcmdNYXgxID0gdGhpcy5hcmdNYXhJbnRlcm5hbCh4MSkuZ2V0KCk7XG4gICAgY29uc3QgYXJnTWF4MiA9IHRoaXMuYXJnTWF4SW50ZXJuYWwoeDIpLmdldCgpO1xuICAgIGlmIChpc05hTihhcmdNYXgxKSB8fCBpc05hTihhcmdNYXgyKSkge1xuICAgICAgcmV0dXJuIFNjYWxhci5uZXcoTmFOKTtcbiAgICB9XG4gICAgcmV0dXJuIFNjYWxhci5uZXcoKyhhcmdNYXgxID09PSBhcmdNYXgyKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdG9wS0ludGVybmFsKG5kYXJyYXk6IE5EQXJyYXksIGs6IG51bWJlcik6XG4gICAgICB7dmFsdWVzOiBBcnJheTFELCBpbmRpY2VzOiBBcnJheTFEfSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCB2YWx1ZXNBbmRJbmRpY2VzOiBBcnJheTx7dmFsdWU6IG51bWJlciwgaW5kZXg6IG51bWJlcn0+ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc0FuZEluZGljZXMucHVzaCh7dmFsdWU6IHZhbHVlc1tpXSwgaW5kZXg6IGl9KTtcbiAgICB9XG4gICAgdmFsdWVzQW5kSW5kaWNlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgfSk7XG4gICAgY29uc3QgdG9wa1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoayk7XG4gICAgY29uc3QgdG9wa0luZGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICB0b3BrVmFsdWVzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS52YWx1ZTtcbiAgICAgIHRvcGtJbmRpY2VzW2ldID0gdmFsdWVzQW5kSW5kaWNlc1tpXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIHt2YWx1ZXM6IEFycmF5MUQubmV3KHRvcGtWYWx1ZXMpLCBpbmRpY2VzOiBBcnJheTFELm5ldyh0b3BrSW5kaWNlcyl9O1xuICB9XG5cbiAgcHJvdGVjdGVkIG1pbkludGVybmFsKG5kYXJyYXk6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgbGV0IG1pbiA9IHZhbHVlc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBTY2FsYXIubmV3KE5hTik7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTY2FsYXIubmV3KG1pbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWF4SW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBsZXQgbWF4ID0gdmFsdWVzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFNjYWxhci5uZXcoTmFOKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNjYWxhci5uZXcobWF4KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBleHBJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5leHAodmFsdWVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiBuZXdWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2dJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4obmRhcnJheTogVCk6IFQge1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmxvZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmRhcnJheS5zaGFwZSwge3ZhbHVlczogbmV3VmFsdWVzfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9nU3VtRXhwSW50ZXJuYWwobmRhcnJheTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgeE1heCA9IHRoaXMubWF4KG5kYXJyYXkpO1xuICAgIGNvbnN0IGEgPSB0aGlzLmFycmF5TWludXNTY2FsYXIobmRhcnJheSwgeE1heCk7XG4gICAgY29uc3QgYiA9IHRoaXMuZXhwKGEpO1xuICAgIGNvbnN0IGMgPSB0aGlzLnN1bShiKTtcbiAgICBjb25zdCBkID0gdGhpcy5sb2coYyk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hZGQoeE1heCwgZCk7XG5cbiAgICB4TWF4LmRpc3Bvc2UoKTtcbiAgICBhLmRpc3Bvc2UoKTtcbiAgICBiLmRpc3Bvc2UoKTtcbiAgICBjLmRpc3Bvc2UoKTtcbiAgICBkLmRpc3Bvc2UoKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVsdUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgY29uc3QgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgubWF4KDAsIHZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmRhcnJheS5zaGFwZSwge3ZhbHVlczogcmVzdWx0VmFsdWVzfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2lnbW9pZEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgY29uc3QgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShuZGFycmF5LnNpemUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5kYXJyYXkuZ2V0VmFsdWVzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDEgLyAoMSArIE1hdGguZXhwKC12YWx1ZXNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiByZXN1bHRWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0YW5oSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC50YW5oKHZhbHVlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmRhcnJheS5zaGFwZSwge3ZhbHVlczogcmVzdWx0VmFsdWVzfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2luSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5zaW4odmFsdWVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihuZGFycmF5LnNoYXBlLCB7dmFsdWVzOiByZXN1bHRWYWx1ZXN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGVwSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KG5kYXJyYXk6IFQpOiBUIHtcbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KG5kYXJyYXkuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gbmRhcnJheS5nZXRWYWx1ZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZSA+IDAgPyAxIDogKHZhbHVlIDwgMCA/IDAgOiB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmRhcnJheS5zaGFwZSwge3ZhbHVlczogcmVzdWx0VmFsdWVzfSk7XG4gIH1cblxuICAvKipcbiAgICogaW1hZ2UgaXMgb2Ygc2hhcGUgW3IsIGMsIGQxXS5cbiAgICogd2VpZ2h0cyBpcyBvZiBzaGFwZSBbRiwgRiwgZDEsIGQyXS5cbiAgICovXG4gIHByb3RlY3RlZCBjb252MmRJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgW3hSb3dzLCB4Q29scywgaW5wdXREZXB0aF0gPSB4LnNoYXBlO1xuICAgIGNvbnN0IGZpZWxkU2l6ZSA9IHdlaWdodHMuc2hhcGVbMF07XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSB3ZWlnaHRzLnNoYXBlWzNdO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICBbeFJvd3MsIHhDb2xzLCBpbnB1dERlcHRoXSwgZmllbGRTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCBwYWQpO1xuICAgIGNvbnN0IHkgPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcbiAgICBmb3IgKGxldCBkMiA9IDA7IGQyIDwgb3V0cHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgIGZvciAobGV0IHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgIGNvbnN0IHhSQ29ybmVyID0geVIgKiBzdHJpZGUgLSBwYWQ7XG4gICAgICAgIGNvbnN0IHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICBjb25zdCB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCBmaWVsZFNpemUgKyB4UkNvcm5lcik7XG4gICAgICAgIGZvciAobGV0IHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgY29uc3QgeENDb3JuZXIgPSB5QyAqIHN0cmlkZSAtIHBhZDtcbiAgICAgICAgICBjb25zdCB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICBjb25zdCB4Q01heCA9IE1hdGgubWluKHhDb2xzLCBmaWVsZFNpemUgKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgbGV0IGRvdFByb2QgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgIGZvciAobGV0IHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICBmb3IgKGxldCBkMSA9IDA7IGQxIDwgaW5wdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geC5nZXQoeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gd2VpZ2h0cy5nZXQod1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYmlhcyA9IChiaWFzZXMgIT0gbnVsbCkgPyBiaWFzZXMuZ2V0KGQyKSA6IDA7XG4gICAgICAgICAgeS5zZXQoZG90UHJvZCArIGJpYXMsIHlSLCB5QywgZDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnYyZEJhY2tQcm9wSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBkeTogQXJyYXkzRCwgd2VpZ2h0czogQXJyYXk0RCwgc3RyaWRlOiBudW1iZXIsXG4gICAgICBwYWQ6IG51bWJlcik6IHtkeDogQXJyYXkzRCwgZHc6IEFycmF5NEQsIGRiOiBBcnJheTFEfSB7XG4gICAgY29uc3QgZlNpemUgPSB3ZWlnaHRzLnNoYXBlWzBdO1xuICAgIGNvbnN0IGR3ID0gdGhpcy5jb252MmREZXJXZWlnaHRzKHgsIGR5LCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICAgIGNvbnN0IGRiID0gdGhpcy5jb252MmREZXJCaWFzKGR5KTtcbiAgICBjb25zdCBkeCA9IHRoaXMuY29udjJkVHJhbnNwb3NlSW50ZXJuYWwoZHksIHdlaWdodHMsIG51bGwsIHN0cmlkZSwgcGFkKTtcbiAgICByZXR1cm4ge2R4LCBkYiwgZHd9O1xuICB9XG5cbiAgLyoqXG4gICAqIGltYWdlIGlzIG9mIHNoYXBlIFtyLCBjLCBkMV0uXG4gICAqIHdlaWdodHMgaXMgb2Ygc2hhcGUgW0YsIEYsIGQxLCBkMl0uXG4gICAqL1xuICBwcm90ZWN0ZWQgY29udjJkVHJhbnNwb3NlSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCB3ZWlnaHRzOiBBcnJheTRELCBiaWFzZXM6IEFycmF5MUR8bnVsbCwgb3JpZ1N0cmlkZTogbnVtYmVyLFxuICAgICAgb3JpZ1BhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgZlNpemUgPSB3ZWlnaHRzLnNoYXBlWzBdO1xuICAgIGNvbnN0IHBhZCA9IGZTaXplIC0gMSAtIG9yaWdQYWQ7XG4gICAgY29uc3Qgb3JpZ0lucHV0RGVwdGggPSB3ZWlnaHRzLnNoYXBlWzJdO1xuICAgIGNvbnN0IG9yaWdPdXRwdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbM107XG4gICAgY29uc3QgeFJvd3MgPSB4LnNoYXBlWzBdO1xuICAgIGNvbnN0IHhDb2xzID0geC5zaGFwZVsxXTtcblxuICAgIC8vIERpbGF0ZSB0aGUgaW5wdXQuXG4gICAgY29uc3QgeFJvd3NEaWxhdGVkID0gKHhSb3dzIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICBjb25zdCB4Q29sc0RpbGF0ZWQgPSAoeENvbHMgLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuXG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIFt4Um93c0RpbGF0ZWQsIHhDb2xzRGlsYXRlZCwgb3JpZ091dHB1dERlcHRoXSwgZlNpemUsIG9yaWdJbnB1dERlcHRoLCAxLFxuICAgICAgICBwYWQpO1xuICAgIGNvbnN0IHkgPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcbiAgICBmb3IgKGxldCBkMiA9IDA7IGQyIDwgb3JpZ0lucHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgIGZvciAobGV0IHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgIGNvbnN0IHhSQ29ybmVyID0geVIgLSBwYWQ7XG4gICAgICAgIGNvbnN0IHhSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHhSQ29ybmVyIC8gb3JpZ1N0cmlkZSkpO1xuICAgICAgICBjb25zdCB4Uk1heCA9IE1hdGgubWluKHhSb3dzLCAoZlNpemUgKyB4UkNvcm5lcikgLyBvcmlnU3RyaWRlKTtcblxuICAgICAgICBmb3IgKGxldCB5QyA9IDA7IHlDIDwgeS5zaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgIGNvbnN0IHhDQ29ybmVyID0geUMgLSBwYWQ7XG4gICAgICAgICAgY29uc3QgeENNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeENDb3JuZXIgLyBvcmlnU3RyaWRlKSk7XG4gICAgICAgICAgY29uc3QgeENNYXggPSBNYXRoLm1pbih4Q29scywgKGZTaXplICsgeENDb3JuZXIpIC8gb3JpZ1N0cmlkZSk7XG5cbiAgICAgICAgICBsZXQgZG90UHJvZCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgY29uc3Qgd1IgPSB4UiAqIG9yaWdTdHJpZGUgLSB4UkNvcm5lcjtcblxuICAgICAgICAgICAgZm9yIChsZXQgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICBjb25zdCB3QyA9IHhDICogb3JpZ1N0cmlkZSAtIHhDQ29ybmVyO1xuXG4gICAgICAgICAgICAgIGZvciAobGV0IGQxID0gMDsgZDEgPCBvcmlnT3V0cHV0RGVwdGg7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHMuZ2V0KGZTaXplIC0gMSAtIHdSLCBmU2l6ZSAtIDEgLSB3QywgZDIsIGQxKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGJpYXMgPSBiaWFzZXMgIT0gbnVsbCA/IGJpYXNlcy5nZXQoZDIpIDogMDtcbiAgICAgICAgICB5LnNldChkb3RQcm9kICsgYmlhcywgeVIsIHlDLCBkMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICAvKipcbiAgICogaW1hZ2UgaXMgb2Ygc2hhcGUgW3IsIGMsIGQxXS5cbiAgICogd2VpZ2h0cyBpcyBvZiBzaGFwZSBbRiwgRiwgZDEsIGQyXS5cbiAgICovXG4gIHByb3RlY3RlZCBjb252MmRUcmFuc3Bvc2VTaGFkZXJMaWtlKFxuICAgICAgeDogQXJyYXkzRCwgb3JpZ1dlaWdodHM6IEFycmF5NEQsIG9yaWdTdHJpZGU6IG51bWJlcixcbiAgICAgIG9yaWdQYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IGZTaXplID0gb3JpZ1dlaWdodHMuc2hhcGVbMF07XG4gICAgY29uc3QgcGFkID0gZlNpemUgLSAxIC0gb3JpZ1BhZDtcbiAgICBjb25zdCBvcmlnSW5wdXREZXB0aCA9IG9yaWdXZWlnaHRzLnNoYXBlWzJdO1xuICAgIGNvbnN0IG9yaWdPdXRwdXREZXB0aCA9IG9yaWdXZWlnaHRzLnNoYXBlWzNdO1xuICAgIGNvbnN0IHhSb3dzID0geC5zaGFwZVswXTtcbiAgICBjb25zdCB4Q29scyA9IHguc2hhcGVbMV07XG5cbiAgICAvLyBEaWxhdGUgdGhlIGlucHV0LlxuICAgIGNvbnN0IHhSb3dzRGlsYXRlZCA9ICh4Um93cyAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gICAgY29uc3QgeENvbHNEaWxhdGVkID0gKHhDb2xzIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcblxuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICBbeFJvd3NEaWxhdGVkLCB4Q29sc0RpbGF0ZWQsIG9yaWdPdXRwdXREZXB0aF0sIGZTaXplLCBvcmlnSW5wdXREZXB0aCwgMSxcbiAgICAgICAgcGFkKTtcbiAgICBjb25zdCB5ID0gQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG5cbiAgICBmb3IgKGxldCBkMiA9IDA7IGQyIDwgb3JpZ0lucHV0RGVwdGg7ICsrZDIpIHtcbiAgICAgIGZvciAobGV0IHlSID0gMDsgeVIgPCB5LnNoYXBlWzBdOyArK3lSKSB7XG4gICAgICAgIGZvciAobGV0IHlDID0gMDsgeUMgPCB5LnNoYXBlWzFdOyArK3lDKSB7XG4gICAgICAgICAgLy8gU2hhZGVyIGNvZGUgYmVnaW5zLlxuICAgICAgICAgIGNvbnN0IHhSQ29ybmVyID0geVIgLSBwYWQ7XG4gICAgICAgICAgY29uc3QgeENDb3JuZXIgPSB5QyAtIHBhZDtcbiAgICAgICAgICBsZXQgZG90UHJvZCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgd1IgPSAwOyB3UiA8IGZTaXplOyArK3dSKSB7XG4gICAgICAgICAgICBjb25zdCB4UiA9ICh4UkNvcm5lciArIHdSKSAvIG9yaWdTdHJpZGU7XG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IHhSb3dzIHx8IE1hdGguZmxvb3IoeFIpICE9PSB4Uikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHdDID0gMDsgd0MgPCBmU2l6ZTsgKyt3Qykge1xuICAgICAgICAgICAgICBjb25zdCB4QyA9ICh4Q0Nvcm5lciArIHdDKSAvIG9yaWdTdHJpZGU7XG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geENvbHMgfHwgTWF0aC5mbG9vcih4QykgIT09IHhDKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChsZXQgZDEgPSAwOyBkMSA8IG9yaWdPdXRwdXREZXB0aDsgKytkMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geC5nZXQoeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1dlaWdodHMuZ2V0KGZTaXplIC0gMSAtIHdSLCBmU2l6ZSAtIDEgLSB3QywgZDIsIGQxKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHkuc2V0KGRvdFByb2QsIHlSLCB5QywgZDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9XG5cbiAgY29udjJkRGVyV2VpZ2h0cyhcbiAgICAgIHg6IEFycmF5M0QsIGRZOiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHplcm9QYWQ6IG51bWJlcik6IEFycmF5NEQge1xuICAgIGNvbnN0IGlucHV0RGVwdGggPSB4LnNoYXBlWzJdO1xuICAgIGNvbnN0IG91dHB1dERlcHRoID0gZFkuc2hhcGVbMl07XG4gICAgY29uc3Qgd2VpZ2h0c1NoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZlNpemUpO1xuICAgIGNvbnN0IGRXID0gQXJyYXk0RC56ZXJvcyh3ZWlnaHRzU2hhcGUpO1xuXG4gICAgY29uc3QgeU51bVJvd3MgPSBkWS5zaGFwZVswXTtcbiAgICBjb25zdCB5TnVtQ29scyA9IGRZLnNoYXBlWzFdO1xuICAgIGNvbnN0IHhOdW1Sb3dzID0geC5zaGFwZVswXTtcbiAgICBjb25zdCB4TnVtQ29scyA9IHguc2hhcGVbMV07XG5cbiAgICBmb3IgKGxldCB3UiA9IDA7IHdSIDwgZlNpemU7ICsrd1IpIHtcbiAgICAgIGNvbnN0IHlSTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh6ZXJvUGFkIC0gd1IpIC8gc3RyaWRlKSk7XG4gICAgICBjb25zdCB5Uk1heCA9IE1hdGgubWluKHlOdW1Sb3dzLCAoeE51bVJvd3MgKyB6ZXJvUGFkIC0gd1IpIC8gc3RyaWRlKTtcblxuICAgICAgZm9yIChsZXQgd0MgPSAwOyB3QyA8IGZTaXplOyArK3dDKSB7XG4gICAgICAgIGNvbnN0IHlDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKCh6ZXJvUGFkIC0gd0MpIC8gc3RyaWRlKSk7XG4gICAgICAgIGNvbnN0IHlDTWF4ID0gTWF0aC5taW4oeU51bUNvbHMsICh4TnVtQ29scyArIHplcm9QYWQgLSB3QykgLyBzdHJpZGUpO1xuXG4gICAgICAgIGZvciAobGV0IGQxID0gMDsgZDEgPCBpbnB1dERlcHRoOyArK2QxKSB7XG4gICAgICAgICAgZm9yIChsZXQgZDIgPSAwOyBkMiA8IG91dHB1dERlcHRoOyArK2QyKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGNvbnZvbHZlLlxuICAgICAgICAgICAgbGV0IGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgeVIgPSB5Uk1pbjsgeVIgPCB5Uk1heDsgKyt5Uikge1xuICAgICAgICAgICAgICBjb25zdCB4UiA9IHdSICsgeVIgKiBzdHJpZGUgLSB6ZXJvUGFkO1xuICAgICAgICAgICAgICBmb3IgKGxldCB5QyA9IHlDTWluOyB5QyA8IHlDTWF4OyArK3lDKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeEMgPSB3QyArIHlDICogc3RyaWRlIC0gemVyb1BhZDtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHguZ2V0KHhSLCB4QywgZDEpICogZFkuZ2V0KHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkVy5zZXQoZG90UHJvZCwgd1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZFc7XG4gIH1cblxuICBjb252MmREZXJCaWFzKGRZOiBBcnJheTNEKTogQXJyYXkxRCB7XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSBkWS5zaGFwZVsyXTtcbiAgICBjb25zdCBudW1Sb3dzID0gZFkuc2hhcGVbMF07XG4gICAgY29uc3QgbnVtQ29scyA9IGRZLnNoYXBlWzFdO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0RGVwdGgpO1xuICAgIGZvciAobGV0IGQyID0gMDsgZDIgPCBvdXRwdXREZXB0aDsgKytkMikge1xuICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICBmb3IgKGxldCByID0gMDsgciA8IG51bVJvd3M7ICsrcikge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUNvbHM7ICsrYykge1xuICAgICAgICAgIHN1bSArPSBkWS5nZXQociwgYywgZDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZXNbZDJdID0gc3VtO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkxRC5uZXcodmFsdWVzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzd2l0Y2hEaW1JbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4odDogVCwgbmV3RGltOiBudW1iZXJbXSk6IFQge1xuICAgIGNvbnN0IG5ld1NoYXBlOiBudW1iZXJbXSA9IG5ldyBBcnJheSh0LnJhbmspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld1NoYXBlW2ldID0gdC5zaGFwZVtuZXdEaW1baV1dO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gdC5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCByZXN1bHQgPSBOREFycmF5Lm1ha2U8VD4obmV3U2hhcGUsIHt2YWx1ZXM6IHJlc3VsdFZhbHVlc30pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5zaXplOyArK2kpIHtcbiAgICAgIGNvbnN0IGxvYyA9IHQuaW5kZXhUb0xvYyhpKTtcblxuICAgICAgLy8gUGVybXV0ZSBsb2NhdGlvbi5cbiAgICAgIGNvbnN0IG5ld0xvYzogbnVtYmVyW10gPSBuZXcgQXJyYXkobG9jLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0xvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdMb2NbaV0gPSBsb2NbbmV3RGltW2ldXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3SW5kZXggPSByZXN1bHQubG9jVG9JbmRleChuZXdMb2MpO1xuICAgICAgcmVzdWx0VmFsdWVzW25ld0luZGV4XSA9IHZhbHVlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgcG9vbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcixcbiAgICAgIHBvb2xUeXBlOiAnbWF4J3wnbWluJ3wnYXZnJykge1xuICAgIGNvbnN0IFt4Um93cywgeENvbHMsIGRlcHRoXSA9IHguc2hhcGU7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIFt4Um93cywgeENvbHMsIGRlcHRoXSwgZlNpemUsIGRlcHRoLCBzdHJpZGUsIHBhZCk7XG4gICAgY29uc3QgeSA9IEFycmF5M0QuemVyb3Mob3V0cHV0U2hhcGUpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGVwdGg7ICsrZCkge1xuICAgICAgZm9yIChsZXQgeVIgPSAwOyB5UiA8IHkuc2hhcGVbMF07ICsreVIpIHtcbiAgICAgICAgY29uc3QgeFJDb3JuZXIgPSB5UiAqIHN0cmlkZSAtIHBhZDtcbiAgICAgICAgY29uc3QgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgIGNvbnN0IHhSTWF4ID0gTWF0aC5taW4oeFJvd3MsIGZTaXplICsgeFJDb3JuZXIpO1xuICAgICAgICBmb3IgKGxldCB5QyA9IDA7IHlDIDwgeS5zaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgIGNvbnN0IHhDQ29ybmVyID0geUMgKiBzdHJpZGUgLSBwYWQ7XG4gICAgICAgICAgY29uc3QgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgY29uc3QgeENNYXggPSBNYXRoLm1pbih4Q29scywgZlNpemUgKyB4Q0Nvcm5lcik7XG5cblxuICAgICAgICAgIGxldCBtaW5NYXhWYWx1ZSA9XG4gICAgICAgICAgICAgIChwb29sVHlwZSA9PT0gJ21heCcgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICBsZXQgYXZnVmFsdWUgPSAwO1xuXG4gICAgICAgICAgZm9yIChsZXQgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgZm9yIChsZXQgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgIGlmIChpc05hTihwaXhlbCkpIHtcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IE5hTjtcbiAgICAgICAgICAgICAgICBhdmdWYWx1ZSA9IE5hTjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKHBvb2xUeXBlID09PSAnbWF4JyAmJiBwaXhlbCA+IG1pbk1heFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgKHBvb2xUeXBlID09PSAnbWluJyAmJiBwaXhlbCA8IG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgYXZnVmFsdWUgKz0gcGl4ZWwgLyAoZlNpemUgKiBmU2l6ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHkuc2V0KHBvb2xUeXBlID09PSAnYXZnJyA/IGF2Z1ZhbHVlIDogbWluTWF4VmFsdWUsIHlSLCB5QywgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWF4UG9vbEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgcmV0dXJuIHRoaXMucG9vbCh4LCBmU2l6ZSwgc3RyaWRlLCBwYWQsICdtYXgnKTtcbiAgfVxuXG4gIG1heFBvb2xQb3NpdGlvbnMoeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKSB7XG4gICAgY29uc3QgW3hSb3dzLCB4Q29scywgZGVwdGhdID0geC5zaGFwZTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmU2l6ZSwgZGVwdGgsIHN0cmlkZSwgcGFkKTtcbiAgICBjb25zdCBtYXhQb3NpdGlvbnMgPSBBcnJheTNELnplcm9zKG91dHB1dFNoYXBlKTtcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgIGZvciAobGV0IHlSID0gMDsgeVIgPCBvdXRwdXRTaGFwZVswXTsgKyt5Uikge1xuICAgICAgICBjb25zdCB4UkNvcm5lciA9IHlSICogc3RyaWRlIC0gcGFkO1xuICAgICAgICBjb25zdCB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgY29uc3QgeFJNYXggPSBNYXRoLm1pbih4Um93cywgZlNpemUgKyB4UkNvcm5lcik7XG4gICAgICAgIGZvciAobGV0IHlDID0gMDsgeUMgPCBvdXRwdXRTaGFwZVsxXTsgKyt5Qykge1xuICAgICAgICAgIGNvbnN0IHhDQ29ybmVyID0geUMgKiBzdHJpZGUgLSBwYWQ7XG4gICAgICAgICAgY29uc3QgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgY29uc3QgeENNYXggPSBNYXRoLm1pbih4Q29scywgZlNpemUgKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgbGV0IG1heFZhbHVlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICAgIGxldCBtYXhQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgIGZvciAobGV0IHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgIGNvbnN0IHdSID0geFIgLSB4UkNvcm5lcjtcbiAgICAgICAgICAgIGZvciAobGV0IHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IHguZ2V0KHhSLCB4QywgZCk7XG4gICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICBtYXhQb3NpdGlvbiA9IHdSICogZlNpemUgKyB3QztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhQb3NpdGlvbnMuc2V0KG1heFBvc2l0aW9uLCB5UiwgeUMsIGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhQb3NpdGlvbnM7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWF4UG9vbEJhY2twcm9wSW50ZXJuYWwoXG4gICAgICBkeTogQXJyYXkzRCwgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgb3JpZ1N0cmlkZTogbnVtYmVyLFxuICAgICAgb3JpZ1BhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgbWF4UG9zaXRpb25zID0gdGhpcy5tYXhQb29sUG9zaXRpb25zKHgsIGZTaXplLCBvcmlnU3RyaWRlLCBvcmlnUGFkKTtcbiAgICBjb25zdCBwYWQgPSBmU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICAgIGNvbnN0IFtkeVJvd3MsIGR5Q29scywgZGVwdGhdID0gZHkuc2hhcGU7XG5cbiAgICAvLyBEaWxhdGUgdGhlIGlucHV0LlxuICAgIGNvbnN0IGR5Um93c0RpbGF0ZWQgPSAoZHlSb3dzIC0gMSkgKiBvcmlnU3RyaWRlICsgMTtcbiAgICBjb25zdCBkeENvbHNEaWxhdGVkID0gKGR5Q29scyAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG5cbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgW2R5Um93c0RpbGF0ZWQsIGR4Q29sc0RpbGF0ZWQsIGRlcHRoXSwgZlNpemUsIGRlcHRoLCAxLCBwYWQpO1xuICAgIGNvbnN0IGR4ID0gQXJyYXkzRC56ZXJvcyhvdXRwdXRTaGFwZSk7XG5cbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRlcHRoOyArK2QpIHtcbiAgICAgIGZvciAobGV0IGR4UiA9IDA7IGR4UiA8IGR4LnNoYXBlWzBdOyArK2R4Uikge1xuICAgICAgICBmb3IgKGxldCBkeEMgPSAwOyBkeEMgPCBkeC5zaGFwZVsxXTsgKytkeEMpIHtcbiAgICAgICAgICAvLyBTaGFkZXIgY29kZSBiZWdpbnMuXG4gICAgICAgICAgY29uc3QgZHlSQ29ybmVyID0gZHhSIC0gcGFkO1xuICAgICAgICAgIGNvbnN0IGR5Q0Nvcm5lciA9IGR4QyAtIHBhZDtcbiAgICAgICAgICBsZXQgZG90UHJvZCA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgd1IgPSAwOyB3UiA8IGZTaXplOyArK3dSKSB7XG4gICAgICAgICAgICBjb25zdCBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gb3JpZ1N0cmlkZTtcbiAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBkeVJvd3MgfHwgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB3QyA9IDA7IHdDIDwgZlNpemU7ICsrd0MpIHtcbiAgICAgICAgICAgICAgY29uc3QgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIG9yaWdTdHJpZGU7XG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwIHx8IGR5QyA+PSBkeUNvbHMgfHwgTWF0aC5mbG9vcihkeUMpICE9PSBkeUMpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBtYXhQb3MgPSBmU2l6ZSAqIGZTaXplIC0gMSAtIG1heFBvc2l0aW9ucy5nZXQoZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICBjb25zdCBjdXJQb3MgPSB3UiAqIGZTaXplICsgd0M7XG5cbiAgICAgICAgICAgICAgY29uc3QgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBwaXhlbCA9IGR5LmdldChkeVIsIGR5QywgZCk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiBtYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgZHhSLCBkeEMsIGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkeDtcbiAgfVxuXG4gIHByb3RlY3RlZCBtaW5Qb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICByZXR1cm4gdGhpcy5wb29sKHgsIGZTaXplLCBzdHJpZGUsIHBhZCwgJ21pbicpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGF2Z1Bvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHJldHVybiB0aGlzLnBvb2woeCwgZlNpemUsIHN0cmlkZSwgcGFkLCAnYXZnJyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVzaXplQmlsaW5lYXIzREludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgbmV3U2hhcGUyRDogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIGFsaWduQ29ybmVyczogYm9vbGVhbik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG91dHB1dCA9IEFycmF5M0QuemVyb3MoW25ld1NoYXBlMkRbMF0sIG5ld1NoYXBlMkRbMV0sIHguc2hhcGVbMl1dKTtcblxuICAgIGNvbnN0IGVmZmVjdGl2ZUlucHV0U2l6ZSA9XG4gICAgICAgIGFsaWduQ29ybmVycyA/IFt4LnNoYXBlWzBdIC0gMSwgeC5zaGFwZVsxXSAtIDEsIHguc2hhcGVbMl1dIDogeC5zaGFwZTtcbiAgICBjb25zdCBlZmZlY3RpdmVPdXRwdXRTaXplID0gYWxpZ25Db3JuZXJzID9cbiAgICAgICAgW291dHB1dC5zaGFwZVswXSAtIDEsIG91dHB1dC5zaGFwZVsxXSAtIDEsIG91dHB1dC5zaGFwZVsyXV0gOlxuICAgICAgICBvdXRwdXQuc2hhcGU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBvdXRwdXQuc2hhcGVbMF07IHIrKykge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBvdXRwdXQuc2hhcGVbMV07IGMrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IG91dHB1dC5zaGFwZVsyXTsgZCsrKSB7XG4gICAgICAgICAgLy8gQmVnaW4gc2hhZGVyLlxuXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZnJhY3Rpb25hbCBpbmRleCBvZiB0aGUgc291cmNlLlxuICAgICAgICAgIGNvbnN0IHNvdXJjZUZyYWNSb3cgPVxuICAgICAgICAgICAgICAoZWZmZWN0aXZlSW5wdXRTaXplWzBdKSAqIHIgLyAoZWZmZWN0aXZlT3V0cHV0U2l6ZVswXSk7XG4gICAgICAgICAgY29uc3Qgc291cmNlRnJhY0NvbCA9XG4gICAgICAgICAgICAgIChlZmZlY3RpdmVJbnB1dFNpemVbMV0pICogYyAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzFdKTtcblxuICAgICAgICAgIGNvbnN0IHNvdXJjZVJvd0Zsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VSb3dDZWlsID1cbiAgICAgICAgICAgICAgTWF0aC5taW4oeC5zaGFwZVswXSAtIDEsIE1hdGguY2VpbChzb3VyY2VGcmFjUm93KSk7XG4gICAgICAgICAgY29uc3Qgc291cmNlQ29sRmxvb3IgPSBNYXRoLmZsb29yKHNvdXJjZUZyYWNDb2wpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbENlaWwgPVxuICAgICAgICAgICAgICBNYXRoLm1pbih4LnNoYXBlWzFdIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcblxuICAgICAgICAgIGNvbnN0IHRvcExlZnQgPSB4LmdldChzb3VyY2VSb3dGbG9vciwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSB4LmdldChzb3VyY2VSb3dDZWlsLCBzb3VyY2VDb2xGbG9vciwgZCk7XG4gICAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB4LmdldChzb3VyY2VSb3dGbG9vciwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSB4LmdldChzb3VyY2VSb3dDZWlsLCBzb3VyY2VDb2xDZWlsLCBkKTtcblxuICAgICAgICAgIGNvbnN0IHJvd0ZyYWMgPSBzb3VyY2VGcmFjUm93IC0gc291cmNlUm93Rmxvb3I7XG4gICAgICAgICAgY29uc3QgY29sRnJhYyA9IHNvdXJjZUZyYWNDb2wgLSBzb3VyY2VDb2xGbG9vcjtcblxuICAgICAgICAgIGNvbnN0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGNvbEZyYWM7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogY29sRnJhYztcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogcm93RnJhYztcblxuICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIHIsIGMsIGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByb3RlY3RlZCBiYXRjaE5vcm1hbGl6YXRpb24zREludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgbWVhbjogQXJyYXkzRHxBcnJheTFELCB2YXJpYW5jZTogQXJyYXkzRHxBcnJheTFELFxuICAgICAgdmFyaWFuY2VFcHNpbG9uID0gLjAwMSwgc2NhbGU/OiBBcnJheTNEfEFycmF5MUQsXG4gICAgICBvZmZzZXQ/OiBBcnJheTNEfEFycmF5MUQpOiBBcnJheTNEIHtcbiAgICBjb25zdCB4VmFsdWVzID0geC5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCBtZWFuVmFsdWVzID0gbWVhbi5nZXRWYWx1ZXMoKTtcbiAgICBjb25zdCB2YXJpYW5jZVZhbHVlcyA9IHZhcmlhbmNlLmdldFZhbHVlcygpO1xuICAgIGNvbnN0IHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5nZXRWYWx1ZXMoKSA6IG5ldyBGbG9hdDMyQXJyYXkoWzFdKTtcbiAgICBjb25zdCBvZmZzZXRWYWx1ZXMgPSBvZmZzZXQgPyBvZmZzZXQuZ2V0VmFsdWVzKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgY29uc3Qgb3V0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4VmFsdWVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHhWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dFZhbHVlc1tpXSA9IG9mZnNldFZhbHVlc1tpICUgb2Zmc2V0VmFsdWVzLmxlbmd0aF0gK1xuICAgICAgICAgICh4VmFsdWVzW2ldIC0gbWVhblZhbHVlc1tpICUgbWVhblZhbHVlcy5sZW5ndGhdKSAqXG4gICAgICAgICAgICAgIHNjYWxlVmFsdWVzW2kgJSBzY2FsZVZhbHVlcy5sZW5ndGhdIC9cbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgICAgdmFyaWFuY2VWYWx1ZXNbaSAlIHZhcmlhbmNlVmFsdWVzLmxlbmd0aF0gKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgIH1cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPEFycmF5M0Q+KHguc2hhcGUsIHt2YWx1ZXM6IG91dFZhbHVlc30pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCAqIGFzIGNvbmNhdDNkX3V0aWwgZnJvbSAnLi9jb25jYXQzZF91dGlsJztcbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQge01hdHJpeE9yaWVudGF0aW9uLCBOREFycmF5TWF0aH0gZnJvbSAnLi9tYXRoJztcbmltcG9ydCAqIGFzIG5kYXJyYXkgZnJvbSAnLi9uZGFycmF5JztcbmltcG9ydCB7QXJyYXkxRCwgQXJyYXkyRCwgQXJyYXkzRCwgQXJyYXk0RCwgTkRBcnJheSwgU2NhbGFyfSBmcm9tICcuL25kYXJyYXknO1xuaW1wb3J0ICogYXMgYWRkc2NhbGVkbWF0X2dwdSBmcm9tICcuL3dlYmdsL2FkZHNjYWxlZG1hdF9ncHUnO1xuaW1wb3J0IHtBcmdNYXhFcXVhbHNQcm9ncmFtfSBmcm9tICcuL3dlYmdsL2FyZ21heGVxdWFsc19ncHUnO1xuaW1wb3J0IHtBcmdNaW5NYXhQcm9ncmFtfSBmcm9tICcuL3dlYmdsL2FyZ21pbm1heF9ncHUnO1xuaW1wb3J0ICogYXMgYXZnX3Bvb2xfZ3B1IGZyb20gJy4vd2ViZ2wvYXZnX3Bvb2xfZ3B1JztcbmltcG9ydCAqIGFzIGJhdGNobm9ybV9ncHUgZnJvbSAnLi93ZWJnbC9iYXRjaG5vcm1fZ3B1JztcbmltcG9ydCAqIGFzIGNvbmNhdDNkX2dwdSBmcm9tICcuL3dlYmdsL2NvbmNhdDNkX2dwdSc7XG5pbXBvcnQgKiBhcyBjb252X2JhY2twcm9wX2dwdSBmcm9tICcuL3dlYmdsL2NvbnZfYmFja3Byb3BfZ3B1JztcbmltcG9ydCAqIGFzIGNvbnZfZ3B1IGZyb20gJy4vd2ViZ2wvY29udl9ncHUnO1xuaW1wb3J0ICogYXMgY29weV9ncHUgZnJvbSAnLi93ZWJnbC9jb3B5X2dwdSc7XG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi93ZWJnbC9ncGdwdV9jb250ZXh0JztcbmltcG9ydCB7QmluYXJ5T3BQcm9ncmFtfSBmcm9tICcuL3dlYmdsL2JpbmFyeW9wX2dwdSc7XG5pbXBvcnQge0dQR1BVUHJvZ3JhbSwgR1BHUFVCaW5hcnl9IGZyb20gJy4vd2ViZ2wvZ3BncHVfbWF0aCc7XG5pbXBvcnQgKiBhcyBncGdwdV9tYXRoIGZyb20gJy4vd2ViZ2wvZ3BncHVfbWF0aCc7XG5pbXBvcnQgKiBhcyBncGdwdV91dGlsIGZyb20gJy4vd2ViZ2wvZ3BncHVfdXRpbCc7XG5pbXBvcnQge0xvZ1N1bUV4cFByb2dyYW19IGZyb20gJy4vd2ViZ2wvbG9nc3VtZXhwX2dwdSc7XG5pbXBvcnQgKiBhcyBtYXhfcG9vbF9iYWNrcHJvcF9ncHUgZnJvbSAnLi93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHUnO1xuaW1wb3J0ICogYXMgbWF4X3Bvb2xfZ3B1IGZyb20gJy4vd2ViZ2wvbWF4X3Bvb2xfZ3B1JztcbmltcG9ydCAqIGFzIG1pbl9wb29sX2dwdSBmcm9tICcuL3dlYmdsL21pbl9wb29sX2dwdSc7XG5pbXBvcnQge01pbk1heFByb2dyYW19IGZyb20gJy4vd2ViZ2wvbWlubWF4X2dwdSc7XG5pbXBvcnQge01hdE11bFByb2dyYW19IGZyb20gJy4vd2ViZ2wvbXVsbWF0X2dwdSc7XG5pbXBvcnQgKiBhcyBwb29sX2dwdSBmcm9tICcuL3dlYmdsL3Bvb2xfZ3B1JztcbmltcG9ydCB7UmVkdWNlU3VtUHJvZ3JhbX0gZnJvbSAnLi93ZWJnbC9yZWR1Y2VzdW1fZ3B1JztcbmltcG9ydCAqIGFzIHJlc2hhcGVfZ3B1IGZyb20gJy4vd2ViZ2wvcmVzaGFwZV9ncHUnO1xuaW1wb3J0ICogYXMgcmVzaXplX2JpbGluZWFyX2dwdSBmcm9tICcuL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHUnO1xuaW1wb3J0IHtUZXh0dXJlTWFuYWdlcn0gZnJvbSAnLi93ZWJnbC90ZXh0dXJlX21hbmFnZXInO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuL3dlYmdsL3dlYmdsX3V0aWwnO1xuaW1wb3J0IHtVbmFyeU9wUHJvZ3JhbSwgVW5hcnlPcH0gZnJvbSAnLi93ZWJnbC91bmFyeW9wX2dwdSc7XG5cbmNvbnN0IEJBVENITk9STV9QUk9HID0gJ2JhdGNobm9ybSc7XG5cbmNvbnN0IENPUFlfUFJPRyA9ICdjb3B5JztcbmNvbnN0IENPTkNBVF9QUk9HID0gJ2NvbmNhdCc7XG5cbi8vIE1hdHJpeCBhbGdlYnJhLlxuY29uc3QgQUREX1NDQUxFRF9NQVRfUFJPRyA9ICdhZGRzY2FsZWRtYXQnO1xuXG4vLyBFbGVtZW50LXdpc2Ugb3BzLlxuY29uc3QgUkVTSEFQRV9QUk9HID0gJ3Jlc2hhcGUnO1xuXG4vLyBDb252b2x1dGlvbi5cbmNvbnN0IENPTlYyRF9QUk9HID0gJ2NvbnYnO1xuY29uc3QgQ09OVjJEX1RSQU5TUE9TRV9QUk9HID0gJ2NvbnZfdHJhbnNwb3NlJztcbmNvbnN0IENPTlYyRF9ERVJXX1BST0cgPSAnY29udl9kZXJ3JztcbmNvbnN0IENPTlYyRF9ERVJCX1BST0cgPSAnY29udl9kZXJiJztcbmNvbnN0IE1BWF9QT09MX1BST0cgPSAnbWF4cG9vbCc7XG5jb25zdCBNQVhfUE9PTF9QT1NJVElPTlNfUFJPRyA9ICdtYXhwb29sX3Bvc24nO1xuY29uc3QgTUFYX1BPT0xfQkFDS1BST1BfUFJPRyA9ICdtYXhwb29sX2JhY2twcm9wJztcbmNvbnN0IE1JTl9QT09MX1BST0cgPSAnbWlucG9vbCc7XG5jb25zdCBBVkdfUE9PTF9QUk9HID0gJ2F2Z3Bvb2wnO1xuXG5jb25zdCBSRVNJWkVfQklMSU5FQVJfUFJPRyA9ICdyZXNpemViaWxpbic7XG5cbmZ1bmN0aW9uIG1ha2VDb3B5UHJvZ3JhbU5hbWUoXG4gICAgc291cmNlU2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIHNvdXJjZVNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgZGVzdFNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzaGFwZU5hbWUgPSBgJHtzb3VyY2VTaGFwZVJvd0NvbFswXX1fJHtzb3VyY2VTaGFwZVJvd0NvbFsxXX1gO1xuICBjb25zdCBzcmNTaXplTmFtZSA9IGAke3NvdXJjZVNpemVSb3dDb2xbMF19XyR7c291cmNlU2l6ZVJvd0NvbFsxXX1gO1xuICBjb25zdCBkc3RTaXplTmFtZSA9IGAke2Rlc3RTaXplUm93Q29sWzBdfV8ke2Rlc3RTaXplUm93Q29sWzFdfWA7XG4gIHJldHVybiBgJHtDT1BZX1BST0d9XyR7c2hhcGVOYW1lfV8ke3NyY1NpemVOYW1lfV8ke2RzdFNpemVOYW1lfWA7XG59XG5cbmV4cG9ydCBjbGFzcyBOREFycmF5TWF0aEdQVSBleHRlbmRzIE5EQXJyYXlNYXRoIHtcbiAgcHJpdmF0ZSBncGdwdTogR1BHUFVDb250ZXh0O1xuICBwcml2YXRlIHRleHR1cmVNYW5hZ2VyOiBUZXh0dXJlTWFuYWdlcjtcbiAgcHJpdmF0ZSBwcm9ncmFtQ2FjaGU6IHtba2V5OiBzdHJpbmddOiBXZWJHTFByb2dyYW19ID0ge307XG4gIHByaXZhdGUgYmluYXJ5Q2FjaGU6IHtba2V5OiBzdHJpbmddOiBHUEdQVUJpbmFyeX0gPSB7fTtcbiAgcHJpdmF0ZSBncGdwdUNyZWF0ZWRMb2NhbGx5OiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGdwZ3B1PzogR1BHUFVDb250ZXh0LCBzYWZlTW9kZSA9IHRydWUpIHtcbiAgICBzdXBlcihzYWZlTW9kZSk7XG4gICAgaWYgKGdwZ3B1ID09IG51bGwpIHtcbiAgICAgIGNvbnN0IGdsID0gZ3BncHVfdXRpbC5jcmVhdGVXZWJHTENvbnRleHQoKTtcbiAgICAgIHRoaXMuZ3BncHUgPSBuZXcgR1BHUFVDb250ZXh0KGdsKTtcbiAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3BncHUgPSBncGdwdTtcbiAgICAgIHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIodGhpcy5ncGdwdSk7XG5cbiAgICBuZGFycmF5LmluaXRpYWxpemVHUFUodGhpcy5ncGdwdSwgdGhpcy50ZXh0dXJlTWFuYWdlcik7XG4gIH1cblxuICBnZXRHUEdQVUNvbnRleHQoKTogR1BHUFVDb250ZXh0IHtcbiAgICByZXR1cm4gdGhpcy5ncGdwdTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjbG9uZUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihuZGFycmF5OiBUKTogVCB7XG4gICAgY29uc3QgdGV4dHVyZVNoYXBlUkMgPSBuZGFycmF5LmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIG1ha2VDb3B5UHJvZ3JhbU5hbWUodGV4dHVyZVNoYXBlUkMsIHRleHR1cmVTaGFwZVJDLCB0ZXh0dXJlU2hhcGVSQyksXG4gICAgICAgICgpID0+IGNvcHlfZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgICAgICAgICAgdGV4dHVyZVNoYXBlUkMsIHRleHR1cmVTaGFwZVJDLCB0ZXh0dXJlU2hhcGVSQykpO1xuXG4gICAgY29uc3QgcmVzdWx0VGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4dHVyZVNoYXBlUkMpO1xuXG4gICAgY29weV9ncHUuY29weShcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgbmRhcnJheS5nZXRUZXh0dXJlKCksIHRleHR1cmVTaGFwZVJDLCBbMCwgMF0sXG4gICAgICAgIHRleHR1cmVTaGFwZVJDLCByZXN1bHRUZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQywgWzAsIDBdLCB0ZXh0dXJlU2hhcGVSQyk7XG5cbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KFxuICAgICAgICBuZGFycmF5LnNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4dHVyZSwgdGV4dHVyZVNoYXBlUkN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXNoYXBlSW50ZXJuYWw8VDEgZXh0ZW5kcyBOREFycmF5LCBUMiBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgbmRhcnJheTogVDEsIG5ld1NoYXBlOiBudW1iZXJbXSk6IFQyIHtcbiAgICBsZXQgbmV3VGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl07XG5cbiAgICBzd2l0Y2ggKG5ld1NoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBuZXdUZXhTaGFwZSA9IFsxLCAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG5ld1RleFNoYXBlID0gW25ld1NoYXBlWzBdLCAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG5ld1RleFNoYXBlID0gW25ld1NoYXBlWzBdLCBuZXdTaGFwZVsxXV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBuZXdUZXhTaGFwZSA9IFtuZXdTaGFwZVswXSwgbmV3U2hhcGVbMV0gKiBuZXdTaGFwZVsyXV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBgUmVzaGFwZXMgaW50byAke25ld1NoYXBlLmxlbmd0aH0tZGltIG5kYXJyYXkgaXMgbm90IHlldCBgICtcbiAgICAgICAgICAgIGBzdXBwb3J0ZWQgb24gR1BVYCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWN0dWFsVGV4U2hhcGUgPSBuZGFycmF5LmdldFRleHR1cmVTaGFwZVJDKG5ld1RleFNoYXBlKTtcbiAgICBsZXQgY2xvbmVkQXJyYXk6IFQxO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxUZXhTaGFwZSwgbmV3VGV4U2hhcGUpKSB7XG4gICAgICBjbG9uZWRBcnJheSA9IHRoaXMucmVzaGFwZVRleHR1cmUobmRhcnJheSwgbmV3VGV4U2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9uZWRBcnJheSA9IHRoaXMuY2xvbmVJbnRlcm5hbChuZGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZEFycmF5LnJlc2hhcGU8VDI+KG5ld1NoYXBlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzbGljZTJESW50ZXJuYWwoXG4gICAgICBpbnB1dDogQXJyYXkyRCwgYmVnaW5Sb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBzaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKTogQXJyYXkyRCB7XG4gICAgY29uc3QgcmVzdWx0ID0gTkRBcnJheS5tYWtlPEFycmF5MkQ+KHNpemVSb3dDb2wsIHtcbiAgICAgIHRleHR1cmU6IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUoc2l6ZVJvd0NvbCksXG4gICAgICB0ZXh0dXJlU2hhcGVSQzogc2l6ZVJvd0NvbFxuICAgIH0pO1xuICAgIHRoaXMuY29weTJESW50ZXJuYWwoXG4gICAgICAgIGlucHV0LCBiZWdpblJvd0NvbCwgc2l6ZVJvd0NvbCwgcmVzdWx0LCBbMCwgMF0sIHNpemVSb3dDb2wpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29weTJESW50ZXJuYWwoXG4gICAgICBzb3VyY2U6IEFycmF5MkQsIHNvdXJjZUJlZ2luUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc291cmNlU2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgZGVzdDogQXJyYXkyRCxcbiAgICAgIGRlc3RCZWdpblJvd0NvbDogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIGRlc3RTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKTogdm9pZCB7XG4gICAgY29uc3Qgc291cmNlU2hhcGVSQyA9IHNvdXJjZS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgIGNvbnN0IGRlc3RTaGFwZVJDID0gZGVzdC5nZXRUZXh0dXJlU2hhcGVSQygpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKFxuICAgICAgICBtYWtlQ29weVByb2dyYW1OYW1lKHNvdXJjZVNoYXBlUkMsIHNvdXJjZVNpemVSb3dDb2wsIGRlc3RTaXplUm93Q29sKSxcbiAgICAgICAgKCkgPT4gY29weV9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICBzb3VyY2VTaGFwZVJDLCBzb3VyY2VTaXplUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCkpO1xuXG4gICAgY29weV9ncHUuY29weShcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgc291cmNlLmdldFRleHR1cmUoKSwgc291cmNlU2hhcGVSQyxcbiAgICAgICAgc291cmNlQmVnaW5Sb3dDb2wsIHNvdXJjZVNpemVSb3dDb2wsIGRlc3QuZ2V0VGV4dHVyZSgpLCBkZXN0U2hhcGVSQyxcbiAgICAgICAgZGVzdEJlZ2luUm93Q29sLCBkZXN0U2l6ZVJvd0NvbCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29uY2F0M0RJbnRlcm5hbCh4MTogQXJyYXkzRCwgeDI6IEFycmF5M0QsIGF4aXM6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IHgxVGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeDEuc2hhcGUpO1xuICAgIGNvbnN0IHgyVGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeDIuc2hhcGUpO1xuXG4gICAgLy8gSWYgdGhlIHRleHR1cmUgc2hhcGVzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNoYXBlcyB0aGF0IHNoYWRlcnMgZXhwZWN0LFxuICAgIC8vIGRvIHBoeXNpY2FsIHRleHR1cmUgcmVzaGFwZXMgb24gdGhlIEdQVS5cbiAgICBjb25zdCBhY3R1YWxYMVRleFNoYXBlID0geDEuZ2V0VGV4dHVyZVNoYXBlUkMoeDFUZXhTaGFwZVJDKTtcbiAgICBsZXQgY2xlYW51cFgxID0gZmFsc2U7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFgxVGV4U2hhcGUsIHgxVGV4U2hhcGVSQykpIHtcbiAgICAgIHgxID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4MSwgeDFUZXhTaGFwZVJDKTtcbiAgICAgIGNsZWFudXBYMSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFgyVGV4U2hhcGUgPSB4Mi5nZXRUZXh0dXJlU2hhcGVSQyh4MlRleFNoYXBlUkMpO1xuICAgIGxldCBjbGVhbnVwWDIgPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWDJUZXhTaGFwZSwgeDJUZXhTaGFwZVJDKSkge1xuICAgICAgeDIgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHgyLCB4MlRleFNoYXBlUkMpO1xuICAgICAgY2xlYW51cFgyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRTaGFwZVJDRCA9XG4gICAgICAgIGNvbmNhdDNkX3V0aWwuY29tcHV0ZUNvbmNhdDNET3V0cHV0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKFxuICAgICAgICBgJHtDT05DQVRfUFJPR31fJHt4MS5zaGFwZX1fJHt4Mi5zaGFwZX1fJHtheGlzfWAsXG4gICAgICAgICgpID0+IGNvbmNhdDNkX2dwdS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZShcbiAgICAgICAgICAgIHgxLnNoYXBlLCB4Mi5zaGFwZSwgcmVzdWx0U2hhcGVSQ0QsIGF4aXMpKTtcblxuICAgIGNvbnN0IHJlc3VsdFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChyZXN1bHRTaGFwZVJDRCk7XG4gICAgY29uc3QgcmVzdWx0VGV4ID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShyZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBjb25jYXQzZF9ncHUuY29uY2F0M0QoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIHgxLmdldFRleHR1cmUoKSwgeDIuZ2V0VGV4dHVyZSgpLCByZXN1bHRUZXgsXG4gICAgICAgIHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGlmIChjbGVhbnVwWDEpIHtcbiAgICAgIHgxLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2xlYW51cFgyKSB7XG4gICAgICB4Mi5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgcmVzdWx0U2hhcGVSQ0QsIHt0ZXh0dXJlOiByZXN1bHRUZXgsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNjYWxlZEFycmF5QWRkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KFxuICAgICAgYzE6IFNjYWxhciwgYTogVCwgYzI6IFNjYWxhciwgYjogVCkge1xuICAgIGxldCBjbGVhbnVwQiA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5kb0dQVVNoYXBlc01hdGNoKGEsIGIpKSB7XG4gICAgICBiID0gdGhpcy5yZXNoYXBlVGV4dHVyZShiLCBhLmdldFRleHR1cmVTaGFwZVJDKCkpO1xuICAgICAgY2xlYW51cEIgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKFxuICAgICAgICBBRERfU0NBTEVEX01BVF9QUk9HLCAoKSA9PiBhZGRzY2FsZWRtYXRfZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKCkpO1xuXG4gICAgY29uc3QgdGV4dHVyZVNoYXBlUkMgPSBhLmdldFRleHR1cmVTaGFwZVJDKCk7XG4gICAgY29uc3QgcmVzdWx0VGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4dHVyZVNoYXBlUkMpO1xuXG4gICAgYWRkc2NhbGVkbWF0X2dwdS5hZGRTY2FsZWRNYXRyaWNlcyhcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgYS5nZXRUZXh0dXJlKCksIGIuZ2V0VGV4dHVyZSgpLCB0ZXh0dXJlU2hhcGVSQ1swXSxcbiAgICAgICAgdGV4dHVyZVNoYXBlUkNbMV0sIGMxLmdldFRleHR1cmUoKSwgYzIuZ2V0VGV4dHVyZSgpLCByZXN1bHRUZXh0dXJlKTtcblxuICAgIGlmIChjbGVhbnVwQikge1xuICAgICAgYi5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8vIEJyaW5nIHRoZSByZXN1bHQgYmFjayB0byB0aGUgb3JpZ2luYWwgc2hhcGUuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihhLnNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4dHVyZSwgdGV4dHVyZVNoYXBlUkN9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBuZWdJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5ORUcpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZU91dHB1dEFycmF5PFQgZXh0ZW5kcyBOREFycmF5PihzaGFwZTogbnVtYmVyW10pOiBUIHtcbiAgICBjb25zdCB0ZXh0dXJlU2hhcGVSQyA9XG4gICAgICAgIHdlYmdsX3V0aWwuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSh0aGlzLmdwZ3B1LmdsLCBzaGFwZSk7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4dHVyZVNoYXBlUkMpO1xuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4oc2hhcGUsIHt0ZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQ30pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21waWxlQW5kUnVuPFQgZXh0ZW5kcyBOREFycmF5LCBLIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBwcm9ncmFtOiBHUEdQVVByb2dyYW0sIGlucHV0czogVFtdKTogSyB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXk8Sz4ocHJvZ3JhbS5vdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qga2V5ID0gZ3BncHVfbWF0aC5tYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0cywgb3V0cHV0KTtcbiAgICBjb25zdCBiaW5hcnkgPSB0aGlzLmdldEFuZFNhdmVCaW5hcnkoa2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gZ3BncHVfbWF0aC5jb21waWxlUHJvZ3JhbSh0aGlzLmdwZ3B1LCBwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgZ3BncHVfbWF0aC5ydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzLCBvdXRwdXQpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBwcml2YXRlIHJlc2hhcGVUZXh0dXJlPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBuZXdUZXh0dXJlU2hhcGU6IFtcbiAgICBudW1iZXIsIG51bWJlclxuICBdKTogVCB7XG4gICAgY29uc3QgYVRleFNoYXBlID0gYS5nZXRUZXh0dXJlU2hhcGVSQygpO1xuXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0oXG4gICAgICAgIFJFU0hBUEVfUFJPRywgKCkgPT4gcmVzaGFwZV9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoKSk7XG5cbiAgICBjb25zdCByZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShuZXdUZXh0dXJlU2hhcGUpO1xuICAgIHJlc2hhcGVfZ3B1LnJlc2hhcGUoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIGEuZ2V0VGV4dHVyZSgpLCBhVGV4U2hhcGVbMF0sIGFUZXhTaGFwZVsxXSxcbiAgICAgICAgcmVzdWx0VGV4dHVyZSwgbmV3VGV4dHVyZVNoYXBlWzBdLCBuZXdUZXh0dXJlU2hhcGVbMV0pO1xuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxUPihcbiAgICAgICAgYS5zaGFwZSwge3RleHR1cmU6IHJlc3VsdFRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiBuZXdUZXh0dXJlU2hhcGV9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXRNdWxJbnRlcm5hbChcbiAgICAgIGE6IEFycmF5MkQsIGI6IEFycmF5MkQsIGFPcmllbnRhdGlvbjogTWF0cml4T3JpZW50YXRpb24sXG4gICAgICBiT3JpZW50YXRpb246IE1hdHJpeE9yaWVudGF0aW9uKTogQXJyYXkyRCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBNYXRNdWxQcm9ncmFtKGEuc2hhcGUsIGIuc2hhcGUsIGFPcmllbnRhdGlvbixcbiAgICAgICAgYk9yaWVudGF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPEFycmF5MkQsIEFycmF5MkQ+KHByb2dyYW0sIFthLCBiXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbXVsdGlwbHlJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQmluYXJ5T3BQcm9ncmFtKCcqJywgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxULCBUPihwcm9ncmFtLCBbYSwgYl0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGJhdGNoTm9ybWFsaXphdGlvbjNESW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBtZWFuOiBBcnJheTNEfEFycmF5MUQsIHZhcmlhbmNlOiBBcnJheTNEfEFycmF5MUQsXG4gICAgICB2YXJpYW5jZUVwc2lsb246IG51bWJlciwgc2NhbGU/OiBBcnJheTNEfEFycmF5MUQsXG4gICAgICBvZmZzZXQ/OiBBcnJheTNEfEFycmF5MUQpOiBBcnJheTNEIHtcbiAgICBjb25zdCB4VGV4U2hhcGUgPSB4LmdldFRleHR1cmVTaGFwZVJDKCk7XG5cbiAgICBsZXQgY2xlYW51cE1lYW4gPSBmYWxzZTtcbiAgICBjb25zdCBwcmVmZXJyZWRNZWFuVGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICBtZWFuLnJhbmsgPT09IDEgPyBbMSwgbWVhbi5zaXplXSA6IHhUZXhTaGFwZTtcbiAgICBsZXQgbWVhblRleFNoYXBlID0gbWVhbi5nZXRUZXh0dXJlU2hhcGVSQyhwcmVmZXJyZWRNZWFuVGV4U2hhcGUpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChtZWFuVGV4U2hhcGUsIHByZWZlcnJlZE1lYW5UZXhTaGFwZSkpIHtcbiAgICAgIG1lYW4gPSB0aGlzLnJlc2hhcGVUZXh0dXJlKG1lYW4sIHByZWZlcnJlZE1lYW5UZXhTaGFwZSk7XG4gICAgICBtZWFuVGV4U2hhcGUgPSBwcmVmZXJyZWRNZWFuVGV4U2hhcGU7XG4gICAgICBjbGVhbnVwTWVhbiA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IGNsZWFudXBWYXJpYW5jZSA9IGZhbHNlO1xuICAgIGNvbnN0IHByZWZlcnJlZFZhcmlhbmNlVGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICB2YXJpYW5jZS5yYW5rID09PSAxID8gWzEsIHZhcmlhbmNlLnNpemVdIDogeFRleFNoYXBlO1xuICAgIGxldCB2YXJpYW5jZVRleFNoYXBlID0gdmFyaWFuY2UuZ2V0VGV4dHVyZVNoYXBlUkMocHJlZmVycmVkTWVhblRleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodmFyaWFuY2VUZXhTaGFwZSwgcHJlZmVycmVkVmFyaWFuY2VUZXhTaGFwZSkpIHtcbiAgICAgIHZhcmlhbmNlID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh2YXJpYW5jZSwgcHJlZmVycmVkVmFyaWFuY2VUZXhTaGFwZSk7XG4gICAgICB2YXJpYW5jZVRleFNoYXBlID0gcHJlZmVycmVkVmFyaWFuY2VUZXhTaGFwZTtcbiAgICAgIGNsZWFudXBWYXJpYW5jZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IHNjYWxlVGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl18bnVsbCA9IG51bGw7XG4gICAgbGV0IGNsZWFudXBTY2FsZSA9IGZhbHNlO1xuICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVmZXJyZWRTY2FsZVRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgICBzY2FsZS5yYW5rID09PSAxID8gWzEsIHNjYWxlLnNpemVdIDogeFRleFNoYXBlO1xuXG4gICAgICBzY2FsZVRleFNoYXBlID0gc2NhbGUuZ2V0VGV4dHVyZVNoYXBlUkMocHJlZmVycmVkU2NhbGVUZXhTaGFwZSk7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoc2NhbGVUZXhTaGFwZSwgcHJlZmVycmVkU2NhbGVUZXhTaGFwZSkpIHtcbiAgICAgICAgc2NhbGUgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKHNjYWxlLCBwcmVmZXJyZWRTY2FsZVRleFNoYXBlKTtcbiAgICAgICAgc2NhbGVUZXhTaGFwZSA9IHByZWZlcnJlZFNjYWxlVGV4U2hhcGU7XG4gICAgICAgIGNsZWFudXBTY2FsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldFRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdfG51bGwgPSBudWxsO1xuICAgIGxldCBjbGVhbnVwT2Zmc2V0ID0gZmFsc2U7XG4gICAgaWYgKG9mZnNldCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVmZXJyZWRPZmZzZXRUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSA9XG4gICAgICAgICAgb2Zmc2V0LnJhbmsgPT09IDEgPyBbMSwgb2Zmc2V0LnNpemVdIDogeFRleFNoYXBlO1xuXG4gICAgICBvZmZzZXRUZXhTaGFwZSA9IG9mZnNldC5nZXRUZXh0dXJlU2hhcGVSQyhwcmVmZXJyZWRPZmZzZXRUZXhTaGFwZSk7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwob2Zmc2V0VGV4U2hhcGUsIHByZWZlcnJlZE9mZnNldFRleFNoYXBlKSkge1xuICAgICAgICBvZmZzZXQgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKG9mZnNldCwgcHJlZmVycmVkT2Zmc2V0VGV4U2hhcGUpO1xuICAgICAgICBvZmZzZXRUZXhTaGFwZSA9IHByZWZlcnJlZE9mZnNldFRleFNoYXBlO1xuICAgICAgICBjbGVhbnVwT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKFxuICAgICAgICBgJHtCQVRDSE5PUk1fUFJPR31fJHt4VGV4U2hhcGV9XyR7bWVhblRleFNoYXBlfV8ke3ZhcmlhbmNlVGV4U2hhcGV9X2AgK1xuICAgICAgICAgICAgYCR7c2NhbGVUZXhTaGFwZSF9XyR7b2Zmc2V0VGV4U2hhcGUhfV8ke3ZhcmlhbmNlRXBzaWxvbn1gLFxuICAgICAgICAoKSA9PiBiYXRjaG5vcm1fZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgICAgICAgICAgeFRleFNoYXBlLCBtZWFuVGV4U2hhcGUsIHZhcmlhbmNlVGV4U2hhcGUsIG9mZnNldFRleFNoYXBlLFxuICAgICAgICAgICAgc2NhbGVUZXhTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKSk7XG5cbiAgICBjb25zdCByZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShyZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBiYXRjaG5vcm1fZ3B1LmJhdGNoTm9ybWFsaXphdGlvbihcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgeC5nZXRUZXh0dXJlKCksIHhUZXhTaGFwZSwgbWVhbi5nZXRUZXh0dXJlKCksXG4gICAgICAgIG1lYW5UZXhTaGFwZSwgdmFyaWFuY2UuZ2V0VGV4dHVyZSgpLCB2YXJpYW5jZVRleFNoYXBlLFxuICAgICAgICBvZmZzZXQgIT0gbnVsbCA/IG9mZnNldC5nZXRUZXh0dXJlKCkgOiBudWxsLFxuICAgICAgICBvZmZzZXQgIT0gbnVsbCA/IG9mZnNldFRleFNoYXBlIDogbnVsbCxcbiAgICAgICAgc2NhbGUgIT0gbnVsbCA/IHNjYWxlLmdldFRleHR1cmUoKSA6IG51bGwsXG4gICAgICAgIHNjYWxlICE9IG51bGwgPyBzY2FsZVRleFNoYXBlIDogbnVsbCwgcmVzdWx0VGV4dHVyZSwgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBNZWFuKSB7XG4gICAgICBtZWFuLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKGNsZWFudXBWYXJpYW5jZSkge1xuICAgICAgdmFyaWFuY2UuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFNjYWxlKSB7XG4gICAgICBzY2FsZSEuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cE9mZnNldCkge1xuICAgICAgb2Zmc2V0IS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgeC5zaGFwZSwge3RleHR1cmU6IHJlc3VsdFRleHR1cmUsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN3aXRjaERpbUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBuZXdEaW06IG51bWJlcltdKTogVCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkIScpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN1bUludGVybmFsKGE6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgUmVkdWNlU3VtUHJvZ3JhbShhLnNpemUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhcmdNaW5JbnRlcm5hbChhOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IEFyZ01pbk1heFByb2dyYW0oYS5zaXplLCAnbWluJyk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFyZ01heEludGVybmFsKGE6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQXJnTWluTWF4UHJvZ3JhbShhLnNpemUsICdtYXgnKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXJnTWF4RXF1YWxzSW50ZXJuYWwoeDE6IE5EQXJyYXksIHgyOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IEFyZ01heEVxdWFsc1Byb2dyYW0oeDEuc2l6ZSwgeDIuc2l6ZSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeDEsIHgyXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgdG9wS0ludGVybmFsKG5kYXJyYXk6IE5EQXJyYXksIGs6IG51bWJlcik6XG4gICAgICB7dmFsdWVzOiBBcnJheTFELCBpbmRpY2VzOiBBcnJheTFEfSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b3BLIEdQVSBub3QgeWV0IGltcGxlbWVudGVkIScpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1pbkludGVybmFsKGE6IE5EQXJyYXkpOiBTY2FsYXIge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgTWluTWF4UHJvZ3JhbShhLnNpemUsICdtaW4nKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWF4SW50ZXJuYWwoYTogTkRBcnJheSk6IFNjYWxhciB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBNaW5NYXhQcm9ncmFtKGEuc2l6ZSwgJ21heCcpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXZpZGVJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCwgYjogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgQmluYXJ5T3BQcm9ncmFtKCcvJywgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxOREFycmF5LCBUPihwcm9ncmFtLCBbYSwgYl0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBULCBiOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBCaW5hcnlPcFByb2dyYW0oJysnLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPE5EQXJyYXksIFQ+KHByb2dyYW0sIFthLCBiXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3ViSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQsIGI6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IEJpbmFyeU9wUHJvZ3JhbSgnLScsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48TkRBcnJheSwgVD4ocHJvZ3JhbSwgW2EsIGJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBsb2dTdW1FeHBJbnRlcm5hbChhOiBOREFycmF5KTogU2NhbGFyIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IExvZ1N1bUV4cFByb2dyYW0oYS5zaXplKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZXhwSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuRVhQKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbG9nSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuTE9HKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVsdUludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCBVbmFyeU9wLlJFTFUpO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzaWdtb2lkSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuU0lHTU9JRCk7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bjxULCBUPihwcm9ncmFtLCBbYV0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHRhbmhJbnRlcm5hbDxUIGV4dGVuZHMgTkRBcnJheT4oYTogVCk6IFQge1xuICAgIGNvbnN0IHByb2dyYW0gPSBuZXcgVW5hcnlPcFByb2dyYW0oYS5zaGFwZSwgVW5hcnlPcC5UQU5IKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2luSW50ZXJuYWw8VCBleHRlbmRzIE5EQXJyYXk+KGE6IFQpOiBUIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbmV3IFVuYXJ5T3BQcm9ncmFtKGEuc2hhcGUsIFVuYXJ5T3AuU0lOKTtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuPFQsIFQ+KHByb2dyYW0sIFthXSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RlcEludGVybmFsPFQgZXh0ZW5kcyBOREFycmF5PihhOiBUKTogVCB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBVbmFyeU9wUHJvZ3JhbShhLnNoYXBlLCBVbmFyeU9wLlNURVApO1xuICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW48VCwgVD4ocHJvZ3JhbSwgW2FdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb252MmRJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBzdHJpZGU6IG51bWJlcixcbiAgICAgIHplcm9QYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IGZpZWxkU2l6ZSA9IHdlaWdodHMuc2hhcGVbMF07XG4gICAgY29uc3QgaW5wdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbMl07XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSB3ZWlnaHRzLnNoYXBlWzNdO1xuICAgIGNvbnN0IHByb2dLZXkgPSBbXG4gICAgICBDT05WMkRfUFJPRywgeC5zaGFwZSwgb3V0cHV0RGVwdGgsIGZpZWxkU2l6ZSwgc3RyaWRlLCBiaWFzZXMgIT0gbnVsbFxuICAgIF0uam9pbignXycpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKHByb2dLZXksICgpID0+IHtcbiAgICAgIHJldHVybiBjb252X2dwdS5nZXRGcmFnbWVudFNoYWRlclNvdXJjZShcbiAgICAgICAgICB4LnNoYXBlLCBvdXRwdXREZXB0aCwgZmllbGRTaXplLCBzdHJpZGUsIHplcm9QYWQsIGJpYXNlcyAhPSBudWxsKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHhUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeC5zaGFwZSk7XG4gICAgY29uc3Qgd1RleFNoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVXZWlnaHRzVGV4U2hhcGUoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZpZWxkU2l6ZSk7XG4gICAgY29uc3QgYmlhc1RleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVCaWFzZXNUZXhTaGFwZShvdXRwdXREZXB0aCk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwVyA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFdUZXhTaGFwZSA9IHdlaWdodHMuZ2V0VGV4dHVyZVNoYXBlUkMod1RleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsV1RleFNoYXBlLCB3VGV4U2hhcGUpKSB7XG4gICAgICB3ZWlnaHRzID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh3ZWlnaHRzLCB3VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFcgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwQiA9IGZhbHNlO1xuICAgIGlmIChiaWFzZXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYWN0dWFsQlRleFNoYXBlID0gYmlhc2VzLmdldFRleHR1cmVTaGFwZVJDKGJpYXNUZXhTaGFwZSk7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsQlRleFNoYXBlLCBiaWFzVGV4U2hhcGUpKSB7XG4gICAgICAgIGJpYXNlcyA9IHRoaXMucmVzaGFwZVRleHR1cmUoYmlhc2VzLCBiaWFzVGV4U2hhcGUpO1xuICAgICAgICBjbGVhbnVwQiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIHguc2hhcGUsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCk7XG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHJlc3VsdFNoYXBlKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbnZfZ3B1LmNvbnZvbHZlKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCB4LmdldFRleHR1cmUoKSwgd2VpZ2h0cy5nZXRUZXh0dXJlKCksXG4gICAgICAgIGJpYXNlcyAhPSBudWxsID8gYmlhc2VzLmdldFRleHR1cmUoKSA6IG51bGwsIHJlc3VsdFRleCwgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBYKSB7XG4gICAgICB4LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKGNsZWFudXBXKSB7XG4gICAgICB3ZWlnaHRzLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKGNsZWFudXBCICYmIGJpYXNlcyAhPSBudWxsKSB7XG4gICAgICBiaWFzZXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8QXJyYXkzRD4oXG4gICAgICAgIHJlc3VsdFNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4LCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb252MmRCYWNrUHJvcEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZHk6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiB7ZHg6IEFycmF5M0QsIGR3OiBBcnJheTRELCBkYjogQXJyYXkxRH0ge1xuICAgIGNvbnN0IGZTaXplID0gd2VpZ2h0cy5zaGFwZVswXTtcbiAgICBjb25zdCBpbnB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVsyXTtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbM107XG4gICAgY29uc3QgeFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4LnNoYXBlKTtcbiAgICBjb25zdCB3VGV4U2hhcGUgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZlNpemUpO1xuICAgIGNvbnN0IHlUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoZHkuc2hhcGUpO1xuXG4gICAgLy8gSWYgdGhlIHRleHR1cmUgc2hhcGVzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNoYXBlcyB0aGF0IHNoYWRlcnMgZXhwZWN0LFxuICAgIC8vIGRvIHBoeXNpY2FsIHRleHR1cmUgcmVzaGFwZXMgb24gdGhlIEdQVS5cbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBjb25zdCBhY3R1YWxYVGV4U2hhcGUgPSB4LmdldFRleHR1cmVTaGFwZVJDKHhUZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFhUZXhTaGFwZSwgeFRleFNoYXBlKSkge1xuICAgICAgeCA9IHRoaXMucmVzaGFwZVRleHR1cmUoeCwgeFRleFNoYXBlKTtcbiAgICAgIGNsZWFudXBYID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgY2xlYW51cFcgPSBmYWxzZTtcbiAgICBjb25zdCBhY3R1YWxXVGV4U2hhcGUgPSB3ZWlnaHRzLmdldFRleHR1cmVTaGFwZVJDKHdUZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFdUZXhTaGFwZSwgd1RleFNoYXBlKSkge1xuICAgICAgd2VpZ2h0cyA9IHRoaXMucmVzaGFwZVRleHR1cmUod2VpZ2h0cywgd1RleFNoYXBlKTtcbiAgICAgIGNsZWFudXBXID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgY2xlYW51cFkgPSBmYWxzZTtcbiAgICBjb25zdCBhY3R1YWxZVGV4U2hhcGUgPSBkeS5nZXRUZXh0dXJlU2hhcGVSQyh5VGV4U2hhcGUpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxZVGV4U2hhcGUsIHlUZXhTaGFwZSkpIHtcbiAgICAgIGR5ID0gdGhpcy5yZXNoYXBlVGV4dHVyZShkeSwgeVRleFNoYXBlKTtcbiAgICAgIGNsZWFudXBZID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBkdyA9IHRoaXMuY29udjJkRGVyV2VpZ2h0cyh4LCBkeSwgZlNpemUsIHN0cmlkZSwgcGFkKTtcbiAgICBjb25zdCBkYiA9IHRoaXMuY29udjJkRGVyQmlhcyhkeSk7XG4gICAgY29uc3QgZHggPSB0aGlzLmNvbnYyZFRyYW5zcG9zZUludGVybmFsKFxuICAgICAgICBkeSwgd2VpZ2h0cywgbnVsbCAvKiogYmlhc2VzICovLCBzdHJpZGUsIHBhZCk7XG5cbiAgICBpZiAoY2xlYW51cFgpIHtcbiAgICAgIHguZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFcpIHtcbiAgICAgIHdlaWdodHMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFkpIHtcbiAgICAgIGR5LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtkeCwgZGIsIGR3fTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb252MmRUcmFuc3Bvc2VJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIHdlaWdodHM6IEFycmF5NEQsIGJpYXNlczogQXJyYXkxRHxudWxsLCBvcmlnU3RyaWRlOiBudW1iZXIsXG4gICAgICBvcmlnUGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBvcmlnSW5wdXREZXB0aCA9IHdlaWdodHMuc2hhcGVbMl07XG4gICAgY29uc3Qgb3JpZ091dHB1dERlcHRoID0gd2VpZ2h0cy5zaGFwZVszXTtcbiAgICBjb25zdCBmaWVsZFNpemUgPSB3ZWlnaHRzLnNoYXBlWzBdO1xuXG4gICAgY29uc3QgcHJvZ0tleSA9IFtcbiAgICAgIENPTlYyRF9UUkFOU1BPU0VfUFJPRywgeC5zaGFwZSwgZmllbGRTaXplLCBvcmlnSW5wdXREZXB0aCwgb3JpZ1N0cmlkZSxcbiAgICAgIG9yaWdQYWQsIGJpYXNlcyAhPSBudWxsXG4gICAgXS5qb2luKCdfJyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0ocHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnZfYmFja3Byb3BfZ3B1LmdldEZyYWdtZW50U2hhZGVyQ29udlRyYW5zcG9zZVNvdXJjZShcbiAgICAgICAgICB4LnNoYXBlLCBmaWVsZFNpemUsIG9yaWdJbnB1dERlcHRoLCBvcmlnU3RyaWRlLCBvcmlnUGFkLFxuICAgICAgICAgIGJpYXNlcyAhPSBudWxsKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHhUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeC5zaGFwZSk7XG4gICAgY29uc3Qgd1RleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVXZWlnaHRzVGV4U2hhcGUoXG4gICAgICAgIG9yaWdJbnB1dERlcHRoLCBvcmlnT3V0cHV0RGVwdGgsIGZpZWxkU2l6ZSk7XG4gICAgY29uc3QgYmlhc1RleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVCaWFzZXNUZXhTaGFwZShvcmlnSW5wdXREZXB0aCk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwVyA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFdUZXhTaGFwZSA9IHdlaWdodHMuZ2V0VGV4dHVyZVNoYXBlUkMod1RleFNoYXBlKTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsV1RleFNoYXBlLCB3VGV4U2hhcGUpKSB7XG4gICAgICB3ZWlnaHRzID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh3ZWlnaHRzLCB3VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFcgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwQiA9IGZhbHNlO1xuICAgIGlmIChiaWFzZXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYWN0dWFsQmlhc1RleFNoYXBlID0gYmlhc2VzLmdldFRleHR1cmVTaGFwZVJDKGJpYXNUZXhTaGFwZSk7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsQmlhc1RleFNoYXBlLCBiaWFzVGV4U2hhcGUpKSB7XG4gICAgICAgIGJpYXNlcyA9IHRoaXMucmVzaGFwZVRleHR1cmUoYmlhc2VzLCBiaWFzVGV4U2hhcGUpO1xuICAgICAgICBjbGVhbnVwQiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCB0aGUgb3V0cHV0IHNoYXBlIGJ5IGRpbGF0aW5nIHRoZSBpbnB1dC5cbiAgICBjb25zdCBkaWxhdGVkUkMgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZURpbGF0ZWRSQyhbeC5zaGFwZVswXSwgeC5zaGFwZVsxXV0sIG9yaWdTdHJpZGUpO1xuICAgIGNvbnN0IHBhZCA9IGZpZWxkU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICAgIGNvbnN0IHJlc3VsdFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICBbZGlsYXRlZFJDWzBdLCBkaWxhdGVkUkNbMV0sIG9yaWdPdXRwdXREZXB0aF0sIGZpZWxkU2l6ZSxcbiAgICAgICAgb3JpZ0lucHV0RGVwdGgsIDEsIHBhZCk7XG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHJlc3VsdFNoYXBlKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbnZfYmFja3Byb3BfZ3B1LmNvbnZUcmFuc3Bvc2UoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIHguZ2V0VGV4dHVyZSgpLCB3ZWlnaHRzLmdldFRleHR1cmUoKSxcbiAgICAgICAgYmlhc2VzICE9IG51bGwgPyBiaWFzZXMuZ2V0VGV4dHVyZSgpIDogbnVsbCwgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cFgpIHtcbiAgICAgIHguZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cFcpIHtcbiAgICAgIHdlaWdodHMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cEIpIHtcbiAgICAgIGJpYXNlcyEuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8QXJyYXkzRD4oXG4gICAgICAgIHJlc3VsdFNoYXBlLCB7dGV4dHVyZTogcmVzdWx0VGV4LCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIGNvbnYyZERlcldlaWdodHMoXG4gICAgICB4OiBBcnJheTNELCBkWTogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgICB6ZXJvUGFkOiBudW1iZXIpOiBBcnJheTREIHtcbiAgICBjb25zdCBpbnB1dERlcHRoID0geC5zaGFwZVsyXTtcbiAgICBjb25zdCBvdXRwdXREZXB0aCA9IGRZLnNoYXBlWzJdO1xuICAgIGNvbnN0IHByb2dLZXkgPSBbXG4gICAgICBDT05WMkRfREVSV19QUk9HLCB4LnNoYXBlLCBmU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZFxuICAgIF0uam9pbignXycpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKHByb2dLZXksICgpID0+IHtcbiAgICAgIHJldHVybiBjb252X2JhY2twcm9wX2dwdS5nZXRGcmFnbWVudFNoYWRlckRlcldlaWdodHNTb3VyY2UoXG4gICAgICAgICAgeC5zaGFwZSwgZlNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgeFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4LnNoYXBlKTtcbiAgICBjb25zdCB5U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZU91dHB1dFNoYXBlM0QoXG4gICAgICAgIHguc2hhcGUsIGZTaXplLCBvdXRwdXREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkKTtcbiAgICBjb25zdCB5VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHlTaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBjbGVhbnVwWSA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFlUZXhTaGFwZSA9IGRZLmdldFRleHR1cmVTaGFwZVJDKHlUZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFlUZXhTaGFwZSwgeVRleFNoYXBlKSkge1xuICAgICAgZFkgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKGRZLCB5VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFkgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdFRleFNoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVXZWlnaHRzVGV4U2hhcGUoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZTaXplKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGNvbnZfYmFja3Byb3BfZ3B1LmRlcldlaWdodHMoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIHguZ2V0VGV4dHVyZSgpLCBkWS5nZXRUZXh0dXJlKCksIHJlc3VsdFRleCxcbiAgICAgICAgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBYKSB7XG4gICAgICB4LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaWYgKGNsZWFudXBZKSB7XG4gICAgICBkWS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2VpZ2h0c1NoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVXZWlnaHRzU2hhcGU0RChpbnB1dERlcHRoLCBvdXRwdXREZXB0aCwgZlNpemUpO1xuICAgIHJldHVybiBOREFycmF5Lm1ha2U8QXJyYXk0RD4oXG4gICAgICAgIHdlaWdodHNTaGFwZSwge3RleHR1cmU6IHJlc3VsdFRleCwgdGV4dHVyZVNoYXBlUkM6IHJlc3VsdFRleFNoYXBlfSk7XG4gIH1cblxuICBjb252MmREZXJCaWFzKGRZOiBBcnJheTNEKTogQXJyYXkxRCB7XG4gICAgY29uc3Qgb3V0cHV0RGVwdGggPSBkWS5zaGFwZVsyXTtcbiAgICBjb25zdCBwcm9nS2V5ID0gW0NPTlYyRF9ERVJCX1BST0csIGRZLnNoYXBlXS5qb2luKCdfJyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0ocHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNvbnZfYmFja3Byb3BfZ3B1LmdldEZyYWdtZW50U2hhZGVyRGVyQmlhc1NvdXJjZShkWS5zaGFwZSk7XG4gICAgfSk7XG4gICAgY29uc3QgeVRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChkWS5zaGFwZSk7XG5cbiAgICAvLyBJZiB0aGUgdGV4dHVyZSBzaGFwZXMgZG9lc24ndCBtYXRjaCB0aGUgc2hhcGVzIHRoYXQgc2hhZGVycyBleHBlY3QsXG4gICAgLy8gZG8gcGh5c2ljYWwgdGV4dHVyZSByZXNoYXBlcyBvbiB0aGUgR1BVLlxuICAgIGxldCBjbGVhbnVwWSA9IGZhbHNlO1xuICAgIGNvbnN0IGFjdHVhbFlUZXhTaGFwZSA9IGRZLmdldFRleHR1cmVTaGFwZVJDKHlUZXhTaGFwZSk7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFlUZXhTaGFwZSwgeVRleFNoYXBlKSkge1xuICAgICAgZFkgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKGRZLCB5VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFkgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVCaWFzZXNUZXhTaGFwZShvdXRwdXREZXB0aCk7XG4gICAgY29uc3QgcmVzdWx0VGV4ID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShyZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBjb252X2JhY2twcm9wX2dwdS5kZXJCaWFzKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCBkWS5nZXRUZXh0dXJlKCksIHJlc3VsdFRleCwgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgaWYgKGNsZWFudXBZKSB7XG4gICAgICBkWS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTFEPihcbiAgICAgICAgW291dHB1dERlcHRoXSwge3RleHR1cmU6IHJlc3VsdFRleCwgdGV4dHVyZVNoYXBlUkM6IHJlc3VsdFRleFNoYXBlfSk7XG4gIH1cblxuICBwcml2YXRlIHBvb2woXG4gICAgICBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLFxuICAgICAgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCB4VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHguc2hhcGUpO1xuXG4gICAgLy8gSWYgdGhlIHRleHR1cmUgc2hhcGVzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNoYXBlcyB0aGF0IHNoYWRlcnMgZXhwZWN0LFxuICAgIC8vIGRvIHBoeXNpY2FsIHRleHR1cmUgcmVzaGFwZXMgb24gdGhlIEdQVS5cbiAgICBjb25zdCBhY3R1YWxYVGV4U2hhcGUgPSB4LmdldFRleHR1cmVTaGFwZVJDKHhUZXhTaGFwZSk7XG4gICAgbGV0IGNsZWFudXBYID0gZmFsc2U7XG4gICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbFhUZXhTaGFwZSwgeFRleFNoYXBlKSkge1xuICAgICAgeCA9IHRoaXMucmVzaGFwZVRleHR1cmUoeCwgeFRleFNoYXBlKTtcbiAgICAgIGNsZWFudXBYID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRTaGFwZSA9XG4gICAgICAgIGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmU2l6ZSwgeC5zaGFwZVsyXSwgc3RyaWRlLCBwYWQpO1xuICAgIGNvbnN0IHJlc3VsdFRleFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChyZXN1bHRTaGFwZSk7XG4gICAgY29uc3QgcG9vbFJlc3VsdFRleCA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUocmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgcG9vbF9ncHUucG9vbENvbW1vbihcbiAgICAgICAgdGhpcy5ncGdwdSwgcHJvZ3JhbSwgeC5nZXRUZXh0dXJlKCksIHBvb2xSZXN1bHRUZXgsIHJlc3VsdFRleFNoYXBlKTtcblxuICAgIGlmIChjbGVhbnVwWCkge1xuICAgICAgeC5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgcmVzdWx0U2hhcGUsIHt0ZXh0dXJlOiBwb29sUmVzdWx0VGV4LCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhQb29sSW50ZXJuYWwoXG4gICAgICB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgcGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBtYXhQb29sUHJvZ0tleSA9XG4gICAgICAgIFtNQVhfUE9PTF9QUk9HLCB4LnNoYXBlLCBmU2l6ZSwgc3RyaWRlLCBwYWRdLmpvaW4oJ18nKTtcbiAgICBjb25zdCBtYXhQb29sUHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0obWF4UG9vbFByb2dLZXksICgpID0+IHtcbiAgICAgIHJldHVybiBtYXhfcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sU291cmNlKFxuICAgICAgICAgIHguc2hhcGUsIGZTaXplLCBzdHJpZGUsIHBhZCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5wb29sKG1heFBvb2xQcm9ncmFtLCB4LCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG1pblBvb2xJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIGZTaXplOiBudW1iZXIsIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIGNvbnN0IG1pblBvb2xQcm9nS2V5ID1cbiAgICAgICAgW01JTl9QT09MX1BST0csIHguc2hhcGUsIGZTaXplLCBzdHJpZGUsIHBhZF0uam9pbignXycpO1xuICAgIGNvbnN0IG1pblBvb2xQcm9ncmFtID0gdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShtaW5Qb29sUHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIG1pbl9wb29sX2dwdS5nZXRGcmFnbWVudFNoYWRlck1pblBvb2xTb3VyY2UoXG4gICAgICAgICAgeC5zaGFwZSwgZlNpemUsIHN0cmlkZSwgcGFkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnBvb2wobWluUG9vbFByb2dyYW0sIHgsIGZTaXplLCBzdHJpZGUsIHBhZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXZnUG9vbEludGVybmFsKFxuICAgICAgeDogQXJyYXkzRCwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHBhZDogbnVtYmVyKTogQXJyYXkzRCB7XG4gICAgY29uc3QgYXZnUG9vbFByb2dLZXkgPVxuICAgICAgICBbQVZHX1BPT0xfUFJPRywgeC5zaGFwZSwgZlNpemUsIHN0cmlkZSwgcGFkXS5qb2luKCdfJyk7XG4gICAgY29uc3QgYXZnUG9vbFByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKGF2Z1Bvb2xQcm9nS2V5LCAoKSA9PiB7XG4gICAgICByZXR1cm4gYXZnX3Bvb2xfZ3B1LmdldEZyYWdtZW50U2hhZGVyQXZnUG9vbFNvdXJjZShcbiAgICAgICAgICB4LnNoYXBlLCBmU2l6ZSwgc3RyaWRlLCBwYWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMucG9vbChhdmdQb29sUHJvZ3JhbSwgeCwgZlNpemUsIHN0cmlkZSwgcGFkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtYXhQb29sQmFja3Byb3BJbnRlcm5hbChcbiAgICAgIGR5OiBBcnJheTNELCB4OiBBcnJheTNELCBmU2l6ZTogbnVtYmVyLCBvcmlnU3RyaWRlOiBudW1iZXIsXG4gICAgICBvcmlnUGFkOiBudW1iZXIpOiBBcnJheTNEIHtcbiAgICBjb25zdCBtYXhQb29sUG9zaXRpb25zUHJvZ0tleSA9IFtcbiAgICAgIE1BWF9QT09MX1BPU0lUSU9OU19QUk9HLCB4LnNoYXBlLCBmU2l6ZSwgb3JpZ1N0cmlkZSwgb3JpZ1BhZFxuICAgIF0uam9pbignXycpO1xuICAgIGNvbnN0IG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtID1cbiAgICAgICAgdGhpcy5nZXRBbmRTYXZlUHJvZ3JhbShtYXhQb29sUG9zaXRpb25zUHJvZ0tleSwgKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBtYXhfcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sUG9zaXRpb25zU291cmNlKFxuICAgICAgICAgICAgICB4LnNoYXBlLCBmU2l6ZSwgb3JpZ1N0cmlkZSwgb3JpZ1BhZCk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgbWF4UG9vbFJlc3VsdFNoYXBlID0gY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKFxuICAgICAgICB4LnNoYXBlLCBmU2l6ZSwgeC5zaGFwZVsyXSwgb3JpZ1N0cmlkZSwgb3JpZ1BhZCk7XG4gICAgY29uc3QgbWF4UG9vbFJlc3VsdFRleFNoYXBlID1cbiAgICAgICAgY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChtYXhQb29sUmVzdWx0U2hhcGUpO1xuICAgIGNvbnN0IG1heFBvb2xQb3NpdGlvbnNSZXN1bHRUZXggPVxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKG1heFBvb2xSZXN1bHRUZXhTaGFwZSk7XG4gICAgLy8gSWYgdGhlIHRleHR1cmUgc2hhcGVzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNoYXBlcyB0aGF0IHNoYWRlcnMgZXhwZWN0LFxuICAgIC8vIGRvIHBoeXNpY2FsIHRleHR1cmUgcmVzaGFwZXMgb24gdGhlIEdQVS5cbiAgICBjb25zdCB4VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHguc2hhcGUpO1xuICAgIGNvbnN0IGFjdHVhbFhUZXhTaGFwZSA9IHguZ2V0VGV4dHVyZVNoYXBlUkMoeFRleFNoYXBlKTtcbiAgICBsZXQgY2xlYW51cFggPSBmYWxzZTtcbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoYWN0dWFsWFRleFNoYXBlLCB4VGV4U2hhcGUpKSB7XG4gICAgICB4ID0gdGhpcy5yZXNoYXBlVGV4dHVyZSh4LCB4VGV4U2hhcGUpO1xuICAgICAgY2xlYW51cFggPSB0cnVlO1xuICAgIH1cblxuICAgIG1heF9wb29sX2dwdS5tYXhQb29sQ29tbW9uKFxuICAgICAgICB0aGlzLmdwZ3B1LCBtYXhQb29sUG9zaXRpb25zUHJvZ3JhbSwgeC5nZXRUZXh0dXJlKCksXG4gICAgICAgIG1heFBvb2xQb3NpdGlvbnNSZXN1bHRUZXgsIG1heFBvb2xSZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBjb25zdCBtYXhQb29sQmFja3Byb3BQcm9nS2V5ID0gW1xuICAgICAgTUFYX1BPT0xfQkFDS1BST1BfUFJPRywgZHkuc2hhcGUsIGZTaXplLCBvcmlnU3RyaWRlLCBvcmlnUGFkXG4gICAgXS5qb2luKCdfJyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0QW5kU2F2ZVByb2dyYW0obWF4UG9vbEJhY2twcm9wUHJvZ0tleSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIG1heF9wb29sX2JhY2twcm9wX2dwdS5nZXRGcmFnbWVudFNoYWRlck1heFBvb2xCYWNrcHJvcChcbiAgICAgICAgICBkeS5zaGFwZSwgZlNpemUsIG9yaWdTdHJpZGUsIG9yaWdQYWQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZHlUZXhTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoZHkuc2hhcGUpO1xuXG4gICAgLy8gSWYgdGhlIHRleHR1cmUgc2hhcGVzIGRvZXNuJ3QgbWF0Y2ggdGhlIHNoYXBlcyB0aGF0IHNoYWRlcnMgZXhwZWN0LFxuICAgIC8vIGRvIHBoeXNpY2FsIHRleHR1cmUgcmVzaGFwZXMgb24gdGhlIEdQVS5cbiAgICBjb25zdCBhY3R1YWxEeVRleFNoYXBlID0gZHkuZ2V0VGV4dHVyZVNoYXBlUkMoZHlUZXhTaGFwZSk7XG4gICAgbGV0IGNsZWFudXBEeSA9IGZhbHNlO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhY3R1YWxEeVRleFNoYXBlLCBkeVRleFNoYXBlKSkge1xuICAgICAgZHkgPSB0aGlzLnJlc2hhcGVUZXh0dXJlKGR5LCBkeVRleFNoYXBlKTtcbiAgICAgIGNsZWFudXBEeSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZGlsYXRlZER5UkMgPVxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZURpbGF0ZWRSQyhbZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdXSwgb3JpZ1N0cmlkZSk7XG4gICAgY29uc3QgcGFkID0gZlNpemUgLSAxIC0gb3JpZ1BhZDtcbiAgICBjb25zdCByZXN1bHRTaGFwZVJDRCA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgICAgW2RpbGF0ZWREeVJDWzBdLCBkaWxhdGVkRHlSQ1sxXSwgZHkuc2hhcGVbMl1dLCBmU2l6ZSwgZHkuc2hhcGVbMl0sIDEsXG4gICAgICAgIHBhZCk7XG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHJlc3VsdFNoYXBlUkNEKTtcbiAgICBjb25zdCByZXN1bHRUZXggPSB0aGlzLnRleHR1cmVNYW5hZ2VyLmFjcXVpcmVUZXh0dXJlKHJlc3VsdFRleFNoYXBlKTtcblxuICAgIG1heF9wb29sX2JhY2twcm9wX2dwdS5tYXhQb29sQmFja3Byb3AoXG4gICAgICAgIHRoaXMuZ3BncHUsIHByb2dyYW0sIGR5LmdldFRleHR1cmUoKSwgbWF4UG9vbFBvc2l0aW9uc1Jlc3VsdFRleCxcbiAgICAgICAgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZSk7XG5cbiAgICBpZiAoY2xlYW51cER5KSB7XG4gICAgICBkeS5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNsZWFudXBYKSB7XG4gICAgICB4LmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKFxuICAgICAgICBtYXhQb29sUG9zaXRpb25zUmVzdWx0VGV4LCBtYXhQb29sUmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgcmVzdWx0U2hhcGVSQ0QsIHt0ZXh0dXJlOiByZXN1bHRUZXgsIHRleHR1cmVTaGFwZVJDOiByZXN1bHRUZXhTaGFwZX0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlc2l6ZUJpbGluZWFyM0RJbnRlcm5hbChcbiAgICAgIHg6IEFycmF5M0QsIG5ld1NoYXBlMkQ6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBhbGlnbkNvcm5lcnM6IGJvb2xlYW4pOiBBcnJheTNEIHtcbiAgICBjb25zdCBwcm9ncmFtS2V5ID1cbiAgICAgICAgW1JFU0laRV9CSUxJTkVBUl9QUk9HLCB4LnNoYXBlLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnNdLmpvaW4oJ18nKTtcblxuICAgIGNvbnN0IG5ld1NoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICBbbmV3U2hhcGUyRFswXSwgbmV3U2hhcGUyRFsxXSwgeC5zaGFwZVsyXV07XG4gICAgY29uc3QgcmVzdWx0VGV4U2hhcGUgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKG5ld1NoYXBlUkNEKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdldEFuZFNhdmVQcm9ncmFtKFxuICAgICAgICBwcm9ncmFtS2V5LFxuICAgICAgICAoKSA9PiByZXNpemVfYmlsaW5lYXJfZ3B1LmdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgICAgICAgICAgeC5zaGFwZSwgbmV3U2hhcGUyRCwgYWxpZ25Db3JuZXJzKSk7XG5cbiAgICBjb25zdCByZXN1bHRUZXh0dXJlID0gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZShyZXN1bHRUZXhTaGFwZSk7XG5cbiAgICByZXNpemVfYmlsaW5lYXJfZ3B1LnJlc2l6ZUJpbGluZWFyKFxuICAgICAgICB0aGlzLmdwZ3B1LCBwcm9ncmFtLCB4LmdldFRleHR1cmUoKSwgcmVzdWx0VGV4dHVyZSwgcmVzdWx0VGV4U2hhcGUpO1xuXG4gICAgcmV0dXJuIE5EQXJyYXkubWFrZTxBcnJheTNEPihcbiAgICAgICAgbmV3U2hhcGVSQ0QsIHt0ZXh0dXJlOiByZXN1bHRUZXh0dXJlLCB0ZXh0dXJlU2hhcGVSQzogcmVzdWx0VGV4U2hhcGV9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QW5kU2F2ZUJpbmFyeShrZXk6IHN0cmluZywgZ2V0QmluYXJ5OiAoKSA9PiBHUEdQVUJpbmFyeSk6XG4gICAgICBHUEdQVUJpbmFyeSB7XG4gICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5Q2FjaGVba2V5XTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QW5kU2F2ZVByb2dyYW0ocHJvZ3JhbUtleTogc3RyaW5nLCBnZXRTaGFkZXJTb3VyY2U6ICgpID0+IHN0cmluZyk6XG4gICAgICBXZWJHTFByb2dyYW0ge1xuICAgIGlmICghKHByb2dyYW1LZXkgaW4gdGhpcy5wcm9ncmFtQ2FjaGUpKSB7XG4gICAgICB0aGlzLnByb2dyYW1DYWNoZVtwcm9ncmFtS2V5XSA9XG4gICAgICAgICAgdGhpcy5ncGdwdS5jcmVhdGVQcm9ncmFtKGdldFNoYWRlclNvdXJjZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbUNhY2hlW3Byb2dyYW1LZXldO1xuICB9XG5cbiAgcHJpdmF0ZSBkb0dQVVNoYXBlc01hdGNoKGE6IE5EQXJyYXksIGI6IE5EQXJyYXkpOiBib29sZWFuIHtcbiAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgIGlmIChhLmluR1BVKCkpIHtcbiAgICAgIC8vIFByZWZlciBCIHRvIGhhdmUgdGhlIHNoYXBlIG9mIEEuXG4gICAgICBiLmdldFRleHR1cmVTaGFwZVJDKGEuZ2V0VGV4dHVyZVNoYXBlUkMoKSk7XG4gICAgfSBlbHNlIGlmIChiLmluR1BVKCkpIHtcbiAgICAgIC8vIFByZWZlciBBIHRvIGhhdmUgdGhlIHNoYXBlIG9mIEIuXG4gICAgICBhLmdldFRleHR1cmVTaGFwZVJDKGIuZ2V0VGV4dHVyZVNoYXBlUkMoKSk7XG4gICAgfVxuICAgIHJldHVybiB1dGlsLmFycmF5c0VxdWFsKGEuZ2V0VGV4dHVyZVNoYXBlUkMoKSwgYi5nZXRUZXh0dXJlU2hhcGVSQygpKTtcbiAgfVxuXG4gIGdldFRleHR1cmVNYW5hZ2VyKCk6IFRleHR1cmVNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlcjtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBwcm9ncmFtS2V5IGluIHRoaXMucHJvZ3JhbUNhY2hlKSB7XG4gICAgICBpZiAodGhpcy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkocHJvZ3JhbUtleSkpIHtcbiAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbUNhY2hlW3Byb2dyYW1LZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkge1xuICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVba2V5XS53ZWJHTFByb2dyYW0pO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmRpc3Bvc2UoKTtcblxuICAgIGlmICh0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkpIHtcbiAgICAgIHRoaXMuZ3BncHUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi93ZWJnbC9ncGdwdV9jb250ZXh0JztcbmltcG9ydCB7VGV4dHVyZU1hbmFnZXJ9IGZyb20gJy4vd2ViZ2wvdGV4dHVyZV9tYW5hZ2VyJztcbmltcG9ydCAqIGFzIHdlYmdsX3V0aWwgZnJvbSAnLi93ZWJnbC93ZWJnbF91dGlsJztcblxuLy8gVGhlc2UgZ2xvYmFsIHZhcmlhYmxlcyBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIG51bGwgc28gdGhhdCBjbG9zdXJlIGtub3dzXG4vLyBub3QgdG8gc2VhbCB0aGVtLlxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBsZXQgR1BHUFU6IEdQR1BVQ29udGV4dCA9IG51bGwhO1xuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBsZXQgVEVYVFVSRV9NQU5BR0VSOiBUZXh0dXJlTWFuYWdlciA9IG51bGwhO1xuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOREFycmF5RGF0YSB7XG4gIHZhbHVlcz86IEZsb2F0MzJBcnJheTtcbiAgdGV4dHVyZT86IFdlYkdMVGV4dHVyZTtcbiAgLyoqIFtyb3dzLCBjb2x1bW5zXSBzaGFwZSBvZiB0aGUgdGV4dHVyZS4gKi9cbiAgdGV4dHVyZVNoYXBlUkM/OiBbbnVtYmVyLCBudW1iZXJdO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVHUFUoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgdGV4dHVyZU1hbmFnZXI6IFRleHR1cmVNYW5hZ2VyKSB7XG4gIEdQR1BVID0gZ3BncHU7XG4gIFRFWFRVUkVfTUFOQUdFUiA9IHRleHR1cmVNYW5hZ2VyO1xufVxuXG5mdW5jdGlvbiB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKSB7XG4gIGlmIChHUEdQVSA9PSBudWxsIHx8IFRFWFRVUkVfTUFOQUdFUiA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHUFUgbm90IGludGlhbGl6ZWQuJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5EQXJyYXkge1xuICAvKiogVGhlIHNoYXBlIG9mIHRoZSBuZGFycmF5LiAqL1xuICBzaGFwZTogbnVtYmVyW107XG4gIC8qKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG5kYXJyYXkuICovXG4gIHNpemU6IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgaW4gZWFjaCBkaW1lbnNpb24gd2hlbiBpbmRleGluZy4gU2VlXG4gICAqIGh0dHBzOi8vZG9jcy5zY2lweS5vcmcvZG9jL251bXB5L3JlZmVyZW5jZS9nZW5lcmF0ZWRcbiAgICogICAgIC9udW1weS5uZGFycmF5LnN0cmlkZXMuaHRtbFxuICAgKi9cbiAgcHJvdGVjdGVkIHN0cmlkZXM6IG51bWJlcltdO1xuXG4gIHByaXZhdGUgZGF0YTogTkRBcnJheURhdGE7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHNoYXBlOiBudW1iZXJbXSwgZGF0YTogTkRBcnJheURhdGEpIHtcbiAgICAvLyBTYW5pdHkgY2hlY2tzLlxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkYXRhLnZhbHVlcyAhPSBudWxsIHx8IGRhdGEudGV4dHVyZSAhPSBudWxsLFxuICAgICAgICAnRWl0aGVyIGB2YWx1ZXNgIG9yIGB0ZXh0dXJlYCBtdXN0IGJlIGRlZmluZWQnKTtcblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkYXRhLnRleHR1cmUgPT0gbnVsbCB8fCAoZGF0YS50ZXh0dXJlU2hhcGVSQyAhPSBudWxsKSxcbiAgICAgICAgJ2B0ZXh0dXJlU2hhcGVgIG11c3QgYmUgZGVmaW5lZCB3aGVuIGB0ZXh0dXJlYCBpcyBkZWZpbmVkJyk7XG5cbiAgICB0aGlzLnNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuXG4gICAgaWYgKGRhdGEudmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIHRoaXMuc2l6ZSA9PT0gZGF0YS52YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICdDb25zdHJ1Y3RpbmcgbmRhcnJheSBvZiBzaGFwZSAoJyArIHRoaXMuc2l6ZSArICcpIHNob3VsZCBtYXRjaCB0aGUnICtcbiAgICAgICAgICAgICAgJyBsZW5ndGggb2YgdmFsdWVzICgnICsgZGF0YS52YWx1ZXMubGVuZ3RoICsgJyknKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICBjb25zdCBkaW0gPSB0aGlzLnNoYXBlLmxlbmd0aDtcblxuICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICB0aGlzLnN0cmlkZXMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGFzdCBkaW1lbnNpb24gaGFzIGltcGxpY2l0IHN0cmlkZSBvZiAxLCB0aHVzIGhhdmluZyBELTEgKGluc3RlYWQgb2YgRClcbiAgICAgIC8vIHN0cmlkZXMuXG4gICAgICB0aGlzLnN0cmlkZXMgPSBuZXcgQXJyYXkoZGltIC0gMSk7XG4gICAgICB0aGlzLnN0cmlkZXNbZGltIC0gMl0gPSB0aGlzLnNoYXBlW2RpbSAtIDFdO1xuICAgICAgZm9yIChsZXQgaSA9IGRpbSAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHRoaXMuc3RyaWRlc1tpXSA9IHRoaXMuc3RyaWRlc1tpICsgMV0gKiB0aGlzLnNoYXBlW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhIG5kYXJyYXkgb2YgemVyb3Mgd2l0aCB0aGUgc3BlY2lmaWVkIHNoYXBlLiAqL1xuICBzdGF0aWMgemVyb3Moc2hhcGU6IG51bWJlcltdKTogTkRBcnJheSB7XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpKTtcbiAgICByZXR1cm4gTkRBcnJheS5tYWtlKHNoYXBlLCB7dmFsdWVzfSk7XG4gIH1cblxuICAvKiogQ3JlYXRlcyBhIG5kYXJyYXkgb2YgemVyb3Mgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgc3BlY2lmaWVkIG5kYXJyYXkuXG4gICAqL1xuICBzdGF0aWMgemVyb3NMaWtlPFQgZXh0ZW5kcyBOREFycmF5Pihhbm90aGVyOiBUKTogVCB7XG4gICAgcmV0dXJuIE5EQXJyYXkuemVyb3MoYW5vdGhlci5zaGFwZSkgYXMgVDtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgbmRhcnJheSB3aXRoIHRoZSBzYW1lIHZhbHVlcy9zaGFwZSBhcyB0aGUgc3BlY2lmaWVkIG5kYXJyYXkuICovXG4gIHN0YXRpYyBsaWtlPFQgZXh0ZW5kcyBOREFycmF5Pihhbm90aGVyOiBUKTogVCB7XG4gICAgY29uc3QgdmFsdWVzID0gYW5vdGhlci5nZXRWYWx1ZXMoKTtcbiAgICByZXR1cm4gTkRBcnJheS5tYWtlPFQ+KGFub3RoZXIuc2hhcGUsIHt2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKX0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgbmV3IG5kYXJyYXkgd2l0aCB0aGUgcHJvdmlkZWQgc2hhcGUgYW5kIHZhbHVlcy4gVmFsdWVzIHNob3VsZCBiZSBpblxuICAgKiBhIGZsYXQgYXJyYXkuXG4gICAqL1xuICBzdGF0aWMgbWFrZTxUIGV4dGVuZHMgTkRBcnJheT4oc2hhcGU6IG51bWJlcltdLCBkYXRhOiBOREFycmF5RGF0YSk6IFQge1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyKGRhdGEpIGFzIFQ7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTFEKGRhdGEpIGFzIGFueTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgZGF0YSkgYXMgYW55O1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkzRChzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGRhdGEpIGFzIGFueTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheTREKFxuICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgICAgICAgICBzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGF0YSkgYXMgYW55O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgICByZXR1cm4gbmV3IE5EQXJyYXkoc2hhcGUsIGRhdGEpIGFzIGFueTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVzaGFwZXMgdGhlIGN1cnJlbnQgbmRhcnJheSBpbnRvIHRoZSBwcm92aWRlZCBzaGFwZS4gKi9cbiAgcmVzaGFwZTxUIGV4dGVuZHMgTkRBcnJheT4obmV3U2hhcGU6IG51bWJlcltdKTogVCB7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwodGhpcy5zaGFwZSwgbmV3U2hhcGUpKSB7XG4gICAgICAvLyBOby1vcC5cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdGhpcy5zaXplID09PSB1dGlsLnNpemVGcm9tU2hhcGUobmV3U2hhcGUpLFxuICAgICAgICAnbmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4nKTtcblxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4obmV3U2hhcGUsIHRoaXMuZGF0YSk7XG4gIH1cblxuICBhc1NjYWxhcigpOiBTY2FsYXIge1xuICAgIHV0aWwuYXNzZXJ0KHRoaXMuc2l6ZSA9PT0gMSwgJ1RoZSBhcnJheSBtdXN0IGhhdmUgb25seSAxIGVsZW1lbnQuJyk7XG4gICAgcmV0dXJuIHRoaXMucmVzaGFwZTxTY2FsYXI+KFtdKTtcbiAgfVxuXG4gIGFzMUQoKTogQXJyYXkxRCB7XG4gICAgcmV0dXJuIHRoaXMucmVzaGFwZTxBcnJheTFEPihbdGhpcy5zaXplXSk7XG4gIH1cblxuICBhczJEKHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogQXJyYXkyRCB7XG4gICAgcmV0dXJuIHRoaXMucmVzaGFwZTxBcnJheTJEPihbcm93cywgY29sdW1uc10pO1xuICB9XG5cbiAgYXMzRChyb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlciwgZGVwdGg6IG51bWJlcik6IEFycmF5M0Qge1xuICAgIHJldHVybiB0aGlzLnJlc2hhcGU8QXJyYXkzRD4oW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gIH1cblxuICBhczREKHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLCBkZXB0aDogbnVtYmVyLCBkZXB0aDI6IG51bWJlcik6IEFycmF5NEQge1xuICAgIHJldHVybiB0aGlzLnJlc2hhcGU8QXJyYXk0RD4oW3Jvd3MsIGNvbHVtbnMsIGRlcHRoLCBkZXB0aDJdKTtcbiAgfVxuXG4gIGdldCByYW5rKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICB9XG5cbiAgZ2V0KC4uLmxvY3M6IG51bWJlcltdKSB7XG4gICAgbGV0IGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFZhbHVlcygpW2luZGV4XTtcbiAgfVxuXG4gIGFkZCh2YWx1ZTogbnVtYmVyLCAuLi5sb2NzOiBudW1iZXJbXSkge1xuICAgIHRoaXMuc2V0KHRoaXMuZ2V0KC4uLmxvY3MpICsgdmFsdWUsIC4uLmxvY3MpO1xuICB9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIC4uLmxvY3M6IG51bWJlcltdKSB7XG4gICAgbGV0IGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgfVxuICAgIHRoaXMuZ2V0VmFsdWVzKClbaW5kZXhdID0gdmFsdWU7XG4gIH1cblxuICBsb2NUb0luZGV4KGxvY3M6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBsZXQgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaW5kZXggKz0gdGhpcy5zdHJpZGVzW2ldICogbG9jc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgaW5kZXhUb0xvYyhpbmRleDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IGxvY3M6IG51bWJlcltdID0gbmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBsb2NzW2ldID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlc1tpXSk7XG4gICAgICBpbmRleCAtPSBsb2NzW2ldICogdGhpcy5zdHJpZGVzW2ldO1xuICAgIH1cbiAgICBsb2NzW2xvY3MubGVuZ3RoIC0gMV0gPSBpbmRleDtcbiAgICByZXR1cm4gbG9jcztcbiAgfVxuXG4gIGZpbGwodmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKCkuZmlsbCh2YWx1ZSk7XG4gIH1cblxuICBnZXREYXRhKCk6IE5EQXJyYXlEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgZ2V0VmFsdWVzKCk6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YS52YWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgICB0aGlzLmRhdGEudmFsdWVzID0gR1BHUFUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZShcbiAgICAgICAgICB0aGlzLmRhdGEudGV4dHVyZSEsIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyFbMF0sXG4gICAgICAgICAgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDIVsxXSk7XG4gICAgICB0aGlzLmRpc3Bvc2VUZXh0dXJlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGEudmFsdWVzO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGxvYWRUb0dQVShwcmVmZXJyZWRUZXhTaGFwZT86IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICB0aHJvd0lmR1BVTm90SW5pdGlhbGl6ZWQoKTtcbiAgICB0aGlzLmRhdGEudGV4dHVyZVNoYXBlUkMgPSB3ZWJnbF91dGlsLmdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoXG4gICAgICAgIEdQR1BVLmdsLCB0aGlzLnNoYXBlLCBwcmVmZXJyZWRUZXhTaGFwZSk7XG4gICAgdGhpcy5kYXRhLnRleHR1cmUgPVxuICAgICAgICBURVhUVVJFX01BTkFHRVIuYWNxdWlyZVRleHR1cmUodGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDKTtcblxuICAgIEdQR1BVLnVwbG9hZE1hdHJpeFRvVGV4dHVyZShcbiAgICAgICAgdGhpcy5kYXRhLnRleHR1cmUsIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQ1swXSxcbiAgICAgICAgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDWzFdLCB0aGlzLmRhdGEudmFsdWVzISk7XG5cbiAgICB0aGlzLmRhdGEudmFsdWVzID0gbnVsbCE7XG4gIH1cblxuICBnZXRUZXh0dXJlKHByZWZlcnJlZFNoYXBlUkM/OiBbbnVtYmVyLCBudW1iZXJdKTogV2ViR0xUZXh0dXJlIHtcbiAgICBpZiAodGhpcy5kYXRhLnRleHR1cmUgPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGxvYWRUb0dQVShwcmVmZXJyZWRTaGFwZVJDKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50ZXh0dXJlITtcbiAgfVxuXG4gIGdldFRleHR1cmVTaGFwZVJDKHByZWZlcnJlZFNoYXBlUkM/OiBbbnVtYmVyLCBudW1iZXJdKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwbG9hZFRvR1BVKHByZWZlcnJlZFNoYXBlUkMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDITtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5kYXRhLnZhbHVlcyA9IG51bGwhO1xuICAgIHRoaXMuc2hhcGUgPSBudWxsITtcbiAgICBpZiAodGhpcy5kYXRhLnRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kaXNwb3NlVGV4dHVyZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGlzcG9zZVRleHR1cmUoKSB7XG4gICAgdGhyb3dJZkdQVU5vdEluaXRpYWxpemVkKCk7XG4gICAgVEVYVFVSRV9NQU5BR0VSLnJlbGVhc2VUZXh0dXJlKFxuICAgICAgICB0aGlzLmRhdGEudGV4dHVyZSEsIHRoaXMuZGF0YS50ZXh0dXJlU2hhcGVSQyEpO1xuICAgIHRoaXMuZGF0YS50ZXh0dXJlID0gbnVsbCE7XG4gICAgdGhpcy5kYXRhLnRleHR1cmVTaGFwZVJDID0gbnVsbCE7XG4gIH1cblxuICBpbkdQVSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRleHR1cmUgIT0gbnVsbDtcbiAgfVxuXG4gIGVxdWFscyh0OiBOREFycmF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlzRXF1YWwodGhpcy5zaGFwZSwgdC5zaGFwZSkgJiZcbiAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh0aGlzLmdldFZhbHVlcygpLCB0LmdldFZhbHVlcygpKTtcbiAgfVxuXG4gIHN0YXRpYyByYW5kPFQgZXh0ZW5kcyBOREFycmF5PihzaGFwZTogbnVtYmVyW10sIHJhbmRGdW5jdGlvbjogKCkgPT4gbnVtYmVyKTpcbiAgICAgIFQge1xuICAgIGNvbnN0IHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJhbmRGdW5jdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBOREFycmF5Lm1ha2U8VD4oc2hhcGUsIHt2YWx1ZXN9KTtcbiAgfVxuXG4gIHN0YXRpYyByYW5kTm9ybWFsPFQgZXh0ZW5kcyBOREFycmF5PihzaGFwZTogbnVtYmVyW10sIG1lYW4gPSAwLCBzdGREZXYgPSAxKSB7XG4gICAgcmV0dXJuIE5EQXJyYXkucmFuZDxUPihzaGFwZSwgKCkgPT4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2KSk7XG4gIH1cblxuICBzdGF0aWMgcmFuZFRydW5jYXRlZE5vcm1hbDxUIGV4dGVuZHMgTkRBcnJheT4oXG4gICAgICBzaGFwZTogbnVtYmVyW10sIG1lYW4gPSAwLCBzdGREZXYgPSAxKSB7XG4gICAgcmV0dXJuIE5EQXJyYXkucmFuZDxUPihzaGFwZSwgKCkgPT4gdXRpbC5yYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKSk7XG4gIH1cblxuICBzdGF0aWMgcmFuZFVuaWZvcm08VCBleHRlbmRzIE5EQXJyYXk+KHNoYXBlOiBudW1iZXJbXSwgYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICByZXR1cm4gTkRBcnJheS5yYW5kPFQ+KHNoYXBlLCAoKSA9PiB1dGlsLnJhbmRVbmlmb3JtKGEsIGIpKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2NhbGFyIGV4dGVuZHMgTkRBcnJheSB7XG4gIGNvbnN0cnVjdG9yKGRhdGE6IE5EQXJyYXlEYXRhKSB7XG4gICAgaWYgKGRhdGEudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICBkYXRhLnRleHR1cmVTaGFwZVJDID0gWzEsIDFdO1xuICAgIH1cbiAgICBzdXBlcihbXSwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgbmV3KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IFNjYWxhcih7dmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KFt2YWx1ZV0pfSk7XG4gIH1cblxuICBzdGF0aWMgWkVSTyA9IFNjYWxhci5uZXcoMCk7XG4gIHN0YXRpYyBPTkUgPSBTY2FsYXIubmV3KDEpO1xuICBzdGF0aWMgVFdPID0gU2NhbGFyLm5ldygyKTtcbiAgc3RhdGljIE5FR19PTkUgPSBTY2FsYXIubmV3KC0xKTtcblxuICBnZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVswXTtcbiAgfVxuXG4gIHNldCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVswXSA9IHZhbHVlO1xuICB9XG5cbiAgYWRkKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpWzBdICs9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheTFEIGV4dGVuZHMgTkRBcnJheSB7XG4gIHNoYXBlOiBbbnVtYmVyXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBOREFycmF5RGF0YSkge1xuICAgIGNvbnN0IHNoYXBlID0gKGRhdGEudmFsdWVzICE9IG51bGwpID9cbiAgICAgICAgW2RhdGEudmFsdWVzLmxlbmd0aF0gOlxuICAgICAgICBbdXRpbC5zaXplRnJvbVNoYXBlKGRhdGEudGV4dHVyZVNoYXBlUkMhKV07XG4gICAgc3VwZXIoc2hhcGUsIGRhdGEpO1xuICB9XG5cbiAgc3RhdGljIG5ldyh2YWx1ZXM6IEZsb2F0MzJBcnJheXxudW1iZXJbXSkge1xuICAgIGlmICghKHZhbHVlcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcbiAgICAgIGNvbnN0IGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGluZmVycmVkU2hhcGUubGVuZ3RoID09PSAxLFxuICAgICAgICAgIGBFcnJvciBjb25zdHJ1Y3RpbmcgQXJyYXkxRC4gU2hhcGUgb2YgdmFsdWVzICR7aW5mZXJyZWRTaGFwZX0gaXMgYCArXG4gICAgICAgICAgICAgIGBub3QgMSBkaW1lbnNpb25hbC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheTFEKHt2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpfSk7XG4gIH1cblxuICBnZXQoaTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVtpXTtcbiAgfVxuXG4gIHNldCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpW2ldID0gdmFsdWU7XG4gIH1cblxuICBhZGQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVtpXSArPSB2YWx1ZTtcbiAgfVxuXG4gIGxvY1RvSW5kZXgobG9jOiBbbnVtYmVyXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGxvY1swXTtcbiAgfVxuXG4gIGluZGV4VG9Mb2MoaW5kZXg6IG51bWJlcik6IFtudW1iZXJdIHtcbiAgICByZXR1cm4gW2luZGV4XTtcbiAgfVxuXG4gIHN0YXRpYyB6ZXJvcyhzaGFwZTogW251bWJlcl0pOiBBcnJheTFEIHtcbiAgICByZXR1cm4gTkRBcnJheS56ZXJvcyhzaGFwZSkgYXMgQXJyYXkxRDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQXJyYXkyRCBleHRlbmRzIE5EQXJyYXkge1xuICBzaGFwZTogW251bWJlciwgbnVtYmVyXTtcblxuICBwcml2YXRlIHN0cmlkZTA6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzaGFwZTogW251bWJlciwgbnVtYmVyXSwgZGF0YTogTkRBcnJheURhdGEpIHtcbiAgICB1dGlsLmFzc2VydChzaGFwZS5sZW5ndGggPT09IDIsICdTaGFwZSBzaG91bGQgYmUgb2YgbGVuZ3RoIDInKTtcbiAgICBzdXBlcihzaGFwZSwgZGF0YSk7XG4gICAgdGhpcy5zdHJpZGUwID0gdGhpcy5zdHJpZGVzWzBdO1xuICB9XG5cbiAgc3RhdGljIG5ldyhcbiAgICAgIHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB2YWx1ZXM6IEZsb2F0MzJBcnJheXxudW1iZXJbXXxudW1iZXJbXVtdKSB7XG4gICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgY29uc3QgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKFxuICAgICAgICAgICAgc2hhcGUsIGluZmVycmVkU2hhcGUsXG4gICAgICAgICAgICBgRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXkyRC4gU2hhcGUgb2YgdmFsdWVzIGAgK1xuICAgICAgICAgICAgICAgIGAke2luZmVycmVkU2hhcGV9IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBgICtcbiAgICAgICAgICAgICAgICBgJHtzaGFwZX0uIGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5MkQoc2hhcGUsIHt2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpfSk7XG4gIH1cblxuICBnZXQoaTogbnVtYmVyLCBqOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal07XG4gIH1cblxuICBzZXQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyLCBqOiBudW1iZXIpIHtcbiAgICB0aGlzLmdldFZhbHVlcygpW3RoaXMuc3RyaWRlMCAqIGkgKyBqXSA9IHZhbHVlO1xuICB9XG5cbiAgYWRkKHZhbHVlOiBudW1iZXIsIGk6IG51bWJlciwgajogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgal0gKz0gdmFsdWU7XG4gIH1cblxuICBsb2NUb0luZGV4KGxvY3M6IFtudW1iZXIsIG51bWJlcl0pOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnN0cmlkZTAgKiBsb2NzWzBdICsgbG9jc1sxXTtcbiAgfVxuXG4gIGluZGV4VG9Mb2MoaW5kZXg6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIHJldHVybiBbTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCksIGluZGV4ICUgdGhpcy5zdHJpZGUwXTtcbiAgfVxuXG4gIHN0YXRpYyB6ZXJvcyhzaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEFycmF5MkQge1xuICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlKSBhcyBBcnJheTJEO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheTNEIGV4dGVuZHMgTkRBcnJheSB7XG4gIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHByaXZhdGUgc3RyaWRlMDogbnVtYmVyO1xuICBwcml2YXRlIHN0cmlkZTE6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBkYXRhOiBOREFycmF5RGF0YSkge1xuICAgIHV0aWwuYXNzZXJ0KHNoYXBlLmxlbmd0aCA9PT0gMywgJ1NoYXBlIHNob3VsZCBiZSBvZiBsZW5ndGggMycpO1xuICAgIHN1cGVyKHNoYXBlLCBkYXRhKTtcbiAgICB0aGlzLnN0cmlkZTAgPSB0aGlzLnN0cmlkZXNbMF07XG4gICAgdGhpcy5zdHJpZGUxID0gdGhpcy5zdHJpZGVzWzFdO1xuICB9XG5cbiAgc3RhdGljIG5ldyhcbiAgICAgIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICB2YWx1ZXM6IEZsb2F0MzJBcnJheXxudW1iZXJbXXxudW1iZXJbXVtdW10pIHtcbiAgICBpZiAoISh2YWx1ZXMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICBjb25zdCBpbmZlcnJlZFNoYXBlID0gdXRpbC5pbmZlclNoYXBlKHZhbHVlcyk7XG4gICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goXG4gICAgICAgICAgICBzaGFwZSwgaW5mZXJyZWRTaGFwZSxcbiAgICAgICAgICAgIGBFcnJvciB3aGVuIGNvbnN0cnVjdGluZyBBcnJheTNELiBTaGFwZSBvZiB2YWx1ZXMgYCArXG4gICAgICAgICAgICAgICAgYCR7aW5mZXJyZWRTaGFwZX0gZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHNoYXBlIGAgK1xuICAgICAgICAgICAgICAgIGAke3NoYXBlfS4gYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXkzRChzaGFwZSwge3ZhbHVlczogdG9UeXBlZEFycmF5KHZhbHVlcyl9KTtcbiAgfVxuXG4gIGdldChpOiBudW1iZXIsIGo6IG51bWJlciwgazogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXTtcbiAgfVxuXG4gIHNldCh2YWx1ZTogbnVtYmVyLCBpOiBudW1iZXIsIGo6IG51bWJlciwgazogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVt0aGlzLnN0cmlkZTAgKiBpICsgdGhpcy5zdHJpZGUxICogaiArIGtdID0gdmFsdWU7XG4gIH1cblxuICBhZGQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyLCBqOiBudW1iZXIsIGs6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKClbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyBrXSArPSB2YWx1ZTtcbiAgfVxuXG4gIGxvY1RvSW5kZXgobG9jczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIHRoaXMuc3RyaWRlMSAqIGxvY3NbMV0gKyBsb2NzWzJdO1xuICB9XG5cbiAgaW5kZXhUb0xvYyhpbmRleDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCk7XG4gICAgaW5kZXggLT0gaSAqIHRoaXMuc3RyaWRlMDtcbiAgICByZXR1cm4gW2ksIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTEpLCBpbmRleCAlIHRoaXMuc3RyaWRlMV07XG4gIH1cblxuICBzdGF0aWMgemVyb3Moc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IEFycmF5M0Qge1xuICAgIHJldHVybiBOREFycmF5Lnplcm9zKHNoYXBlKSBhcyBBcnJheTNEO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBcnJheTREIGV4dGVuZHMgTkRBcnJheSB7XG4gIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgcHJpdmF0ZSBzdHJpZGUwOiBudW1iZXI7XG4gIHByaXZhdGUgc3RyaWRlMTogbnVtYmVyO1xuICBwcml2YXRlIHN0cmlkZTI6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGRhdGE6IE5EQXJyYXlEYXRhKSB7XG4gICAgdXRpbC5hc3NlcnQoc2hhcGUubGVuZ3RoID09PSA0LCAnU2hhcGUgc2hvdWxkIGJlIG9mIGxlbmd0aCA0Jyk7XG4gICAgc3VwZXIoc2hhcGUsIGRhdGEpO1xuICAgIHRoaXMuc3RyaWRlMCA9IHRoaXMuc3RyaWRlc1swXTtcbiAgICB0aGlzLnN0cmlkZTEgPSB0aGlzLnN0cmlkZXNbMV07XG4gICAgdGhpcy5zdHJpZGUyID0gdGhpcy5zdHJpZGVzWzJdO1xuICB9XG5cbiAgc3RhdGljIG5ldyhcbiAgICAgIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgIHZhbHVlczogRmxvYXQzMkFycmF5fG51bWJlcltdfG51bWJlcltdW11bXVtdKSB7XG4gICAgaWYgKCEodmFsdWVzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkge1xuICAgICAgY29uc3QgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoID4gMSkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKFxuICAgICAgICAgICAgc2hhcGUsIGluZmVycmVkU2hhcGUsXG4gICAgICAgICAgICBgRXJyb3Igd2hlbiBjb25zdHJ1Y3RpbmcgQXJyYXk0RC4gU2hhcGUgb2YgdmFsdWVzIGAgK1xuICAgICAgICAgICAgICAgIGAke2luZmVycmVkU2hhcGV9IGRvZXMgbm90IG1hdGNoIHRoZSBwcm92aWRlZCBzaGFwZSBgICtcbiAgICAgICAgICAgICAgICBgJHtzaGFwZX0uIGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5NEQoc2hhcGUsIHt2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMpfSk7XG4gIH1cblxuICBnZXQoaTogbnVtYmVyLCBqOiBudW1iZXIsIGs6IG51bWJlciwgbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKClcbiAgICAgICAgW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdO1xuICB9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIGk6IG51bWJlciwgajogbnVtYmVyLCBrOiBudW1iZXIsIGw6IG51bWJlcikge1xuICAgIHRoaXMuZ2V0VmFsdWVzKClcbiAgICAgICAgW3RoaXMuc3RyaWRlMCAqIGkgKyB0aGlzLnN0cmlkZTEgKiBqICsgdGhpcy5zdHJpZGUyICogayArIGxdID0gdmFsdWU7XG4gIH1cblxuICBhZGQodmFsdWU6IG51bWJlciwgaTogbnVtYmVyLCBqOiBudW1iZXIsIGs6IG51bWJlciwgbDogbnVtYmVyKSB7XG4gICAgdGhpcy5nZXRWYWx1ZXMoKVxuICAgICAgICBbdGhpcy5zdHJpZGUwICogaSArIHRoaXMuc3RyaWRlMSAqIGogKyB0aGlzLnN0cmlkZTIgKiBrICsgbF0gKz0gdmFsdWU7XG4gIH1cblxuICBsb2NUb0luZGV4KGxvY3M6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpZGUwICogbG9jc1swXSArIHRoaXMuc3RyaWRlMSAqIGxvY3NbMV0gK1xuICAgICAgICB0aGlzLnN0cmlkZTIgKiBsb2NzWzJdICsgbG9jc1szXTtcbiAgfVxuXG4gIGluZGV4VG9Mb2MoaW5kZXg6IG51bWJlcik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMCk7XG4gICAgaW5kZXggLT0gaSAqIHRoaXMuc3RyaWRlMDtcbiAgICBjb25zdCBqID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuc3RyaWRlMSk7XG4gICAgaW5kZXggLT0gaiAqIHRoaXMuc3RyaWRlMTtcbiAgICByZXR1cm4gW2ksIGosIE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZTIpLCBpbmRleCAlIHRoaXMuc3RyaWRlMl07XG4gIH1cblxuICBzdGF0aWMgemVyb3Moc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJyYXk0RCB7XG4gICAgcmV0dXJuIE5EQXJyYXkuemVyb3Moc2hhcGUpIGFzIEFycmF5NEQ7XG4gIH1cbn1cblxudHlwZSBBcnJheURhdGEgPSBGbG9hdDMyQXJyYXl8bnVtYmVyW118bnVtYmVyW11bXXxudW1iZXJbXVtdW118bnVtYmVyW11bXVtdW107XG5cbmZ1bmN0aW9uIHRvVHlwZWRBcnJheShhOiBBcnJheURhdGEpOiBGbG9hdDMyQXJyYXkge1xuICByZXR1cm4gKGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpID8gYSA6IG5ldyBGbG9hdDMyQXJyYXkodXRpbC5mbGF0dGVuKGEpKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXRyaXhBO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hdHJpeEI7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWF0cml4QVNjYWxhcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXRyaXhCU2NhbGFyO1xuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcblxuICAgIGNvbnN0IHZlYzIgaGFsZlRleGVsID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBmbG9hdCBhID0gdGV4dHVyZTJEKG1hdHJpeEEsIHJlc3VsdFVWKS5yO1xuICAgICAgZmxvYXQgYiA9IHRleHR1cmUyRChtYXRyaXhCLCByZXN1bHRVVikucjtcbiAgICAgIGZsb2F0IGFTY2FsYXIgPSB0ZXh0dXJlMkQobWF0cml4QVNjYWxhciwgaGFsZlRleGVsKS5yO1xuICAgICAgZmxvYXQgYlNjYWxhciA9IHRleHR1cmUyRChtYXRyaXhCU2NhbGFyLCBoYWxmVGV4ZWwpLnI7XG4gICAgICB2ZWMyIGFiU2NhbGVkID0gdmVjMihhLCBiKSAqIHZlYzIoYVNjYWxhciwgYlNjYWxhcik7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGFiU2NhbGVkLnggKyBhYlNjYWxlZC55LCAwLCAwLCAwKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNjYWxlZE1hdHJpY2VzKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIGFkZFNjYWxlZE1hdHJpY2VzUHJvZ3JhbTogV2ViR0xQcm9ncmFtLFxuICAgIGE6IFdlYkdMVGV4dHVyZSwgYjogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcixcbiAgICBhU2NhbGFyOiBXZWJHTFRleHR1cmUsIGJTY2FsYXI6IFdlYkdMVGV4dHVyZSwgcmVzdWx0OiBXZWJHTFRleHR1cmUpIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShyZXN1bHQsIHJvd3MsIGNvbHVtbnMpO1xuICBncGdwdS5zZXRQcm9ncmFtKGFkZFNjYWxlZE1hdHJpY2VzUHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShhLCAnbWF0cml4QScsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYiwgJ21hdHJpeEInLCAxKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGFTY2FsYXIsICdtYXRyaXhBU2NhbGFyJywgMik7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShiU2NhbGFyLCAnbWF0cml4QlNjYWxhcicsIDMpO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkQWRkU2NhbGVkTWF0cmljZXNEb3dubG9hZChcbiAgICBhOiBGbG9hdDMyQXJyYXksIGI6IEZsb2F0MzJBcnJheSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsXG4gICAgYVNjYWxhcjogbnVtYmVyLCBiU2NhbGFyOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCBncGdwdSA9IG5ldyBHUEdQVUNvbnRleHQoKTtcbiAgY29uc3QgcHJvZ3JhbTogV2ViR0xQcm9ncmFtID0gZ3BncHUuY3JlYXRlUHJvZ3JhbShnZXRGcmFnbWVudFNoYWRlclNvdXJjZSgpKTtcblxuICBjb25zdCBhVGV4ID0gZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgYlRleCA9IGdwZ3B1LmNyZWF0ZU1hdHJpeFRleHR1cmUocm93cywgY29sdW1ucyk7XG4gIGNvbnN0IGFTY2FsYXJUZXggPSBncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKDEsIDEpO1xuICBjb25zdCBiU2NhbGFyVGV4ID0gZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZSgxLCAxKTtcbiAgY29uc3QgcmVzdWx0VGV4ID0gZ3BncHUuY3JlYXRlTWF0cml4VGV4dHVyZShyb3dzLCBjb2x1bW5zKTtcblxuICBncGdwdS51cGxvYWRNYXRyaXhUb1RleHR1cmUoYVRleCwgcm93cywgY29sdW1ucywgYSk7XG4gIGdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShiVGV4LCByb3dzLCBjb2x1bW5zLCBiKTtcbiAgZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKGFTY2FsYXJUZXgsIDEsIDEsIG5ldyBGbG9hdDMyQXJyYXkoW2FTY2FsYXJdKSk7XG4gIGdwZ3B1LnVwbG9hZE1hdHJpeFRvVGV4dHVyZShiU2NhbGFyVGV4LCAxLCAxLCBuZXcgRmxvYXQzMkFycmF5KFtiU2NhbGFyXSkpO1xuXG4gIGFkZFNjYWxlZE1hdHJpY2VzKFxuICAgICAgZ3BncHUsIHByb2dyYW0sIGFUZXgsIGJUZXgsIHJvd3MsIGNvbHVtbnMsIGFTY2FsYXJUZXgsIGJTY2FsYXJUZXgsXG4gICAgICByZXN1bHRUZXgpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IGdwZ3B1LmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUocmVzdWx0VGV4LCByb3dzLCBjb2x1bW5zKTtcblxuICBncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGFUZXgpO1xuICBncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGJUZXgpO1xuICBncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKHJlc3VsdFRleCk7XG4gIGdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoYVNjYWxhclRleCk7XG4gIGdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUoYlNjYWxhclRleCk7XG4gIGdwZ3B1LmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LmRpc3Bvc2UoKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBhcmdtaW5tYXhfZ3B1IGZyb20gJy4vYXJnbWlubWF4X2dwdSc7XG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIEFyZ01heEVxdWFsc1Byb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIHBhcmFtczogQXJyYXk8e30+ID0gW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYVNpemU6IG51bWJlciwgYlNpemU6IG51bWJlcikge1xuICAgIGNvbnN0IGFTbmlwcGV0ID0gYXJnbWlubWF4X2dwdS5nZXRBcmdNaW5NYXhTbmlwcGV0KCdtYXgnLCAnQScsIGFTaXplKTtcbiAgICBjb25zdCBiU25pcHBldCA9IGFyZ21pbm1heF9ncHUuZ2V0QXJnTWluTWF4U25pcHBldCgnbWF4JywgJ0InLCBiU2l6ZSk7XG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgICR7YVNuaXBwZXR9XG4gICAgICAke2JTbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IGFyZ01heEEgPSBnZXRBcmdNaW5NYXhBKCk7XG4gICAgICAgIGZsb2F0IGFyZ01heEIgPSBnZXRBcmdNaW5NYXhCKCk7XG5cbiAgICAgICAgZmxvYXQgdmFsdWU7XG4gICAgICAgIGlmIChpc05hTihhcmdNYXhBKSkge1xuICAgICAgICAgIHZhbHVlID0gYXJnTWF4QTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTihhcmdNYXhCKSkge1xuICAgICAgICAgIHZhbHVlID0gYXJnTWF4QjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGZsb2F0KGFyZ01heEEgPT0gYXJnTWF4Qik7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmdNaW5NYXhTbmlwcGV0KG9wOiAnbWluJ3wnbWF4JywgdGV4TmFtZTogc3RyaW5nLFxuICAgIHNpemU6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGNvbXBPcCA9IChvcCA9PT0gJ21pbicpID8gJzwnIDogJz4nO1xuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldEFyZ01pbk1heCR7dGV4TmFtZX0oKSB7XG4gICAgICBmbG9hdCBiZXN0SW5kZXggPSAwLjA7XG4gICAgICBmbG9hdCBiZXN0VmFsdWUgPSBnZXQke3RleE5hbWV9RmxhdCgwLjApO1xuXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c2l6ZX07IGkrKykge1xuICAgICAgICBmbG9hdCBpX2Zsb2F0ID0gZmxvYXQoaSk7XG4gICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldCR7dGV4TmFtZX1GbGF0KGlfZmxvYXQpO1xuICAgICAgICBpZiAoaXNOYU4oY2FuZGlkYXRlKSkge1xuICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmRpZGF0ZSAke2NvbXBPcH0gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICAgIGJlc3RJbmRleCA9IGlfZmxvYXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiZXN0SW5kZXg7XG4gICAgfVxuICBgO1xufVxuXG5leHBvcnQgY2xhc3MgQXJnTWluTWF4UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIHBhcmFtczogQXJyYXk8e30+O1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFTaXplOiBudW1iZXIsIG9wVHlwZTogJ21pbid8J21heCcpIHtcbiAgICB0aGlzLnBhcmFtcyA9IFtvcFR5cGVdO1xuICAgIGNvbnN0IGFTbmlwcGV0ID0gZ2V0QXJnTWluTWF4U25pcHBldChvcFR5cGUsICdBJywgYVNpemUpO1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke2FTbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHNldE91dHB1dChnZXRBcmdNaW5NYXhBKCkpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5pbXBvcnQgKiBhcyBwb29sX2dwdSBmcm9tICcuL3Bvb2xfZ3B1JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyQXZnUG9vbFNvdXJjZShcbiAgICB4U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgcGFkOiBudW1iZXIpIHtcbiAgcmV0dXJuIHBvb2xfZ3B1LmdldEZyYWdtZW50U2hhZGVyUG9vbENvbW1vblNvdXJjZShcbiAgICAgIHhTaGFwZVJDRCwgZlNpemUsIHN0cmlkZSwgcGFkLCAnYXZnJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXZnUG9vbChcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHg6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgcG9vbF9ncHUucG9vbENvbW1vbihncGdwdSwgcHJvZ3JhbSwgeCwgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbCk7XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgIHhUZXhTaGFwZVJDOiBbbnVtYmVyLCBudW1iZXJdLCBtZWFuVGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSxcbiAgICB2YXJpYW5jZVRleFNoYXBlUkM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgb2Zmc2V0VGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXXxudWxsLFxuICAgIHNjYWxlVGV4U2hhcGVSQz86IFtudW1iZXIsIG51bWJlcl18bnVsbCwgdmFyaWFuY2VFcHNpbG9uID0gMC4wMDEpOiBzdHJpbmcge1xuICBsZXQgb2Zmc2V0U2FtcGxlclNuaXBwZXQgPSAnJztcbiAgbGV0IG9mZnNldFNoYXBlSW5pdGlhbGl6YXRpb25TbmlwcGV0ID0gJyc7XG4gIGxldCBvZmZzZXRDb29yZHNTbmlwcGV0ID0gJyc7XG4gIGxldCBvZmZzZXRVVlNuaXBwZXQgPSAnJztcbiAgbGV0IG9mZnNldFZhbHVlU25pcHBldCA9ICcnO1xuICBsZXQgb2Zmc2V0T3BlcmF0aW9uU25pcHBldCA9ICcwLjAnO1xuXG4gIGxldCBzY2FsZVNhbXBsZXJTbmlwcGV0ID0gJyc7XG4gIGxldCBzY2FsZVNoYXBlSW5pdGlhbGl6YXRpb25TbmlwcGV0ID0gJyc7XG4gIGxldCBzY2FsZUNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgbGV0IHNjYWxlVVZTbmlwcGV0ID0gJyc7XG4gIGxldCBzY2FsZVZhbHVlU25pcHBldCA9ICcnO1xuICBsZXQgc2NhbGVPcGVyYXRpb25TbmlwcGV0ID0gJyc7XG5cbiAgaWYgKG9mZnNldFRleFNoYXBlUkMgIT0gbnVsbCkge1xuICAgIG9mZnNldFNhbXBsZXJTbmlwcGV0ID0gJ3VuaWZvcm0gc2FtcGxlcjJEIG9mZnNldDsnO1xuICAgIG9mZnNldFNoYXBlSW5pdGlhbGl6YXRpb25TbmlwcGV0ID0gYGNvbnN0IHZlYzIgb2Zmc2V0U2hhcGVDUiA9IHZlYzIoXG4gICAgICAgICAgICAke29mZnNldFRleFNoYXBlUkNbMV19LCAke29mZnNldFRleFNoYXBlUkNbMF19KTtgO1xuICAgIG9mZnNldENvb3Jkc1NuaXBwZXQgPSAndmVjMiBvZmZzZXRDb29yZHNDUiA9IG1vZCh5VGV4Q1IsIG9mZnNldFNoYXBlQ1IpOyc7XG4gICAgb2Zmc2V0VVZTbmlwcGV0ID1cbiAgICAgICAgJ3ZlYzIgb2Zmc2V0VVYgPSAob2Zmc2V0Q29vcmRzQ1IgKyBoYWxmQ1IpIC8gb2Zmc2V0U2hhcGVDUjsnO1xuICAgIG9mZnNldFZhbHVlU25pcHBldCA9ICdmbG9hdCBvZmZzZXRWYWx1ZSA9IHRleHR1cmUyRChvZmZzZXQsIG9mZnNldFVWKS5yOyc7XG4gICAgb2Zmc2V0T3BlcmF0aW9uU25pcHBldCA9ICdvZmZzZXRWYWx1ZSc7XG4gIH1cblxuICBpZiAoc2NhbGVUZXhTaGFwZVJDICE9IG51bGwpIHtcbiAgICBzY2FsZVNhbXBsZXJTbmlwcGV0ID0gJ3VuaWZvcm0gc2FtcGxlcjJEIHNjYWxlOyc7XG4gICAgc2NhbGVTaGFwZUluaXRpYWxpemF0aW9uU25pcHBldCA9IGBjb25zdCB2ZWMyIHNjYWxlU2hhcGVDUiA9IHZlYzIoXG4gICAgICAgICAgICAke3NjYWxlVGV4U2hhcGVSQ1sxXX0sICR7c2NhbGVUZXhTaGFwZVJDWzBdfSk7YDtcbiAgICBzY2FsZUNvb3Jkc1NuaXBwZXQgPSAndmVjMiBzY2FsZUNvb3Jkc0NSID0gbW9kKHlUZXhDUiwgc2NhbGVTaGFwZUNSKTsnO1xuICAgIHNjYWxlVVZTbmlwcGV0ID0gJ3ZlYzIgc2NhbGVVViA9IChzY2FsZUNvb3Jkc0NSICsgaGFsZkNSKSAvIHNjYWxlU2hhcGVDUjsnO1xuICAgIHNjYWxlVmFsdWVTbmlwcGV0ID0gJ2Zsb2F0IHNjYWxlVmFsdWUgPSB0ZXh0dXJlMkQoc2NhbGUsIHNjYWxlVVYpLnI7JztcbiAgICBzY2FsZU9wZXJhdGlvblNuaXBwZXQgPSAnaW52ICo9IHNjYWxlVmFsdWU7JztcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHg7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWVhbjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB2YXJpYW5jZTtcbiAgICAke29mZnNldFNhbXBsZXJTbmlwcGV0fVxuICAgICR7c2NhbGVTYW1wbGVyU25pcHBldH1cblxuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcblxuICAgIGNvbnN0IHZlYzIgeFNoYXBlQ1IgPSB2ZWMyKCR7eFRleFNoYXBlUkNbMV19LCAke3hUZXhTaGFwZVJDWzBdfSk7XG4gICAgY29uc3QgdmVjMiBtZWFuU2hhcGVDUiA9IHZlYzIoJHttZWFuVGV4U2hhcGVSQ1sxXX0sICR7bWVhblRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIHZhcmlhbmNlU2hhcGVDUiA9IHZlYzIoXG4gICAgICAgICR7dmFyaWFuY2VUZXhTaGFwZVJDWzFdfSwgJHt2YXJpYW5jZVRleFNoYXBlUkNbMF19KTtcblxuICAgICR7b2Zmc2V0U2hhcGVJbml0aWFsaXphdGlvblNuaXBwZXR9XG4gICAgJHtzY2FsZVNoYXBlSW5pdGlhbGl6YXRpb25TbmlwcGV0fVxuXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcbiAgICBjb25zdCBmbG9hdCB2YXJpYW5jZUVwc2lsb24gPSAke3ZhcmlhbmNlRXBzaWxvbn07XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHlUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIHZlYzIgbWVhbkNvb3Jkc0NSID0gbW9kKHlUZXhDUiwgbWVhblNoYXBlQ1IpO1xuICAgICAgdmVjMiB2YXJpYW5jZUNvb3Jkc0NSID0gbW9kKHlUZXhDUiwgdmFyaWFuY2VTaGFwZUNSKTtcbiAgICAgICR7b2Zmc2V0Q29vcmRzU25pcHBldH1cbiAgICAgICR7c2NhbGVDb29yZHNTbmlwcGV0fVxuXG4gICAgICB2ZWMyIG1lYW5VViA9IChtZWFuQ29vcmRzQ1IgKyBoYWxmQ1IpIC8gbWVhblNoYXBlQ1I7XG4gICAgICB2ZWMyIHZhcmlhbmNlVVYgPSAodmFyaWFuY2VDb29yZHNDUiArIGhhbGZDUikgLyB2YXJpYW5jZVNoYXBlQ1I7XG4gICAgICAke29mZnNldFVWU25pcHBldH1cbiAgICAgICR7c2NhbGVVVlNuaXBwZXR9XG5cbiAgICAgIGZsb2F0IHhWYWx1ZSA9IHRleHR1cmUyRCh4LCByZXN1bHRVVikucjtcbiAgICAgIGZsb2F0IG1lYW5WYWx1ZSA9IHRleHR1cmUyRChtZWFuLCBtZWFuVVYpLnI7XG4gICAgICBmbG9hdCB2YXJpYW5jZVZhbHVlID0gdGV4dHVyZTJEKHZhcmlhbmNlLCB2YXJpYW5jZVVWKS5yO1xuICAgICAgJHtvZmZzZXRWYWx1ZVNuaXBwZXR9XG4gICAgICAke3NjYWxlVmFsdWVTbmlwcGV0fVxuXG4gICAgICBmbG9hdCBpbnYgPSAxLjAgLyBzcXJ0KHZhcmlhbmNlVmFsdWUgKyB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgJHtzY2FsZU9wZXJhdGlvblNuaXBwZXR9XG4gICAgICBmbG9hdCB4VGltZXNJbnYgPSB4VmFsdWUgKiBpbnY7XG4gICAgICBmbG9hdCBtZWFuVGltZXNJbnZXaXRoT2Zmc2V0ID0gJHtvZmZzZXRPcGVyYXRpb25TbmlwcGV0fVxuICAgICAgICAgIC0gbWVhblZhbHVlICogaW52O1xuXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHhUaW1lc0ludiArIG1lYW5UaW1lc0ludldpdGhPZmZzZXQsIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hOb3JtYWxpemF0aW9uKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDogV2ViR0xUZXh0dXJlLFxuICAgIHhTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgbWVhbjogV2ViR0xUZXh0dXJlLFxuICAgIG1lYW5TaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSwgdmFyaWFuY2U6IFdlYkdMVGV4dHVyZSxcbiAgICB2YXJpYW5jZVNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBvZmZzZXQ6IFdlYkdMVGV4dHVyZXxudWxsLFxuICAgIG9mZnNldFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdfG51bGwsIHNjYWxlOiBXZWJHTFRleHR1cmV8bnVsbCxcbiAgICBzY2FsZVNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdfG51bGwsIHJlc3VsdDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUoXG4gICAgICByZXN1bHQsIHJlc3VsdFNoYXBlUm93Q29sWzBdLCByZXN1bHRTaGFwZVJvd0NvbFsxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4LCAneCcsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUobWVhbiwgJ21lYW4nLCAxKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHZhcmlhbmNlLCAndmFyaWFuY2UnLCAyKTtcbiAgbGV0IG5leHRJbmRleCA9IDM7XG4gIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShvZmZzZXQsICdvZmZzZXQnLCBuZXh0SW5kZXgpO1xuICAgIG5leHRJbmRleCsrO1xuICB9XG4gIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHNjYWxlLCAnc2NhbGUnLCBuZXh0SW5kZXgpO1xuICB9XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBCaW5hcnlPcFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgcGFyYW1zOiBBcnJheTx7fT47XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgc3VwcG9ydHNCcm9hZGNhc3Rpbmc6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3Iob3A6ICcrJyB8ICctJyB8ICcqJyB8ICcvJywgYVNoYXBlOiBudW1iZXJbXSwgYlNoYXBlOiBudW1iZXJbXSkge1xuICAgIHRoaXMuc3VwcG9ydHNCcm9hZGNhc3RpbmcgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gW29wXTtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RlZFNoYXBlKGFTaGFwZSwgYlNoYXBlKTtcbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcbiAgICAgICAgc2V0T3V0cHV0KGEgJHtvcH0gYik7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vY29udl91dGlsJztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJTb3VyY2UoXG4gICAgeDFTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB4MlNoYXBlUkNEOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgcmVzdWx0U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgYXhpczogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgeDFUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4MVNoYXBlUkNEKTtcbiAgY29uc3QgeDJUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4MlNoYXBlUkNEKTtcblxuICBjb25zdCB5QXhlcyA9IFsneVInLCAneUMnLCAneUQnXTtcbiAgY29uc3QgY29uY2F0QXhpcyA9IHlBeGVzW2F4aXNdO1xuXG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHgxO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHgyO1xuXG4gICAgY29uc3QgdmVjMiB4MVNoYXBlQ1IgPSB2ZWMyKCR7eDFUZXhTaGFwZVJDWzFdfSwgJHt4MVRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIHgyU2hhcGVDUiA9IHZlYzIoJHt4MlRleFNoYXBlUkNbMV19LjAsICR7eDJUZXhTaGFwZVJDWzBdfS4wKTtcblxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHlUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIE1hcCBmcm9tIDJEICh5VGV4UiwgeVRleEMpIHRvIDNEICh5UiwgeUMsIHlEKS5cbiAgICAgIGZsb2F0IHlSID0geVRleENSLnk7XG4gICAgICBmbG9hdCB5QyA9IGZsb29yKHlUZXhDUi54IC8gJHtyZXN1bHRTaGFwZVJDRFsyXX0uMCk7XG4gICAgICBmbG9hdCB5RCA9IG1vZCh5VGV4Q1IueCwgJHtyZXN1bHRTaGFwZVJDRFsyXX0uMCk7XG5cbiAgICAgIGZsb2F0IHZhbHVlID0gMC4wO1xuXG4gICAgICBpZiAoJHtjb25jYXRBeGlzfSA8ICR7eDFTaGFwZVJDRFtheGlzXX0uMCkge1xuICAgICAgICAvLyBNYXAgeVIsIHlDLCB5RCBiYWNrIHRvIHgxIGNvb3JkaW5hdGVzLlxuICAgICAgICB2ZWMyIHgxQ1IgPSB2ZWMyKHlDICogJHt4MVNoYXBlUkNEWzJdfS4wICsgeUQsIHlSKTtcbiAgICAgICAgdmVjMiB4MVVWID0gKHgxQ1IgKyBoYWxmQ1IpIC8geDFTaGFwZUNSO1xuICAgICAgICB2YWx1ZSA9IHRleHR1cmUyRCh4MSwgeDFVVikucjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7Y29uY2F0QXhpc30gPSAke2NvbmNhdEF4aXN9IC0gJHt4MVNoYXBlUkNEW2F4aXNdfS4wO1xuXG4gICAgICAgIC8vIE1hcCB5UiwgeUMsIHlEIGJhY2sgdG8geDIgY29vcmRpbmF0ZXMuXG4gICAgICAgIHZlYzIgeDJDUiA9IHZlYzIoeUMgKiAke3gyU2hhcGVSQ0RbMl19LjAgKyB5RCwgeVIpO1xuICAgICAgICB2ZWMyIHgyVVYgPSAoeDJDUiArIGhhbGZDUikgLyB4MlNoYXBlQ1I7XG4gICAgICAgIHZhbHVlID0gdGV4dHVyZTJEKHgyLCB4MlVWKS5yO1xuICAgICAgfVxuXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbHVlLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdDNEKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDE6IFdlYkdMVGV4dHVyZSxcbiAgICB4MjogV2ViR0xUZXh0dXJlLCByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKHJlc3VsdCwgcmVzdWx0U2hhcGVSQ1swXSwgcmVzdWx0U2hhcGVSQ1sxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4MSwgJ3gxJywgMCk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4MiwgJ3gyJywgMSk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuXG5pbXBvcnQgKiBhcyBjb252X2dwdSBmcm9tICcuL2NvbnZfZ3B1JztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJEZXJXZWlnaHRzU291cmNlKFxuICAgIHhTaGFwZVJvd0NvbERlcHRoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGZTaXplOiBudW1iZXIsXG4gICAgb3V0cHV0RGVwdGg6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsIHplcm9QYWQ6IG51bWJlcikge1xuICBjb25zdCBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCA9XG4gICAgICBjb252X2dwdS5nZXRGcmFnbWVudFNoYWRlckdldE1hdHJpeFZhbHVlT3JaZXJvUGFkU291cmNlKCk7XG4gIGNvbnN0IGlucHV0RGVwdGggPSB4U2hhcGVSb3dDb2xEZXB0aFsyXTtcblxuICBjb25zdCB4VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeFNoYXBlUm93Q29sRGVwdGgpO1xuXG4gIGNvbnN0IHlTaGFwZSA9IGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRChcbiAgICAgIHhTaGFwZVJvd0NvbERlcHRoLCBmU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCk7XG4gIGNvbnN0IHlOdW1Sb3dzID0geVNoYXBlWzBdO1xuICBjb25zdCB5TnVtQ29scyA9IHlTaGFwZVsxXTtcbiAgY29uc3QgeVRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKHlTaGFwZSk7XG5cbiAgY29uc3QgZlNpemVUaW1lc0lucHV0RGVwdGggPSBmU2l6ZSAqIGlucHV0RGVwdGg7XG5cbiAgY29uc3QgcHJvbG9ndWUgPSBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHg7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgZHk7XG4gIGA7XG5cbiAgcmV0dXJuIHByb2xvZ3VlICsgJ1xcbicgKyBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCArICdcXG4nICtcbiAgICAgIGBcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuICAgIGNvbnN0IHZlYzIgeFNoYXBlQ1IgPSB2ZWMyKCR7eFRleFNoYXBlUkNbMV19LCAke3hUZXhTaGFwZVJDWzBdfSk7XG4gICAgY29uc3QgdmVjMiBkeVNoYXBlQ1IgPSB2ZWMyKCR7eVRleFNoYXBlUkNbMV19LCAke3lUZXhTaGFwZVJDWzBdfSk7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHdUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIE1hcCBmcm9tIDJEICh3VGV4Uiwgd1RleEMpIHRvIDREICh3Uiwgd0MsIGQxLCBkMikuXG4gICAgICBmbG9hdCB3UiA9IGZsb29yKHdUZXhDUi55IC8gJHtmU2l6ZVRpbWVzSW5wdXREZXB0aH0uMCk7XG4gICAgICBmbG9hdCB3VGV4UkxlZnRvdmVyID0gd1RleENSLnkgLSB3UiAqICR7ZlNpemVUaW1lc0lucHV0RGVwdGh9LjA7XG4gICAgICBmbG9hdCB3QyA9IGZsb29yKHdUZXhSTGVmdG92ZXIgLyAke2lucHV0RGVwdGh9LjApO1xuICAgICAgZmxvYXQgZDEgPSBtb2Qod1RleFJMZWZ0b3ZlciwgJHtpbnB1dERlcHRofS4wKTtcbiAgICAgIGZsb2F0IGQyID0gd1RleENSLng7XG5cbiAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXG4gICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHt5TnVtUm93c307IHlSKyspIHtcbiAgICAgICAgZmxvYXQgeVRleFIgPSBmbG9hdCh5Uik7XG4gICAgICAgIGZsb2F0IHhSID0gd1IgKyB5VGV4UiAqICR7c3RyaWRlfS4wIC0gJHt6ZXJvUGFkfS4wO1xuICAgICAgICBmbG9hdCB4VGV4UiA9IHhSO1xuXG4gICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke3lOdW1Db2xzfTsgeUMrKykge1xuICAgICAgICAgIGZsb2F0IHlDX2Zsb2F0ID0gZmxvYXQoeUMpO1xuICAgICAgICAgIGZsb2F0IHhDID0gd0MgKyB5Q19mbG9hdCAqICR7c3RyaWRlfS4wIC0gJHt6ZXJvUGFkfS4wO1xuXG4gICAgICAgICAgLy8gTWFwIGZyb20gM0QgKHhSLCB4QywgZDEpIHRvIDJEICh4VGV4UiwgeFRleEMpLlxuICAgICAgICAgIC8vIE1hcCBmcm9tIDNEICh5UiwgeUMsIGQyKSB0byAyRCAoeVRleFIsIHlUZXhDKS5cbiAgICAgICAgICB2ZWMyIHh5VGV4QyA9XG4gICAgICAgICAgICAgIHZlYzIoeEMsIHlDX2Zsb2F0KSAqIHZlYzIoJHtpbnB1dERlcHRofS4wLCAke291dHB1dERlcHRofS4wKSArXG4gICAgICAgICAgICAgIHZlYzIoZDEsIGQyKTtcbiAgICAgICAgICBmbG9hdCB4VGV4QyA9IHh5VGV4Qy54O1xuICAgICAgICAgIGZsb2F0IHlUZXhDID0geHlUZXhDLnk7XG5cbiAgICAgICAgICAvLyBSZWFkIGR5KHlSLCB5QywgZDIpLlxuICAgICAgICAgIHZlYzIgZHlVViA9ICh2ZWMyKHlUZXhDLCB5VGV4UikgKyBoYWxmQ1IpIC8gZHlTaGFwZUNSO1xuICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSB0ZXh0dXJlMkQoZHksIGR5VVYpLnI7XG5cbiAgICAgICAgICAvLyBSZWFkIHgoeFIsIHhDLCBkMSkgKHBvdGVudGlhbGx5IHplcm8tcGFkZGVkKS5cbiAgICAgICAgICBmbG9hdCB4VmFsdWUgPVxuICAgICAgICAgICAgZ2V0TWF0cml4VmFsdWVPclplcm9QYWQoeCwgeFNoYXBlQ1IsIHZlYzIoeFRleEMsIHhUZXhSKSk7XG5cbiAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkb3RQcm9kLCAwLCAwLCAwKTtcbiAgICB9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyQ29udlRyYW5zcG9zZVNvdXJjZShcbiAgICB4U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZlNpemU6IG51bWJlciwgb3JpZ0lucHV0RGVwdGg6IG51bWJlcixcbiAgICBvcmlnU3RyaWRlOiBudW1iZXIsIG9yaWdQYWQ6IG51bWJlciwgaGFzQmlhczogYm9vbGVhbikge1xuICBjb25zdCBwYWQgPSBmU2l6ZSAtIDEgLSBvcmlnUGFkO1xuICBjb25zdCBbeFJvd3MsIHhDb2xzLCBvcmlnT3V0cHV0RGVwdGhdID0geFNoYXBlUkNEO1xuXG4gIGNvbnN0IHhUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRCh4U2hhcGVSQ0QpO1xuICBjb25zdCB3VGV4U2hhcGVSQyA9XG4gICAgICBjb252X3V0aWwuY29tcHV0ZVdlaWdodHNUZXhTaGFwZShvcmlnSW5wdXREZXB0aCwgb3JpZ091dHB1dERlcHRoLCBmU2l6ZSk7XG5cbiAgY29uc3QgZ2V0Qmlhc1ZhbHVlID0gaGFzQmlhcyA/XG4gICAgICBjb252X2dwdS5nZXRGcmFnbWVudFNoYWRlckdldEJpYXNWYWx1ZVNvdXJjZShvcmlnSW5wdXREZXB0aCkgOlxuICAgICAgJyc7XG4gIGNvbnN0IGJpYXNQcm9sb2d1ZSA9IGhhc0JpYXMgPyAndW5pZm9ybSBzYW1wbGVyMkQgYmlhc2VzOycgOiAnJztcbiAgY29uc3QgYmlhc09wZXJhdGlvbiA9IGhhc0JpYXMgPyAnZG90UHJvZCArPSBnZXRCaWFzVmFsdWUoYmlhc2VzLCBkMik7JyA6ICcnO1xuXG4gIGNvbnN0IHByb2xvZ3VlID0gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB4O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodHM7XG4gICAgJHtiaWFzUHJvbG9ndWV9XG4gICAgYDtcblxuICByZXR1cm4gcHJvbG9ndWUgKyAnXFxuJyArIGdldEJpYXNWYWx1ZSArICdcXG4nICtcbiAgICAgIGBcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuICAgIGNvbnN0IHZlYzIgeFNoYXBlQ1IgPSB2ZWMyKCR7eFRleFNoYXBlUkNbMV19LCAke3hUZXhTaGFwZVJDWzBdfSk7XG4gICAgY29uc3QgdmVjMiB3U2hhcGVDUiA9IHZlYzIoJHt3VGV4U2hhcGVSQ1sxXX0sICR7d1RleFNoYXBlUkNbMF19KTtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIHZlYzIgeVRleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgLy8gTWFwIGZyb20gMkQgKHlUZXhSLCB5VGV4QykgdG8gM0QgKHlSLCB5QywgZDIpLlxuICAgICAgZmxvYXQgeVIgPSB5VGV4Q1IueTtcbiAgICAgIGZsb2F0IHlDID0gZmxvb3IoeVRleENSLnggLyAke29yaWdJbnB1dERlcHRofS4wKTtcbiAgICAgIGZsb2F0IGQyID0gbW9kKHlUZXhDUi54LCAke29yaWdJbnB1dERlcHRofS4wKTtcblxuICAgICAgdmVjMiB4UkNDb3JuZXIgPSB2ZWMyKHlSLCB5QykgLSB2ZWMyKCR7cGFkfS4wLCAke3BhZH0uMCk7XG4gICAgICBmbG9hdCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgZmxvYXQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQyLCBkMSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmU2l6ZX07IHdSKyspIHtcbiAgICAgICAgZmxvYXQgd1JfZmxvYXQgPSBmbG9hdCh3Uik7XG4gICAgICAgIGZsb2F0IHhSID0gKHhSQ29ybmVyICsgd1JfZmxvYXQpIC8gJHtvcmlnU3RyaWRlfS4wO1xuICAgICAgICAvLyBUT0RPKHNtaWxrb3YpOiBTcGxpY2UgdGhpcyB3aXRoIGFub3RoZXIgdmVyc2lvbiB3aGVyZSB5b3UgY2FsbFxuICAgICAgICAvLyBnZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZCgpLiBIZXJlIGFuZCBiZWxvdy5cbiAgICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49ICR7eFJvd3N9LjAgfHwgZnJhY3QoeFIpID4gMC4wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCB3UlBlcm0gPSAke2ZTaXplfS4wIC0gMS4wIC0gd1JfZmxvYXQ7XG4gICAgICAgIGZsb2F0IHhUZXhSID0geFI7XG5cbiAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZlNpemV9OyB3QysrKSB7XG4gICAgICAgICAgZmxvYXQgd0NfZmxvYXQgPSBmbG9hdCh3Qyk7XG4gICAgICAgICAgZmxvYXQgeEMgPSAoeENDb3JuZXIgKyB3Q19mbG9hdCkgLyAke29yaWdTdHJpZGV9LjA7XG4gICAgICAgICAgaWYgKHhDIDwgMC4wIHx8IHhDID49ICR7eENvbHN9LjAgfHwgZnJhY3QoeEMpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbG9hdCB3Q1Blcm0gPSAke2ZTaXplfS4wIC0gMS4wIC0gd0NfZmxvYXQ7XG4gICAgICAgICAgZmxvYXQgd1RleFIgPSB3UlBlcm0gKiAke2ZTaXplfS4wICogJHtvcmlnSW5wdXREZXB0aH0uMCArXG4gICAgICAgICAgICAgICAgICAgICAgICB3Q1Blcm0gKiAke29yaWdJbnB1dERlcHRofS4wICsgZDI7XG5cbiAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtvcmlnT3V0cHV0RGVwdGh9OyBkMSsrKSB7XG4gICAgICAgICAgICBmbG9hdCBkMV9mbG9hdCA9IGZsb2F0KGQxKTtcbiAgICAgICAgICAgIGZsb2F0IHhUZXhDID0geEMgKiAke29yaWdPdXRwdXREZXB0aH0uMCArIGQxX2Zsb2F0O1xuICAgICAgICAgICAgZmxvYXQgd1RleEMgPSBkMV9mbG9hdDtcblxuICAgICAgICAgICAgLy8gUmVhZCB4KHhSLCB4QywgZDEpLlxuICAgICAgICAgICAgdmVjMiB4VVYgPSAodmVjMih4VGV4QywgeFRleFIpICsgaGFsZkNSKSAvIHhTaGFwZUNSO1xuICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gdGV4dHVyZTJEKHgsIHhVVikucjtcblxuICAgICAgICAgICAgLy8gUmVhZCB3KHdSUGVybSwgd0NQZXJtLCBkMiwgZDEpLlxuICAgICAgICAgICAgdmVjMiB3VVYgPSAodmVjMih3VGV4Qywgd1RleFIpICsgaGFsZkNSKSAvIHdTaGFwZUNSO1xuICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gdGV4dHVyZTJEKHdlaWdodHMsIHdVVikucjtcblxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAke2JpYXNPcGVyYXRpb259XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRvdFByb2QsIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJEZXJCaWFzU291cmNlKFxuICAgIGR5U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSkge1xuICBjb25zdCBkeVRleFNoYXBlUkMgPSBjb252X3V0aWwuY29tcHV0ZVRleFNoYXBlRnJvbTNEKGR5U2hhcGVSQ0QpO1xuICBjb25zdCBbeU51bVJvd3MsIHlOdW1Db2xzLCBvdXRwdXREZXB0aF0gPSBkeVNoYXBlUkNEO1xuXG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGR5O1xuXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcbiAgICBjb25zdCB2ZWMyIGR5U2hhcGVDUiA9IHZlYzIoJHtkeVRleFNoYXBlUkNbMV19LCAke2R5VGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiBiaWFzVGV4Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpO1xuXG4gICAgICAvLyBUaGUgYmlhcyB0ZXh0dXJlIFJDIHNoYXBlIGlzIFsxLCBkMl0uXG4gICAgICBmbG9hdCBkMiA9IGJpYXNUZXhDUi54O1xuXG4gICAgICBmbG9hdCBkZXJCaWFzID0gMC4wO1xuICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8ICR7eU51bVJvd3N9OyB5UisrKSB7XG4gICAgICAgIGZsb2F0IHlUZXhSID0gZmxvYXQoeVIpO1xuXG4gICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke3lOdW1Db2xzfTsgeUMrKykge1xuICAgICAgICAgIGZsb2F0IHlDX2Zsb2F0ID0gZmxvYXQoeUMpO1xuICAgICAgICAgIC8vIE1hcCBmcm9tIDNEICh5UiwgeUMsIGQyKSB0byAyRCAoeVRleFIsIHlUZXhDKS5cbiAgICAgICAgICBmbG9hdCB5VGV4QyA9IHlDX2Zsb2F0ICogJHtvdXRwdXREZXB0aH0uMCArIGQyO1xuXG4gICAgICAgICAgLy8gUmVhZCBkeSh5UiwgeUMsIGQyKS5cbiAgICAgICAgICB2ZWMyIGR5VVYgPSAodmVjMih5VGV4QywgeVRleFIpICsgaGFsZkNSKSAvIGR5U2hhcGVDUjtcbiAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gdGV4dHVyZTJEKGR5LCBkeVVWKS5yO1xuXG4gICAgICAgICAgZGVyQmlhcyArPSBkeVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRlckJpYXMsIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVyQmlhcyhcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIGR5VGV4OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0OiBXZWJHTFRleHR1cmUsIHJlc3VsdFRleFNoYXBlUkM6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShcbiAgICAgIHJlc3VsdCwgcmVzdWx0VGV4U2hhcGVSQ1swXSwgcmVzdWx0VGV4U2hhcGVSQ1sxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShkeVRleCwgJ2R5JywgMCk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJXZWlnaHRzKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeFRleDogV2ViR0xUZXh0dXJlLFxuICAgIGR5VGV4OiBXZWJHTFRleHR1cmUsIHJlc3VsdDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdFRleFNoYXBlUkM6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShcbiAgICAgIHJlc3VsdCwgcmVzdWx0VGV4U2hhcGVSQ1swXSwgcmVzdWx0VGV4U2hhcGVSQ1sxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4VGV4LCAneCcsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoZHlUZXgsICdkeScsIDEpO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udlRyYW5zcG9zZShcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHhUZXg6IFdlYkdMVGV4dHVyZSxcbiAgICB3ZWlnaHRzVGV4OiBXZWJHTFRleHR1cmUsIGJpYXNlc1RleDogV2ViR0xUZXh0dXJlfG51bGwsXG4gICAgcmVzdWx0VGV4OiBXZWJHTFRleHR1cmUsIHJlc3VsdFRleFNoYXBlUkM6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShcbiAgICAgIHJlc3VsdFRleCwgcmVzdWx0VGV4U2hhcGVSQ1swXSwgcmVzdWx0VGV4U2hhcGVSQ1sxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh4VGV4LCAneCcsIDApO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUod2VpZ2h0c1RleCwgJ3dlaWdodHMnLCAxKTtcbiAgaWYgKGJpYXNlc1RleCAhPSBudWxsKSB7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGJpYXNlc1RleCwgJ2JpYXNlcycsIDIpO1xuICB9XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlclByb2xvZ3VlU291cmNlKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHg7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgd2VpZ2h0cztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBiaWFzZXM7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO2A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlckdldE1hdHJpeFZhbHVlT3JaZXJvUGFkU291cmNlKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgZmxvYXQgZ2V0TWF0cml4VmFsdWVPclplcm9QYWQoaW4gc2FtcGxlcjJEIG1hdHJpeCwgdmVjMiBtYXRyaXhTaGFwZUNSLFxuICAgICAgICB2ZWMyIHJlcXVlc3RlZENSKSB7XG4gICAgICB2ZWMyIHV2ID0gKHJlcXVlc3RlZENSICsgdmVjMigwLjUsIDAuNSkpIC8gbWF0cml4U2hhcGVDUjtcbiAgICAgIGZsb2F0IHZhbHVlID0gdGV4dHVyZTJEKG1hdHJpeCwgdXYpLnI7XG4gICAgICBib29sIGxlc3NUaGFuWmVybyA9IGFueShsZXNzVGhhbih1diwgdmVjMigwLCAwKSkpO1xuICAgICAgYm9vbCBncmVhdGVyVGhhbk9uZSA9IGFueShncmVhdGVyVGhhbih1diwgdmVjMigxLCAxKSkpO1xuICAgICAgYm9vbCBvdXRzaWRlID0gbGVzc1RoYW5aZXJvIHx8IGdyZWF0ZXJUaGFuT25lO1xuICAgICAgcmV0dXJuIG1peCh2YWx1ZSwgMC4wLCBmbG9hdChvdXRzaWRlKSk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlckNvbnZvbHZlU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBvdXRwdXREZXB0aDogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLCBwYWQ6IG51bWJlciwgaGFzQmlhczogYm9vbGVhbikge1xuICBjb25zdCBpbnB1dERlcHRoID0geFNoYXBlUkNEWzJdO1xuICBjb25zdCB4VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeFNoYXBlUkNEKTtcbiAgY29uc3Qgd1RleFNoYXBlUkMgPVxuICAgICAgY29udl91dGlsLmNvbXB1dGVXZWlnaHRzVGV4U2hhcGUoaW5wdXREZXB0aCwgb3V0cHV0RGVwdGgsIGZTaXplKTtcblxuICByZXR1cm4gYFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG4gICAgY29uc3QgdmVjMiB4U2hhcGVDUiA9IHZlYzIoJHt4VGV4U2hhcGVSQ1sxXX0sICR7eFRleFNoYXBlUkNbMF19KTtcbiAgICBjb25zdCB2ZWMyIHdTaGFwZUNSID0gdmVjMigke3dUZXhTaGFwZVJDWzFdfSwgJHt3VGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiB5VGV4Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpO1xuXG4gICAgICAvLyBNYXAgZnJvbSAyRCAoeVRleFIsIHlUZXhDKSB0byAzRCAoeVIsIHlDLCBkMikuXG4gICAgICBmbG9hdCB5UiA9IHlUZXhDUi55O1xuICAgICAgZmxvYXQgeUMgPSBmbG9vcih5VGV4Q1IueCAvICR7b3V0cHV0RGVwdGh9LjApO1xuICAgICAgZmxvYXQgZDIgPSBtb2QoeVRleENSLngsICR7b3V0cHV0RGVwdGh9LjApO1xuICAgICAgZmxvYXQgd1RleEMgPSBkMjtcblxuICAgICAgdmVjMiB4UkNDb3JuZXIgPSB2ZWMyKHlSLCB5QykgKiB2ZWMyKCR7c3RyaWRlfSwgJHtzdHJpZGV9KSAtXG4gICAgICAgICAgdmVjMigke3BhZH0uMCwgJHtwYWR9LjApO1xuICAgICAgZmxvYXQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgIGZsb2F0IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxuICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZlNpemV9OyB3UisrKSB7XG4gICAgICAgIGZsb2F0IHdSX2Zsb2F0ID0gZmxvYXQod1IpO1xuICAgICAgICBmbG9hdCB4UiA9IHhSQ29ybmVyICsgd1JfZmxvYXQ7XG4gICAgICAgIGZsb2F0IHhUZXhSID0geFI7XG5cbiAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZlNpemV9OyB3QysrKSB7XG4gICAgICAgICAgZmxvYXQgd0NfZmxvYXQgPSBmbG9hdCh3Qyk7XG4gICAgICAgICAgZmxvYXQgeEMgPSB4Q0Nvcm5lciArIHdDX2Zsb2F0O1xuXG4gICAgICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7aW5wdXREZXB0aH07IGQxKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGQxX2Zsb2F0ID0gZmxvYXQoZDEpO1xuICAgICAgICAgICAgZmxvYXQgeFRleEMgPSB4QyAqICR7aW5wdXREZXB0aH0uMCArIGQxX2Zsb2F0O1xuICAgICAgICAgICAgZmxvYXQgd1RleFIgPSB3Ul9mbG9hdCAqICR7ZlNpemUgKiBpbnB1dERlcHRofS4wICtcbiAgICAgICAgICAgICAgICB3Q19mbG9hdCAqICR7aW5wdXREZXB0aH0uMCArIGQxX2Zsb2F0O1xuXG4gICAgICAgICAgICBmbG9hdCB4VmFsdWUgPVxuICAgICAgICAgICAgICAgIGdldE1hdHJpeFZhbHVlT3JaZXJvUGFkKHgsIHhTaGFwZUNSLCB2ZWMyKHhUZXhDLCB4VGV4UikpO1xuXG4gICAgICAgICAgICAvLyBSZWFkIHcod1IsIHdDLCBkMSwgZDIpLlxuICAgICAgICAgICAgdmVjMiB3VVYgPSAodmVjMih3VGV4Qywgd1RleFIpICsgaGFsZkNSKSAvIHdTaGFwZUNSO1xuICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gdGV4dHVyZTJEKHdlaWdodHMsIHdVVikucjtcblxuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoJHtoYXNCaWFzfSkge1xuICAgICAgICBkb3RQcm9kICs9IGdldEJpYXNWYWx1ZShiaWFzZXMsIGQyKTtcbiAgICAgIH1cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoZG90UHJvZCwgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlckdldEJpYXNWYWx1ZVNvdXJjZShvdXRwdXREZXB0aDogbnVtYmVyKTpcbiAgICBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldEJpYXNWYWx1ZShpbiBzYW1wbGVyMkQgYmlhcywgZmxvYXQgYmlhc0MpIHtcbiAgICAgIGNvbnN0IHZlYzIgYmlhc1NoYXBlQ1IgPSB2ZWMyKCR7b3V0cHV0RGVwdGh9LCAxKTtcbiAgICAgIHZlYzIgYmlhc0NSID0gdmVjMihtb2QoYmlhc0MsICR7b3V0cHV0RGVwdGh9LjApLCAwKTtcbiAgICAgIHZlYzIgYmlhc1VWID0gKGJpYXNDUiArIHZlYzIoMC41LCAwLjUpKSAvIGJpYXNTaGFwZUNSO1xuICAgICAgcmV0dXJuIHRleHR1cmUyRChiaWFzLCBiaWFzVVYpLnI7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlclNvdXJjZShcbiAgICBhU2hhcGVSb3dDb2xEZXB0aDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCByZXN1bHREZXB0aDogbnVtYmVyLFxuICAgIGZpZWxkU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgemVyb1BhZDogbnVtYmVyLFxuICAgIGhhc0JpYXM6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCBwcm9sb2d1ZSA9IGdldEZyYWdtZW50U2hhZGVyUHJvbG9ndWVTb3VyY2UoKTtcbiAgY29uc3QgZ2V0TWF0cml4VmFsdWVPclplcm9QYWQgPVxuICAgICAgZ2V0RnJhZ21lbnRTaGFkZXJHZXRNYXRyaXhWYWx1ZU9yWmVyb1BhZFNvdXJjZSgpO1xuICBjb25zdCBjb252b2x2ZSA9IGdldEZyYWdtZW50U2hhZGVyQ29udm9sdmVTb3VyY2UoXG4gICAgICBhU2hhcGVSb3dDb2xEZXB0aCwgZmllbGRTaXplLCByZXN1bHREZXB0aCwgc3RyaWRlLCB6ZXJvUGFkLCBoYXNCaWFzKTtcbiAgY29uc3QgZ2V0Qmlhc1ZhbHVlID0gZ2V0RnJhZ21lbnRTaGFkZXJHZXRCaWFzVmFsdWVTb3VyY2UocmVzdWx0RGVwdGgpO1xuXG4gIHJldHVybiBbXG4gICAgcHJvbG9ndWUsXG4gICAgZ2V0TWF0cml4VmFsdWVPclplcm9QYWQsXG4gICAgZ2V0Qmlhc1ZhbHVlLFxuICAgIGNvbnZvbHZlLFxuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udm9sdmUoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBhOiBXZWJHTFRleHR1cmUsXG4gICAgd2VpZ2h0czogV2ViR0xUZXh0dXJlLCBiaWFzZXM6IFdlYkdMVGV4dHVyZXxudWxsLCByZXN1bHQ6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHRTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbFswXSwgcmVzdWx0U2hhcGVSb3dDb2xbMV0pO1xuICBncGdwdS5zZXRQcm9ncmFtKHByb2dyYW0pO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYSwgJ3gnLCAwKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHdlaWdodHMsICd3ZWlnaHRzJywgMSk7XG4gIGlmIChiaWFzZXMgIT0gbnVsbCkge1xuICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShiaWFzZXMsICdiaWFzZXMnLCAyKTtcbiAgfVxuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgIHNvdXJjZVNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBzb3VyY2VTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIGRlc3RTaXplUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgc291cmNlO1xuICAgIHVuaWZvcm0gdmVjMiBzb3VyY2VTdGFydENSO1xuICAgIHVuaWZvcm0gdmVjMiBkZXN0U3RhcnRDUjtcblxuICAgIGNvbnN0IHZlYzIgc291cmNlU2hhcGVDUiA9XG4gICAgICB2ZWMyKCR7c291cmNlU2hhcGVSb3dDb2xbMV19LCAke3NvdXJjZVNoYXBlUm93Q29sWzBdfSk7XG4gICAgY29uc3QgdmVjMiBzb3VyY2VTaXplQ1IgPVxuICAgICAgdmVjMigke3NvdXJjZVNpemVSb3dDb2xbMV19LCAke3NvdXJjZVNpemVSb3dDb2xbMF19KTtcbiAgICBjb25zdCB2ZWMyIGRlc3RTaXplQ1IgPVxuICAgICAgdmVjMigke2Rlc3RTaXplUm93Q29sWzFdfSwgJHtkZXN0U2l6ZVJvd0NvbFswXX0pO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiBkZXN0T2Zmc2V0Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpIC0gZGVzdFN0YXJ0Q1I7XG4gICAgICBmbG9hdCBkZXN0T2Zmc2V0RmxhdCA9IChkZXN0T2Zmc2V0Q1IueSAqIGRlc3RTaXplQ1IueCkgKyBkZXN0T2Zmc2V0Q1IueDtcbiAgICAgIHZlYzIgc291cmNlT2Zmc2V0Q1IgPSB2ZWMyKG1vZChkZXN0T2Zmc2V0RmxhdCwgc291cmNlU2l6ZUNSLngpLFxuICAgICAgICBmbG9vcihkZXN0T2Zmc2V0RmxhdCAvIHNvdXJjZVNpemVDUi54KSk7XG4gICAgICB2ZWMyIHNvdXJjZUNSID0gc291cmNlU3RhcnRDUiArIHNvdXJjZU9mZnNldENSO1xuICAgICAgdmVjMiBzb3VyY2VVViA9IChzb3VyY2VDUiArIHZlYzIoMC41LCAwLjUpKSAvIHNvdXJjZVNoYXBlQ1I7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoc291cmNlLCBzb3VyY2VVVik7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgc291cmNlOiBXZWJHTFRleHR1cmUsXG4gICAgc291cmNlU2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIHNvdXJjZVN0YXJ0Um93Q29sOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgIHNvdXJjZVNpemVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIGRlc3Q6IFdlYkdMVGV4dHVyZSxcbiAgICBkZXN0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0sIGRlc3RTdGFydFJvd0NvbDogW251bWJlciwgbnVtYmVyXSxcbiAgICBkZXN0U2l6ZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKGRlc3QsIGRlc3RTaGFwZVJvd0NvbFswXSwgZGVzdFNoYXBlUm93Q29sWzFdKTtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb24oXG4gICAgICBkZXN0U3RhcnRSb3dDb2xbMF0sIGRlc3RTaXplUm93Q29sWzBdLCBkZXN0U3RhcnRSb3dDb2xbMV0sXG4gICAgICBkZXN0U2l6ZVJvd0NvbFsxXSk7XG4gIGdwZ3B1LnNldFByb2dyYW0ocHJvZ3JhbSk7XG4gIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZShzb3VyY2UsICdzb3VyY2UnLCAwKTtcbiAgY29uc3Qgc291cmNlU3RhcnRDUkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbignc291cmNlU3RhcnRDUicpO1xuICBncGdwdS5nbC51bmlmb3JtMmYoXG4gICAgICBzb3VyY2VTdGFydENSTG9jLCBzb3VyY2VTdGFydFJvd0NvbFsxXSwgc291cmNlU3RhcnRSb3dDb2xbMF0pO1xuICBjb25zdCBkZXN0U3RhcnRDUkxvYyA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbignZGVzdFN0YXJ0Q1InKTtcbiAgZ3BncHUuZ2wudW5pZm9ybTJmKGRlc3RTdGFydENSTG9jLCBkZXN0U3RhcnRSb3dDb2xbMV0sIGRlc3RTdGFydFJvd0NvbFswXSk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGdwZ3B1X3V0aWwgZnJvbSAnLi9ncGdwdV91dGlsJztcbmltcG9ydCAqIGFzIHRleF91dGlsIGZyb20gJy4vdGV4X3V0aWwnO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuL3dlYmdsX3V0aWwnO1xuXG5pbXBvcnQge1dlYkdMTG9zZUNvbnRleHRFeHRlbnNpb259IGZyb20gJy4vd2ViZ2xfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBHUEdQVUNvbnRleHQge1xuICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICB0ZXh0dXJlRmxvYXRFeHRlbnNpb246IHt9O1xuICBjb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uOiB7fTtcbiAgbG9zZUNvbnRleHRFeHRlbnNpb246IFdlYkdMTG9zZUNvbnRleHRFeHRlbnNpb247XG4gIHZlcnRleEJ1ZmZlcjogV2ViR0xCdWZmZXI7XG4gIGluZGV4QnVmZmVyOiBXZWJHTEJ1ZmZlcjtcbiAgZnJhbWVidWZmZXI6IFdlYkdMRnJhbWVidWZmZXI7XG4gIG91dHB1dFRleHR1cmU6IFdlYkdMVGV4dHVyZXxudWxsID0gbnVsbDtcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtfG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRpc3Bvc2VkID0gZmFsc2U7XG4gIHByaXZhdGUgYXV0b0RlYnVnVmFsaWRhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihnbD86IFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICAgIGlmIChnbCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2wgPSBncGdwdV91dGlsLmNyZWF0ZVdlYkdMQ29udGV4dCgpO1xuICAgIH1cblxuICAgIC8vIFdlYkdMIDIuMCBlbmFibGVzIHRleHR1cmUgZmxvYXRzIHdpdGhvdXQgYW4gZXh0ZW5zaW9uLlxuICAgIGlmICghd2ViZ2xfdXRpbC5pc1dlYkdMMkVuYWJsZWQoKSkge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICB3ZWJnbF91dGlsLmdldEV4dGVuc2lvbk9yVGhyb3codGhpcy5nbCwgJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvc2VDb250ZXh0RXh0ZW5zaW9uID1cbiAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdXRUJHTF9sb3NlX2NvbnRleHQnKSBhc1xuICAgICAgICBXZWJHTExvc2VDb250ZXh0RXh0ZW5zaW9uO1xuICAgIHRoaXMudmVydGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVWZXJ0ZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IGdwZ3B1X3V0aWwuY3JlYXRlSW5kZXhCdWZmZXIodGhpcy5nbCk7XG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IHdlYmdsX3V0aWwuY3JlYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gIH1cblxuICBwdWJsaWMgZGlzcG9zZSgpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGlmICh0aGlzLnByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uJyArXG4gICAgICAgICAgJyBUaGlzIGlzIHByb2JhYmx5IGEgcmVzb3VyY2UgbGVhaywgZGVsZXRlIHRoZSBwcm9ncmFtIHdpdGggJyArXG4gICAgICAgICAgJ0dQR1BVQ29udGV4dC5kZWxldGVQcm9ncmFtIGJlZm9yZSBkaXNwb3NpbmcuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4ICcgK1xuICAgICAgICAgICd0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0ICcgK1xuICAgICAgICAgICdtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSAnICtcbiAgICAgICAgICAnZGlzcG9zaW5nLicpO1xuICAgIH1cbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmZpbmlzaCgpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuZnJhbWVidWZmZXIpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICAgIGdsLCAoKSA9PiBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLmluZGV4QnVmZmVyKSk7XG4gICAgdGhpcy5sb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIGVuYWJsZUF1dG9tYXRpY0RlYnVnVmFsaWRhdGlvbihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSA9IGVuYWJsZWQ7XG4gICAgd2ViZ2xfdXRpbC5lbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKTtcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGVNYXRyaXhUZXh0dXJlKHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogV2ViR0xUZXh0dXJlIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZU1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gIH1cblxuICBwdWJsaWMgdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgICAgcGl4ZWxzOiBJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICBncGdwdV91dGlsLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCBwaXhlbHMpO1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUocm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOlxuICAgICAgV2ViR0xUZXh0dXJlIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHJldHVybiBncGdwdV91dGlsLmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodGhpcy5nbCwgcm93cywgY29sdW1ucyk7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlTWF0cml4VGV4dHVyZSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgPT09IHRleHR1cmUpIHtcbiAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgKCkgPT4gdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGxvYWRNYXRyaXhUb1RleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLFxuICAgICAgbWF0cml4OiBGbG9hdDMyQXJyYXkpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGNvbnN0IG51bUNoYW5uZWxzID0gMTtcbiAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1RleHR1cmUoXG4gICAgICAgIHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpO1xuICB9XG5cbiAgcHVibGljIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShcbiAgICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIsXG4gICAgICBtYXRyaXg6IEZsb2F0MzJBcnJheSkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKFxuICAgICAgICB0aGlzLmdsLCB0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xuICB9XG5cbiAgcHVibGljIGRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUoXG4gICAgICB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcihcbiAgICAgICAgdGV4dHVyZSxcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKSk7XG4gIH1cblxuICBwdWJsaWMgZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZShcbiAgICAgIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKFxuICAgICAgICB0ZXh0dXJlLFxuICAgICAgICAoKSA9PiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUoXG4gICAgICAgICAgICB0aGlzLmdsLCByb3dzLCBjb2x1bW5zKSk7XG4gIH1cblxuICBwdWJsaWMgY3JlYXRlUHJvZ3JhbShmcmFnbWVudFNoYWRlclNvdXJjZTogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlcjogV2ViR0xTaGFkZXIgPVxuICAgICAgICB3ZWJnbF91dGlsLmNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlciA9IGdwZ3B1X3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsKTtcbiAgICBjb25zdCBwcm9ncmFtOiBXZWJHTFByb2dyYW0gPSB3ZWJnbF91dGlsLmNyZWF0ZVByb2dyYW0oZ2wpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcikpO1xuICAgIHdlYmdsX3V0aWwubGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlUHJvZ3JhbShwcm9ncmFtOiBXZWJHTFByb2dyYW0pIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtICE9IG51bGwpIHtcbiAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsICgpID0+IHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFByb2dyYW0ocHJvZ3JhbTogV2ViR0xQcm9ncmFtfG51bGwpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgaWYgKCh0aGlzLnByb2dyYW0gIT0gbnVsbCkgJiYgdGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0odGhpcy5nbCwgdGhpcy5wcm9ncmFtKTtcbiAgICB9XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgKCkgPT4gdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0pKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KFxuICAgICAgICB0aGlzLmdsLCB0aGlzLnByb2dyYW0hLCB1bmlmb3JtTmFtZSk7XG4gIH1cblxuICBwdWJsaWMgc2V0SW5wdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgaW5wdXRNYXRyaXhUZXh0dXJlOiBXZWJHTFRleHR1cmUsIHVuaWZvcm1OYW1lOiBzdHJpbmcsXG4gICAgICB0ZXh0dXJlVW5pdDogbnVtYmVyKSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICB3ZWJnbF91dGlsLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIoXG4gICAgICAgIHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSEsIGlucHV0TWF0cml4VGV4dHVyZSwgdW5pZm9ybU5hbWUsIHRleHR1cmVVbml0KTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgb3V0cHV0TWF0cml4VGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcikge1xuICAgIHRoaXMuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihvdXRwdXRNYXRyaXhUZXh0dXJlLCBjb2x1bW5zLCByb3dzKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKFxuICAgICAgb3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcikge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID1cbiAgICAgICAgdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG4gICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgcHVibGljIHNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uKFxuICAgICAgc3RhcnRSb3c6IG51bWJlciwgbnVtUm93czogbnVtYmVyLCBzdGFydENvbHVtbjogbnVtYmVyLFxuICAgICAgbnVtQ29sdW1uczogbnVtYmVyKSB7XG4gICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihcbiAgICAgICAgc3RhcnRDb2x1bW4sIHN0YXJ0Um93LCBudW1Db2x1bW5zLCBudW1Sb3dzKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbihcbiAgICAgIHN0YXJ0Um93OiBudW1iZXIsIG51bVJvd3M6IG51bWJlciwgc3RhcnRDb2x1bW46IG51bWJlcixcbiAgICAgIG51bUNvbHVtbnM6IG51bWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0T3V0cHV0UGFja2VkTWF0cml4V3JpdGVSZWdpb24gbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgcHVibGljIGRlYnVnVmFsaWRhdGUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gIH1cblxuICBwdWJsaWMgZXhlY3V0ZVByb2dyYW0oKSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICB0aGlzLnRocm93SWZOb1Byb2dyYW0oKTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgZ3BncHVfdXRpbC5iaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoXG4gICAgICAgIGdsLCB0aGlzLnByb2dyYW0hLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgIHRoaXMuZGVidWdWYWxpZGF0ZSgpO1xuICAgIH1cbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgICAgZ2wsICgpID0+IGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKSk7XG4gIH1cblxuICBwdWJsaWMgYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkKCkge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgKCkgPT4gdGhpcy5nbC5maW5pc2goKSk7XG4gIH1cblxuICBwcml2YXRlIGRvd25sb2FkTWF0cml4RHJpdmVyKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgICAgZG93bmxvYWRBbmREZWNvZGU6ICgpID0+IEZsb2F0MzJBcnJheSk6IEZsb2F0MzJBcnJheSB7XG4gICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKFxuICAgICAgICB0aGlzLmdsLCB0ZXh0dXJlLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBkb3dubG9hZEFuZERlY29kZSgpO1xuICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgd2ViZ2xfdXRpbC5iaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcihcbiAgICAgICAgICB0aGlzLmdsLCB0aGlzLm91dHB1dFRleHR1cmUsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgaWYgKHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3ZWJnbF91dGlsLnVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcih0aGlzLmdsLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcihcbiAgICAgIG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZDogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLFxuICAgICAgaGVpZ2h0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKFxuICAgICAgICBnbCwgb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB0aGlzLmZyYW1lYnVmZmVyKTtcbiAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZUZyYW1lYnVmZmVyKGdsKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gb3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlcihcbiAgICAgIHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICAgIHRoaXMuZ2wsICgpID0+IHRoaXMuZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gIH1cblxuICBwcml2YXRlIHRocm93SWZEaXNwb3NlZCgpIHtcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gdXNlIGRpc3Bvc2VkIEdQR1BVQ29udGV4dC4nKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRocm93SWZOb1Byb2dyYW0oKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdQVSBwcm9ncmFtIGlzIGN1cnJlbnRseSBzZXQuJyk7XG4gICAgfVxuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi4vbmRhcnJheSc7XG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuaW1wb3J0ICogYXMgc2hhZGVyX2NvbXBpbGVyIGZyb20gJy4vc2hhZGVyX2NvbXBpbGVyJztcbmltcG9ydCB7U2hhcGVJbmZvfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uLy4uL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHBhcmFtczogQXJyYXk8e30+O1xuICB1c2VyQ29kZTogc3RyaW5nO1xuICBzdXBwb3J0c0Jyb2FkY2FzdGluZz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR1BHUFVCaW5hcnkge1xuICB3ZWJHTFByb2dyYW06IFdlYkdMUHJvZ3JhbTtcbiAgcHJvZ3JhbTogR1BHUFVQcm9ncmFtO1xuICBncGdwdTogR1BHUFVDb250ZXh0O1xuICBzb3VyY2U6IHN0cmluZztcbiAgaW5TaGFwZUluZm9zOiBTaGFwZUluZm9bXTtcbiAgb3V0U2hhcGVJbmZvOiBTaGFwZUluZm87XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlUHJvZ3JhbTxUIGV4dGVuZHMgTkRBcnJheSwgSyBleHRlbmRzIE5EQXJyYXk+KFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IEdQR1BVUHJvZ3JhbSwgaW5wdXRzOiBUW10sXG4gICAgb3V0cHV0OiBLKTogR1BHUFVCaW5hcnkge1xuICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW0udXNlckNvZGU7XG4gIGNvbnN0IGlucHV0SW5mb3MgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXMubWFwKCh4LCBpKSA9PiB7XG4gICAgY29uc3Qgc2hhcGVJbmZvID0ge1xuICAgICAgbG9naWNhbFNoYXBlOiBpbnB1dHNbaV0uc2hhcGUsXG4gICAgICB0ZXhTaGFwZTogaW5wdXRzW2ldLmdldFRleHR1cmVTaGFwZVJDKClcbiAgICB9O1xuICAgIHJldHVybiB7bmFtZTogeCwgc2hhcGVJbmZvfTtcbiAgfSk7XG4gIGNvbnN0IGluU2hhcGVJbmZvcyA9IGlucHV0SW5mb3MubWFwKHggPT4geC5zaGFwZUluZm8pO1xuICBjb25zdCBvdXRTaGFwZUluZm8gPSB7XG4gICAgbG9naWNhbFNoYXBlOiBvdXRwdXQuc2hhcGUsXG4gICAgdGV4U2hhcGU6IG91dHB1dC5nZXRUZXh0dXJlU2hhcGVSQygpXG4gIH07XG4gIGNvbnN0IHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKFxuICAgICAgaW5wdXRJbmZvcywgb3V0U2hhcGVJbmZvLCB1c2VyQ29kZSxcbiAgICAgIHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpO1xuICByZXR1cm4ge1xuICAgIHByb2dyYW0sXG4gICAgc291cmNlLFxuICAgIHdlYkdMUHJvZ3JhbTogZ3BncHUuY3JlYXRlUHJvZ3JhbShzb3VyY2UpLFxuICAgIGdwZ3B1LFxuICAgIGluU2hhcGVJbmZvcyxcbiAgICBvdXRTaGFwZUluZm9cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCaW5hcnlBbmRQcm9ncmFtKHNoYXBlSW5mb3M6IFNoYXBlSW5mb1tdLCBiQXJyYXlzOiBOREFycmF5W10pIHtcbiAgc2hhcGVJbmZvcy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgY29uc3Qgc2hhcGVBID0gcy5sb2dpY2FsU2hhcGU7XG4gICAgY29uc3QgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICBjb25zdCBzaGFwZUIgPSBiQXJyYXlzW2ldLnNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlQiA9IGJBcnJheXNbaV0uZ2V0VGV4dHVyZVNoYXBlUkMoKTtcblxuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChzaGFwZUEsIHNoYXBlQikpIHtcbiAgICAgIHRocm93IEVycm9yKGBCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIGAgK1xuICAgICAgICAgIGB0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgJHtzaGFwZUF9IGFuZCAke3NoYXBlQn0gbXVzdCBtYXRjaGApO1xuICAgIH1cbiAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZWAgK1xuICAgICAgICAgIGAgY3VycmVudCBhcmdzLiBTaGFwZSAke3RleFNoYXBlQX0gYW5kICR7dGV4U2hhcGVCfSBtdXN0IG1hdGNoYCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1blByb2dyYW08VCBleHRlbmRzIE5EQXJyYXksIEsgZXh0ZW5kcyBOREFycmF5PihcbiAgICBiaW5hcnk6IEdQR1BVQmluYXJ5LCBpbnB1dHM6IFRbXSwgb3V0cHV0OiBLKTogdm9pZCB7XG4gIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShiaW5hcnkuaW5TaGFwZUluZm9zLCBpbnB1dHMpO1xuICB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oW2JpbmFyeS5vdXRTaGFwZUluZm9dLCBbb3V0cHV0XSk7XG5cbiAgY29uc3Qgb3V0VGV4ID0gb3V0cHV0LmdldFRleHR1cmUoKTtcbiAgY29uc3Qgb3V0VGV4U2hhcGUgPSBvdXRwdXQuZ2V0VGV4dHVyZVNoYXBlUkMoKTtcbiAgY29uc3QgZ3BncHUgPSBiaW5hcnkuZ3BncHU7XG4gIGdwZ3B1LnNldE91dHB1dE1hdHJpeFRleHR1cmUob3V0VGV4LCBvdXRUZXhTaGFwZVswXSwgb3V0VGV4U2hhcGVbMV0pO1xuICBncGdwdS5zZXRQcm9ncmFtKGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICBjb25zdCB0ZXggPSBpbnB1dC5nZXRUZXh0dXJlKCk7XG4gICAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKHRleCwgYmluYXJ5LnByb2dyYW0udmFyaWFibGVOYW1lc1tpXSwgaSk7XG4gIH0pO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVNoYWRlcktleShcbiAgICBwcm9ncmFtOiBHUEdQVVByb2dyYW0sIGlucHV0czogTkRBcnJheVtdLFxuICAgIG91dHB1dDogTkRBcnJheSk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IHByb2dyYW0ucGFyYW1zO1xuICBjb25zdCBrZXlTdGFydCA9XG4gICAgICBpbnB1dHMuY29uY2F0KG91dHB1dCkubWFwKHggPT4geC5zaGFwZSArICdfJyArIHguZ2V0VGV4dHVyZVNoYXBlUkMoKSk7XG4gIGNvbnN0IGtleUVuZCA9IHBhcmFtcy5tYXAocCA9PiBwLnRvU3RyaW5nKCkpO1xuICBsZXQga2V5ID0gW3Byb2dyYW0uY29uc3RydWN0b3IubmFtZV07XG4gIGtleS5wdXNoKChwcm9ncmFtLnN1cHBvcnRzQnJvYWRjYXN0aW5nID09PSB0cnVlKS50b1N0cmluZygpKTtcbiAga2V5ID0ga2V5LmNvbmNhdChrZXlTdGFydCwga2V5RW5kKTtcbiAgcmV0dXJuIGtleS5qb2luKCdfJyk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHRleF91dGlsIGZyb20gJy4vdGV4X3V0aWwnO1xuaW1wb3J0ICogYXMgd2ViZ2xfdXRpbCBmcm9tICcuL3dlYmdsX3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzIHtcbiAgcmV0dXJuIHtcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IHRydWVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdlYkdMQ29udGV4dChjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCkge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcygpO1xuICBsZXQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgaWYgKGNhbnZhcyAhPSBudWxsKSB7XG4gICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0KGF0dHJpYnV0ZXMpO1xuICB9XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kaXNhYmxlKGdsLkJMRU5EKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kaXNhYmxlKGdsLkRJVEhFUikpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuY3VsbEZhY2UoZ2wuQkFDSykpO1xuICByZXR1cm4gZ2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IFdlYkdMU2hhZGVyIHtcbiAgY29uc3QgdmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICBhdHRyaWJ1dGUgdmVjMyBjbGlwU3BhY2VQb3M7XG4gICAgYXR0cmlidXRlIHZlYzIgdXY7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XG4gICAgICByZXN1bHRVViA9IHV2O1xuICAgIH1gO1xuICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhCdWZmZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IFdlYkdMQnVmZmVyIHtcbiAgLy8gW3ggeSB6IHUgdl0gKiBbdXBwZXItbGVmdCwgbG93ZXItbGVmdCwgdXBwZXItcmlnaHQsIGxvd2VyLXJpZ2h0XVxuICBjb25zdCB2ZXJ0ZXhBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICBbLTEsIDEsIDAsIDAsIDEsIC0xLCAtMSwgMCwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMSwgLTEsIDAsIDEsIDBdKTtcbiAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyKGdsLCB2ZXJ0ZXhBcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbmRleEJ1ZmZlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xCdWZmZXIge1xuICAvLyBPcGVuR0wgKGFuZCBXZWJHTCkgaGF2ZSBcIkNDVyA9PSBmcm9udFwiIHdpbmRpbmdcbiAgY29uc3QgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAyLCAxLCAzXSk7XG4gIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKGdsLCB0cmlhbmdsZVZlcnRleEluZGljZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgbnVtQ2hhbm5lbHM6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh3ZWJnbF91dGlsLmlzV2ViR0wyRW5hYmxlZCgpKSB7XG4gICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICByZXR1cm4gKGdsIGFzIGFueSkuUkdCQTMyRjtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHJldHVybiAoZ2wgYXMgYW55KS5SMzJGO1xuICB9XG4gIHJldHVybiBnbC5SR0JBO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0dXJlRm9ybWF0KFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIG51bUNoYW5uZWxzOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAod2ViZ2xfdXRpbC5pc1dlYkdMMkVuYWJsZWQoKSAmJiBudW1DaGFubmVscyA9PT0gMSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICByZXR1cm4gKGdsIGFzIGFueSkuUkVEO1xuICB9XG4gIHJldHVybiBnbC5SR0JBO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLFxuICAgIG51bUNoYW5uZWxzOiBudW1iZXIpOiBXZWJHTFRleHR1cmUge1xuICB3ZWJnbF91dGlsLnZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICBjb25zdCB0ZXh0dXJlID0gd2ViZ2xfdXRpbC5jcmVhdGVUZXh0dXJlKGdsKTtcblxuICBjb25zdCB0ZXgyZCA9IGdsLlRFWFRVUkVfMkQ7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gIGNvbnN0IGZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKHRleDJkLCB0ZXh0dXJlKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgIGdsLCAoKSA9PiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpKTtcbiAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soXG4gICAgICBnbCxcbiAgICAgICgpID0+IGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgdGV4MmQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIGdsLkZMT0FULCBudWxsKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKSk7XG4gIHJldHVybiB0ZXh0dXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0cml4VGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IFdlYkdMVGV4dHVyZSB7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9XG4gICAgICB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuICBjb25zdCBudW1DaGFubmVscyA9IDE7XG4gIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBXZWJHTFRleHR1cmUge1xuICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPVxuICAgICAgdGV4X3V0aWwuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgbnVtQ2hhbm5lbHMgPSA0O1xuICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IFdlYkdMVGV4dHVyZSB7XG4gIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9XG4gICAgICB0ZXhfdXRpbC5nZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3QgbnVtQ2hhbm5lbHMgPSA0O1xuICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAgICB2ZXJ0ZXhCdWZmZXI6IFdlYkdMQnVmZmVyKSB7XG4gIGNvbnN0IHBvc09mZnNldCA9IDA7ICAgICAgICAgICAgICAgLy8geCBpcyB0aGUgZmlyc3QgYnVmZmVyIGVsZW1lbnRcbiAgY29uc3QgdXZPZmZzZXQgPSAzICogNDsgICAgICAgICAgICAvLyB1diBjb21lcyBhZnRlciBbeCB5IHpdXG4gIGNvbnN0IHN0cmlkZSA9ICgzICogNCkgKyAoMiAqIDQpOyAgLy8geHl6ICsgdXYsIGVhY2ggZW50cnkgaXMgNC1ieXRlIGZsb2F0LlxuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgIGdsLCAoKSA9PiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKSk7XG4gIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShcbiAgICAgIGdsLCBwcm9ncmFtLCAnY2xpcFNwYWNlUG9zJywgdmVydGV4QnVmZmVyLCAzLCBzdHJpZGUsIHBvc09mZnNldCk7XG4gIHRyeSB7XG4gICAgd2ViZ2xfdXRpbC5iaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKFxuICAgICAgICBnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByb2dyYW1zIHdpdGggMXgxIG91dHB1dCB0ZXh0dXJlcyBkb24ndCB1c2UgdGhlIHV2IGF0dHJpYnV0ZS5cbiAgICAvLyBUaGlzIGNhbiBjYXVzZSB0aGUgc2hhZGVyIGxpbmtlciB0byBkZWFkLXN0cmlwIGl0LCBzbyB3ZSBzaG91bGRuJ3RcbiAgICAvLyBjb21wbGFpbiBvciBmYWlsIGlmIGl0J3Mgbm90IHByZXNlbnQuXG4gICAgaWYgKCFlLmhhc093blByb3BlcnR5KCduYW1lZFZlcnRleEF0dHJpYnV0ZU5vdEZvdW5kJykpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRQaXhlbERhdGFUb1RleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLFxuICAgIHBpeGVsczogSW1hZ2VEYXRhfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudCkge1xuICBjb25zdCBudW1DaGFubmVscyA9IDQ7XG4gIGNvbnN0IGludGVybmFsRm9ybWF0ID0gZ2V0VGV4dHVyZUludGVybmFsRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsXG4gICAgICAoKSA9PiBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBnbC5SR0JBLCBnbC5GTE9BVCwgcGl4ZWxzKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKSk7XG59XG5cbmZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLCBkYXRhOiBGbG9hdDMyQXJyYXksIG51bUNoYW5uZWxzOiBudW1iZXIpIHtcbiAgY29uc3QgdGV4dHVyZUZvcm1hdCA9IGdldFRleHR1cmVGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKTtcblxuICB3ZWJnbF91dGlsLnZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSkpO1xuICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhcbiAgICAgIGdsLFxuICAgICAgKCkgPT4gZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgICBnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlRm9ybWF0LCBnbC5GTE9BVCxcbiAgICAgICAgICBkYXRhKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1RleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCByb3dzOiBudW1iZXIsXG4gICAgY29sdW1uczogbnVtYmVyLCBtYXRyaXg6IEZsb2F0MzJBcnJheSwgbnVtQ2hhbm5lbHM6IG51bWJlcikge1xuICBjb25zdCBbdywgaF0gPVxuICAgICAgdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcblxuICBjb25zdCBjaGFubmVsc1BlclRleHR1cmUgPVxuICAgICAgbnVtQ2hhbm5lbHMgPT09IDEgPyB3ZWJnbF91dGlsLmdldENoYW5uZWxzUGVyVGV4dHVyZSgpIDogbnVtQ2hhbm5lbHM7XG4gIGNvbnN0IHVucGFja2VkQXJyYXkgPVxuICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKFxuICAgICAgICAgIG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkoXG4gICAgICBtYXRyaXgsIHVucGFja2VkQXJyYXksIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG5cbiAgdXBsb2FkRGF0YVRvVGV4dHVyZShnbCwgdGV4dHVyZSwgdywgaCwgdW5wYWNrZWRBcnJheSwgbnVtQ2hhbm5lbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgcm93czogbnVtYmVyLFxuICAgIGNvbHVtbnM6IG51bWJlciwgbWF0cml4OiBGbG9hdDMyQXJyYXkpIHtcbiAgY29uc3QgW3csIGhdID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG4gIGNvbnN0IHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgdGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gIHRleF91dGlsLmVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpO1xuICBjb25zdCBudW1DaGFubmVscyA9IDQ7XG4gIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHcsIGgsIHBhY2tlZFJHQkEsIG51bUNoYW5uZWxzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICBjb25zdCBbdywgaF0gPVxuICAgICAgdGV4X3V0aWwuZ2V0VW5wYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcblxuICBjb25zdCBjaGFubmVsc1BlclRleHR1cmUgPSA0O1xuICBjb25zdCB1bnBhY2tlZEFycmF5ID1cbiAgICAgIG5ldyBGbG9hdDMyQXJyYXkodGV4X3V0aWwuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShcbiAgICAgICAgICByb3dzICogY29sdW1ucywgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHVucGFja2VkQXJyYXkpKTtcblxuICBjb25zdCBtYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHJvd3MgKiBjb2x1bW5zKTtcbiAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoXG4gICAgICB1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogRmxvYXQzMkFycmF5IHtcbiAgY29uc3QgW3csIGhdID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG4gIGNvbnN0IHBhY2tlZFJHQkEgPSBuZXcgRmxvYXQzMkFycmF5KFxuICAgICAgdGV4X3V0aWwuZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKSk7XG4gIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsICgpID0+IGdsLnJlYWRQaXhlbHMoMCwgMCwgdywgaCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIHBhY2tlZFJHQkEpKTtcbiAgY29uc3QgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShwYWNrZWRSR0JBLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIExvZ1N1bUV4cFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydBJ107XG4gIHBhcmFtczogQXJyYXk8e30+ID0gW107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFTaXplOiBudW1iZXIpIHtcbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCBhTWF4ID0gZ2V0QUZsYXQoMC4wKTtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2FTaXplfTsgaSsrKSB7XG4gICAgICAgICAgYU1heCA9IG1heChhTWF4LCBnZXRBRmxhdChmbG9hdChpKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgZXhwU3VtID0gMC4wO1xuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7YVNpemV9OyBpKyspIHtcbiAgICAgICAgICBleHBTdW0gKz0gZXhwKGdldEFGbGF0KGZsb2F0KGkpKSAtIGFNYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0T3V0cHV0KGFNYXggKyBsb2coZXhwU3VtKSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vY29udl91dGlsJztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sQmFja3Byb3AoXG4gICAgZHlTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBvcmlnU3RyaWRlOiBudW1iZXIsXG4gICAgb3JpZ1BhZDogbnVtYmVyKSB7XG4gIGNvbnN0IG9yaWdJbnB1dERlcHRoID0gZHlTaGFwZVJDRFsyXTtcbiAgY29uc3QgcGFkID0gZlNpemUgLSAxIC0gb3JpZ1BhZDtcbiAgY29uc3QgW2R5Um93cywgZHlDb2xzLCBkZXB0aF0gPSBkeVNoYXBlUkNEO1xuXG4gIGNvbnN0IGR5VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoZHlTaGFwZVJDRCk7XG5cbiAgcmV0dXJuIGBcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgZHk7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgbWF4UG9zO1xuXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcbiAgICBjb25zdCB2ZWMyIGR5U2hhcGVDUiA9IHZlYzIoJHtkeVRleFNoYXBlUkNbMV19LCAke2R5VGV4U2hhcGVSQ1swXX0pO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiBkeFRleENSID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnh5KTtcblxuICAgICAgLy8gTWFwIGZyb20gMkQgKGR4VGV4UiwgZHhUZXhDKSB0byAzRCAoZHhSLCBkeEMsIGQpLlxuICAgICAgZmxvYXQgZHhSID0gZHhUZXhDUi55O1xuICAgICAgZmxvYXQgZHhDID0gZmxvb3IoZHhUZXhDUi54IC8gJHtvcmlnSW5wdXREZXB0aH0uMCk7XG4gICAgICBmbG9hdCBkID0gbW9kKGR4VGV4Q1IueCwgJHtvcmlnSW5wdXREZXB0aH0uMCk7XG5cbiAgICAgIHZlYzIgZHlSQ0Nvcm5lciA9IHZlYzIoZHhSLCBkeEMpIC0gdmVjMigke3BhZH0uMCwgJHtwYWR9LjApO1xuICAgICAgZmxvYXQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xuICAgICAgZmxvYXQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xuXG4gICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh5UiwgZHhDLCBkKS5cbiAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZTaXplfTsgd1IrKykge1xuICAgICAgICBmbG9hdCB3Ul9mbG9hdCA9IGZsb2F0KHdSKTtcbiAgICAgICAgZmxvYXQgZHlSID0gKGR5UkNvcm5lciArIHdSX2Zsb2F0KSAvICR7b3JpZ1N0cmlkZX0uMDtcbiAgICAgICAgLy8gVE9ETyhuc3Rob3JhdCk6IFNwbGljZSB0aGlzIHdpdGggYW5vdGhlciB2ZXJzaW9uIHdoZXJlIHlvdSBjYWxsXG4gICAgICAgIC8vIGdldE1hdHJpeFZhbHVlT3JaZXJvUGFkKCkuIEhlcmUgYW5kIGJlbG93LlxuICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2R5Um93c30uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCBkeVRleFIgPSBkeVI7XG5cbiAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZlNpemV9OyB3QysrKSB7XG4gICAgICAgICAgZmxvYXQgd0NfZmxvYXQgPSBmbG9hdCh3Qyk7XG4gICAgICAgICAgZmxvYXQgZHlDID0gKGR5Q0Nvcm5lciArIHdDX2Zsb2F0KSAvICR7b3JpZ1N0cmlkZX0uMDtcbiAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2R5Q29sc30uMCB8fCBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbG9hdCBkeVRleEMgPSBkeUMgKiAke2RlcHRofS4wICsgZDtcblxuICAgICAgICAgIC8vIFJlYWQgZHkoZHlSLCBkeUMsIGQpLlxuICAgICAgICAgIHZlYzIgZHlVViA9ICh2ZWMyKGR5VGV4QywgZHlUZXhSKSArIGhhbGZDUikgLyBkeVNoYXBlQ1I7XG4gICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IHRleHR1cmUyRChkeSwgZHlVVikucjtcblxuICAgICAgICAgIC8vIFJlYWQgbWF4UG9zKGR5UiwgZHlDLCBkKS5cbiAgICAgICAgICBmbG9hdCBtYXhQb3NWYWx1ZSA9XG4gICAgICAgICAgICAgICR7ZlNpemUgKiBmU2l6ZSAtIDF9LjAgLSB0ZXh0dXJlMkQobWF4UG9zLCBkeVVWKS5yO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxuICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cbiAgICAgICAgICBmbG9hdCBjdXJQb3NWYWx1ZSA9IHdSX2Zsb2F0ICogJHtmU2l6ZX0uMCArIHdDX2Zsb2F0O1xuICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XG5cbiAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBtYXNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGRvdFByb2QsIDAsIDAsIDApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF4UG9vbEJhY2twcm9wKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgZHlUZXg6IFdlYkdMVGV4dHVyZSxcbiAgICBtYXhQb3NpdGlvbnNUZXg6IFdlYkdMVGV4dHVyZSwgcmVzdWx0VGV4OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0VGV4U2hhcGVSQzogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0VGV4LCByZXN1bHRUZXhTaGFwZVJDWzBdLCByZXN1bHRUZXhTaGFwZVJDWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGR5VGV4LCAnZHknLCAwKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKG1heFBvc2l0aW9uc1RleCwgJ21heFBvcycsIDEpO1xuICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcbmltcG9ydCAqIGFzIHBvb2xfZ3B1IGZyb20gJy4vcG9vbF9ncHUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sUG9zaXRpb25zU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlcikge1xuICByZXR1cm4gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sQ29tbW9uU291cmNlKFxuICAgICAgeFNoYXBlUkNELCBmU2l6ZSwgc3RyaWRlLCBwYWQsIHRydWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlcikge1xuICByZXR1cm4gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sQ29tbW9uU291cmNlKFxuICAgICAgeFNoYXBlUkNELCBmU2l6ZSwgc3RyaWRlLCBwYWQsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJNYXhQb29sQ29tbW9uU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlciwgY29tcHV0ZU1heFBvc2l0aW9uczogYm9vbGVhbikge1xuICByZXR1cm4gcG9vbF9ncHUuZ2V0RnJhZ21lbnRTaGFkZXJQb29sQ29tbW9uU291cmNlKFxuICAgICAgeFNoYXBlUkNELCBmU2l6ZSwgc3RyaWRlLCBwYWQsICdtYXgnLCBjb21wdXRlTWF4UG9zaXRpb25zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1heFBvb2xDb21tb24oXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcHJvZ3JhbTogV2ViR0xQcm9ncmFtLCB4OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0OiBXZWJHTFRleHR1cmUsIHJlc3VsdFNoYXBlUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdKSB7XG4gIHBvb2xfZ3B1LnBvb2xDb21tb24oZ3BncHUsIHByb2dyYW0sIHgsIHJlc3VsdCwgcmVzdWx0U2hhcGVSb3dDb2wpO1xufSIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5pbXBvcnQgKiBhcyBwb29sX2dwdSBmcm9tICcuL3Bvb2xfZ3B1JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyTWluUG9vbFNvdXJjZShcbiAgICB4U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZlNpemU6IG51bWJlciwgc3RyaWRlOiBudW1iZXIsXG4gICAgcGFkOiBudW1iZXIpIHtcbiAgcmV0dXJuIHBvb2xfZ3B1LmdldEZyYWdtZW50U2hhZGVyUG9vbENvbW1vblNvdXJjZShcbiAgICAgIHhTaGFwZVJDRCwgZlNpemUsIHN0cmlkZSwgcGFkLCAnbWluJywgZmFsc2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWluUG9vbChcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHg6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgcG9vbF9ncHUucG9vbENvbW1vbihncGdwdSwgcHJvZ3JhbSwgeCwgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbCk7XG59IiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIE1pbk1heFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydBJ107XG4gIHBhcmFtczogQXJyYXk8e30+O1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhU2l6ZTogbnVtYmVyLCBvcFR5cGU6ICdtaW4nfCdtYXgnKSB7XG4gICAgdGhpcy5wYXJhbXMgPSBbb3BUeXBlXTtcbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldEFGbGF0KDAuMCk7XG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHthU2l6ZX07IGkrKykge1xuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEFGbGF0KGZsb2F0KGkpKTtcbiAgICAgICAgICBpZiAoaXNOYU4oY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgc2V0T3V0cHV0KGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gJHtvcFR5cGV9KHZhbHVlLCBjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge01hdHJpeE9yaWVudGF0aW9ufSBmcm9tICcuLi9tYXRoJztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgTWF0TXVsUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ21hdHJpeEEnLCAnbWF0cml4QiddO1xuICBwYXJhbXM6IEFycmF5PHt9PjtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGFTaGFwZTogW251bWJlciwgbnVtYmVyXSwgYlNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgYU9yaWVudCA9IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIsXG4gICAgICBiT3JpZW50ID0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikge1xuICAgIHRoaXMucGFyYW1zID0gW2FPcmllbnQsIGJPcmllbnRdO1xuXG4gICAgY29uc3Qgb3V0ZXJTaGFwZUEgPVxuICAgICAgICAoYU9yaWVudCA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBhU2hhcGVbMF0gOiBhU2hhcGVbMV07XG4gICAgY29uc3Qgb3V0ZXJTaGFwZUIgPVxuICAgICAgICAoYk9yaWVudCA9PT0gTWF0cml4T3JpZW50YXRpb24uUkVHVUxBUikgPyBiU2hhcGVbMV0gOiBiU2hhcGVbMF07XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtvdXRlclNoYXBlQSwgb3V0ZXJTaGFwZUJdO1xuXG4gICAgY29uc3Qgc2hhcmVkRGltID1cbiAgICAgIChhT3JpZW50ID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSID8gYVNoYXBlWzFdIDogYVNoYXBlWzBdKTtcbiAgICBjb25zdCBhU25pcHBldCA9IChhT3JpZW50ID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICdhUm93LCBpX2Zsb2F0JyA6ICdpX2Zsb2F0LCBhUm93JztcbiAgICBjb25zdCBiU25pcHBldCA9IChiT3JpZW50ID09PSBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKSA/XG4gICAgICAgICdpX2Zsb2F0LCBiQ29sJyA6ICdiQ29sLCBpX2Zsb2F0JztcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBpbnQgc2hhcmVkRGltID0gJHtzaGFyZWREaW19O1xuXG4gICAgICBmbG9hdCBkb3RBUm93QkNvbChmbG9hdCBhUm93LCBmbG9hdCBiQ29sKSB7XG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzaGFyZWREaW07IGkrKykge1xuICAgICAgICAgIGZsb2F0IGlfZmxvYXQgPSBmbG9hdChpKTtcbiAgICAgICAgICBmbG9hdCBhID0gZ2V0TWF0cml4QSgke2FTbmlwcGV0fSk7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldE1hdHJpeEIoJHtiU25pcHBldH0pO1xuICAgICAgICAgIHJlc3VsdCArPSAoYSAqIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBzZXRPdXRwdXQoZG90QVJvd0JDb2wocmVzUkMueCwgcmVzUkMueSkpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vY29udl91dGlsJztcbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXJQb29sQ29tbW9uU291cmNlKFxuICAgIHhTaGFwZVJDRDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBmU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlcixcbiAgICBwYWQ6IG51bWJlciwgcG9vbFR5cGU6ICdtYXgnfCdtaW4nfCdhdmcnLCBjb21wdXRlUG9zaXRpb25zOiBib29sZWFuKSB7XG4gIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuJyk7XG4gIH1cblxuICBjb25zdCBkZXB0aCA9IHhTaGFwZVJDRFsyXTtcblxuICBjb25zdCB4VGV4U2hhcGVSQyA9IGNvbnZfdXRpbC5jb21wdXRlVGV4U2hhcGVGcm9tM0QoeFNoYXBlUkNEKTtcblxuICBsZXQgcmV0dXJuVmFsdWUgPSAnbWluTWF4VmFsdWUnO1xuICBpZiAoY29tcHV0ZVBvc2l0aW9ucykge1xuICAgIHJldHVyblZhbHVlID0gJ21pbk1heFBvc2l0aW9uJztcbiAgfSBlbHNlIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycpIHtcbiAgICByZXR1cm5WYWx1ZSA9ICdhdmdWYWx1ZSc7XG4gIH1cblxuICByZXR1cm4gYFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB4O1xuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcblxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG4gICAgY29uc3QgdmVjMiB4U2hhcGVDUiA9IHZlYzIoJHt4VGV4U2hhcGVSQ1sxXX0sICR7eFRleFNoYXBlUkNbMF19KTtcblxuICAgIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XG4gICAgICByZXR1cm4gdmFsID09IHZhbCA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWMyIHlUZXhDUiA9IGZsb29yKGdsX0ZyYWdDb29yZC54eSk7XG5cbiAgICAgIC8vIE1hcCBmcm9tIDJEICh5VGV4UiwgeVRleEMpIHRvIDNEICh5UiwgeUMsIGQyKS5cbiAgICAgIGZsb2F0IHlSID0geVRleENSLnk7XG4gICAgICBmbG9hdCB5QyA9IGZsb29yKHlUZXhDUi54IC8gJHtkZXB0aH0uMCk7XG4gICAgICBmbG9hdCBkID0gbW9kKHlUZXhDUi54LCAke2RlcHRofS4wKTtcblxuICAgICAgdmVjMiB4UkNDb3JuZXIgPSB2ZWMyKHlSLCB5QykgKiB2ZWMyKCR7c3RyaWRlfSwgJHtzdHJpZGV9KSAtXG4gICAgICAgICAgdmVjMigke3BhZH0uMCwgJHtwYWR9LjApO1xuICAgICAgZmxvYXQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgIGZsb2F0IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxuICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcbiAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xuICAgICAgZmxvYXQgbWluTWF4VmFsdWVGb3VuZCA9IDAuMDtcbiAgICAgIGZsb2F0IG1pbk1heFBvc2l0aW9uID0gMC4wO1xuICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XG5cbiAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZTaXplfTsgd1IrKykge1xuICAgICAgICBmbG9hdCB3Ul9mbG9hdCA9IGZsb2F0KHdSKTtcbiAgICAgICAgZmxvYXQgeFIgPSB4UkNvcm5lciArIHdSX2Zsb2F0O1xuICAgICAgICBmbG9hdCB4VGV4UiA9IHhSO1xuXG4gICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2ZTaXplfTsgd0MrKykge1xuICAgICAgICAgIGZsb2F0IHdDX2Zsb2F0ID0gZmxvYXQod0MpO1xuICAgICAgICAgIGZsb2F0IHhDID0geENDb3JuZXIgKyB3Q19mbG9hdDtcbiAgICAgICAgICBmbG9hdCB4VGV4QyA9IHhDICogJHtkZXB0aH0uMCArIGQ7XG5cbiAgICAgICAgICB2ZWMyIHRleENSID0gdmVjMih4VGV4QywgeFRleFIpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3RlZCBVViBpcyBpbnZhbGlkLlxuICAgICAgICAgIHZlYzIgdXYgPSAodGV4Q1IgKyBoYWxmQ1IpIC8geFNoYXBlQ1I7XG4gICAgICAgICAgYm9vbCBsZXNzVGhhblplcm8gPSBhbnkobGVzc1RoYW4odXYsIHZlYzIoMCwgMCkpKTtcbiAgICAgICAgICBib29sIGdyZWF0ZXJUaGFuT25lID0gYW55KGdyZWF0ZXJUaGFuKHV2LCB2ZWMyKDEsIDEpKSk7XG4gICAgICAgICAgYm9vbCBvdXRzaWRlID0gbGVzc1RoYW5aZXJvIHx8IGdyZWF0ZXJUaGFuT25lO1xuICAgICAgICAgIGlmIChvdXRzaWRlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IHRleHR1cmUyRCh4LCB1dikucjtcbiAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbHVlLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCR7cG9vbFR5cGUgPT09ICdhdmcnfSkge1xuICAgICAgICAgICAgYXZnVmFsdWUgKz0gdmFsdWUgLyAke2ZTaXplICogZlNpemV9LjA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LCB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgZmxvYXQgY3VycmVudE1pbk1heFZhbHVlID0gbWl4KFxuICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJHtwb29sVHlwZSA9PT0gJ21pbicgPyAnPD0nIDogJz49J30gY3VycmVudE1pbk1heFZhbHVlKSB7XG4gICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIG1pbk1heFZhbHVlRm91bmQgPSAxLjA7XG4gICAgICAgICAgICAgIGlmICgke2NvbXB1dGVQb3NpdGlvbnN9KSB7XG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSB3Ul9mbG9hdCAqICR7ZlNpemV9LjAgKyB3Q19mbG9hdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgke3JldHVyblZhbHVlfSwgMCwgMCwgMCk7XG4gICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb29sQ29tbW9uKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgeDogV2ViR0xUZXh0dXJlLFxuICAgIHJlc3VsdDogV2ViR0xUZXh0dXJlLCByZXN1bHRTaGFwZVJvd0NvbDogW251bWJlciwgbnVtYmVyXSkge1xuICBncGdwdS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlKFxuICAgICAgcmVzdWx0LCByZXN1bHRTaGFwZVJvd0NvbFswXSwgcmVzdWx0U2hhcGVSb3dDb2xbMV0pO1xuICBncGdwdS5zZXRQcm9ncmFtKHByb2dyYW0pO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoeCwgJ3gnLCAwKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBSZWR1Y2VTdW1Qcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICBwYXJhbXM6IEFycmF5PHt9PiA9IFtdO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgYVNpemU6IG51bWJlcikge1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHN1bSA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2FTaXplfTsgaSsrKSB7XG4gICAgICAgICAgc3VtICs9IGdldEFGbGF0KGZsb2F0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoc3VtKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVDb250ZXh0fSBmcm9tICcuL2dwZ3B1X2NvbnRleHQnO1xuXG5pbXBvcnQgKiBhcyB3ZWJnbF91dGlsIGZyb20gJy4vd2ViZ2xfdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJSR0JTaGFkZXIoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgZGVzdGluYXRpb25XaWR0aDogbnVtYmVyKTogV2ViR0xQcm9ncmFtIHtcbiAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHNvdXJjZTtcbiAgICB2YXJ5aW5nIHZlYzIgcmVzdWx0VVY7XG5cbiAgICBjb25zdCBmbG9hdCBkZXN0aW5hdGlvbldpZHRoID0gJHtkZXN0aW5hdGlvbldpZHRofS4wO1xuICAgIGNvbnN0IGZsb2F0IGEgPSAxLjA7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBmbG9hdCB4ciA9IGZsb29yKHJlc3VsdFVWLnMgKiBkZXN0aW5hdGlvbldpZHRoKSAqIDMuMDtcbiAgICAgIHZlYzMgeCA9IHhyICsgdmVjMygwLCAxLCAyKTtcblxuICAgICAgZmxvYXQgc291cmNlV2lkdGggPSBkZXN0aW5hdGlvbldpZHRoICogMy4wO1xuICAgICAgdmVjMyB1ID0gKHggKyAwLjUpIC8gc291cmNlV2lkdGg7XG4gICAgICBmbG9hdCB2ID0gMS4wIC0gcmVzdWx0VVYudDtcblxuICAgICAgZmxvYXQgciA9IHRleHR1cmUyRChzb3VyY2UsIHZlYzIodVswXSwgdikpLnI7XG4gICAgICBmbG9hdCBnID0gdGV4dHVyZTJEKHNvdXJjZSwgdmVjMih1WzFdLCB2KSkucjtcbiAgICAgIGZsb2F0IGIgPSB0ZXh0dXJlMkQoc291cmNlLCB2ZWMyKHVbMl0sIHYpKS5yO1xuXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHIsIGcsIGIsIGEpO1xuICAgIH1gO1xuXG4gIHJldHVybiBncGdwdS5jcmVhdGVQcm9ncmFtKGZyYWdtZW50U2hhZGVyU291cmNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRvQ2FudmFzKFxuICAgIGdwZ3B1OiBHUEdQVUNvbnRleHQsIHJlbmRlclNoYWRlcjogV2ViR0xQcm9ncmFtLCBzb3VyY2VUZXg6IFdlYkdMVGV4dHVyZSkge1xuICB3ZWJnbF91dGlsLmJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdwZ3B1LmdsKTtcbiAgcmVuZGVyVG9GcmFtZWJ1ZmZlcihncGdwdSwgcmVuZGVyU2hhZGVyLCBzb3VyY2VUZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVG9GcmFtZWJ1ZmZlcihcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCByZW5kZXJTaGFkZXI6IFdlYkdMUHJvZ3JhbSwgc291cmNlVGV4OiBXZWJHTFRleHR1cmUpIHtcbiAgZ3BncHUuc2V0UHJvZ3JhbShyZW5kZXJTaGFkZXIpO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoc291cmNlVGV4LCAnc291cmNlJywgMCk7XG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKCk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hdHJpeEE7XG4gICAgdW5pZm9ybSB2ZWMyIGlucHV0RGltQ1I7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc3VsdERpbUNSO1xuICAgIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiByZXN1bHRDUiA9IGZsb29yKHJlc3VsdFVWICogcmVzdWx0RGltQ1IpO1xuICAgICAgLy8gaW5kZXhJbkZsYXQgPSByb3cgKiBzdHJpZGUgKyBjb2x1bW4sIHdoZXJlIHN0cmlkZSA9PSBudW1PdXRwdXRDb2x1bW5zXG4gICAgICBmbG9hdCBpbmRleEluRmxhdCA9IHJlc3VsdENSLnkgKiByZXN1bHREaW1DUi54ICsgcmVzdWx0Q1IueDtcblxuICAgICAgdmVjMiBpbnB1dENSID0gdmVjMihcbiAgICAgICAgbW9kKGluZGV4SW5GbGF0LCBpbnB1dERpbUNSLngpLCAvLyBjb2wgPSBpbmRleEluRmxhdCAlIG51bUlucHV0Q29sdW1uc1xuICAgICAgICBmbG9vcihpbmRleEluRmxhdCAvIGlucHV0RGltQ1IueCkgLy8gcm93ID0gaW5kZXhJbkZsYXQgLyBudW1JbnB1dENvbHVtbnNcbiAgICAgICkgKyBoYWxmQ1I7XG5cbiAgICAgIHZlYzIgaW5wdXRVViA9IGlucHV0Q1IgLyBpbnB1dERpbUNSO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKG1hdHJpeEEsIGlucHV0VVYpO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzaGFwZShcbiAgICBncGdwdTogR1BHUFVDb250ZXh0LCByZXNoYXBlUHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBhOiBXZWJHTFRleHR1cmUsXG4gICAgYU51bVJvd3M6IG51bWJlciwgYU51bUNvbHM6IG51bWJlciwgcmVzdWx0OiBXZWJHTFRleHR1cmUsXG4gICAgcmVzdWx0TnVtUm93czogbnVtYmVyLCByZXN1bHROdW1Db2xzOiBudW1iZXIpIHtcbiAgY29uc3QgaW5wdXRTaXplID0gYU51bVJvd3MgKiBhTnVtQ29scztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IHJlc3VsdE51bUNvbHMgKiByZXN1bHROdW1Sb3dzO1xuICB1dGlsLmFzc2VydChcbiAgICAgIGlucHV0U2l6ZSA9PT0gb3V0cHV0U2l6ZSxcbiAgICAgIGBUaGUgaW5wdXQgc2l6ZSAoJHtpbnB1dFNpemV9KSBhbmQgb3V0cHV0IHNpemUgKCR7b3V0cHV0U2l6ZX0pIGAgK1xuICAgICAgICAgIGBtdXN0IG1hdGNoYCk7XG5cbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShyZXN1bHQsIHJlc3VsdE51bVJvd3MsIHJlc3VsdE51bUNvbHMpO1xuICBncGdwdS5zZXRQcm9ncmFtKHJlc2hhcGVQcm9ncmFtKTtcbiAgZ3BncHUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlKGEsICdtYXRyaXhBJywgMCk7XG5cbiAgY29uc3QgaW5wdXREaW1DUkxvY2F0aW9uID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uKCdpbnB1dERpbUNSJyk7XG4gIGdwZ3B1LmdsLnVuaWZvcm0yZihpbnB1dERpbUNSTG9jYXRpb24sIGFOdW1Db2xzLCBhTnVtUm93cyk7XG5cbiAgY29uc3QgcmVzdWx0RGltQ1JMb2NhdGlvbiA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbigncmVzdWx0RGltQ1InKTtcbiAgZ3BncHUuZ2wudW5pZm9ybTJmKHJlc3VsdERpbUNSTG9jYXRpb24sIHJlc3VsdE51bUNvbHMsIHJlc3VsdE51bVJvd3MpO1xuXG4gIGdwZ3B1LmV4ZWN1dGVQcm9ncmFtKCk7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9jb252X3V0aWwnO1xuXG5pbXBvcnQge0dQR1BVQ29udGV4dH0gZnJvbSAnLi9ncGdwdV9jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZyYWdtZW50U2hhZGVyU291cmNlKFxuICAgIGlucHV0U2hhcGVSQ0Q6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBvdXRwdXREaW1lbnNpb25zUm93Q29sOiBbbnVtYmVyLCBudW1iZXJdLCBhbGlnbkNvcm5lcnM6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCBkZXB0aCA9IGlucHV0U2hhcGVSQ0RbMl07XG5cbiAgY29uc3QgaW5wdXRUZXhTaGFwZVJDID0gY29udl91dGlsLmNvbXB1dGVUZXhTaGFwZUZyb20zRChpbnB1dFNoYXBlUkNEKTtcblxuICBjb25zdCBlZmZlY3RpdmVJbnB1dFNoYXBlUkNEID0gYWxpZ25Db3JuZXJzID9cbiAgICAgIFtpbnB1dFNoYXBlUkNEWzBdIC0gMSwgaW5wdXRTaGFwZVJDRFsxXSAtIDEsIGRlcHRoXSA6XG4gICAgICBpbnB1dFNoYXBlUkNEO1xuXG4gIGNvbnN0IGVmZmVjdGl2ZU91dHB1dFNoYXBlUkNEID0gYWxpZ25Db3JuZXJzID9cbiAgICAgIFtvdXRwdXREaW1lbnNpb25zUm93Q29sWzBdIC0gMSwgb3V0cHV0RGltZW5zaW9uc1Jvd0NvbFsxXSAtIDEsIGRlcHRoXSA6XG4gICAgICBbb3V0cHV0RGltZW5zaW9uc1Jvd0NvbFswXSwgb3V0cHV0RGltZW5zaW9uc1Jvd0NvbFsxXSwgZGVwdGhdO1xuXG4gIHJldHVybiBgXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hdHJpeEE7XG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XG5cbiAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVDUiA9IHZlYzIoJHtpbnB1dFNoYXBlUkNEWzFdfSwgJHtpbnB1dFNoYXBlUkNEWzBdfSk7XG4gICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlVGV4Q1IgPSB2ZWMyKFxuICAgICAgICAke2lucHV0VGV4U2hhcGVSQ1sxXX0sICR7aW5wdXRUZXhTaGFwZVJDWzBdfSk7XG5cbiAgICBjb25zdCB2ZWMyIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvQ1IgPSB2ZWMyKFxuICAgICAgICAke2VmZmVjdGl2ZUlucHV0U2hhcGVSQ0RbMV0gLyBlZmZlY3RpdmVPdXRwdXRTaGFwZVJDRFsxXX0sXG4gICAgICAgICR7ZWZmZWN0aXZlSW5wdXRTaGFwZVJDRFswXSAvIGVmZmVjdGl2ZU91dHB1dFNoYXBlUkNEWzBdfSk7XG5cbiAgICBmbG9hdCBzYW1wbGVJbnB1dChmbG9hdCBjb2wsIGZsb2F0IHJvdywgZmxvYXQgZCkge1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCAqICR7ZGVwdGh9LjAgKyBkLCByb3cpICsgaGFsZkNSKSAvIGlucHV0U2hhcGVUZXhDUjtcbiAgICAgIHJldHVybiB0ZXh0dXJlMkQobWF0cml4QSwgdXYpLnI7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgdmVjMiB5VGV4Q1IgPSBmbG9vcihnbF9GcmFnQ29vcmQueHkpO1xuXG4gICAgICAvLyBNYXAgZnJvbSAyRCAoeVRleFIsIHlUZXhDKSB0byAzRCAoeVIsIHlDLCBkKS5cbiAgICAgIHZlYzIgeUNSID0gdmVjMihmbG9vcih5VGV4Q1IueCAvICR7ZGVwdGh9LjApLCB5VGV4Q1IueSk7XG4gICAgICBmbG9hdCBkID0gbW9kKHlUZXhDUi54LCAke2RlcHRofS4wKTtcblxuICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXG4gICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleENSID0geUNSICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9DUjtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXG4gICAgICB2ZWMyIHNvdXJjZUZsb29yQ1IgPSBmbG9vcihzb3VyY2VGcmFjSW5kZXhDUik7XG4gICAgICB2ZWMyIHNvdXJjZUNlaWxDUiA9IG1pbihpbnB1dFNoYXBlQ1IgLSAxLjAsIGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcblxuICAgICAgZmxvYXQgdG9wTGVmdCA9IHNhbXBsZUlucHV0KHNvdXJjZUZsb29yQ1JbMF0sIHNvdXJjZUZsb29yQ1JbMV0sIGQpO1xuICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IHNhbXBsZUlucHV0KHNvdXJjZUZsb29yQ1JbMF0sIHNvdXJjZUNlaWxDUlsxXSwgZCk7XG4gICAgICBmbG9hdCB0b3BSaWdodCA9IHNhbXBsZUlucHV0KHNvdXJjZUNlaWxDUlswXSwgc291cmNlRmxvb3JDUlsxXSwgZCk7XG4gICAgICBmbG9hdCBib3R0b21SaWdodCA9IHNhbXBsZUlucHV0KHNvdXJjZUNlaWxDUlswXSwgc291cmNlQ2VpbENSWzFdLCBkKTtcblxuICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHNvdXJjZUZsb29yQ1I7XG5cbiAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNDUlswXTtcbiAgICAgIGZsb2F0IGJvdHRvbSA9IGJvdHRvbUxlZnQgKyAoYm90dG9tUmlnaHQgLSBib3R0b21MZWZ0KSAqIGZyYWNDUlswXTtcbiAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjQ1JbMV07XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobmV3VmFsdWUsIDAuMCwgMC4wLCAwLjApO1xuICAgIH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzaXplQmlsaW5lYXIoXG4gICAgZ3BncHU6IEdQR1BVQ29udGV4dCwgcmVzaXplQmlsaW5lYXJQcm9ncmFtOiBXZWJHTFByb2dyYW0sIGE6IFdlYkdMVGV4dHVyZSxcbiAgICByZXN1bHQ6IFdlYkdMVGV4dHVyZSwgcmVzdWx0U2hhcGVSb3dDb2w6IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShcbiAgICAgIHJlc3VsdCwgcmVzdWx0U2hhcGVSb3dDb2xbMF0sIHJlc3VsdFNoYXBlUm93Q29sWzFdKTtcbiAgZ3BncHUuc2V0UHJvZ3JhbShyZXNpemVCaWxpbmVhclByb2dyYW0pO1xuICBncGdwdS5zZXRJbnB1dE1hdHJpeFRleHR1cmUoYSwgJ21hdHJpeEEnLCAwKTtcbiAgZ3BncHUuZXhlY3V0ZVByb2dyYW0oKTtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcblxuZXhwb3J0IHR5cGUgU2hhcGVJbmZvID0ge1xuICBsb2dpY2FsU2hhcGU6IG51bWJlcltdLFxuICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXTtcbn07XG5cbmV4cG9ydCB0eXBlIElucHV0SW5mbyA9IHtcbiAgbmFtZTogc3RyaW5nLFxuICBzaGFwZUluZm86IFNoYXBlSW5mb1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTaGFkZXIoaW5wdXRzSW5mbzogSW5wdXRJbmZvW10sIG91dHB1dFNoYXBlOiBTaGFwZUluZm8sXG4gICAgdXNlckNvZGU6IHN0cmluZywgYnJvYWRjYXN0OiBib29sZWFuKTogc3RyaW5nIHtcbiAgY29uc3QgaW5wdXRQcmVmaXhTbmlwcGV0ID1cbiAgICAgIGlucHV0c0luZm8ubWFwKHggPT4gYHVuaWZvcm0gc2FtcGxlcjJEICR7eC5uYW1lfTtgKS5qb2luKCdcXG4nKTtcbiAgY29uc3QgaW5wdXRTYW1wbGluZ1NuaXBwZXQgPVxuICAgICAgaW5wdXRzSW5mby5tYXAoeCA9PiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldCh4LCBvdXRwdXRTaGFwZSwgYnJvYWRjYXN0KSlcbiAgICAgICAgICAuam9pbignXFxuJyk7XG4gIGNvbnN0IG91dFRleFNoYXBlID0gb3V0cHV0U2hhcGUudGV4U2hhcGU7XG4gIGNvbnN0IG91dHB1dFNhbXBsaW5nU25pcHBldCA9XG4gICAgICBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQob3V0cHV0U2hhcGUubG9naWNhbFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gIGNvbnN0IHNvdXJjZSA9IFtcbiAgICBTSEFERVJfUFJFRklYLCBpbnB1dFByZWZpeFNuaXBwZXQsIFNBTVBMRV8xRF9TTklQUEVULCBTQU1QTEVfMkRfU05JUFBFVCxcbiAgICBTQU1QTEVfM0RfU05JUFBFVCwgU0FNUExFXzREX1NOSVBQRVQsIGlucHV0U2FtcGxpbmdTbmlwcGV0LFxuICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCwgdXNlckNvZGVcbiAgXS5qb2luKCdcXG4nKTtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5wdXRTYW1wbGluZ1NuaXBwZXQoXG4gICAgaW5JbmZvOiBJbnB1dEluZm8sIG91dFNoYXBlSW5mbzogU2hhcGVJbmZvLCBicm9hZGNhc3Q6IGJvb2xlYW4pIHtcbiAgY29uc3Qgc2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgY29uc3QgdGV4U2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICBjb25zdCBvdXRUZXhTaGFwZSA9IG91dFNoYXBlSW5mby50ZXhTaGFwZTtcblxuICBsZXQgcmVzID0gJyc7XG4gIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmVzICs9IGdldFNhbXBsZXJTY2FsYXIoaW5JbmZvLm5hbWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVzICs9IGdldFNhbXBsZXIxRChpbkluZm8ubmFtZSwgdGV4U2hhcGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcmVzICs9IGdldFNhbXBsZXIyRChpbkluZm8ubmFtZSwgc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgdGV4U2hhcGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgcmVzICs9IGdldFNhbXBsZXIzRChcbiAgICAgICAgICBpbkluZm8ubmFtZSwgc2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICByZXMgKz0gZ2V0U2FtcGxlcjREKFxuICAgICAgICAgIGluSW5mby5uYW1lLCBzaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtzaGFwZS5sZW5ndGh9LUQgaW5wdXQgc2FtcGxpbmdgICtcbiAgICAgICAgICBgIGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gIH1cbiAgLy8gSWYgaW5wdXQgYW5kIG91dHB1dCBoYXZlIG1hdGNoaW5nIGxvZ2ljYWwgc2hhcGVzLCBhZGRcbiAgLy8gZ2V0VGV4TmFtZUF0T3V0Q29vcmQoKSBtZXRob2QgdGhhdCBzYW1wbGVzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZVxuICAvLyBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gIGlmIChicm9hZGNhc3QgfHwgdXRpbC5hcnJheXNFcXVhbChcbiAgICAgICAgICBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSkpIHtcbiAgICByZXMgKz1cbiAgICAgICAgZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGluSW5mby5uYW1lLCB0ZXhTaGFwZSwgb3V0VGV4U2hhcGUsIGJyb2FkY2FzdCk7XG4gIH1cbiAgcmVzICs9IGdldFNhbXBsZXJGbGF0KGluSW5mby5uYW1lLCB0ZXhTaGFwZSk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldE91dHB1dFNhbXBsaW5nU25pcHBldChcbiAgICBvdXRTaGFwZTogbnVtYmVyW10sIG91dFRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBEb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY2FsbCBnZXRPdXRwdXRDb29yZHMoKSB3aGVuIG91dHB1dCBpcyBzY2FsYXIuXG4gICAgICByZXR1cm4gJyc7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGdldE91dHB1dDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIG91dFRleFNoYXBlKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZ2V0T3V0cHV0NERDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICAgIG91dFRleFNoYXBlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke291dFNoYXBlLmxlbmd0aH0tRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5jb25zdCBTSEFERVJfUFJFRklYID0gYFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gIHZhcnlpbmcgdmVjMiByZXN1bHRVVjtcbiAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcblxuICB2b2lkIHNldE91dHB1dChmbG9hdCB2YWwpIHtcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XG4gIH1cblxuICBib29sIGlzTmFOKGZsb2F0IHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gdmFsID8gZmFsc2UgOiB0cnVlO1xuICB9XG5gO1xuXG5jb25zdCBTQU1QTEVfMURfU05JUFBFVCA9IGBcbiAgZmxvYXQgc2FtcGxlMUQoc2FtcGxlcjJEIHRleHR1cmUsIGZsb2F0IHRleE51bVIsIGZsb2F0IHRleE51bUMsIGZsb2F0IGluZGV4KSB7XG4gICAgZmxvYXQgdGV4UiA9IGZsb29yKGluZGV4IC8gdGV4TnVtQyk7XG4gICAgZmxvYXQgdGV4QyA9IG1vZChpbmRleCwgdGV4TnVtQyk7XG4gICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcbiAgfVxuYDtcblxuY29uc3QgU0FNUExFXzJEX1NOSVBQRVQgPSBgXG4gIGZsb2F0IHNhbXBsZTJEKHNhbXBsZXIyRCB0ZXh0dXJlLCBmbG9hdCB0ZXhOdW1SLCBmbG9hdCB0ZXhOdW1DLCBmbG9hdCBudW1DLFxuICAgICAgZmxvYXQgcm93LCBmbG9hdCBjb2wpIHtcbiAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMyKHJvdywgY29sKSwgdmVjMihudW1DLCAxLjApKTtcbiAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyB0ZXhOdW1DKTtcbiAgICBmbG9hdCB0ZXhDID0gbW9kKGluZGV4LCB0ZXhOdW1DKTtcbiAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xuICB9XG5gO1xuXG5jb25zdCBTQU1QTEVfM0RfU05JUFBFVCA9IGBcbiAgZmxvYXQgc2FtcGxlM0Qoc2FtcGxlcjJEIHRleHR1cmUsIGZsb2F0IHRleE51bVIsIGZsb2F0IHRleE51bUMsIGZsb2F0IHN0cmlkZTAsXG4gICAgICBmbG9hdCBzdHJpZGUxLCBmbG9hdCByb3csIGZsb2F0IGNvbCwgZmxvYXQgZGVwdGgpIHtcbiAgICBmbG9hdCBpbmRleCA9IGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksIHZlYzMoc3RyaWRlMCwgc3RyaWRlMSwgMS4wKSk7XG4gICAgZmxvYXQgdGV4UiA9IGZsb29yKGluZGV4IC8gdGV4TnVtQyk7XG4gICAgZmxvYXQgdGV4QyA9IG1vZChpbmRleCwgdGV4TnVtQyk7XG4gICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcbiAgfVxuYDtcblxuY29uc3QgU0FNUExFXzREX1NOSVBQRVQgPSBgXG4gIGZsb2F0IHNhbXBsZTREKHNhbXBsZXIyRCB0ZXh0dXJlLCBmbG9hdCB0ZXhOdW1SLCBmbG9hdCB0ZXhOdW1DLCBmbG9hdCBzdHJpZGUwLFxuICAgICAgZmxvYXQgc3RyaWRlMSwgZmxvYXQgc3RyaWRlMiwgZmxvYXQgcm93LCBmbG9hdCBjb2wsIGZsb2F0IGRlcHRoLFxuICAgICAgZmxvYXQgZGVwdGgyKSB7XG4gICAgZmxvYXQgaW5kZXggPSBkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXG4gICAgICAgICAgICAgICAgICAgICAgdmVjNChzdHJpZGUwLCBzdHJpZGUxLCBzdHJpZGUyLCAxLjApKTtcbiAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyB0ZXhOdW1DKTtcbiAgICBmbG9hdCB0ZXhDID0gbW9kKGluZGV4LCB0ZXhOdW1DKTtcbiAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICByZXR1cm4gdGV4dHVyZTJEKHRleHR1cmUsIHV2KS5yO1xuICB9XG5gO1xuXG5mdW5jdGlvbiBnZXRPdXRwdXQxRENvb3JkcyhcbiAgICBzaGFwZTogW251bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGZsb29yKGdsX0ZyYWdDb29yZC54KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIGlmICh0ZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgIHJldHVybiBgXG4gICAgICBmbG9hdCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiBmbG9vcihnbF9GcmFnQ29vcmQueSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgIHZlYzIgcmVzVGV4UkMgPSBmbG9vcihnbF9GcmFnQ29vcmQueXgpO1xuICAgICAgcmV0dXJuIGRvdChyZXNUZXhSQywgdmVjMigke3RleFNoYXBlWzFdfS4wLCAxLjApKTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldE91dHB1dDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdO1xuICByZXR1cm4gYFxuICAgIHZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgdmVjMiByZXNUZXhSQyA9IGZsb29yKGdsX0ZyYWdDb29yZC55eCk7XG4gICAgICBmbG9hdCBpbmRleCA9IGRvdChyZXNUZXhSQywgdmVjMigke3RleFNoYXBlWzFdfS4wLCAxLjApKTtcbiAgICAgIGZsb2F0IHIgPSBmbG9vcihpbmRleCAvICR7c3RyaWRlMH0uMCk7XG4gICAgICBpbmRleCAtPSByICogJHtzdHJpZGUwfS4wO1xuICAgICAgZmxvYXQgYyA9IGZsb29yKGluZGV4IC8gJHtzdHJpZGUxfS4wKTtcbiAgICAgIGZsb2F0IGQgPSBtb2QoaW5kZXgsICR7c3RyaWRlMX0uMCk7XG4gICAgICByZXR1cm4gdmVjMyhyLCBjLCBkKTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldE91dHB1dDREQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM107XG4gIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gIHJldHVybiBgXG4gICAgdmVjNCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICB2ZWMyIHJlc1RleFJDID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnl4KTtcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHJlc1RleFJDLCB2ZWMyKCR7dGV4U2hhcGVbMV19LjAsIDEuMCkpO1xuXG4gICAgICBmbG9hdCByID0gZmxvb3IoaW5kZXggLyAke3N0cmlkZTB9LjApO1xuICAgICAgaW5kZXggLT0gciAqICR7c3RyaWRlMH0uMDtcblxuICAgICAgZmxvYXQgYyA9IGZsb29yKGluZGV4IC8gJHtzdHJpZGUxfS4wKTtcbiAgICAgIGluZGV4IC09IGMgKiAke3N0cmlkZTF9LjA7XG5cbiAgICAgIGZsb2F0IGQgPSBmbG9vcihpbmRleCAvICR7c3RyaWRlMn0uMCk7XG4gICAgICBmbG9hdCBkMiA9IG1vZChpbmRleCwgJHtzdHJpZGUyfS4wKTtcblxuICAgICAgcmV0dXJuIHZlYzQociwgYywgZCwgZDIpO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0cHV0MkRDb29yZHMoXG4gICAgc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgIHJldHVybiBgXG4gICAgICB2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgcmV0dXJuIGZsb29yKGdsX0ZyYWdDb29yZC55eCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIHZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgdmVjMiByZXNUZXhSQyA9IGZsb29yKGdsX0ZyYWdDb29yZC55eCk7XG4gICAgICBmbG9hdCBpbmRleCA9IGRvdChyZXNUZXhSQywgdmVjMigke3RleFNoYXBlWzFdfS4wLCAxLjApKTtcbiAgICAgIGZsb2F0IHIgPSBmbG9vcihpbmRleCAvICR7c2hhcGVbMV19LjApO1xuICAgICAgZmxvYXQgYyA9IG1vZChpbmRleCwgJHtzaGFwZVsxXX0uMCk7XG4gICAgICByZXR1cm4gdmVjMihyLCBjKTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXJTY2FsYXIodGV4TmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICByZXR1cm4gYFxuICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleE5hbWV9LCBoYWxmQ1IpLnI7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRTYW1wbGVyMUQoXG4gICAgdGV4TmFtZTogc3RyaW5nLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgY29uc3QgdFIgPSB0ZXhTaGFwZVswXTtcbiAgY29uc3QgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgaWYgKHRleFNoYXBlWzBdID09PSAxICYmIHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgaGFsZkNSKS5yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgaWYgKHRleFNoYXBlWzFdID09PSAxKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGluZGV4ICsgMC41KSAvICR7dFJ9LjApO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHV2KS5yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgaWYgKHRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IGluZGV4KSB7XG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyAke3RDfS4wLCAwLjUpO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHV2KS5yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCBpbmRleCkge1xuICAgICAgcmV0dXJuIHNhbXBsZTFEKCR7dGV4TmFtZX0sICR7dFJ9LjAsICR7dEN9LjAsIGluZGV4KTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXIzRChcbiAgICB0ZXhOYW1lOiBzdHJpbmcsIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gIGNvbnN0IHRSID0gdGV4U2hhcGVbMF07XG4gIGNvbnN0IHRDID0gdGV4U2hhcGVbMV07XG4gIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHNoYXBlWzJdO1xuICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl07XG4gIHJldHVybiBgXG4gICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgcm93LCBmbG9hdCBjb2wsIGZsb2F0IGRlcHRoKSB7XG4gICAgICByZXR1cm4gc2FtcGxlM0QoJHt0ZXhOYW1lfSwgJHt0Un0uMCwgJHt0Q30uMCwgJHtzdHJpZGUwfS4wLCAke3N0cmlkZTF9LjAsXG4gICAgICAgICAgcm93LCBjb2wsIGRlcHRoKTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXI0RChcbiAgICB0ZXhOYW1lOiBzdHJpbmcsIHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgY29uc3QgdFIgPSB0ZXhTaGFwZVswXTtcbiAgY29uc3QgdEMgPSB0ZXhTaGFwZVsxXTtcbiAgY29uc3Qgc3RyaWRlMiA9IHNoYXBlWzNdO1xuICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gIHJldHVybiBgXG4gIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IHJvdywgZmxvYXQgY29sLCBmbG9hdCBkZXB0aCwgZmxvYXQgZGVwdGgyKSB7XG4gICAgcmV0dXJuIHNhbXBsZTREKCR7dGV4TmFtZX0sICR7dFJ9LjAsICR7dEN9LjAsICR7c3RyaWRlMH0uMCwgJHtzdHJpZGUxfS4wLFxuICAgICAgICAke3N0cmlkZTJ9LjAsIHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKTtcbiAgfVxuYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlcjJEKFxuICAgIHRleE5hbWU6IHN0cmluZywgc2hhcGU6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gIGNvbnN0IHRSID0gdGV4U2hhcGVbMF07XG4gIGNvbnN0IHRDID0gdGV4U2hhcGVbMV07XG4gIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgcm93LCBmbG9hdCBjb2wpIHtcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKCR7dEN9LjAsICR7dFJ9LjApO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHV2KS5yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIGBcbiAgICBmbG9hdCAke2Z1bmNOYW1lfShmbG9hdCByb3csIGZsb2F0IGNvbCkge1xuICAgICAgcmV0dXJuIHNhbXBsZTJEKCR7dGV4TmFtZX0sICR7dFJ9LjAsICR7dEN9LjAsICR7c2hhcGVbMV19LjAsIHJvdywgY29sKTtcbiAgICB9XG4gIGA7XG59XG5cbmZ1bmN0aW9uIGdldFNhbXBsZXJGbGF0KHRleE5hbWU6IHN0cmluZywgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSkgK1xuICAgICAgJ0ZsYXQnO1xuICBjb25zdCB0TnVtUiA9IHRleFNoYXBlWzBdO1xuICBjb25zdCB0TnVtQyA9IHRleFNoYXBlWzFdO1xuICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleE5hbWV9LCBoYWxmQ1IpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICBpZiAodE51bUMgPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoaW5kZXggKyAwLjUpIC8gJHt0TnVtUn0uMCk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICBpZiAodE51bVIgPT09IDEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oZmxvYXQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvICR7dE51bUN9LjAsIDAuNSk7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQoJHt0ZXhOYW1lfSwgdXYpLnI7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYFxuICAgIGZsb2F0ICR7ZnVuY05hbWV9KGZsb2F0IGluZGV4KSB7XG4gICAgICBmbG9hdCB0ZXhSID0gZmxvb3IoaW5kZXggLyAke3ROdW1DfS4wKTtcbiAgICAgIGZsb2F0IHRleEMgPSBtb2QoaW5kZXgsICR7dE51bUN9LjApO1xuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoJHt0TnVtQ30uMCwgJHt0TnVtUn0uMCk7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHV2KS5yO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKHRleE5hbWU6IHN0cmluZywgaW5UZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSxcbiAgICBvdXRUZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSwgYnJvYWRjYXN0OiBib29sZWFuKSB7XG4gIGNvbnN0IGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKSArXG4gICAgJ0F0T3V0Q29vcmRzJztcbiAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHJlc3VsdFVWKS5yO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbiAgY29uc3QgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGluVGV4U2hhcGUpO1xuICBjb25zdCBicm9hZGNhc3RTbmlwcGV0ID0gYnJvYWRjYXN0ID8gYGluZGV4ID0gbW9kKGluZGV4LCAke2luU2l6ZX0uMCk7YCA6ICcnO1xuXG4gIHJldHVybiBgXG4gICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICB2ZWMyIHJlc1RleFJDID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnl4KTtcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHJlc1RleFJDLCB2ZWMyKCR7b3V0VGV4U2hhcGVbMV19LjAsIDEuMCkpO1xuICAgICAgJHticm9hZGNhc3RTbmlwcGV0fVxuICAgICAgZmxvYXQgdGV4UiA9IGZsb29yKGluZGV4IC8gJHtpblRleFNoYXBlWzFdfS4wKTtcbiAgICAgIGZsb2F0IHRleEMgPSBtb2QoaW5kZXgsICR7aW5UZXhTaGFwZVsxXX0uMCk7XG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cbiAgICAgICAgICAgICAgICAgdmVjMigke2luVGV4U2hhcGVbMV19LjAsICR7aW5UZXhTaGFwZVswXX0uMCk7XG4gICAgICByZXR1cm4gdGV4dHVyZTJEKCR7dGV4TmFtZX0sIHV2KS5yO1xuICAgIH1cbiAgYDtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQoXG4gICAgcm93czogbnVtYmVyLCBjb2x1bW5zOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgcmV0dXJuIFtjb2x1bW5zLCByb3dzXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUoXG4gICAgbWF0cml4U2l6ZTogbnVtYmVyLCBjaGFubmVsc1BlclRleHR1cmU6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBtYXRyaXhTaXplICogY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChcbiAgICByb3dzOiBudW1iZXIsIGNvbHVtbnM6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICByZXR1cm4gW2NvbHVtbnMgKiA0LCByb3dzXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdHJpeFNpemVGcm9tVW5wYWNrZWRBcnJheVNpemUoXG4gICAgdW5wYWNrZWRTaXplOiBudW1iZXIsIGNoYW5uZWxzUGVyVGV4dHVyZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHVucGFja2VkU2l6ZSAlIGNoYW5uZWxzUGVyVGV4dHVyZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3VucGFja2VkU2l6ZSAoJyArIHVucGFja2VkU2l6ZSArICcpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAnICtcbiAgICAgICAgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWRTaXplIC8gY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTWF0cml4VG9VbnBhY2tlZEFycmF5KFxuICAgIG1hdHJpeDogRmxvYXQzMkFycmF5LCB1bnBhY2tlZEFycmF5OiBGbG9hdDMyQXJyYXksXG4gICAgY2hhbm5lbHNQZXJUZXh0dXJlOiBudW1iZXIpIHtcbiAgY29uc3QgcmVxdWlyZWRTaXplID1cbiAgICAgIGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKTtcbiAgaWYgKHVucGFja2VkQXJyYXkubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndW5wYWNrZWRBcnJheSBsZW5ndGggKCcgKyB1bnBhY2tlZEFycmF5Lmxlbmd0aCArXG4gICAgICAgICcpIG11c3QgYmUgPj0gJyArIHJlcXVpcmVkU2l6ZSk7XG4gIH1cbiAgbGV0IGRzdCA9IDA7XG4gIGZvciAobGV0IHNyYyA9IDA7IHNyYyA8IG1hdHJpeC5sZW5ndGg7ICsrc3JjKSB7XG4gICAgdW5wYWNrZWRBcnJheVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgZHN0ICs9IGNoYW5uZWxzUGVyVGV4dHVyZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXkoXG4gICAgdW5wYWNrZWRBcnJheTogRmxvYXQzMkFycmF5LCBtYXRyaXg6IEZsb2F0MzJBcnJheSxcbiAgICBjaGFubmVsc1BlclRleHR1cmU6IG51bWJlcikge1xuICBjb25zdCByZXF1aXJlZFNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKFxuICAgICAgdW5wYWNrZWRBcnJheS5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbWF0cml4IGxlbmd0aCAoJyArIG1hdHJpeC5sZW5ndGggKyAnKSBtdXN0IGJlID49ICcgKyByZXF1aXJlZFNpemUpO1xuICB9XG4gIGxldCBkc3QgPSAwO1xuICBmb3IgKGxldCBzcmMgPSAwOyBzcmMgPCB1bnBhY2tlZEFycmF5Lmxlbmd0aDsgc3JjICs9IGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIG1hdHJpeFtkc3QrK10gPSB1bnBhY2tlZEFycmF5W3NyY107XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KFxuICAgIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIHJldHVybiBbTWF0aC5jZWlsKGNvbHVtbnMgLyAyKSwgTWF0aC5jZWlsKHJvd3MgLyAyKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKFxuICAgIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgW3csIGhdID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyk7XG4gIHJldHVybiB3ICogaCAqIDQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEoXG4gICAgbWF0cml4OiBGbG9hdDMyQXJyYXksIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLFxuICAgIHBhY2tlZFJHQkE6IEZsb2F0MzJBcnJheSkge1xuICBjb25zdCByZXF1aXJlZFNpemUgPSBnZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpO1xuICBpZiAocGFja2VkUkdCQS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdwYWNrZWRSR0JBIGxlbmd0aCAoJyArIHBhY2tlZFJHQkEubGVuZ3RoICtcbiAgICAgICAgJykgbXVzdCBiZSA+PSAnICsgcmVxdWlyZWRTaXplKTtcbiAgfVxuICAvKlxuICAgIFVucGFja2VkIG1hdHJpeCwgcm93LW1ham9yIG9yZGVyIGluIEZsb2F0MzJBcnJheVsxNl06ICBBIEIgQyBEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUgRiBHIEhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSSBKIEsgTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNIE4gTyBQXG5cbiAgICBQYWNrZWQgbWF0cml4LCAyeDIgUkdCQTMyIHRleHR1cmUgKG1lbW9yeSB2aWV3KTogICAgICAgQUJFRiBDREdIIElKTU4gS0xPUFxuXG4gICAgUGFja2VkIG1hdHJpeCwgMngyIFJHQkEzMiB0ZXh0dXJlIChtYXRyaXggdmlldyk6ICAgICAgIEFCfENEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVGfEdIXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tKy0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElKfEtMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1OfE9QXG4gICAqL1xuICBjb25zdCBbdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0XSA9XG4gICAgICBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKTtcbiAgY29uc3Qgb2RkV2lkdGggPSAoY29sdW1ucyAlIDIpID09PSAxO1xuICBjb25zdCBvZGRIZWlnaHQgPSAocm93cyAlIDIpID09PSAxO1xuICBjb25zdCB3aWR0aEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3IoY29sdW1ucyAvIDIpO1xuICBjb25zdCBoZWlnaHRJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKHJvd3MgLyAyKTtcblxuICAvLyBsb29wIG92ZXIgZnVsbCAyeDIgYmxvY2tzXG4gIHtcbiAgICBjb25zdCBkc3RTdHJpZGUgPSAob2RkV2lkdGggPyA0IDogMCk7XG4gICAgY29uc3Qgb25lUm93ID0gY29sdW1ucztcbiAgICBsZXQgZHN0ID0gMDtcbiAgICBmb3IgKGxldCBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICBjb25zdCBtYXRyaXhTcmNSb3cgPSAoYmxvY2tZICogMiAqIGNvbHVtbnMpO1xuICAgICAgZm9yIChsZXQgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeFNyY0NvbCA9IGJsb2NrWCAqIDI7XG4gICAgICAgIGNvbnN0IHNyYyA9IG1hdHJpeFNyY1JvdyArIG1hdHJpeFNyY0NvbDtcbiAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMV0gPSBtYXRyaXhbc3JjICsgMV07XG4gICAgICAgIHBhY2tlZFJHQkFbZHN0ICsgMl0gPSBtYXRyaXhbc3JjICsgb25lUm93XTtcbiAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAzXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3cgKyAxXTtcbiAgICAgICAgZHN0ICs9IDQ7XG4gICAgICB9XG4gICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxvb3AgZG93biBmaW5hbCBvZGQgY29sdW1uXG4gIGlmIChvZGRXaWR0aCkge1xuICAgIGxldCBzcmMgPSBjb2x1bW5zIC0gMTtcbiAgICBsZXQgZHN0ID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICBjb25zdCBzcmNTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICBjb25zdCBkc3RTdHJpZGUgPSB0ZXh0dXJlV2lkdGggKiA0O1xuICAgIGZvciAobGV0IGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBjb2x1bW5zXTtcbiAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxvb3AgYWNyb3NzIGZpbmFsIHJvd1xuICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgbGV0IHNyYyA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgIGxldCBkc3QgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICBmb3IgKGxldCBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgIHBhY2tlZFJHQkFbZHN0KytdID0gbWF0cml4W3NyYysrXTtcbiAgICAgIGRzdCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbGwgaW4gYm90dG9tLXJpZ2h0IHRleGVsXG4gIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF0gPSBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgcmV0dXJuIHBhY2tlZFJHQkE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQShcbiAgICBwYWNrZWRSR0JBOiBGbG9hdDMyQXJyYXksIHJvd3M6IG51bWJlciwgY29sdW1uczogbnVtYmVyLFxuICAgIG1hdHJpeDogRmxvYXQzMkFycmF5KTogRmxvYXQzMkFycmF5IHtcbiAgY29uc3QgcmVxdWlyZWRTaXplID0gcm93cyAqIGNvbHVtbnM7XG4gIGlmIChyZXF1aXJlZFNpemUgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbWF0cml4IGxlbmd0aCAoJyArIG1hdHJpeC5sZW5ndGggKyAnKSBtdXN0IGJlID49ICcgKyByZXF1aXJlZFNpemUpO1xuICB9XG4gIGNvbnN0IG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgY29uc3Qgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgY29uc3Qgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgY29uc3QgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gIGNvbnN0IFt0ZXh0dXJlV2lkdGgsIHRleHR1cmVIZWlnaHRdID1cbiAgICAgIGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpO1xuXG4gIC8vIGxvb3Agb3ZlciBmdWxsIDJ4MiBibG9ja3NcbiAge1xuICAgIGNvbnN0IHNyY1N0cmlkZSA9IG9kZFdpZHRoID8gNCA6IDA7XG4gICAgY29uc3QgZHN0U3RyaWRlID0gY29sdW1ucyArIChvZGRXaWR0aCA/IDEgOiAwKTtcbiAgICBsZXQgc3JjID0gMDtcbiAgICBsZXQgZHN0Um93MSA9IDA7XG4gICAgbGV0IGRzdFJvdzIgPSBjb2x1bW5zO1xuICAgIGZvciAobGV0IGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgIGZvciAobGV0IGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICBtYXRyaXhbZHN0Um93MisrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgfVxuICAgICAgc3JjICs9IHNyY1N0cmlkZTtcbiAgICAgIGRzdFJvdzEgKz0gZHN0U3RyaWRlO1xuICAgICAgZHN0Um93MiArPSBkc3RTdHJpZGU7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vcCBkb3duIGZpbmFsIGNvbHVtblxuICBpZiAob2RkV2lkdGgpIHtcbiAgICBsZXQgc3JjID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICBsZXQgZHN0ID0gY29sdW1ucyAtIDE7XG4gICAgY29uc3Qgc3JjU3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICBjb25zdCBkc3RTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICBmb3IgKGxldCBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICBtYXRyaXhbZHN0XSA9IHBhY2tlZFJHQkFbc3JjXTtcbiAgICAgIG1hdHJpeFtkc3QgKyBjb2x1bW5zXSA9IHBhY2tlZFJHQkFbc3JjICsgMl07XG4gICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICB9XG4gIH1cblxuICAvLyBsb29wIGFjcm9zcyBmaW5hbCByb3dcbiAgaWYgKG9kZEhlaWdodCkge1xuICAgIGxldCBzcmMgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICBsZXQgZHN0ID0gKHJvd3MgLSAxKSAqIGNvbHVtbnM7XG4gICAgZm9yIChsZXQgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICBtYXRyaXhbZHN0KytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICBzcmMgKz0gMjtcbiAgICB9XG4gIH1cblxuICAvLyBmaWxsIGluIGJvdHRvbS1yaWdodCBjZWxsXG4gIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdID0gcGFja2VkUkdCQVtwYWNrZWRSR0JBLmxlbmd0aCAtIDRdO1xuICB9XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHUEdQVUNvbnRleHR9IGZyb20gJy4vZ3BncHVfY29udGV4dCc7XG5cbmV4cG9ydCBjbGFzcyBUZXh0dXJlTWFuYWdlciB7XG4gIHByaXZhdGUgbnVtVXNlZFRleHR1cmVzID0gMDtcbiAgcHJpdmF0ZSBudW1GcmVlVGV4dHVyZXMgPSAwO1xuICBwcml2YXRlIGZyZWVUZXh0dXJlczoge1tzaGFwZTogc3RyaW5nXTogV2ViR0xUZXh0dXJlW119ID0ge307XG4gIHByaXZhdGUgbG9nRW5hYmxlZCA9IGZhbHNlO1xuICBwcml2YXRlIHVzZWRUZXh0dXJlQ291bnQ6IHtbc2hhcGU6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdwZ3B1OiBHUEdQVUNvbnRleHQpIHt9XG5cbiAgYWNxdWlyZVRleHR1cmUoc2hhcGVSQzogW251bWJlciwgbnVtYmVyXSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3Qgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUkMpO1xuICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgfVxuICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMudXNlZFRleHR1cmVDb3VudCkpIHtcbiAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0gPSAwO1xuICAgIH1cbiAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldKys7XG5cbiAgICBpZiAodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzLS07XG4gICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcysrO1xuICAgICAgdGhpcy5sb2coKTtcbiAgICAgIHJldHVybiB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0uc2hpZnQoKSE7XG4gICAgfVxuICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgdGhpcy5sb2coKTtcblxuICAgIHJldHVybiB0aGlzLmdwZ3B1LmNyZWF0ZU1hdHJpeFRleHR1cmUoc2hhcGVSQ1swXSwgc2hhcGVSQ1sxXSk7XG4gIH1cblxuICByZWxlYXNlVGV4dHVyZSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogdm9pZCB7XG4gICAgY29uc3Qgc2hhcGVLZXkgPSBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlKTtcbiAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLmZyZWVUZXh0dXJlcykpIHtcbiAgICAgIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ucHVzaCh0ZXh0dXJlKTtcbiAgICB0aGlzLm51bUZyZWVUZXh0dXJlcysrO1xuICAgIHRoaXMubnVtVXNlZFRleHR1cmVzLS07XG4gICAgdGhpcy51c2VkVGV4dHVyZUNvdW50W3NoYXBlS2V5XS0tO1xuICAgIHRoaXMubG9nKCk7XG4gIH1cblxuICBwcml2YXRlIGxvZygpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0b3RhbCA9IHRoaXMubnVtRnJlZVRleHR1cmVzICsgdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAgICdGcmVlL1VzZWQnLCB0aGlzLm51bUZyZWVUZXh0dXJlcyArICcgLyAnICsgdGhpcy5udW1Vc2VkVGV4dHVyZXMsXG4gICAgICAgIGAoJHt0b3RhbH0pYCk7XG4gIH1cblxuICBnZXROdW1Vc2VkVGV4dHVyZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXM7XG4gIH1cblxuICBnZXROdW1GcmVlVGV4dHVyZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5udW1GcmVlVGV4dHVyZXM7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3Qgc2hhcGUgaW4gdGhpcy5mcmVlVGV4dHVyZXMpIHtcbiAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlcy5oYXNPd25Qcm9wZXJ0eShzaGFwZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVdW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbDogW251bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyAnXycgKyBzaGFwZVJvd3NDb2xbMV07XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgZW51bSBVbmFyeU9wIHtcbiAgRVhQLCBMT0csIE5FRywgUkVMVSwgU0lHTU9JRCwgU1RFUCwgU0lOLCBUQU5IXG59XG5cbmV4cG9ydCBjbGFzcyBVbmFyeU9wUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgcGFyYW1zOiBBcnJheTx7fT47XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihhU2hhcGU6IG51bWJlcltdLCBvcDogVW5hcnlPcCkge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgdGhpcy5wYXJhbXMgPSBbb3BdO1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGZsb2F0IHYgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgJHtnZXRPcFNuaXBwZXQob3ApfVxuICAgICAgICBzZXRPdXRwdXQocik7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPcFNuaXBwZXQob3A6IFVuYXJ5T3ApIHtcbiAgc3dpdGNoKG9wKSB7XG4gICAgY2FzZSBVbmFyeU9wLkVYUDpcbiAgICAgIHJldHVybiAnZmxvYXQgciA9IGV4cCh2KTsnO1xuICAgIGNhc2UgVW5hcnlPcC5MT0c6XG4gICAgICByZXR1cm4gJ2Zsb2F0IHIgPSBsb2codik7JztcbiAgICBjYXNlIFVuYXJ5T3AuTkVHOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gLXY7JztcbiAgICBjYXNlIFVuYXJ5T3AuUkVMVTpcbiAgICAgIHJldHVybiAnZmxvYXQgciA9ICh2IDwgMC4wKSA/IDAuMCA6IHY7JztcbiAgICBjYXNlIFVuYXJ5T3AuU0lHTU9JRDpcbiAgICAgIHJldHVybiAnZmxvYXQgciA9IDEuMCAvICgxLjAgKyBleHAoLTEuMCAqIHYpKTsnO1xuICAgIGNhc2UgVW5hcnlPcC5TVEVQOlxuICAgICAgcmV0dXJuICdmbG9hdCByID0gKHYgPT0gdikgPyAodiA+IDAuMCA/IDEuMCA6IDAuMCkgOiB2Oyc7XG4gICAgY2FzZSBVbmFyeU9wLlNJTjpcbiAgICAgIHJldHVybiAnZmxvYXQgciA9IHNpbih2KTsnO1xuICAgIGNhc2UgVW5hcnlPcC5UQU5IOlxuICAgICAgcmV0dXJuIGBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh2KSk7XG4gICAgICAgICAgICAgIGZsb2F0IHIgPSBzaWduKHYpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtgO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIHVuYXJ5IG9wIHR5cGUgJyArIG9wKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5sZXQgVVNFX1dFQkdMMl9XSEVOX0FWQUlMQUJMRSA9IHRydWU7XG5sZXQgV0VCR0wyX0VOQUJMRUQ6IGJvb2xlYW58dW5kZWZpbmVkID0gbnVsbCE7XG5sZXQgTUFYX1RFWFRVUkVfU0laRTogbnVtYmVyID0gbnVsbCE7XG5cbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViR0xDb250ZXh0QXR0cmlidXRlcyB7XG4gIGFscGhhPzogYm9vbGVhbjtcbiAgYW50aWFsaWFzPzogYm9vbGVhbjtcbiAgcHJlbXVsdGlwbGllZEFscGhhPzogYm9vbGVhbjtcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyPzogYm9vbGVhbjtcbiAgZGVwdGg/OiBib29sZWFuO1xuICBzdGVuY2lsPzogYm9vbGVhbjtcbiAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViR0xMb3NlQ29udGV4dEV4dGVuc2lvbiB7IGxvc2VDb250ZXh0KCk6IHZvaWQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dChhdHRyaWJ1dGVzOiBXZWJHTENvbnRleHRBdHRyaWJ1dGVzKTpcbiAgICBXZWJHTFJlbmRlcmluZ0NvbnRleHQge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gMTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIHJldHVybiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG59XG5cbi8qKlxuICogRm9yY2UgdGhlIGxpYnJhcnkgdG8gcHJlZmVyIFdlYkdMIDEuMCBpbnN0ZWFkIG9mIFdlYkdMIDIuMCBldmVuIHdoZW4gV2ViR0xcbiAqIDIuMCBpcyBhdmFpbGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmZXJXZWJHTDEoKSB7XG4gIFVTRV9XRUJHTDJfV0hFTl9BVkFJTEFCTEUgPSBmYWxzZTtcbiAgV0VCR0wyX0VOQUJMRUQgPSBudWxsO1xufVxuXG4vKipcbiAqIFByZWZlciBXZWJHTCAyLjAgdG8gV2ViR0wgMS4wLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmZXJXZWJHTDIoKSB7XG4gIFVTRV9XRUJHTDJfV0hFTl9BVkFJTEFCTEUgPSB0cnVlO1xuICBXRUJHTDJfRU5BQkxFRCA9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdMMkVuYWJsZWQoKSB7XG4gIGlmICghVVNFX1dFQkdMMl9XSEVOX0FWQUlMQUJMRSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChXRUJHTDJfRU5BQkxFRCA9PSBudWxsKSB7XG4gICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGdsID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgV0VCR0wyX0VOQUJMRUQgPSB0cnVlO1xuXG4gICAgICBjb25zdCBsb3NlQ29udGV4dEV4dGVuc2lvbiA9XG4gICAgICAgICAgZ2V0RXh0ZW5zaW9uT3JUaHJvdyhcbiAgICAgICAgICAgICAgZ2wgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0LCAnV0VCR0xfbG9zZV9jb250ZXh0JykgYXNcbiAgICAgICAgICBXZWJHTExvc2VDb250ZXh0RXh0ZW5zaW9uO1xuICAgICAgbG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgV0VCR0wyX0VOQUJMRUQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdFQkdMMl9FTkFCTEVEO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhcbiAgICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICAgIGF0dHJpYnV0ZXM6IFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMpOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQge1xuICBsZXQgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgaWYgKGlzV2ViR0wyRW5hYmxlZCgpKSB7XG4gICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgYXR0cmlidXRlcykgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGdsID0gKGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnV0ZXMpIHx8XG4gICAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGF0dHJpYnV0ZXMpKSBhc1xuICAgICAgICBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gIH1cblxuICBpZiAoZ2wgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuJyk7XG4gIH1cbiAgcmV0dXJuIGdsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbEFuZENoZWNrPFQ+KGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGZ1bmM6ICgpID0+IFQpOiBUIHtcbiAgY29uc3QgcmV0dXJuVmFsdWUgPSBmdW5jKCk7XG4gIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubGV0IHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcoZW5hYmxlZDogYm9vbGVhbikge1xuICB3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQgPSBlbmFibGVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tXZWJHTEVycm9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcbiAgaWYgKHdlYkdMRGVidWdFcnJvckNoZWNraW5nRW5hYmxlZCkge1xuICAgIGNvbnN0IGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICBpZiAoZXJyb3IgIT09IGdsLk5PX0VSUk9SKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIEVycm9yOiAnICsgZ2V0V2ViR0xFcnJvck1lc3NhZ2UoZ2wsIGVycm9yKSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBzdGF0dXM6IG51bWJlcik6IHN0cmluZyB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBnbC5OT19FUlJPUjpcbiAgICAgIHJldHVybiAnTk9fRVJST1InO1xuICAgIGNhc2UgZ2wuSU5WQUxJRF9FTlVNOlxuICAgICAgcmV0dXJuICdJTlZBTElEX0VOVU0nO1xuICAgIGNhc2UgZ2wuSU5WQUxJRF9WQUxVRTpcbiAgICAgIHJldHVybiAnSU5WQUxJRF9WQUxVRSc7XG4gICAgY2FzZSBnbC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgIHJldHVybiAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgIGNhc2UgZ2wuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046XG4gICAgICByZXR1cm4gJ0lOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OJztcbiAgICBjYXNlIGdsLk9VVF9PRl9NRU1PUlk6XG4gICAgICByZXR1cm4gJ09VVF9PRl9NRU1PUlknO1xuICAgIGNhc2UgZ2wuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgcmV0dXJuICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ1Vua25vd24gZXJyb3IgY29kZSAnICsgc3RhdHVzO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb25PclRocm93KFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGV4dGVuc2lvbk5hbWU6IHN0cmluZyk6IHt9IHtcbiAgcmV0dXJuIHRocm93SWZOdWxsPHt9PihcbiAgICAgIGdsLCAoKSA9PiBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSksXG4gICAgICAnRXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdmVydGV4U2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlciB7XG4gIGNvbnN0IHZlcnRleFNoYWRlcjogV2ViR0xTaGFkZXIgPSB0aHJvd0lmTnVsbDxXZWJHTFNoYWRlcj4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpLFxuICAgICAgJ1VuYWJsZSB0byBjcmVhdGUgdmVydGV4IFdlYkdMU2hhZGVyLicpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSkpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKSk7XG4gIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuJyk7XG4gIH1cbiAgcmV0dXJuIHZlcnRleFNoYWRlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50U2hhZGVyKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGZyYWdtZW50U2hhZGVyU291cmNlOiBzdHJpbmcpOiBXZWJHTFNoYWRlciB7XG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyOiBXZWJHTFNoYWRlciA9IHRocm93SWZOdWxsPFdlYkdMU2hhZGVyPihcbiAgICAgIGdsLCAoKSA9PiBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKSxcbiAgICAgICdVbmFibGUgdG8gY3JlYXRlIGZyYWdtZW50IFdlYkdMU2hhZGVyLicpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpKTtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKSk7XG4gIGlmIChnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSBmcmFnbWVudCBzaGFkZXIuJyk7XG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KTogV2ViR0xQcm9ncmFtIHtcbiAgcmV0dXJuIHRocm93SWZOdWxsPFdlYkdMUHJvZ3JhbT4oXG4gICAgICBnbCwgKCkgPT4gZ2wuY3JlYXRlUHJvZ3JhbSgpLCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFByb2dyYW0uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5rUHJvZ3JhbShnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0pIHtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKSk7XG4gIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSA9PT0gZmFsc2UpIHtcbiAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbGluayB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMuJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0pIHtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC52YWxpZGF0ZVByb2dyYW0ocHJvZ3JhbSkpO1xuICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRlciBwcm9ncmFtIHZhbGlkYXRpb24gZmFpbGVkLicpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgZGF0YTogRmxvYXQzMkFycmF5KTogV2ViR0xCdWZmZXIge1xuICBjb25zdCBidWZmZXI6IFdlYkdMQnVmZmVyID0gdGhyb3dJZk51bGw8V2ViR0xCdWZmZXI+KFxuICAgICAgZ2wsICgpID0+IGdsLmNyZWF0ZUJ1ZmZlcigpLCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpKTtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGRhdGE6IFVpbnQxNkFycmF5KTogV2ViR0xCdWZmZXIge1xuICBjb25zdCBidWZmZXI6IFdlYkdMQnVmZmVyID0gdGhyb3dJZk51bGw8V2ViR0xCdWZmZXI+KFxuICAgICAgZ2wsICgpID0+IGdsLmNyZWF0ZUJ1ZmZlcigpLCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlcikpO1xuICBjYWxsQW5kQ2hlY2soXG4gICAgICBnbCwgKCkgPT4gZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuU1RBVElDX0RSQVcpKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IG51bWJlciB7XG4gIGlmIChNQVhfVEVYVFVSRV9TSVpFICE9IG51bGwpIHtcbiAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbiAgfVxuICBNQVhfVEVYVFVSRV9TSVpFID1cbiAgICAgIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2whLmdldFBhcmFtZXRlcihnbCEuTUFYX1RFWFRVUkVfU0laRSkpO1xuICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5uZWxzUGVyVGV4dHVyZSgpOiBudW1iZXIge1xuICBpZiAoaXNXZWJHTDJFbmFibGVkKCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gNDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IFdlYkdMVGV4dHVyZSB7XG4gIHJldHVybiB0aHJvd0lmTnVsbDxXZWJHTFRleHR1cmU+KFxuICAgICAgZ2wsICgpID0+IGdsLmNyZWF0ZVRleHR1cmUoKSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xUZXh0dXJlLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlU2l6ZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xuICBjb25zdCBtYXhUZXh0dXJlU2l6ZTogbnVtYmVyID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gIGlmICgod2lkdGggPD0gMCkgfHwgKGhlaWdodCA8PSAwKSkge1xuICAgIGNvbnN0IHJlcXVlc3RlZCA9ICdbJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJ10nO1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICsgJyBpcyBpbnZhbGlkLicpO1xuICB9XG4gIGlmICgod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSkgfHwgKGhlaWdodCA+IG1heFRleHR1cmVTaXplKSkge1xuICAgIGNvbnN0IHJlcXVlc3RlZCA9ICdbJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJ10nO1xuICAgIGNvbnN0IG1heCA9ICdbJyArIG1heFRleHR1cmVTaXplICsgJ3gnICsgbWF4VGV4dHVyZVNpemUgKyAnXSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSAnICsgcmVxdWVzdGVkICtcbiAgICAgICAgJyBncmVhdGVyIHRoYW4gV2ViR0wgbWF4aW11bSBvbiB0aGlzIGJyb3dzZXIgLyBHUFUgJyArIG1heCArICcuJyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lYnVmZmVyKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpOiBXZWJHTEZyYW1lYnVmZmVyIHtcbiAgcmV0dXJuIHRocm93SWZOdWxsPFdlYkdMRnJhbWVidWZmZXI+KFxuICAgICAgZ2wsICgpID0+IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCksICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSwgYXR0cmlidXRlOiBzdHJpbmcsXG4gICAgYnVmZmVyOiBXZWJHTEJ1ZmZlciwgYXJyYXlFbnRyaWVzUGVySXRlbTogbnVtYmVyLCBpdGVtU3RyaWRlSW5CeXRlczogbnVtYmVyLFxuICAgIGl0ZW1PZmZzZXRJbkJ5dGVzOiBudW1iZXIpIHtcbiAgY29uc3QgbG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlKTtcbiAgaWYgKGxvYyA9PT0gLTEpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuYWJsZSB0byBnZXQgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiBvbiBXZWJHTFByb2dyYW0uJyk7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIChlcnJvciBhcyBhbnkpLm5hbWVkVmVydGV4QXR0cmlidXRlTm90Rm91bmQgPSBhdHRyaWJ1dGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKSk7XG4gIGNhbGxBbmRDaGVjayhcbiAgICAgIGdsLFxuICAgICAgKCkgPT4gZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICBsb2MsIGFycmF5RW50cmllc1Blckl0ZW0sIGdsLkZMT0FULCBmYWxzZSwgaXRlbVN0cmlkZUluQnl0ZXMsXG4gICAgICAgICAgaXRlbU9mZnNldEluQnl0ZXMpKTtcbiAgY2FsbEFuZENoZWNrKGdsLCAoKSA9PiBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2MpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRUZXh0dXJlVW5pdChcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCB0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHRleHR1cmVVbml0OiBudW1iZXIpIHtcbiAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCkpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuYmluZFRleHR1cmVVbml0KFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHRleHR1cmVVbml0OiBudW1iZXIpIHtcbiAgdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCkpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHByb2dyYW06IFdlYkdMUHJvZ3JhbSxcbiAgICB1bmlmb3JtTmFtZTogc3RyaW5nKTogV2ViR0xVbmlmb3JtTG9jYXRpb24ge1xuICByZXR1cm4gdGhyb3dJZk51bGw8V2ViR0xVbmlmb3JtTG9jYXRpb24+KFxuICAgICAgZ2wsICgpID0+IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSksXG4gICAgICAndW5pZm9ybSBcIicgKyB1bmlmb3JtTmFtZSArICdcIiBub3QgcHJlc2VudCBpbiBwcm9ncmFtLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcihcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICB1bmlmb3JtU2FtcGxlck5hbWU6IHN0cmluZywgdGV4dHVyZVVuaXQ6IG51bWJlcikge1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpKTtcbiAgY29uc3Qgc2FtcGxlckxvY2F0aW9uID1cbiAgICAgIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdsLCBwcm9ncmFtLCB1bmlmb3JtU2FtcGxlck5hbWUpO1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLnVuaWZvcm0xaShzYW1wbGVyTG9jYXRpb24sIHRleHR1cmVVbml0KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0KSB7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KSk7XG4gIGNhbGxBbmRDaGVjayhnbCwgKCkgPT4gZ2wuc2Npc3NvcigwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKFxuICAgIGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSxcbiAgICBmcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcikge1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpKTtcbiAgY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsXG4gICAgICAoKSA9PiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuYmluZENvbG9yVGV4dHVyZUZyb21GcmFtZWJ1ZmZlcihcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBmcmFtZWJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcikge1xuICBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpKTtcbiAgY2FsbEFuZENoZWNrKFxuICAgICAgZ2wsXG4gICAgICAoKSA9PiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIG51bGwsIDApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRnJhbWVidWZmZXIoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCkge1xuICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgaWYgKHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFcnJvciBiaW5kaW5nIGZyYW1lYnVmZmVyOiAnICsgZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2UoZ2wsIHN0YXR1cykpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBzdGF0dXM6IG51bWJlcik6IHN0cmluZyB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XG4gICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVCc7XG4gICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQnO1xuICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxuICAgICAgcmV0dXJuICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMnO1xuICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XG4gICAgICByZXR1cm4gJ0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICd1bmtub3duIGVycm9yICcgKyBzdGF0dXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJZk51bGw8VD4oXG4gICAgZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgcmV0dXJuVE9yTnVsbDogKCkgPT4gVCB8IG51bGwsXG4gICAgZmFpbHVyZU1lc3NhZ2U6IHN0cmluZyk6IFQge1xuICBjb25zdCB0T3JOdWxsOiBUfG51bGwgPSBjYWxsQW5kQ2hlY2soZ2wsICgpID0+IHJldHVyblRPck51bGwoKSk7XG4gIGlmICh0T3JOdWxsID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFpbHVyZU1lc3NhZ2UpO1xuICB9XG4gIHJldHVybiB0T3JOdWxsIGFzIFQ7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgdGV4dHVyZVVuaXQ6IG51bWJlcikge1xuICBjb25zdCBtYXhUZXh0dXJlVW5pdCA9IGdsLk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIC0gMTtcbiAgY29uc3QgZ2xUZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0ICsgZ2wuVEVYVFVSRTA7XG4gIGlmIChnbFRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgZ2xUZXh0dXJlVW5pdCA+IG1heFRleHR1cmVVbml0KSB7XG4gICAgY29uc3QgdGV4dHVyZVVuaXRSYW5nZSA9ICdbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkUnICsgbWF4VGV4dHVyZVVuaXQgKyAnXSc7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0ZXh0dXJlVW5pdCBtdXN0IGJlIGluICcgKyB0ZXh0dXJlVW5pdFJhbmdlICsgJy4nKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZShcbiAgICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBsb2dpY2FsU2hhcGU6IG51bWJlcltdLFxuICAgIHByZWZlcnJlZFRleFNoYXBlPzogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCBtYXhUZXhTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gIGNvbnN0IHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUobG9naWNhbFNoYXBlKTtcbiAgaWYgKHByZWZlcnJlZFRleFNoYXBlICE9IG51bGwpIHtcbiAgICBjb25zdCBzaXplUHJlZmVycmVkID0gdXRpbC5zaXplRnJvbVNoYXBlKHByZWZlcnJlZFRleFNoYXBlKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgc2l6ZSA9PT0gc2l6ZVByZWZlcnJlZCxcbiAgICAgICAgYFNpemUgb2Ygc2hhcGUgKCR7c2l6ZX0pIG11c3QgbWF0Y2ggc2l6ZSBvZiBgICtcbiAgICAgICAgICAgIGBwcmVmZXJyZWRTaGFwZSAoJHtzaXplUHJlZmVycmVkfSlgKTtcbiAgICBpZiAocHJlZmVycmVkVGV4U2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBwcmVmZXJyZWRUZXhTaGFwZVsxXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICByZXR1cm4gcHJlZmVycmVkVGV4U2hhcGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvZ2ljYWxTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleFNpemUpIHtcbiAgICByZXR1cm4gW3NpemUsIDFdO1xuICB9IGVsc2UgaWYgKFxuICAgICAgbG9naWNhbFNoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dpY2FsU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgbG9naWNhbFNoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICByZXR1cm4gbG9naWNhbFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIH0gZWxzZSBpZiAoXG4gICAgICBsb2dpY2FsU2hhcGUubGVuZ3RoID09PSAzICYmIGxvZ2ljYWxTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICBsb2dpY2FsU2hhcGVbMV0gKiBsb2dpY2FsU2hhcGVbMl0gPD0gbWF4VGV4U2l6ZSkge1xuICAgIHJldHVybiBbbG9naWNhbFNoYXBlWzBdLCBsb2dpY2FsU2hhcGVbMV0gKiBsb2dpY2FsU2hhcGVbMl1dO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1dGlsLnNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuaW1wb3J0IHtBZGROb2RlLCBBcmdNYXhFcXVhbHNOb2RlLCBBcmdNYXhOb2RlLCBDb25jYXQzRE5vZGUsIENvbnZvbHV0aW9uMkROb2RlLCBEaXZpZGVOb2RlLCBFeHBOb2RlLCBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSwgTG9nTm9kZSwgTWF0TXVsTm9kZSwgTWF4UG9vbE5vZGUsIE1lYW5TcXVhcmVkQ29zdE5vZGUsIE11bHRpcGx5Tm9kZSwgTm9kZSwgUmVkdWNlU3VtTm9kZSwgUmVMVU5vZGUsIFJlc2hhcGVOb2RlLCBTaWdtb2lkTm9kZSwgU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLCBTb2Z0bWF4Tm9kZSwgU3BsaXROb2RlLCBTcXVhcmVOb2RlLCBTdWJ0cmFjdE5vZGUsIFRhbkhOb2RlfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi9ncmFwaF91dGlsJztcbmltcG9ydCB7QWRkfSBmcm9tICcuL29wcy9hZGQnO1xuaW1wb3J0IHtBcmdNYXh9IGZyb20gJy4vb3BzL2FyZ21heCc7XG5pbXBvcnQge0FyZ01heEVxdWFsc30gZnJvbSAnLi9vcHMvYXJnbWF4ZXF1YWxzJztcbmltcG9ydCB7Q29uY2F0M0R9IGZyb20gJy4vb3BzL2NvbmNhdDNkJztcbmltcG9ydCB7Q29udm9sdXRpb24yRH0gZnJvbSAnLi9vcHMvY29udm9sdXRpb24nO1xuaW1wb3J0IHtEaXZpZGV9IGZyb20gJy4vb3BzL2RpdmlkZSc7XG5pbXBvcnQge1JlTFUsIFNpZ21vaWQsIFNxdWFyZSwgVGFuSH0gZnJvbSAnLi9vcHMvZWxlbWVudF93aXNlX2FjdGl2YXRpb24nO1xuaW1wb3J0IHtNZWFuU3F1YXJlZENvc3R9IGZyb20gJy4vb3BzL2VsZW1lbnRfd2lzZV9jb3N0JztcbmltcG9ydCB7RXhwfSBmcm9tICcuL29wcy9leHAnO1xuaW1wb3J0IHtMaW5lYXJDb21iaW5hdGlvbn0gZnJvbSAnLi9vcHMvbGluZWFyX2NvbWJpbmF0aW9uJztcbmltcG9ydCB7TG9nfSBmcm9tICcuL29wcy9sb2cnO1xuaW1wb3J0IHtNYXRNdWx9IGZyb20gJy4vb3BzL21hdG11bCc7XG5pbXBvcnQge01heFBvb2x9IGZyb20gJy4vb3BzL21heF9wb29sJztcbmltcG9ydCB7TXVsdGlwbHl9IGZyb20gJy4vb3BzL211bHRpcGx5JztcbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wcy9vcCc7XG5pbXBvcnQge1JlZHVjZVN1bX0gZnJvbSAnLi9vcHMvcmVkdWNlX3N1bSc7XG5pbXBvcnQge1Jlc2hhcGV9IGZyb20gJy4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHtTb2Z0bWF4LCBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdH0gZnJvbSAnLi9vcHMvc29mdG1heCc7XG5pbXBvcnQge1NwbGl0fSBmcm9tICcuL29wcy9zcGxpdCc7XG5pbXBvcnQge1N1YnRyYWN0fSBmcm9tICcuL29wcy9zdWJ0cmFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbWl0RnJvbUdyYXBoTm9kZXMobm9kZXM6IE5vZGVbXSk6IE9wZXJhdGlvbltdIHtcbiAgY29uc3Qgb3BzOiBPcGVyYXRpb25bXSA9IFtdO1xuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3BzLCBlbWl0T3BGcm9tTm9kZShub2RlKSkpO1xuICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBlbWl0T3BGcm9tTm9kZShub2RlOiBOb2RlKTogT3BlcmF0aW9uW10ge1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFJlc2hhcGVOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgUmVzaGFwZShub2RlLmlucHV0c1tSZXNoYXBlTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgTWF0TXVsTm9kZSkge1xuICAgIGNvbnN0IHgxID0gbm9kZS5pbnB1dHNbTWF0TXVsTm9kZS5YMV07XG4gICAgY29uc3QgeDIgPSBub2RlLmlucHV0c1tNYXRNdWxOb2RlLlgyXTtcbiAgICByZXR1cm4gW25ldyBNYXRNdWwoeDEsIHgyLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb252b2x1dGlvbjJETm9kZSkge1xuICAgIGNvbnN0IHcgPSBub2RlLmlucHV0c1tDb252b2x1dGlvbjJETm9kZS5XXTtcbiAgICBjb25zdCB4ID0gbm9kZS5pbnB1dHNbQ29udm9sdXRpb24yRE5vZGUuWF07XG4gICAgY29uc3QgYiA9IG5vZGUuaW5wdXRzW0NvbnZvbHV0aW9uMkROb2RlLkJdO1xuICAgIHJldHVybiBbbmV3IENvbnZvbHV0aW9uMkQoXG4gICAgICAgIHcsIHgsIGIsIG5vZGUub3V0cHV0LCBub2RlLmZpZWxkU2l6ZSwgbm9kZS5vdXRwdXREZXB0aCwgbm9kZS5zdHJpZGUsXG4gICAgICAgIG5vZGUuemVyb1BhZCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBNYXhQb29sTm9kZSkge1xuICAgIGNvbnN0IHggPSBub2RlLmlucHV0c1tNYXhQb29sTm9kZS5YXTtcbiAgICByZXR1cm4gW25ldyBNYXhQb29sKFxuICAgICAgICB4LCBub2RlLm91dHB1dCwgbm9kZS5maWVsZFNpemUsIG5vZGUuc3RyaWRlLCBub2RlLnplcm9QYWQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRXhwTm9kZSkge1xuICAgIHJldHVybiBbbmV3IEV4cChub2RlLmlucHV0c1tFeHBOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBMb2dOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgTG9nKG5vZGUuaW5wdXRzW0xvZ05vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlTFVOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgUmVMVShub2RlLmlucHV0c1tSZUxVTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGFuSE5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBUYW5IKG5vZGUuaW5wdXRzW1RhbkhOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTaWdtb2lkTm9kZSkge1xuICAgIHJldHVybiBbbmV3IFNpZ21vaWQobm9kZS5pbnB1dHNbU2lnbW9pZE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSkge1xuICAgIGNvbnN0IHggPSBub2RlLmlucHV0c1tTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuWF07XG4gICAgY29uc3QgdGFyZ2V0ID0gbm9kZS5pbnB1dHNbU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlRBUkdFVF07XG4gICAgcmV0dXJuIFtuZXcgU29mdG1heENyb3NzRW50cm9weUNvc3QoeCwgdGFyZ2V0LCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTb2Z0bWF4Tm9kZSkge1xuICAgIHJldHVybiBbbmV3IFNvZnRtYXgobm9kZS5pbnB1dHNbU29mdG1heE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE1lYW5TcXVhcmVkQ29zdE5vZGUpIHtcbiAgICBjb25zdCBsYWJlbCA9IG5vZGUuaW5wdXRzW01lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUxdO1xuICAgIGNvbnN0IHByZWRpY3Rpb24gPSBub2RlLmlucHV0c1tNZWFuU3F1YXJlZENvc3ROb2RlLlBSRURJQ1RJT05dO1xuICAgIHJldHVybiBbbmV3IE1lYW5TcXVhcmVkQ29zdChsYWJlbCwgcHJlZGljdGlvbiwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQXJnTWF4RXF1YWxzTm9kZSkge1xuICAgIHJldHVybiBbbmV3IEFyZ01heEVxdWFscyhcbiAgICAgICAgbm9kZS5pbnB1dHNbQXJnTWF4RXF1YWxzTm9kZS5YMV0sIG5vZGUuaW5wdXRzW0FyZ01heEVxdWFsc05vZGUuWDJdLFxuICAgICAgICBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcmdNYXhOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgQXJnTWF4KG5vZGUueCwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBMaW5lYXJDb21iaW5hdGlvbihcbiAgICAgICAgbm9kZS5pbnB1dHNbRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDFdLFxuICAgICAgICBub2RlLmlucHV0c1tGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMl0sXG4gICAgICAgIG5vZGUuaW5wdXRzW0Z1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMxXSxcbiAgICAgICAgbm9kZS5pbnB1dHNbRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzJdLCBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb25jYXQzRE5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBDb25jYXQzRChcbiAgICAgICAgbm9kZS5pbnB1dHNbQ29uY2F0M0ROb2RlLlgxXSwgbm9kZS5pbnB1dHNbQ29uY2F0M0ROb2RlLlgyXSwgbm9kZS5heGlzLFxuICAgICAgICBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBTcXVhcmVOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgU3F1YXJlKG5vZGUuaW5wdXRzW1NxdWFyZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFkZE5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBBZGQoXG4gICAgICAgIG5vZGUuaW5wdXRzW0FkZE5vZGUuVDFdLCBub2RlLmlucHV0c1tBZGROb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgU3VidHJhY3ROb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgU3VidHJhY3QoXG4gICAgICAgIG5vZGUuaW5wdXRzW1N1YnRyYWN0Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW1N1YnRyYWN0Tm9kZS5UMl0sXG4gICAgICAgIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE11bHRpcGx5Tm9kZSkge1xuICAgIHJldHVybiBbbmV3IE11bHRpcGx5KFxuICAgICAgICBub2RlLmlucHV0c1tNdWx0aXBseU5vZGUuVDFdLCBub2RlLmlucHV0c1tNdWx0aXBseU5vZGUuVDJdLFxuICAgICAgICBub2RlLm91dHB1dCldO1xuICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBEaXZpZGVOb2RlKSB7XG4gICAgcmV0dXJuIFtuZXcgRGl2aWRlKFxuICAgICAgICBub2RlLmlucHV0c1tEaXZpZGVOb2RlLlQxXSwgbm9kZS5pbnB1dHNbRGl2aWRlTm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFNwbGl0Tm9kZSkge1xuICAgIHJldHVybiBbbmV3IFNwbGl0KG5vZGUuaW5wdXRzW1NwbGl0Tm9kZS5YXSwgbm9kZS5vdXRwdXRzKV07XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlZHVjZVN1bU5vZGUpIHtcbiAgICByZXR1cm4gW25ldyBSZWR1Y2VTdW0obm9kZS5pbnB1dHNbUmVkdWNlU3VtTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgfSBlbHNlIGlmIChncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiAnICsgKG5vZGUuY29uc3RydWN0b3IgYXMgYW55KS5uYW1lKTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFkZCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIHByaXZhdGUgZHlTaXplU2NhbGFyOiBTY2FsYXI7XG5cbiAgLyoqIEVsZW1lbnQtd2lzZSBhZGQgb3BlcmF0aW9uLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpcyBzY2FsYXIuICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSxcbiAgICAgICAgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0OiBOREFycmF5O1xuICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDEsIHgyKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclBsdXNBcnJheSh4MiwgeDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5hZGQoeDEsIHgyKTtcbiAgICAgIH1cbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKHJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHRoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgY29uc3Qgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhciA9IFNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy54MVRlbnNvciwga2VlcChtYXRoLmRpdmlkZShzdW0sIHRoaXMuZHlTaXplU2NhbGFyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngxVGVuc29yLCBkeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLngyVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgIGNvbnN0IHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICBpZiAodGhpcy5keVNpemVTY2FsYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5keVNpemVTY2FsYXIgPSBTY2FsYXIubmV3KGR5LnNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgICAgIHRoaXMueDJUZW5zb3IsIGtlZXAobWF0aC5kaXZpZGUoc3VtLCB0aGlzLmR5U2l6ZVNjYWxhcikpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwgZHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmdNYXggZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQW4gQXJnTWF4IG9wZXJhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgeFRlbnNvcjogVGVuc29yLCBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5hcmdNYXgoeCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01heCBiYWNrcHJvcCB1bmltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFyZ01heEVxdWFscyBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBbiBBcmdNYXhFcXVhbHMgb3BlcmF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHgxVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeDJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChtYXRoLmFyZ01heEVxdWFscyh4MSwgeDIpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXhFcXVhbHMgYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBjb25jYXQzZF91dGlsIGZyb20gJy4uL21hdGgvY29uY2F0M2RfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtBcnJheTNEfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25jYXQzRCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIENvbmNhdCAzRCBvcGVyYXRpb24uXG4gICAqXG4gICAqIENvbmNhdHMgdHdvIDNEIHRlbnNvcnMgYWxvbmcgYW4gYXhpcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgYXhpczogbnVtYmVyLFxuICAgICAgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbmNhdDNkX3V0aWwuYXNzZXJ0Q29uY2F0M0RTaGFwZXNNYXRjaChcbiAgICAgICAgeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlLCBheGlzKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpIGFzIEFycmF5M0Q7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpIGFzIEFycmF5M0Q7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBjb25zdCBjb25jYXRSZXN1bHQgPSBtYXRoLmNvbmNhdDNEKHgxLCB4MiwgdGhpcy5heGlzKTtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKGNvbmNhdFJlc3VsdCkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29uY2F0M0QgYmFja3Byb3Agbm90IGltcGxlbWVudGVkLicpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBjb252X3V0aWwgZnJvbSAnLi4vbWF0aC9jb252X3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7QXJyYXkxRCwgQXJyYXkzRCwgQXJyYXk0RH0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbnZvbHV0aW9uMkQgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBwcml2YXRlIHplcm9QYWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNvbnZvbHV0aW9uIG9wIHdpdGggdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRTaGFwZSBUaGUgc2hhcGUgb2YgdGhlIGlucHV0IG5kYXJyYXkuXG4gICAqIEBwYXJhbSBmaWVsZFNpemUgVGhlIHNpemUgb2YgdGhlIGZpbHRlciAocm93cy9jb2xzIG9mIHNsaWRpbmcgd2luZG93KS5cbiAgICogQHBhcmFtIG91dHB1dERlcHRoIFRoZSBkZXB0aCBvZiB0aGUgb3V0cHV0IChOdW1iZXIgb2YgZmlsdGVycykuXG4gICAqIEBwYXJhbSBzdHJpZGUgSG93IG1hbnkgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBmaWx0ZXIgYnkgd2hlbiBzbGlkaW5nLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gMS5cbiAgICogQHBhcmFtIHplcm9QYWQgSG93IG1hbnkgcGl4ZWxzIHRvIHBhZCB0aGUgaW5wdXQgZnJvbSBlYWNoIHNpZGUuIERlZmF1bHRzIHRvXG4gICAqICAgICBhIHZhbHVlIHNvIHRoYXQgdGhlIHJvd3MgYW5kIGNvbHVtbnMgb2YgdGhlIG91dHB1dCBuZGFycmF5IGlzXG4gICAqICAgICB0aGUgc2FtZSBhcyB0aGUgaW5wdXQgbmRhcnJheS5cbiAgICogQHBhcmFtIHdlaWdodHMgT3B0aW9uYWwuIFRoZSB3ZWlnaHRzIG9mIHRoZSBmaWx0ZXJzLlxuICAgKiBAcGFyYW0gYmlhc2VzIE9wdGlvbmFsLiBUaGUgYmlhcyB0ZXJtcyBvZiB0aGUgZmlsdGVycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB3VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeFRlbnNvcjogVGVuc29yLCBwcml2YXRlIGJUZW5zb3I6IFRlbnNvcixcbiAgICAgIHByaXZhdGUgeVRlbnNvcjogVGVuc29yLCBwcml2YXRlIGZpZWxkU2l6ZTogbnVtYmVyLFxuICAgICAgcHJpdmF0ZSBvdXRwdXREZXB0aDogbnVtYmVyLCBwcml2YXRlIHN0cmlkZSA9IDEsIHplcm9QYWQ/OiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXNzZXJ0V2VpZ2h0c1NoYXBlKHdUZW5zb3Iuc2hhcGUpO1xuICAgIHRoaXMuemVyb1BhZCA9IHplcm9QYWQgIT0gbnVsbCA/XG4gICAgICAgIHplcm9QYWQgOlxuICAgICAgICBjb252X3V0aWwuY29tcHV0ZURlZmF1bHRQYWQoXG4gICAgICAgICAgICB0aGlzLnhUZW5zb3Iuc2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0aGlzLmZpZWxkU2l6ZSxcbiAgICAgICAgICAgIHRoaXMuc3RyaWRlKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdXRpbC5pc0ludCh0aGlzLnplcm9QYWQpLFxuICAgICAgICBgVGhlIHplcm8gcGFkZGluZyAoJHt0aGlzLnplcm9QYWR9KSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgYCArXG4gICAgICAgICAgICBgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzYCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcikgYXMgQXJyYXk0RDtcbiAgICBjb25zdCBiaWFzZXMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYlRlbnNvcikgYXMgQXJyYXkxRDtcbiAgICBjb25zdCB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpIGFzIEFycmF5M0Q7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgIHRoaXMueVRlbnNvcixcbiAgICAgICAgICBrZWVwKG1hdGguY29udjJkKHgsIHdlaWdodHMsIGJpYXNlcywgdGhpcy5zdHJpZGUsIHRoaXMuemVyb1BhZCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB3ZWlnaHRzID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLndUZW5zb3IpIGFzIEFycmF5NEQ7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKSBhcyBBcnJheTNEO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcikgYXMgQXJyYXkzRDtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGNvbnN0IHtkdywgZGIsIGR4fSA9XG4gICAgICAgICAgbWF0aC5jb252MmRCYWNrUHJvcCh4LCBkeSwgd2VpZ2h0cywgdGhpcy5zdHJpZGUsIHRoaXMuemVyb1BhZCk7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy53VGVuc29yLCBrZWVwKGR3KSk7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy5iVGVuc29yLCBrZWVwKGRiKSk7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54VGVuc29yLCBrZWVwKGR4KSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzc2VydFdlaWdodHNTaGFwZSh3ZWlnaHRzU2hhcGU6IG51bWJlcltdKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHdlaWdodHNTaGFwZVswXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsxXSA9PT0gdGhpcy5maWVsZFNpemUgJiZcbiAgICAgICAgICAgIHdlaWdodHNTaGFwZVsyXSA9PT0gdGhpcy54VGVuc29yLnNoYXBlWzJdICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbM10gPT09IHRoaXMub3V0cHV0RGVwdGgsXG4gICAgICAgIGB3ZWlnaHRzIG11c3QgYmUgb2Ygc2hhcGUgWyR7dGhpcy5maWVsZFNpemV9LCR7dGhpcy5maWVsZFNpemV9LGAgK1xuICAgICAgICAgICAgYCR7dGhpcy54VGVuc29yLnNoYXBlWzJdfSwke3RoaXMub3V0cHV0RGVwdGh9XSBidXQgdGhleSBhcmUgb2ZgICtcbiAgICAgICAgICAgIGBzaGFwZSBbJHt3ZWlnaHRzU2hhcGV9XWApO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERpdmlkZSBleHRlbmRzIE9wZXJhdGlvbiB7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQtd2lzZSBkaXZpZGUgb3BlcmF0aW9uLiBCcm9hZGNhc3RzIGlmIG9uZSBvZiB0aGUgdGVuc29ycyBpc1xuICAgKiBzY2FsYXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgeDFUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB4MlRlbnNvcjogVGVuc29yLFxuICAgICAgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoeDJUZW5zb3Iuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSksXG4gICAgICAgICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZScpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB0MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdDogTkRBcnJheTtcbiAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDEuc2hhcGUpKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyRGl2aWRlZEJ5QXJyYXkodDEsIHQyKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHQyLnNoYXBlKSkge1xuICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHQxLCB0Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtYXRoLmRpdmlkZSh0MSwgdDIpO1xuICAgICAgfVxuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLnlUZW5zb3IsIGtlZXAocmVzdWx0KSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuXG4gICAgY29uc3QgeDFJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSk7XG4gICAgY29uc3QgeDJJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSk7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgIGNvbnN0IGRpdiA9IG1hdGguZGl2aWRlKGR5LCB4Mik7XG5cbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MVRlbnNvciwga2VlcChtYXRoLnN1bShkaXYpKSk7XG5cbiAgICAgICAgICBkaXYuZGlzcG9zZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgICAgIHRoaXMueDFUZW5zb3IsIGtlZXAobWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcihkeSwgeDIpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGtlZXAobWF0aC5kaXZpZGUoZHksIHgyKSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgIC8vIGR4MiA9IC0xICogeDEgKiB4MiBeIC0yLlxuICAgICAgICBjb25zdCB4MlNxdWFyZWQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgyLCB4Mik7XG5cbiAgICAgICAgbGV0IHgxT3ZlclgyU3F1YXJlZDogTkRBcnJheTtcbiAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgxT3ZlclgyU3F1YXJlZCA9IG1hdGguZGl2aWRlKHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHgyID0gbWF0aC5uZWcoeDFPdmVyWDJTcXVhcmVkKTtcbiAgICAgICAgY29uc3QgZHlUaW1lc0Rlcml2YXRpdmUgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCBkeDIpO1xuXG4gICAgICAgIGlmICh4MklzU2NhbGFyKSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDJUZW5zb3IsIGtlZXAobWF0aC5zdW0oZHlUaW1lc0Rlcml2YXRpdmUpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDJUZW5zb3IsIGtlZXAoZHlUaW1lc0Rlcml2YXRpdmUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG5pbXBvcnQge0FjdGl2YXRpb25GdW5jdGlvbiwgUmVMVUZ1bmMsIFNpZ21vaWRGdW5jLCBTcXVhcmVGdW5jLCBUYW5IRnVuY30gZnJvbSAnLi4vbWF0aC9hY3RpdmF0aW9uX2Z1bmN0aW9ucyc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50V2lzZUFjdGl2YXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByb3RlY3RlZCB4VGVuc29yOiBUZW5zb3IsIHByb3RlY3RlZCB5VGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIGZ1bmM6IEFjdGl2YXRpb25GdW5jdGlvbikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcCh0aGlzLmZ1bmMub3V0cHV0KG1hdGgsIHgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgLy8gZEUvZHhfaSA9IHN1bV9qIGRFL2R5X2ogKiBkeV9qL2R4X2lcbiAgICAvLyAgICAgICAgID0gZEUvZHlfaSAqIGR5X2kvZHhfaVxuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgY29uc3QgeSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3QgZHlkeCA9IHRoaXMuZnVuYy5kZXIobWF0aCwgeCwgeSk7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54VGVuc29yLCBrZWVwKG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR5ZHgpKSk7XG4gICAgICBkeWR4LmRpc3Bvc2UoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlTFUgZXh0ZW5kcyBFbGVtZW50V2lzZUFjdGl2YXRpb24ge1xuICBjb25zdHJ1Y3Rvcih4VGVuc29yOiBUZW5zb3IsIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBSZUxVRnVuYygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhbkggZXh0ZW5kcyBFbGVtZW50V2lzZUFjdGl2YXRpb24ge1xuICBjb25zdHJ1Y3Rvcih4VGVuc29yOiBUZW5zb3IsIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBUYW5IRnVuYygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ21vaWQgZXh0ZW5kcyBFbGVtZW50V2lzZUFjdGl2YXRpb24ge1xuICBjb25zdHJ1Y3Rvcih4VGVuc29yOiBUZW5zb3IsIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBTaWdtb2lkRnVuYygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNxdWFyZSBleHRlbmRzIEVsZW1lbnRXaXNlQWN0aXZhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHhUZW5zb3I6IFRlbnNvciwgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoeFRlbnNvciwgeVRlbnNvciwgbmV3IFNxdWFyZUZ1bmMoKSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge0VsZW1lbnRXaXNlQ29zdEZ1bmN0aW9uLCBTcXVhcmVDb3N0RnVuY30gZnJvbSAnLi4vbWF0aC9jb3N0X2Z1bmN0aW9ucyc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtTY2FsYXJ9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbGVtZW50V2lzZUNvc3QgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBwcml2YXRlIG9uZU92ZXJOU2NhbGFyOiBTY2FsYXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcm90ZWN0ZWQgeDFUZW5zb3I6IFRlbnNvciwgcHJvdGVjdGVkIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcm90ZWN0ZWQgeVRlbnNvcjogVGVuc29yLCBwcm90ZWN0ZWQgZnVuYzogRWxlbWVudFdpc2VDb3N0RnVuY3Rpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub25lT3Zlck5TY2FsYXIgPSBTY2FsYXIubmV3KDEgLyB1dGlsLnNpemVGcm9tU2hhcGUoeDFUZW5zb3Iuc2hhcGUpKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRXaXNlQ29zdCA9IHRoaXMuZnVuYy5jb3N0KG1hdGgsIHgxLCB4Mik7XG4gICAgICBjb25zdCBzdW0gPSBtYXRoLnN1bShlbGVtZW50V2lzZUNvc3QpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHRoaXMub25lT3Zlck5TY2FsYXIsIHN1bSk7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGtlZXAodGhpcy5mdW5jLmRlcihtYXRoLCB4MSwgeDIpKSk7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngyVGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcCh0aGlzLmZ1bmMuZGVyKG1hdGgsIHgyLCB4MSkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICB0aGlzLm9uZU92ZXJOU2NhbGFyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIE1lYW5TcXVhcmVkQ29zdCBleHRlbmRzIEVsZW1lbnRXaXNlQ29zdCB7XG4gIGNvbnN0cnVjdG9yKHgxVGVuc29yOiBUZW5zb3IsIHgyVGVuc29yOiBUZW5zb3IsIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgbmV3IFNxdWFyZUNvc3RGdW5jKCkpO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRXhwIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEV4cG9uZW50YXRpb24gb3BlcmF0aW9uIC0gZV54LlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB4VGVuc29yOiBUZW5zb3IsIHByaXZhdGUgeVRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQodGhpcy55VGVuc29yLCBrZWVwKG1hdGguZXhwKHgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54VGVuc29yKSkge1xuICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54VGVuc29yLCBrZWVwKG1hdGguZWxlbWVudFdpc2VNdWwoeSwgZHkpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lYXJDb21iaW5hdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBBIDItdGVuc29yIGxpbmVhciBjb21iaW5hdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIENvbWJpbmVzIHRlbnNvcnMgeDEgYW5kIHgyIChvZiB0aGUgc2FtZSBzaGFwZSkgd2l0aCB3ZWlnaHRzIGMxICYgYzI7XG4gICAqIENvbXB1dGVzIGMxKngxICsgYzIqeDIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgeDFUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB4MlRlbnNvcjogVGVuc29yLFxuICAgICAgcHJpdmF0ZSBjMVRlbnNvcjogVGVuc29yLCBwcml2YXRlIGMyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIG91dFRlbnNvcjogVGVuc29yKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgIGNvbnN0IHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICBjb25zdCBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcikuYXNTY2FsYXIoKTtcbiAgICBjb25zdCBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcikuYXNTY2FsYXIoKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy5vdXRUZW5zb3IsIGtlZXAobWF0aC5zY2FsZWRBcnJheUFkZChjMSwgeDEsIGMyLCB4MikpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIGNvbnN0IGMxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMxVGVuc29yKTtcbiAgICBjb25zdCBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcik7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MVRlbnNvcikpIHtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGtlZXAobWF0aC5zY2FsYXJUaW1lc0FycmF5KGMxLCBkeSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDJUZW5zb3IsIGtlZXAobWF0aC5zY2FsYXJUaW1lc0FycmF5KGMyLCBkeSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy5jMVRlbnNvcikpIHtcbiAgICAgICAgY29uc3QgZG90UHJvZHVjdDEgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSk7XG4gICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLmMxVGVuc29yLCBrZWVwKG1hdGguc3VtKGRvdFByb2R1Y3QxKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLmMyVGVuc29yKSkge1xuICAgICAgICBjb25zdCBkb3RQcm9kdWN0MiA9IG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KTtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMuYzJUZW5zb3IsIGtlZXAobWF0aC5zdW0oZG90UHJvZHVjdDIpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2cgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogTmF0dXJhbCBsb2cgb3BlcmF0aW9uIC0gbG4oeClcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgeFRlbnNvcjogVGVuc29yLCBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChtYXRoLmxvZyh4KSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueFRlbnNvcikpIHtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueFRlbnNvciwga2VlcChtYXRoLmRpdmlkZShkeSwgeCkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TWF0cml4T3JpZW50YXRpb24sIE5EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtBcnJheTFELCBBcnJheTJEfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXRNdWwgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgeDFUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB4MlRlbnNvcjogVGVuc29yLFxuICAgICAgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChcbiAgICAgICAgICAgIHRoaXMueVRlbnNvciwga2VlcChtYXRoLm1hdE11bCh4MSBhcyBBcnJheTJELCB4MiBhcyBBcnJheTJEKSkpO1xuICAgICAgfSBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoXG4gICAgICAgICAgICB0aGlzLnlUZW5zb3IsXG4gICAgICAgICAgICBrZWVwKG1hdGgubWF0cml4VGltZXNWZWN0b3IoeDEgYXMgQXJyYXkyRCwgeDIgYXMgQXJyYXkxRCkpKTtcbiAgICAgIH0gZWxzZSBpZiAoeDEuc2hhcGUubGVuZ3RoID09PSAxICYmIHgyLnNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgICAgdGhpcy55VGVuc29yLFxuICAgICAgICAgICAga2VlcChtYXRoLnZlY3RvclRpbWVzTWF0cml4KHgxIGFzIEFycmF5MUQsIHgyIGFzIEFycmF5MkQpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgbGV0IHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBsZXQgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIGxldCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuXG4gICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgeDEgPSB4MS5yZXNoYXBlKFsxLCB4MS5zaXplXSk7XG4gICAgICBkeSA9IGR5LnJlc2hhcGUoWzEsIGR5LnNpemVdKTtcbiAgICB9XG4gICAgaWYgKHgyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgeDIgPSB4Mi5yZXNoYXBlKFt4Mi5zaXplLCAxXSk7XG4gICAgICBkeSA9IGR5LnJlc2hhcGUoW2R5LnNpemUsIDFdKTtcbiAgICB9XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICAvLyB5ID0geDEgKiB4MlxuICAgICAgLy8gZHgxID0gZHkgKiB4MlRcbiAgICAgIC8vIGR4MiA9IHgxVCAqIGR5XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBjb25zdCBkeDEgPSBtYXRoLm1hdE11bChcbiAgICAgICAgICAgIGR5IGFzIEFycmF5MkQsIHgyIGFzIEFycmF5MkQsIE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIsXG4gICAgICAgICAgICBNYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VEKTtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgdGhpcy54MVRlbnNvcixcbiAgICAgICAgICAgIGtlZXAodGhpcy54MVRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDEuYXMxRCgpIDogZHgxKSk7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngyVGVuc29yKSkge1xuICAgICAgICBjb25zdCBkeDIgPSBtYXRoLm1hdE11bChcbiAgICAgICAgICAgIHgxIGFzIEFycmF5MkQsIGR5IGFzIEFycmF5MkQsIE1hdHJpeE9yaWVudGF0aW9uLlRSQU5TUE9TRUQsXG4gICAgICAgICAgICBNYXRyaXhPcmllbnRhdGlvbi5SRUdVTEFSKTtcbiAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgdGhpcy54MlRlbnNvcixcbiAgICAgICAgICAgIGtlZXAodGhpcy54MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgPyBkeDIuYXMxRCgpIDogZHgyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGNvbnZfdXRpbCBmcm9tICcuLi9tYXRoL2NvbnZfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtBcnJheTNEfSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTWF4UG9vbCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIHByaXZhdGUgcGFkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHhUZW5zb3I6IFRlbnNvciwgcHJpdmF0ZSB5VGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIGZpZWxkU2l6ZTogbnVtYmVyLCBwcml2YXRlIHN0cmlkZSA9IDEsIHBhZD86IG51bWJlcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAocGFkICE9IG51bGwpIHtcbiAgICAgIHRoaXMucGFkID0gcGFkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZCA9IGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZChcbiAgICAgICAgICB4VGVuc29yLnNoYXBlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGhpcy5maWVsZFNpemUsXG4gICAgICAgICAgdGhpcy5zdHJpZGUpO1xuICAgIH1cblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB1dGlsLmlzSW50KHRoaXMucGFkKSxcbiAgICAgICAgYFRoZSB6ZXJvIHBhZGRpbmcgKCR7dGhpcy5wYWR9KSBtdXN0IGJlIGFuIGludGVnZXIuIENoYW5nZSB0aGUgYCArXG4gICAgICAgICAgICBgc3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzYCk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcikgYXMgQXJyYXkzRDtcbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgIHRoaXMueVRlbnNvcixcbiAgICAgICAgICBrZWVwKG1hdGgubWF4UG9vbCh4LCB0aGlzLmZpZWxkU2l6ZSwgdGhpcy5zdHJpZGUsIHRoaXMucGFkKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcikgYXMgQXJyYXkzRDtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpIGFzIEFycmF5M0Q7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy54VGVuc29yLFxuICAgICAgICAgIGtlZXAobWF0aC5tYXhQb29sQmFja3Byb3AoXG4gICAgICAgICAgICAgIGR5LCB4LCB0aGlzLmZpZWxkU2l6ZSwgdGhpcy5zdHJpZGUsIHRoaXMucGFkKSkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQgKiBhcyBncmFwaF91dGlsIGZyb20gJy4uL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtOREFycmF5TWF0aH0gZnJvbSAnLi4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpcGx5IGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIEVsZW1lbnQtd2lzZSBtdWx0aXBseSBvcGVyYXRpb24uIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzXG4gICAqIHNjYWxhci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSB4MVRlbnNvcjogVGVuc29yLCBwcml2YXRlIHgyVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSxcbiAgICAgICAgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICBjb25zdCB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0OiBOREFycmF5O1xuICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHQxLCB0Mik7XG4gICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJUaW1lc0FycmF5KHQyLCB0MSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHQxLCB0Mik7XG4gICAgICB9XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMueVRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgY29uc3QgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngxVGVuc29yKSkge1xuICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHRoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgY29uc3QgbXVsID0gbWF0aC5lbGVtZW50V2lzZU11bChkeSwgeDIpO1xuXG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDFUZW5zb3IsIGtlZXAobWF0aC5zdW0obXVsKSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKSkge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy54MVRlbnNvciwga2VlcChtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDIsIGR5KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLngxVGVuc29yLCBrZWVwKG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy54MlRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICBjb25zdCBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4MSk7XG5cbiAgICAgICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54MlRlbnNvciwga2VlcChtYXRoLnN1bShtdWwpKSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDEuc2hhcGUpKSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KFxuICAgICAgICAgICAgICB0aGlzLngyVGVuc29yLCBrZWVwKG1hdGguc2NhbGFyVGltZXNBcnJheSh4MSwgZHkpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRBcnJheXMuc2V0KHRoaXMueDJUZW5zb3IsIGtlZXAobWF0aC5lbGVtZW50V2lzZU11bCh4MSwgZHkpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3BlcmF0aW9uIHtcbiAgYWJzdHJhY3QgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApOlxuICAgICAgdm9pZDtcblxuICBhYnN0cmFjdCBiYWNrUHJvcChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKTogdm9pZDtcblxuICBkaXNwb3NlVHJhbnNpZW50QXJyYXlzKFxuICAgICAgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCwgZ3JhZGllbnRBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7fVxuXG4gIGRpc3Bvc2UoKSB7fVxufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXl9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWR1Y2VTdW0gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKiogRWxlbWVudC13aXNlIGFkZCBvcGVyYXRpb24uIEJyb2FkY2FzdHMgaWYgb25lIG9mIHRoZSB0ZW5zb3JzIGlzIHNjYWxhci4gKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB4OiBUZW5zb3IsIHByaXZhdGUgb3V0VGVuc29yOiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gob3V0VGVuc29yLnNoYXBlLCBbXSk7XG4gIH1cblxuICBwcml2YXRlIG9uZXM6IE5EQXJyYXk7XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngpO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLm91dFRlbnNvciwga2VlcChtYXRoLnN1bSh4KSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGlmICghZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLngpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3QgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuICAgICAgaWYgKHRoaXMub25lcyA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHhBcnJheSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54KTtcbiAgICAgICAgdGhpcy5vbmVzID0gTkRBcnJheS56ZXJvc0xpa2UoeEFycmF5KTtcbiAgICAgICAgdGhpcy5vbmVzLmZpbGwoMSk7XG4gICAgICB9XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQodGhpcy54LCBrZWVwKG1hdGguc2NhbGFyVGltZXNBcnJheShkeSwgdGhpcy5vbmVzKSkpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi9ncmFwaCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5fSBmcm9tICcuLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi4vdGVuc29yX2FycmF5X21hcCc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcCc7XG5cbmV4cG9ydCBjbGFzcyBSZXNoYXBlPFQxIGV4dGVuZHMgTkRBcnJheSwgVDIgZXh0ZW5kcyBOREFycmF5PiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgeFRlbnNvcjogVGVuc29yLCBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgeFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeFRlbnNvci5zaGFwZSk7XG4gICAgY29uc3QgeVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeVRlbnNvci5zaGFwZSk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHhTaXplID09PSB5U2l6ZSxcbiAgICAgICAgYFRoZSBpbnB1dCBzaXplICgke3hTaXplfSkgYW5kIG91dHB1dCBzaXplICgke3lTaXplfSkgbXVzdCBtYXRjaGApO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpIGFzIFQxO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChcbiAgICAgICAgICB0aGlzLnlUZW5zb3IsIGtlZXAobWF0aC5yZXNoYXBlPFQxLCBUMj4oeCwgdGhpcy55VGVuc29yLnNoYXBlKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmFja1Byb3AoXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCxcbiAgICAgIGdyYWRpZW50QXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcikgYXMgVDI7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBncmFkaWVudEFycmF5cy5zZXQoXG4gICAgICAgICAgdGhpcy54VGVuc29yLCBrZWVwKG1hdGgucmVzaGFwZTxUMiwgVDE+KGR5LCB0aGlzLnhUZW5zb3Iuc2hhcGUpKSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge0FycmF5MUQsIFNjYWxhcn0gZnJvbSAnLi4vbWF0aC9uZGFycmF5JztcbmltcG9ydCB7VGVuc29yQXJyYXlNYXB9IGZyb20gJy4uL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3AnO1xuXG5leHBvcnQgY2xhc3MgU29mdG1heCBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbG9naXRzVGVuc29yOiBUZW5zb3IsIHByaXZhdGUgb3V0cHV0OiBUZW5zb3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKSBhcyBBcnJheTFEO1xuICAgIHJldHVybiBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMub3V0cHV0LCBrZWVwKG1hdGguc29mdG1heChsb2dpdHMpKSk7XG4gICAgfSk7XG4gIH1cblxuICBiYWNrUHJvcCgpIHtcbiAgICB0aHJvdyBFcnJvcignU29mdG1heCBiYWNrcHJvcCBpcyBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0IGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIGxvZ2l0c1RlbnNvcjogVGVuc29yLCBwcml2YXRlIGxhYmVsVGVuc29yOiBUZW5zb3IsXG4gICAgICBwcml2YXRlIHlUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb2Z0bWF4VGVuc29yID0gbmV3IFRlbnNvcihsb2dpdHNUZW5zb3Iuc2hhcGUpO1xuICB9XG5cbiAgZmVlZEZvcndhcmQobWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKSBhcyBBcnJheTFEO1xuICAgIGNvbnN0IGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKSBhcyBBcnJheTFEO1xuXG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgY29uc3Qgc29mdG1heFJlc3VsdCA9IG1hdGguc29mdG1heChsb2dpdHMpO1xuXG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KHRoaXMuc29mdG1heFRlbnNvciwga2VlcChzb2Z0bWF4UmVzdWx0KSk7XG4gICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KFxuICAgICAgICAgIHRoaXMueVRlbnNvcixcbiAgICAgICAgICBrZWVwKGNyb3NzRW50cm9weUNvc3QobWF0aCwgc29mdG1heFJlc3VsdCwgbGFiZWwsIHRoaXMuZXBzaWxvbikpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCBzb2Z0bWF4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnNvZnRtYXhUZW5zb3IpO1xuICAgIGNvbnN0IGxhYmVsID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmxhYmVsVGVuc29yKTtcblxuICAgIG1hdGguc2NvcGUoKGtlZXApID0+IHtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLmxvZ2l0c1RlbnNvciwga2VlcChtYXRoLnN1Yihzb2Z0bWF4LCBsYWJlbCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc3Bvc2VUcmFuc2llbnRBcnJheXMoXG4gICAgICBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwLCBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBpbmZlcmVuY2VBcnJheXMuZGlzcG9zZUFycmF5KHRoaXMuc29mdG1heFRlbnNvcik7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZXBzaWxvbi5kaXNwb3NlKCk7XG4gIH1cblxuICBwcml2YXRlIHNvZnRtYXhUZW5zb3I6IFRlbnNvcjtcbiAgcHJpdmF0ZSBlcHNpbG9uID0gU2NhbGFyLm5ldygxZS01KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzRW50cm9weUNvc3QoXG4gICAgbWF0aDogTkRBcnJheU1hdGgsIHk6IEFycmF5MUQsIHRhcmdldDogQXJyYXkxRCwgZXBzaWxvbjogU2NhbGFyKTogU2NhbGFyIHtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB5LnNpemUgPT09IHRhcmdldC5zaXplLCAnVGhlIG91dHB1dCBhbmQgdGFyZ2V0IG11c3QgYmUgdGhlIHNhbWUgc2l6ZScpO1xuXG4gIHJldHVybiBtYXRoLnNjb3BlKCgpID0+IHtcbiAgICBjb25zdCB5UGx1c0VwcyA9IG1hdGguc2NhbGFyUGx1c0FycmF5KGVwc2lsb24sIHkpO1xuICAgIGNvbnN0IGxvZ091dHB1dCA9IG1hdGgubG9nKHlQbHVzRXBzKTtcbiAgICBjb25zdCB0YXJMb2dPdXRwdXQgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHRhcmdldCwgbG9nT3V0cHV0KTtcbiAgICBjb25zdCBjb3N0VmVjdG9yID0gbWF0aC5uZWcodGFyTG9nT3V0cHV0KTtcbiAgICByZXR1cm4gbWF0aC5zdW0oY29zdFZlY3Rvcik7XG4gIH0pO1xufVxuIiwiLyogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuLi9ncmFwaF91dGlsJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4uL21hdGgvbWF0aCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuLyoqXG4gKiBTcGxpdCBvcHMgYXJlIHVzZWQgdG8gYWNjdW11bGF0ZSBiYWNrcHJvcCBkZXJpdmF0aXZlcyB3aGVuIGEgbm9kZSdzIG91dHB1dFxuICogdGVuc29yIGlzIGNvbnN1bWVkIGJ5IG11bHRpcGxlIG5vZGVzLlxuICovXG5leHBvcnQgY2xhc3MgU3BsaXQgZXh0ZW5kcyBPcGVyYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlucHV0OiBUZW5zb3IsIHByaXZhdGUgb3V0cHV0czogVGVuc29yW10pIHtcbiAgICBzdXBlcigpO1xuICAgIG91dHB1dHMuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChpbnB1dC5zaGFwZSwgb3V0cHV0LnNoYXBlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZlZWRGb3J3YXJkKG1hdGg6IE5EQXJyYXlNYXRoLCBpbmZlcmVuY2VBcnJheXM6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgY29uc3QgaW5wdXRBcnJheSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5pbnB1dCk7XG4gICAgdGhpcy5vdXRwdXRzLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQob3V0cHV0LCBpbnB1dEFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBpZiAoIWdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy5pbnB1dCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBsZXQgZHggPSBtYXRoLmFkZChcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRwdXRzWzBdKSxcbiAgICAgICAgICBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRwdXRzWzFdKSk7XG4gICAgICAvLyBTdW0gYWNyb3NzIGFsbCB0aGUgZGVyaXZhdGl2ZXMgb2YgdGhlIGNvbnN1bWVycyBvZiB0aGlzIG5vZGUuXG4gICAgICB0aGlzLm91dHB1dHMuc2xpY2UoMikuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgICBkeCA9IG1hdGguYWRkKGR4LCBncmFkaWVudEFycmF5cy5nZXQob3V0cHV0KSk7XG4gICAgICB9KTtcbiAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLmlucHV0LCBrZWVwKGR4KSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL2dyYXBoJztcbmltcG9ydCAqIGFzIGdyYXBoX3V0aWwgZnJvbSAnLi4vZ3JhcGhfdXRpbCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuLi9tYXRoL21hdGgnO1xuaW1wb3J0IHtOREFycmF5LCBTY2FsYXJ9IGZyb20gJy4uL21hdGgvbmRhcnJheSc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuLi90ZW5zb3JfYXJyYXlfbWFwJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7T3BlcmF0aW9ufSBmcm9tICcuL29wJztcblxuZXhwb3J0IGNsYXNzIFN1YnRyYWN0IGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgcHJpdmF0ZSBkeVNpemVTY2FsYXI6IFNjYWxhcjtcblxuICAvKipcbiAgICogRWxlbWVudC13aXNlIHN1YnRyYWN0IG9wZXJhdGlvbi4gQnJvYWRjYXN0cyBpZiBvbmUgb2YgdGhlIHRlbnNvcnMgaXNcbiAgICogc2NhbGFyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHQxOiBUZW5zb3IsIHByaXZhdGUgdDI6IFRlbnNvciwgcHJpdmF0ZSBvdXRUZW5zb3I6IFRlbnNvcikge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodDEuc2hhcGUsIHQyLnNoYXBlKSxcbiAgICAgICAgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gIH1cblxuICBmZWVkRm9yd2FyZChtYXRoOiBOREFycmF5TWF0aCwgaW5mZXJlbmNlQXJyYXlzOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIGNvbnN0IHQxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnQxKTtcbiAgICBjb25zdCB0MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy50Mik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBsZXQgcmVzdWx0OiBOREFycmF5O1xuICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJNaW51c0FycmF5KHQxLCB0Mik7XG4gICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0aC5hcnJheU1pbnVzU2NhbGFyKHQxLCB0Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtYXRoLnN1Yih0MSwgdDIpO1xuICAgICAgfVxuICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldCh0aGlzLm91dFRlbnNvciwga2VlcChyZXN1bHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tQcm9wKFxuICAgICAgbWF0aDogTkRBcnJheU1hdGgsIGluZmVyZW5jZUFycmF5czogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5czogVGVuc29yQXJyYXlNYXApIHtcbiAgICBjb25zdCBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG5cbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcCh0aGlzLnQxKSkge1xuICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHRoaXMudDEuc2hhcGUpKSB7XG4gICAgICAgICAgY29uc3Qgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhciA9IFNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy50MSwga2VlcChtYXRoLmRpdmlkZShzdW0sIHRoaXMuZHlTaXplU2NhbGFyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLnQxLCBrZWVwKGR5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AodGhpcy50MikpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0aGlzLnQyLnNoYXBlKSkge1xuICAgICAgICAgIGNvbnN0IHN1bSA9IG1hdGguc3VtKGR5KTtcbiAgICAgICAgICBjb25zdCBuZWdTdW0gPSBtYXRoLm5lZyhzdW0pO1xuICAgICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhciA9IFNjYWxhci5uZXcoZHkuc2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldChcbiAgICAgICAgICAgICAgdGhpcy50Miwga2VlcChtYXRoLmRpdmlkZShuZWdTdW0sIHRoaXMuZHlTaXplU2NhbGFyKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyYWRpZW50QXJyYXlzLnNldCh0aGlzLnQyLCBrZWVwKG1hdGgubmVnKGR5KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7Tm9kZSwgVmFyaWFibGVOb2RlfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7U2Vzc2lvblJ1bnRpbWV9IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuL3RlbnNvcl9hcnJheV9tYXAnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT3B0aW1pemVyIHtcbiAgcHJvdGVjdGVkIHZhcmlhYmxlTm9kZXM6IFZhcmlhYmxlTm9kZVtdO1xuICBwcm90ZWN0ZWQgc3BlY2lmaWVkVmFyaWFibGVOb2RlczogVmFyaWFibGVOb2RlW118bnVsbDtcblxuICBjb25zdHJ1Y3RvcihzcGVjaWZpZWRWYXJpYWJsZUxpc3Q/OiBOb2RlW10pIHtcbiAgICBpZiAoc3BlY2lmaWVkVmFyaWFibGVMaXN0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9IHNwZWNpZmllZFZhcmlhYmxlTGlzdCBhcyBWYXJpYWJsZU5vZGVbXTtcbiAgICB9XG4gIH1cblxuICBhYnN0cmFjdCBiZWZvcmVCYXRjaChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBiYXRjaFNpemU6IG51bWJlciwgcnVudGltZTogU2Vzc2lvblJ1bnRpbWUsXG4gICAgICBhY3RpdmF0aW9uQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheU1hcDogVGVuc29yQXJyYXlNYXApOiB2b2lkO1xuXG4gIGFic3RyYWN0IGFmdGVyRXhhbXBsZShcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBydW50aW1lOiBTZXNzaW9uUnVudGltZSxcbiAgICAgIGFjdGl2YXRpb25BcnJheU1hcDogVGVuc29yQXJyYXlNYXAsXG4gICAgICBncmFkaWVudEFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgYWZ0ZXJCYXRjaChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBiYXRjaFNpemU6IG51bWJlciwgcnVudGltZTogU2Vzc2lvblJ1bnRpbWUsXG4gICAgICBhY3RpdmF0aW9uQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwLFxuICAgICAgZ3JhZGllbnRBcnJheU1hcDogVGVuc29yQXJyYXlNYXApOiB2b2lkO1xuXG4gIGFic3RyYWN0IGRpc3Bvc2UoKTogdm9pZDtcbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLyoqXG4gKiBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIHRoZSBwcmlvcml0eSBxdWV1ZS5cbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBlbGVtZW50IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIGVsZW1lbnQgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4gXCJhID4gYlwiIHJldHVybnMgPiAwLiBcImEgPCBiXCIgcmV0dXJucyA8IDAuIFwiYSA9PT0gYlwiIHJldHVybnMgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlPFQ+KGE6IFQsIGI6IFQpOiBudW1iZXIge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxO1xuICB9XG59XG5cbi8qKlxuICogQSBDb21wYXJhdG9yIGlzIGEgdXNlci1wcm92aWRlZCBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHR3byBUIGluc3RhbmNlcy4gVGhlXG4gKiBjb252ZW50aW9uIGZvciBkZWZhdWx0Q29tcGFyZSBpcyBleHBlY3RlZCB0byBiZSBmb2xsb3dlZCB0byBtYWludGFpbiB0aGVcbiAqIGJpbmFyeSBtaW4taGVhcCBpbnRlZ3JpdHkuXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgZWxlbWVudCB0byBjb21wYXJlLlxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBlbGVtZW50IHRvIGNvbXBhcmUuXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBhcmF0b3I8VD4gPSAoYTogVCwgYjogVCkgPT4gbnVtYmVyO1xuXG4vKipcbiAqIEluZGV4T2JzZXJ2ZXIgaXMgYSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRoYXQgaW5mb3JtcyB0aGUgY2FsbGVyIHdoZW4gYW5cbiAqIGVsZW1lbnQgaW4gdGhlIHByaW9yaXR5IHF1ZXVlJ3MgYmluYXJ5IG1pbi1oZWFwIGhhcyBiZWVuIHJlbG9jYXRlZC5cbiAqIEBwYXJhbSB0IFRoZSBlbGVtZW50IHRoYXQgd2FzIHJlbG9jYXRlZC5cbiAqIEBwYXJhbSBuZXdJbmRleCBUaGUgbmV3IGxvY2F0aW9uIGluIHRoZSBiaW5hcnkgbWluLWhlYXAgb2YgdGhlIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCB0eXBlIEluZGV4T2JzZXJ2ZXI8VD4gPSAodDogVCwgbmV3SW5kZXg6IG51bWJlcikgPT4gdm9pZDtcblxuLyoqXG4gKiBBIHByaW9yaXR5IHF1ZXVlLCBpbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBhIGJpbmFyeSBtaW4taGVhcC4gTG93ZXIgcHJpb3JpdHlcbiAqIG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgaGlnaGVyIHByaW9yaXR5LlxuICogZW5xdWV1ZSwgZGVxdWV1ZSwgYW5kIHVwZGF0ZSBhcmUgYWxsIE8obG9nIE4pIHdpdGggcmVzcGVjdCB0byB0aGUgbnVtYmVyIG9mXG4gKiBlbGVtZW50cyBpbiB0aGUgcXVldWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcmlvcml0eVF1ZXVlPFQ+IHtcbiAgcHJpdmF0ZSBoZWFwOiBUW10gPSBbXTtcblxuICAvKipcbiAgICogQHBhcmFtIGNvbXBhcmF0b3IgQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHR3byBxdWV1ZSBlbGVtZW50cy5cbiAgICogQHBhcmFtIGluZGV4T2JzZXJ2ZXIgQW4gb3B0aW9uYWwgY2FsbGJhY2sgcmFpc2VkIHdoZW4gdGhlIHByaW9yaXR5IHF1ZXVlXG4gICAqIGNoYW5nZXMgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGl0cyBtaW4taGVhcC4gVXNlZnVsIGZvciB0cmFja2luZyB0aGVcbiAgICogcG9zaXRpb25zIG9mIGVsZW1lbnRzIHRoYXQgbmVlZCB1cGRhdGluZy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBjb21wYXJhdG9yOiBDb21wYXJhdG9yPFQ+LFxuICAgICAgcHJpdmF0ZSBpbmRleE9ic2VydmVyPzogSW5kZXhPYnNlcnZlcjxUPikge31cblxuICAvKipcbiAgICogQWRkIGFuIGVsZW1lbnQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlLlxuICAgKiBAcGFyYW0gdCBUaGUgZWxlbWVudCB0byBlbnF1ZXVlLlxuICAgKi9cbiAgZW5xdWV1ZSh0OiBUKSB7XG4gICAgdGhpcy5oZWFwLnB1c2godCk7XG4gICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5zaWZ0VXAodGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIHByaW9yaXR5IHF1ZXVlLlxuICAgKiBAcmV0dXJuIFRoZSBlbGVtZW50IGluIHRoZSBwcmlvcml0eSBxdWV1ZSB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5XG4gICAqIChsb3dlc3QgbnVtZXJpYyBwcmlvcml0eSB2YWx1ZSkuXG4gICAqL1xuICBkZXF1ZXVlKCk6IFQge1xuICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVxdWV1ZSBjYWxsZWQgb24gZW1wdHkgcHJpb3JpdHkgcXVldWUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHQgPSB0aGlzLmhlYXBbMF07XG4gICAgdGhpcy5zd2FwKDAsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgdGhpcy5zaWZ0RG93bigwKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFuIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4gVGhpcyBjYW4gYmUgYSBmdWxsIGVsZW1lbnRcbiAgICogcmVwbGFjZW1lbnQsIG9yIGl0IGNhbiBiZSBhbiBpbi1wbGFjZSB1cGRhdGUuIFRoZSBwcmlvcml0eSBpcyBhc3N1bWVkIHRvIGJlXG4gICAqIGNoYW5nZWQsIGFuZCB0aGUgaW50ZXJuYWwgc3RvcmFnZSBpcyB1cGRhdGVkLiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsXG4gICAqIGlmIHRoZSBzdG9yYWdlIGluZGV4IG9mIHRoZSB1cGRhdGVkIGVsZW1lbnQgaXMga25vd247IGNvbnN0cnVjdCB0aGVcbiAgICogUHJpb3JpdHlRdWV1ZSB3aXRoIGFuIEluZGV4T2JzZXJ2ZXIgdG8gdHJhY2sgZWxlbWVudCBsb2NhdGlvbnMuXG4gICAqIEBwYXJhbSBuZXdUIFRoZSBuZXcgZWxlbWVudCB0byByZXBsYWNlIGluIHRoZSBwcmlvcml0eSBxdWV1ZS5cbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgdGhlIG5ldyBlbGVtZW50IGludG8uXG4gICAqL1xuICB1cGRhdGUobmV3VDogVCwgaW5kZXg6IG51bWJlcikge1xuICAgIC8qIElmIHRoZSBlbGVtZW50IGlzIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgaGVhcCwgbm8gc2lmdGluZyBpcyBuZWNlc3NhcnksXG4gICAgICogaXQgY2FuIGJlIHNhZmVseSByZW1vdmVkLiAqL1xuICAgIGNvbnN0IGxhc3QgPSAoaW5kZXggPT09IHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICBpZiAoIWxhc3QpIHtcbiAgICAgIHRoaXMuc3dhcChpbmRleCwgdGhpcy5oZWFwLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAvKiBUaGUgZWxlbWVudCBhdCAnaW5kZXgnIGhhcyBiZWVuIHJlbW92ZWQsIGFuZCByZXBsYWNlZCB3aXRoIHdoYXRldmVyIHdhc1xuICAgICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaGVhcC4gU2luY2UgdGhhdCBlbGVtZW50IG1pZ2h0IGhhdmUgY29tZSBmcm9tIGFcbiAgICAgICAqIGRpZmZlcmVudCBzdWJ0cmVlIChhbmQgbm90IGJlIGEgZGlyZWN0IGRlc2NlbmRhbnQgb2YgdGhlIG5vZGUgYXRcbiAgICAgICAqICdpbmRleCcpLCB3ZSBtaWdodCBuZWVkIHRvIHNpZnQgdGhpcyBuZXcgdmFsdWUgdXAgaW5zdGVhZCBvZiBkb3duLiBUZXN0XG4gICAgICAgKiBib3RoIGRpcmVjdGlvbnMsIGFuZCBzaWZ0IHRvIHdoZXJldmVyIHRoZSBub2RlIG5lZWRzIHRvIGdvLlxuICAgICAgICovXG4gICAgICBpZiAodGhpcy5zaWZ0VXBJbmRleChpbmRleCkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2lmdFVwKGluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zaWZ0RG93bihpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW5xdWV1ZShuZXdUKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVkaWNhdGUgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgUHJpb3JpdHlRdWV1ZSBpcyBlbXB0eS5cbiAgICogQHJldHVybiBUcnVlIGlmIHRoZSBQcmlvcml0eVF1ZXVlIGlzIGVtcHR5LCBvdGhlcndpc2UgRmFsc2UuXG4gICAqL1xuICBlbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5oZWFwLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHByaXZhdGUgb25JbmRleENoYW5nZWQodDogVCwgbmV3SW5kZXg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmluZGV4T2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuaW5kZXhPYnNlcnZlcih0LCBuZXdJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogU3RhbmRhcmQgemVyby1pbmRleGVkIGJpbmFyeSBoZWFwIGFycmF5IGxheW91dDpcbiAgICogICBQYXJlbnQoTikgPSBGbG9vcigoTiAtIDEpIC8gMilcbiAgICogICBMZWZ0Q2hpbGQoTikgPSAoTiAqIDIpICsgMVxuICAgKiAgIFJpZ2h0Q2hpbGQoTikgPSAoTiAqIDIpICsgMlxuICAgKi9cblxuICBwcml2YXRlIGdldFBhcmVudEluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMZWZ0Q2hpbGRJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAxO1xuICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gIH1cblxuICBwcml2YXRlIGdldFJpZ2h0Q2hpbGRJbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAyO1xuICAgIHJldHVybiBjYW5kaWRhdGUgPCB0aGlzLmhlYXAubGVuZ3RoID8gY2FuZGlkYXRlIDogLTE7XG4gIH1cblxuICBwcml2YXRlIHNpZnRVcEluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IHBhcmVudEluZGV4ID0gdGhpcy5nZXRQYXJlbnRJbmRleChpbmRleCk7XG4gICAgaWYgKHBhcmVudEluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb21wYXJlKHBhcmVudEluZGV4LCBpbmRleCkgPiAwKSB7XG4gICAgICByZXR1cm4gcGFyZW50SW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHByaXZhdGUgc2lmdFVwKGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzaWZ0RG93bkluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYXAubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBsYXJnZXN0Q2hpbGRJbmRleCA9IGluZGV4O1xuICAgIGNvbnN0IGxlZnRDaGlsZEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgaWYgKChsZWZ0Q2hpbGRJbmRleCAhPT0gLTEpICYmXG4gICAgICAgICh0aGlzLmNvbXBhcmUobGVmdENoaWxkSW5kZXgsIGxhcmdlc3RDaGlsZEluZGV4KSA8IDApKSB7XG4gICAgICBsYXJnZXN0Q2hpbGRJbmRleCA9IGxlZnRDaGlsZEluZGV4O1xuICAgIH1cbiAgICBjb25zdCByaWdodENoaWxkSW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgaWYgKChyaWdodENoaWxkSW5kZXggIT09IC0xKSAmJlxuICAgICAgICAodGhpcy5jb21wYXJlKHJpZ2h0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gcmlnaHRDaGlsZEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gKGxhcmdlc3RDaGlsZEluZGV4ID09PSBpbmRleCkgPyAtMSA6IGxhcmdlc3RDaGlsZEluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBzaWZ0RG93bihpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHNpZnRJbmRleCA9IHRoaXMuc2lmdERvd25JbmRleChpbmRleCk7XG4gICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0RG93bkluZGV4KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbXBhcmUoYUluZGV4OiBudW1iZXIsIGJJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJhdG9yKHRoaXMuaGVhcFthSW5kZXhdLCB0aGlzLmhlYXBbYkluZGV4XSk7XG4gIH1cblxuICBwcml2YXRlIHN3YXAoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICBjb25zdCB0ZW1wID0gdGhpcy5oZWFwW2FdO1xuICAgIHRoaXMuaGVhcFthXSA9IHRoaXMuaGVhcFtiXTtcbiAgICB0aGlzLmhlYXBbYl0gPSB0ZW1wO1xuICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2FdLCBhKTtcbiAgICB0aGlzLm9uSW5kZXhDaGFuZ2VkKHRoaXMuaGVhcFtiXSwgYik7XG4gIH1cbn1cbiIsIi8qIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuaW1wb3J0IHtHcmFwaCwgTm9kZSwgVGVuc29yfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7SW5wdXRQcm92aWRlcn0gZnJvbSAnLi9pbnB1dF9wcm92aWRlcic7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0ICogYXMgb3BlcmF0aW9uX2VtaXR0ZXIgZnJvbSAnLi9vcGVyYXRpb25fZW1pdHRlcic7XG5pbXBvcnQge09wZXJhdGlvbn0gZnJvbSAnLi9vcHMvb3AnO1xuaW1wb3J0IHtPcHRpbWl6ZXJ9IGZyb20gJy4vb3B0aW1pemVyJztcbmltcG9ydCAqIGFzIHNlc3Npb25fdXRpbCBmcm9tICcuL3Nlc3Npb25fdXRpbCc7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEZlZWRFbnRyeSBhc3NvY2lhdGVzIGEgdGVuc29yIHdpdGggdXNlci1wcm92aWRlZCBOREFycmF5IGRhdGEuXG4gKi9cbmV4cG9ydCB0eXBlIEZlZWRFbnRyeSA9IHtcbiAgdGVuc29yOiBUZW5zb3IsXG4gIGRhdGE6IE5EQXJyYXl8SW5wdXRQcm92aWRlclxufTtcblxuLyoqXG4gKiBBIEZlZWREaWN0aW9uYXJ5IGhvbGRzIGEgbWFwIGZyb20gdGVuc29ycyB0byB1c2VyLXByb3ZpZGVkIE5EQXJyYXlzLiBGZWVkXG4gKiBkaWN0aW9uYXJpZXMgcmVwcmVzZW50IHRoZSAnZW50cnkgcG9pbnRzJyBvZiBldmFsdWF0aW9uLCBzaW5jZSBncmFwaCBub2Rlc1xuICogdGhhdCBhcmUgcmVwbGFjZWQgYnkgZmVlZHMgZG9uJ3QgbmVlZCB0byBoYXZlIHRoZWlyIGlucHV0IG5vZGVzIGV2YWx1YXRlZC5cbiAqIEZlZWQgZGljdGlvbmFyaWVzIHVzdWFsbHkgcHJvdmlkZSBOREFycmF5IGRhdGEgZm9yIFBsYWNlaG9sZGVyIG5vZGVzLCBidXQgYW55XG4gKiBub2RlIGluIHRoZSBncmFwaCBjYW4gYmUgcmVwbGFjZWQgYnkgYSBmZWVkIGRpY3Rpb25hcnkgZW50cnkuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRmVlZERpY3Rpb25hcnkge1xuICBkaWN0OiB7W3RlbnNvcklEOiBudW1iZXJdOiBGZWVkRW50cnl9ID0ge307XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgY29uc3RydWN0IGEgRmVlZERpY3Rpb25hcnkgZnJvbSBhbiBhcnJheSBvZiBlbnRyaWVzLlxuICAgKiBAcGFyYW0gZmVlZEVudHJpZXMgT3B0aW9uYWwgYXJyYXkgb2YgRmVlZEVudHJ5IG9iamVjdHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmZWVkRW50cmllcz86IEZlZWRFbnRyeVtdKSB7XG4gICAgaWYgKGZlZWRFbnRyaWVzKSB7XG4gICAgICBmZWVkRW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHRoaXMuZGljdFtlbnRyeS50ZW5zb3IuaWRdID0gZW50cnkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZW51bSBDb3N0UmVkdWN0aW9uIHtcbiAgTk9ORSxcbiAgU1VNLFxuICBNRUFOXG59XG5cbi8qKlxuICogQSBTZXNzaW9uIG1haW50YWlucyB0aGUgcnVudGltZSBzdGF0ZSByZXF1aXJlZCB0byBlZmZpY2llbnRseSBldmFsdWF0ZSBub2Rlcy5cbiAqIE9uIHRoZWlyIG93biwgZ3JhcGggb2JqZWN0cyBhcmUgdmVyeSBsaWdodHdlaWdodCBsb2dpY2FsIHRvcG9sb2dpZXM7IHRoZXlcbiAqIGhhdmUgbm8gcmVsYXRpb25zaGlwIHdpdGggdGhlIEdQVS4gU2Vzc2lvbnMgZW5jYXBzdWxhdGUgdGhlIGV2YWx1YXRpb24gb2ZcbiAqIG5vZGVzLCB0aGUgbWFuYWdlbWVudCBvZiBHUFUgcmVzb3VyY2VzLCB0aGUgY2FjaGluZyBvZiBldmFsdWF0aW9uIHBhdGhzLCBhbmRcbiAqIGFueXRoaW5nIGVsc2UgcmVxdWlyZWQgdG8gZXZhbHVhdGUgb3IgdHJhaW4gYSBuZXR3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0gZ3JhcGggVGhlIGdyYXBoIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgU2Vzc2lvbi5cbiAgICogQHBhcmFtIG1hdGggVGhlIE5EQXJyYXlNYXRoIGludGVyZmFjZSB0aGF0IHRoaXMgU2Vzc2lvbiBzaG91bGQgdXNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ3JhcGg6IEdyYXBoLCBwcml2YXRlIG1hdGg6IE5EQXJyYXlNYXRoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIGFsbCBzeXN0ZW0gcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFNlc3Npb24uXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwLmRpc3Bvc2UoKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLnJ1bnRpbWVDYWNoZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgcnVudGltZSA9IHRoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICBpZiAocnVudGltZS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKG9wID0+IG9wLmRpc3Bvc2UoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICBpZiAodGhpcy5iYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXRjaFNpemVTY2FsYXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLm9uZVNjYWxhci5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgYSBsaXN0IG9mIHRlbnNvcnMsIHVzaW5nIHRoZSBwcm92aWRlZCBmZWVkIGVudHJpZXMgdG8gcHJvdmlkZVxuICAgKiB1cHN0cmVhbSBOREFycmF5IGlucHV0LlxuICAgKiBXaGVuIHVzaW5nIGEgYE5EQXJyYXlNYXRoYCBvYmplY3QgaW4gc2FmZSBtb2RlIHRoaXMgbXVzdCBiZSB1c2VkIGluIGFcbiAgICogbWF0aC5zY29wZSgpLlxuICAgKiBAcGFyYW0gdGVuc29ycyBUaGUgbGlzdCBvZiB0ZW5zb3JzIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0gZmVlZEVudHJpZXMgTGlzdCBvZiBgRmVlZEVudHJ5YCB0byByZWFkIHdoZW4gcmVwbGFjaW5nIGdyYXBoXG4gICAqIHRlbnNvcnMgd2l0aCBOREFycmF5cy5cbiAgICogQHJldHVybiBUaGUgY29tcHV0ZWQgdmFsdWVzIG9mIHRoZSB0ZW5zb3JzLlxuICAgKi9cbiAgZXZhbEFsbCh0ZW5zb3JzOiBUZW5zb3JbXSwgZmVlZEVudHJpZXM6IEZlZWRFbnRyeVtdKTogTkRBcnJheVtdIHtcbiAgICByZXR1cm4gdGhpcy5tYXRoLnNjb3BlKCgpID0+IHtcbiAgICAgIGNvbnN0IGZlZWQgPSBuZXcgRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpO1xuICAgICAgY29uc3QgcnVudGltZSA9IHRoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKHRlbnNvcnMsIGZlZWQpO1xuXG4gICAgICBjb25zdCBhY3RpdmF0aW9ucyA9IHRoaXMuYWN0aXZhdGlvbkFycmF5TWFwO1xuXG4gICAgICBzZXNzaW9uX3V0aWwuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKFxuICAgICAgICAgIHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzKFxuICAgICAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucywgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAsIHRoaXMuZ3JhZGllbnRBcnJheU1hcCk7XG5cbiAgICAgIHNlc3Npb25fdXRpbC5hZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcChcbiAgICAgICAgICBydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICBzZXNzaW9uX3V0aWwubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoXG4gICAgICAgICAgZmVlZCwgYWN0aXZhdGlvbnMsIHRoaXMubWF0aCk7XG5cbiAgICAgIHJ1bnRpbWUub3BlcmF0aW9ucy5mb3JFYWNoKG9wID0+IG9wLmZlZWRGb3J3YXJkKHRoaXMubWF0aCwgYWN0aXZhdGlvbnMpKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IHRlbnNvcnMubWFwKHggPT4gYWN0aXZhdGlvbnMuZ2V0KHgpKTtcbiAgICAgIHRlbnNvcnMuZm9yRWFjaCh4ID0+IGFjdGl2YXRpb25zLmRlbGV0ZSh4KSk7XG5cbiAgICAgIHNlc3Npb25fdXRpbC5yZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoXG4gICAgICAgICAgZmVlZCwgYWN0aXZhdGlvbnMsIHRoaXMubWF0aCk7XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGEgdGVuc29yLCB1c2luZyB0aGUgcHJvdmlkZWQgZmVlZCBlbnRyaWVzIHRvIHByb3ZpZGVcbiAgICogdXBzdHJlYW0gTkRBcnJheSBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHRlbnNvciBUaGUgdGVuc29yIHRvIGV2YWx1YXRlLlxuICAgKiBAcGFyYW0gZmVlZEVudHJpZXMgTGlzdCBvZiBgRmVlZEVudHJ5YCB0byByZWFkIHdoZW4gcmVwbGFjaW5nIGdyYXBoXG4gICAqIHRlbnNvcnMgd2l0aCBOREFycmF5cy5cbiAgICogQHJldHVybiBUaGUgY29tcHV0ZWQgdmFsdWUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIGV2YWwodGVuc29yOiBUZW5zb3IsIGZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXSk6IE5EQXJyYXkge1xuICAgIHJldHVybiB0aGlzLmV2YWxBbGwoW3RlbnNvcl0sIGZlZWRFbnRyaWVzKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFpbnMgYSBiYXRjaC5cbiAgICogUmV0dXJucyBhIHJlZHVjZWQgY29zdCBpZiB0aGUgY29zdFJlZHVjdGlvbiBwYXJhbWV0ZXIgaXMgc2V0LlxuICAgKiBXaGVuIHVzaW5nIGEgYE5EQXJyYXlNYXRoYCBvYmplY3QgaW4gc2FmZSBtb2RlIHRoaXMgbXVzdCBiZSB1c2VkIGluIGFcbiAgICogbWF0aC5zY29wZSgpLlxuICAgKiBAcGFyYW0gY29zdFRlbnNvciBBIHRlbnNvciByZXByZXNlbnRpbmcgdGhlIGNvc3QgdG8gb3B0aW1pemUuIFNob3VsZCBiZSBhXG4gICAqIHNjYWxhci5cbiAgICogQHBhcmFtIGZlZWRFbnRyaWVzIEZlZWQgZW50cmllcyBmb3IgdGhpcyB0cmFpbiBydW4uIFByb3ZpZGVzIGlucHV0cy5cbiAgICogQHBhcmFtIGJhdGNoU2l6ZSBCYXRjaCBzaXplIGZvciB0aGlzIHRyYWluIGxvb3AuXG4gICAqIEBwYXJhbSBvcHRpbWl6ZXIgQW4gb3B0aW1pemVyIHRvIHBlcmZvcm0gd2VpZ2h0IHVwZGF0ZXMuXG4gICAqIEBwYXJhbSBjb3N0UmVkdWN0aW9uIEFuIG9wdGlvbiB0byBhbGxvdyB0aGUgdXNlciB0byBnZXQgYSBzdW1tZWQsIGF2ZXJhZ2VkLFxuICAgKiBvciBubyBjb3N0IGJhY2suXG4gICAqIEByZXR1cm4gVGhlIHJlZHVjZWQgY29zdCwgaWYgY29zdCByZWR1Y3Rpb24gaXMgbm90IE5PTkUuIFRoZSB1c2VyIGlzXG4gICAqIHJlc3BvbnNpYmxlIGZvciBkaXNwb3NpbmcgdGhlIGNvc3QgTkRBcnJheSBiZXR3ZWVuIHRyYWluIGxvb3BzLlxuICAgKi9cbiAgdHJhaW4oXG4gICAgICBjb3N0VGVuc29yOiBUZW5zb3IsIGZlZWRFbnRyaWVzOiBGZWVkRW50cnlbXSwgYmF0Y2hTaXplOiBudW1iZXIsXG4gICAgICBvcHRpbWl6ZXI6IE9wdGltaXplciwgY29zdFJlZHVjdGlvbiA9IENvc3RSZWR1Y3Rpb24uTk9ORSk6IFNjYWxhciB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuaXNTY2FsYXJTaGFwZShjb3N0VGVuc29yLnNoYXBlKSxcbiAgICAgICAgJ0Nvc3QgdGVuc29yIGZvciB0cmFpbmluZyBtdXN0IGJlIGEgc2NhbGFyIHZhbHVlLicpO1xuXG4gICAgaWYgKHRoaXMucHJldkJhdGNoU2l6ZSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICB0aGlzLnByZXZCYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICB0aGlzLmJhdGNoU2l6ZVNjYWxhciA9IFNjYWxhci5uZXcoYmF0Y2hTaXplKTtcbiAgICB9XG5cbiAgICBjb25zdCBmZWVkID0gbmV3IEZlZWREaWN0aW9uYXJ5KGZlZWRFbnRyaWVzKTtcbiAgICBzZXNzaW9uX3V0aWwudGhyb3dJZkZlZWREaWN0aW9uYXJ5Q29udGFpbnNOREFycmF5cyhmZWVkKTtcblxuICAgIGNvbnN0IHJ1bnRpbWUgPSB0aGlzLmdldE9yQ3JlYXRlUnVudGltZShbY29zdFRlbnNvcl0sIGZlZWQpO1xuICAgIGNvbnN0IGluZmVyZW5jZU9wZXJhdGlvbnMgPSBydW50aW1lLm9wZXJhdGlvbnM7XG4gICAgY29uc3QgYmFja1Byb3BPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIGNvbnN0IGFjdGl2YXRpb25zID0gdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXA7XG4gICAgY29uc3QgZ3JhZGllbnRzID0gdGhpcy5ncmFkaWVudEFycmF5TWFwO1xuICAgIGdyYWRpZW50cy5zZXQoY29zdFRlbnNvciwgdGhpcy5vbmVTY2FsYXIpO1xuXG4gICAgc2Vzc2lvbl91dGlsLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKFxuICAgICAgICBydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG5cbiAgICBvcHRpbWl6ZXIuYmVmb3JlQmF0Y2goXG4gICAgICAgIHRoaXMubWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcblxuICAgIHJldHVybiB0aGlzLm1hdGguc2NvcGUoKGtlZXAsIHRyYWNrKSA9PiB7XG4gICAgICBsZXQgY29zdCA9IHRyYWNrKFNjYWxhci5uZXcoMCkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoU2l6ZTsgKytpKSB7XG4gICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoXG4gICAgICAgICAgICBydW50aW1lLm5vZGVzLCBhY3RpdmF0aW9ucyk7XG4gICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzKFxuICAgICAgICAgICAgcnVudGltZS5ub2RlcywgZ3JhZGllbnRzKTtcbiAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMoXG4gICAgICAgICAgICBydW50aW1lLm9wZXJhdGlvbnMsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuXG4gICAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChcbiAgICAgICAgICAgIGZlZWQsIGFjdGl2YXRpb25zLCB0aGlzLm1hdGgpO1xuXG4gICAgICAgIGluZmVyZW5jZU9wZXJhdGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgIG9wID0+IG9wLmZlZWRGb3J3YXJkKHRoaXMubWF0aCwgYWN0aXZhdGlvbnMpKTtcbiAgICAgICAgYmFja1Byb3BPcGVyYXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICBvcCA9PiBvcC5iYWNrUHJvcCh0aGlzLm1hdGgsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpKTtcblxuICAgICAgICBvcHRpbWl6ZXIuYWZ0ZXJFeGFtcGxlKHRoaXMubWF0aCwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG5cbiAgICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChcbiAgICAgICAgICAgIGZlZWQsIGFjdGl2YXRpb25zLCB0aGlzLm1hdGgpO1xuXG4gICAgICAgIGNvc3QgPSB0aGlzLnVwZGF0ZUNvc3RGb3JFeGFtcGxlKFxuICAgICAgICAgICAgY29zdCwgYWN0aXZhdGlvbnMuZ2V0KGNvc3RUZW5zb3IpLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW1pemVyLmFmdGVyQmF0Y2goXG4gICAgICAgICAgdGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVDb3N0Rm9yQmF0Y2goY29zdCwgY29zdFJlZHVjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNvc3RGb3JFeGFtcGxlKFxuICAgICAgdG90YWxDb3N0OiBTY2FsYXIsIGN1cnJDb3N0OiBTY2FsYXIsXG4gICAgICBjb3N0UmVkdWN0aW9uOiBDb3N0UmVkdWN0aW9uKTogU2NhbGFyIHtcbiAgICBpZiAoY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5NRUFOIHx8XG4gICAgICAgIGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uU1VNKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRoLmFkZCh0b3RhbENvc3QsIGN1cnJDb3N0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsQ29zdDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ29zdEZvckJhdGNoKHRvdGFsQ29zdDogU2NhbGFyLCBjb3N0UmVkdWN0aW9uOiBDb3N0UmVkdWN0aW9uKTpcbiAgICAgIFNjYWxhciB7XG4gICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgcmV0dXJuIHRoaXMubWF0aC5kaXZpZGUodG90YWxDb3N0LCB0aGlzLmJhdGNoU2l6ZVNjYWxhcik7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbENvc3Q7XG4gIH1cblxuICBwcml2YXRlIGdldE9yQ3JlYXRlUnVudGltZSh0ZW5zb3JzOiBUZW5zb3JbXSwgZmVlZDogRmVlZERpY3Rpb25hcnkpOlxuICAgICAgU2Vzc2lvblJ1bnRpbWUge1xuICAgIGNvbnN0IGtleSA9IHRoaXMubWFrZVJ1bnRpbWVDYWNoZUtleSh0ZW5zb3JzLCBmZWVkKTtcbiAgICBsZXQgcnVudGltZSA9IHRoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgaWYgKHJ1bnRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG5vZGVzID1cbiAgICAgICAgICBzZXNzaW9uX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcih0ZW5zb3JzLCBmZWVkKTtcbiAgICAgIC8vIEluIGluZmVyZW5jZSBtb2RlIHNwbGl0IG5vZGVzIGFyZSBub3QgbmVlZGVkLCBidXQgdGhlaXIgY29zdCBpc1xuICAgICAgLy8gbmVnbGlnaWJsZSwgYW5kIGFsd2F5cyBhZGRpbmcgdGhlbSBpbiBhbGxvd3MgZm9yIGNhY2hpbmcgb2YgMSBydW50aW1lXG4gICAgICAvLyBmb3IgYm90aCB0cmFpbi9ldmFsLlxuICAgICAgbm9kZXMgPSBzZXNzaW9uX3V0aWwuYWRkU3BsaXROb2Rlcyhub2Rlcyk7XG4gICAgICBzZXNzaW9uX3V0aWwucmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KGZlZWQsIG5vZGVzKTtcbiAgICAgIHNlc3Npb25fdXRpbC50aHJvd0Vycm9ySWZFdmFsdWF0aW9uU2V0Q29udGFpbnNQbGFjZWhvbGRlck5vZGVzKG5vZGVzKTtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBvcGVyYXRpb25fZW1pdHRlci5lbWl0RnJvbUdyYXBoTm9kZXMobm9kZXMpO1xuICAgICAgcnVudGltZSA9IHtub2Rlcywgb3BlcmF0aW9uc307XG4gICAgICB0aGlzLnJ1bnRpbWVDYWNoZVtrZXldID0gcnVudGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVudGltZTtcbiAgfVxuXG4gIHByaXZhdGUgbWFrZVJ1bnRpbWVDYWNoZUtleSh0ZW5zb3JzOiBUZW5zb3JbXSwgZmVlZDogRmVlZERpY3Rpb25hcnkpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZW5zb3JzLm1hcCh4ID0+IHguaWQpLnNvcnQoKS5qb2luKCdfJykgKyAnX18nICtcbiAgICAgICAgT2JqZWN0LmtleXMoZmVlZC5kaWN0KS5zb3J0KCkuam9pbignXycpO1xuICB9XG5cbiAgLyoqIE1hcHMgZWFjaCBvdXRwdXQgdGVuc29yIG9mIHRoZSBncmFwaCB0byBpdHMgYWN0aXZhdGlvbiB2YWx1ZS4gKi9cbiAgYWN0aXZhdGlvbkFycmF5TWFwID0gbmV3IFRlbnNvckFycmF5TWFwKCk7XG4gIC8qKiBNYXBzIGVhY2ggdGVuc29yIG9mIHRoZSBncmFwaCB0byBpdHMgZGVyaXZhdGl2ZSB3cnQgdGhlIGNvc3QgZnVuY3Rpb24uICovXG4gIGdyYWRpZW50QXJyYXlNYXAgPSBuZXcgVGVuc29yQXJyYXlNYXAoKTtcbiAgcHJpdmF0ZSBydW50aW1lQ2FjaGU6IHtba2V5OiBzdHJpbmddOiBTZXNzaW9uUnVudGltZX0gPSB7fTtcbiAgLyoqIEJhdGNoIHNpemUgb2YgdGhlIHByZXZpb3VzIHRyYWluKCkgY2FsbC4gKi9cbiAgcHJpdmF0ZSBwcmV2QmF0Y2hTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgYmF0Y2hTaXplU2NhbGFyOiBTY2FsYXI7XG4gIHByaXZhdGUgb25lU2NhbGFyID0gU2NhbGFyLm5ldygxKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCB0eXBlIFNlc3Npb25SdW50aW1lID0ge1xuICBub2RlczogTm9kZVtdOyBvcGVyYXRpb25zOiBPcGVyYXRpb25bXTtcbn07XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbmltcG9ydCB7Q29uc3RhbnROb2RlLCBOb2RlLCBQbGFjZWhvbGRlck5vZGUsIFNwbGl0Tm9kZSwgVGVuc29yLCBWYXJpYWJsZU5vZGV9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0ICogYXMgZ3JhcGhfdXRpbCBmcm9tICcuL2dyYXBoX3V0aWwnO1xuaW1wb3J0IHtJbnB1dFByb3ZpZGVyfSBmcm9tICcuL2lucHV0X3Byb3ZpZGVyJztcbmltcG9ydCB7TkRBcnJheU1hdGh9IGZyb20gJy4vbWF0aC9tYXRoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtPcGVyYXRpb259IGZyb20gJy4vb3BzL29wJztcbmltcG9ydCB7RmVlZERpY3Rpb25hcnl9IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvckFycmF5TWFwfSBmcm9tICcuL3RlbnNvcl9hcnJheV9tYXAnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JhcGggbm9kZXMgdGhhdCBzdG9wIHRyYXZlcnNhbCwgYmFzZWQgb24gdGhlIGNvbnRlbnRzXG4gKiBvZiB0aGUgcHJvdmlkZWQgRmVlZERpY3Rpb25hcnkuIFRoaXMgaXMgYSBzaW1wbGUgMToxIGV4dHJhY3Rpb24gb2Ygbm9kZXMgZnJvbVxuICogdGhlIEZlZWREaWN0aW9uYXJ5LlxuICpcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBmZWVkRGljdGlvbmFyeSBUaGUgRmVlZERpY3Rpb25hcnkgdG8gc2NhbiBmb3IgdGVybWluYXRpb24gbm9kZXMuXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIE5vZGVzIHdoaWNoIGhhbHQgdHJhdmVyc2FsIHdoZW4gdmlzaXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnkoXG4gICAgZmVlZERpY3Rpb25hcnk6IEZlZWREaWN0aW9uYXJ5KTogTm9kZVtdIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpXG4gICAgICAubWFwKHRlbnNvcklEID0+IGZlZWREaWN0aW9uYXJ5LmRpY3RbK3RlbnNvcklEXS50ZW5zb3Iubm9kZSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSB0ZW5zb3IgYW5kIGEgZmVlZCBkaWN0aW9uYXJ5LCBjb21wdXRlcyB0aGUgc2V0IG9mIG5vZGVzIHRoYXQgbmVlZCB0b1xuICogYmUgZXZhbHVhdGVkIHRvIHBlcmZvcm0gaW5mZXJlbmNlLlxuICpcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBldmFsVGVuc29ycyBUaGUgbGlzdCBvZiB0ZW5zb3JzIHRvIGV2ZW50dWFsbHkgYmUgZXZhbHVhdGVkLlxuICogQHBhcmFtIGZlZWREaWN0aW9uYXJ5IFRoZSBwb3B1bGF0ZWQgZmVlZCBkaWN0aW9uYXJ5LlxuICogQHJldHVybiBUaGUgc2V0IG9mIG5vZGVzIHRvIGV2YWx1YXRlLCBpbiBldmFsdWF0aW9uIG9yZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcihcbiAgICBldmFsVGVuc29yczogVGVuc29yW10sIGZlZWREaWN0aW9uYXJ5OiBGZWVkRGljdGlvbmFyeSk6IE5vZGVbXSB7XG4gIGNvbnN0IHRlcm1pbmF0aW5nTm9kZXMgPVxuICAgICAgZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSk7XG4gIGNvbnN0IGV2YWxOb2RlcyA9IGV2YWxUZW5zb3JzLm1hcCh4ID0+IHgubm9kZSk7XG4gIGNvbnN0IHVub3JkZXJlZEV2YWx1YXRpb25TZXQgPVxuICAgICAgZ3JhcGhfdXRpbC5nZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0KGV2YWxOb2RlcywgdGVybWluYXRpbmdOb2Rlcyk7XG4gIGNvbnN0IG9yZGVyZWRFdmFsdWF0aW9uU2V0ID1cbiAgICAgIGdyYXBoX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCk7XG4gIHJldHVybiBvcmRlcmVkRXZhbHVhdGlvblNldDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHByb3ZpZGVkIG5vZGUgYXJyYXkgYW5kIGFkZHMgYWxsIHBlcnNpc3RlbnQgbm9kZSBOREFycmF5cyB0b1xuICogdGhlIHByb3ZpZGVkIFRlbnNvckFycmF5TWFwLlxuICpcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBldmFsdWF0aW9uU2V0IFRoZSBhcnJheSBvZiBub2RlcyB0byBzY2FuLlxuICogQHBhcmFtIHRlbnNvckFycmF5TWFwIFRoZSBtYXAgdGhhdCByZWNlaXZlcyB0aGUgTkRBcnJheXMgZnJvbSBwZXJzaXN0ZW50XG4gKiBub2Rlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKFxuICAgIGV2YWx1YXRpb25TZXQ6IE5vZGVbXSwgdGVuc29yQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwKSB7XG4gIGV2YWx1YXRpb25TZXQuZm9yRWFjaChub2RlID0+IHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFZhcmlhYmxlTm9kZSB8fCBub2RlIGluc3RhbmNlb2YgQ29uc3RhbnROb2RlKSB7XG4gICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG5vZGUuZGF0YSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQoZXZhbHVhdGlvblNldDogTm9kZVtdKTpcbiAgICBWYXJpYWJsZU5vZGVbXSB7XG4gIGNvbnN0IG5vZGVzOiBWYXJpYWJsZU5vZGVbXSA9IFtdO1xuICBldmFsdWF0aW9uU2V0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBWYXJpYWJsZU5vZGUpIHtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoXG4gICAgZmVlZERpY3Rpb25hcnk6IEZlZWREaWN0aW9uYXJ5KSB7XG4gIE9iamVjdC5rZXlzKGZlZWREaWN0aW9uYXJ5LmRpY3QpLmZvckVhY2godGVuc29ySUQgPT4ge1xuICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0Wyt0ZW5zb3JJRF0uZGF0YSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAndHJhaW5pbmcgcmVxdWlyZXMgRmVlZERpY3Rpb25hcnkgZW50cmllcyB0byBiZSBJbnB1dFByb3ZpZGVycycgK1xuICAgICAgICAgICdhbmQgbm90IE5EQXJyYXlzLicpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoXG4gICAgYmF0Y2hGZWVkOiBGZWVkRGljdGlvbmFyeSwgYWN0aXZhdGlvbnM6IFRlbnNvckFycmF5TWFwLCBtYXRoOiBOREFycmF5TWF0aCkge1xuICBPYmplY3Qua2V5cyhiYXRjaEZlZWQuZGljdCkuZm9yRWFjaCh0ZW5zb3JJRCA9PiB7XG4gICAgY29uc3QgZmVlZEVudHJ5ID0gYmF0Y2hGZWVkLmRpY3RbK3RlbnNvcklEXTtcblxuICAgIGxldCBkYXRhOiBOREFycmF5O1xuICAgIGlmIChmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIE5EQXJyYXkpIHtcbiAgICAgIGRhdGEgPSBmZWVkRW50cnkuZGF0YSBhcyBOREFycmF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGZlZWRFbnRyeS5kYXRhIGFzIElucHV0UHJvdmlkZXI7XG4gICAgICBkYXRhID0gcHJvdmlkZXIuZ2V0TmV4dENvcHkobWF0aCk7XG4gICAgfVxuXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoZmVlZEVudHJ5LnRlbnNvci5zaGFwZSwgZGF0YS5zaGFwZSksXG4gICAgICAgIGBFcnJvciBsb2FkaW5nIEZlZWRFbnRyeTogZmVlZGluZyBOREFycmF5IG9mIHNoYXBlICR7ZGF0YS5zaGFwZX0gYCArXG4gICAgICAgICAgICBgZG9lcyBub3QgbWF0Y2ggVGVuc29yIChpZDogJHtmZWVkRW50cnkudGVuc29yLmlkfSkgc2hhcGU6IGAgK1xuICAgICAgICAgICAgYCR7ZmVlZEVudHJ5LnRlbnNvci5zaGFwZX0uYCk7XG4gICAgYWN0aXZhdGlvbnMuc2V0KGZlZWRFbnRyeS50ZW5zb3IsIGRhdGEpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChcbiAgICBiYXRjaEZlZWQ6IEZlZWREaWN0aW9uYXJ5LCBhY3RpdmF0aW9uczogVGVuc29yQXJyYXlNYXAsIG1hdGg6IE5EQXJyYXlNYXRoKSB7XG4gIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKHRlbnNvcklEID0+IHtcbiAgICBjb25zdCBmZWVkRW50cnkgPSBiYXRjaEZlZWQuZGljdFsrdGVuc29ySURdO1xuXG4gICAgaWYgKCEoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiBOREFycmF5KSkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBmZWVkRW50cnkuZGF0YSBhcyBJbnB1dFByb3ZpZGVyO1xuXG4gICAgICBjb25zdCBmZWVkRW50cnlBcnJheSA9IGFjdGl2YXRpb25zLmdldChmZWVkRW50cnkudGVuc29yKTtcbiAgICAgIHByb3ZpZGVyLmRpc3Bvc2VDb3B5KG1hdGgsIGZlZWRFbnRyeUFycmF5KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9ucy5kZWxldGUoZmVlZEVudHJ5LnRlbnNvcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIG5vZGVzIGZyb20gdGhlIHByb3ZpZGVkIE5vZGUgYXJyYXkgd2hvc2Ugb3V0cHV0IHRlbnNvcnMgZXhpc3QgaW5cbiAqIHRoZSBwcm92aWRlZCBmZWVkIGRpY3Rpb25hcnkuIEFmdGVyIGNhbGxpbmcgdGhpcywgdGhlIE5vZGUgYXJyYXkgc2hvdWxkXG4gKiBjb250YWluIHplcm8gUGxhY2Vob2xkZXIgbm9kZXMsIG9yIHRoZSB1c2VyIGhhcyBmYWlsZWQgdG8gcHJvdmlkZSBhIGZlZWQgZm9yXG4gKiBhIFBsYWNlaG9sZGVyIG5vZGUuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGZlZWREaWN0aW9uYXJ5IFRoZSBGZWVkRGljdGlvbmFyeSB0byBwcm9jZXNzLlxuICogQHBhcmFtIGV2YWx1YXRpb25TZXQgVGhlIGFycmF5IG9mIG5vZGVzIHRvIHJlbW92ZSBpbnB1dCBub2RlcyBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmVlZERpY3Rpb25hcnlOb2Rlc0Zyb21FdmFsdWF0aW9uU2V0KFxuICAgIGZlZWREaWN0aW9uYXJ5OiBGZWVkRGljdGlvbmFyeSwgZXZhbHVhdGlvblNldDogTm9kZVtdKSB7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBldmFsdWF0aW9uU2V0Lmxlbmd0aCkge1xuICAgIGNvbnN0IG5vZGUgPSBldmFsdWF0aW9uU2V0W2ldO1xuICAgIGlmIChmZWVkRGljdGlvbmFyeS5kaWN0W25vZGUub3V0cHV0LmlkXSAhPSBudWxsKSB7XG4gICAgICBldmFsdWF0aW9uU2V0LnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKytpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc3Bvc2VzIGFueSBOREFycmF5cyBvbiB0aGUgdGVuc29yQXJyYXlNYXAgZnJvbSBvcGVyYXRpb24gb3V0cHV0cyBhbmQgc2V0c1xuICogdGhlIHZhbHVlIHRvIG51bGwuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGV2YWx1YXRpb25TZXQgVGhlIHNldCBvZiBub2RlcyB0byBiZSBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gdGVuc29yQXJyYXlNYXAgVGhlIG1hcCB0byBkaXNwb3NlIGFuZCBpbml0aWFsaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzKFxuICAgIGV2YWx1YXRpb25TZXQ6IE5vZGVbXSwgdGVuc29yQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwKSB7XG4gIGV2YWx1YXRpb25TZXQuZm9yRWFjaChub2RlID0+IHtcbiAgICBpZiAoIWdyYXBoX3V0aWwuaXNJbnB1dE5vZGUobm9kZSkpIHtcbiAgICAgIGlmICghZ3JhcGhfdXRpbC5pc1Bhc3N0aHJvdWdoTm9kZShub2RlLCB0ZW5zb3JBcnJheU1hcCkpIHtcbiAgICAgICAgdGVuc29yQXJyYXlNYXAuZGlzcG9zZUFycmF5KG5vZGUub3V0cHV0KTtcbiAgICAgIH1cbiAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBEaXNwb3NlcyBhbnkgTkRBcnJheXMgb24gdGhlIHRlbnNvckFycmF5TWFwIGZyb20gZGVyaXZhdGl2ZXMgb2Ygb3BlcmF0aW9uXG4gKiBpbnB1dHMgYW5kIHNldHMgdGhlIHZhbHVlIHRvIG51bGwuXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIGV2YWx1YXRpb25TZXQgVGhlIHNldCBvZiBub2RlcyB0byBiZSBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gZ3JhZGllbnRzIFRoZSBncmFkaWVudCBtYXAgdG8gZGlzcG9zZSBhbmQgaW5pdGlhbGl6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMoXG4gICAgZXZhbHVhdGlvblNldDogTm9kZVtdLCBncmFkaWVudHM6IFRlbnNvckFycmF5TWFwKSB7XG4gIGV2YWx1YXRpb25TZXQuZm9yRWFjaChub2RlID0+IHtcbiAgICBPYmplY3Qua2V5cyhub2RlLmlucHV0cykuZm9yRWFjaChpbnB1dE5hbWUgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBub2RlLmlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgaWYgKGdyYWRpZW50cy5nZXQoaW5wdXQsIHRydWUpICE9PSBncmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0LCB0cnVlKSkge1xuICAgICAgICBncmFkaWVudHMuZGlzcG9zZUFycmF5KGlucHV0KTtcbiAgICAgIH1cbiAgICAgIGdyYWRpZW50cy5zZXQoaW5wdXQsIG51bGwpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIENhbGxzIHVuZGVybHlpbmcgb3BlcmF0aW9uIGRpc3Bvc2VUcmFuc2llbnRBcnJheXMgbWV0aG9kcyB3aGljaCBjbGVhbiB1cCBhbnlcbiAqIE5EQXJyYXlzIHdoaWNoIG9wZXJhdGlvbnMgbWF5IGhhdmUgY3JlYXRlZCBkdXJpbmcgYSBydW4uXG4gKlxuICogQGhpZGRlblxuICogQHBhcmFtIG9wZXJhdGlvbk5vZGVzIFRoZSBhcnJheSBvZiBOb2RlcyB0byB0cmF2ZXJzZS5cbiAqIEBwYXJhbSBvdXRwdXRUZW5zb3IgVGhlIHRlbnNvciBiZWluZyBldmFsdWF0ZWQuXG4gKiBAcGFyYW0gbWFwIFRoZSBUZW5zb3JBcnJheU1hcCB0byBvcGVyYXRlIG9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhcbiAgICBvcGVyYXRpb25zOiBPcGVyYXRpb25bXSwgYWN0aXZhdGlvbnM6IFRlbnNvckFycmF5TWFwLFxuICAgIGdyYWRpZW50czogVGVuc29yQXJyYXlNYXApIHtcbiAgb3BlcmF0aW9ucy5mb3JFYWNoKG9wID0+IG9wLmRpc3Bvc2VUcmFuc2llbnRBcnJheXMoYWN0aXZhdGlvbnMsIGdyYWRpZW50cykpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRoZSBwcm92aWRlZCBOb2RlIGFycmF5IGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZXJlIGFyZSBhbnlcbiAqIFBsYWNlaG9sZGVyIG5vZGVzIHByZXNlbnQuIENhbGwgYWZ0ZXIgdGhlIGV2YWx1YXRpb24gc2V0IGhhcyBiZWVuIHBydW5lZCB3aXRoXG4gKiB0aGUgYWNjb21wYW55aW5nIEZlZWREaWN0aW9uYXJ5IHRvIGVuc3VyZSB0aGF0IGFsbCBpbnB1dHMgaGF2ZSBiZWVuIHJlc29sdmVkLlxuICpcbiAqIEBoaWRkZW5cbiAqIEBwYXJhbSBldmFsdWF0aW9uU2V0IFRoZSBhcnJheSBvZiBub2RlcyB0byBzY2FuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyhcbiAgICBldmFsdWF0aW9uU2V0OiBOb2RlW10pIHtcbiAgZXZhbHVhdGlvblNldC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJOb2RlKSB7XG4gICAgICBjb25zdCBzaGFwZSA9ICdbJyArIG5vZGUub3V0cHV0LnNoYXBlLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1BsYWNlaG9sZGVyIG5vZGUgXCInICsgbm9kZS5uYW1lICsgJ1wiICcgKyBzaGFwZSArXG4gICAgICAgICAgJyBub3QgcHJlc2VudCBpbiBmZWVkIGRpY3Rpb25hcnkuJyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHNwbGl0cyBub2RlcyBhZnRlciBldmVyeSBub2RlIHRoYXQgaGFzIG11bHRpcGxlIGNvbnN1bWVycy5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAcGFyYW0gbm9kZXMgVGhlIG5vZGUgbGlzdCBpbiBldmFsdWF0aW9uIG9yZGVyLlxuICogQHJldHVybiBUaGUgbm9kZSBsaXN0IHdpdGggc3BsaXQgbm9kZXMgaW5qZWN0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTcGxpdE5vZGVzKG5vZGVzOiBOb2RlW10pOiBOb2RlW10ge1xuICBjb25zdCBub2RlSWRUb051bUNvbnN1bWVyczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgbm9kZUlkVG9TcGxpdE5vZGU6IHtbbm9kZUlkOiBudW1iZXJdOiBTcGxpdE5vZGV9ID0ge307XG5cbiAgLy8gRmluZCBub2RlcyB0aGF0IGhhdmUgbXVsdGlwbGUgY29uc3VtZXJzLlxuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmlucHV0cyk7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBpbnB1dFRlbnNvciA9IG5vZGUuaW5wdXRzW2tleV07XG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VGVuc29yLm5vZGU7XG4gICAgICBpZiAobm9kZUlkVG9OdW1Db25zdW1lcnNbaW5wdXQuaWRdID09IG51bGwpIHtcbiAgICAgICAgbm9kZUlkVG9OdW1Db25zdW1lcnNbaW5wdXQuaWRdID0gMDtcbiAgICAgIH1cbiAgICAgIG5vZGVJZFRvTnVtQ29uc3VtZXJzW2lucHV0LmlkXSsrO1xuICAgICAgaWYgKG5vZGVJZFRvTnVtQ29uc3VtZXJzW2lucHV0LmlkXSA+IDEgJiZcbiAgICAgICAgICBub2RlSWRUb1NwbGl0Tm9kZVtpbnB1dC5pZF0gPT0gbnVsbCkge1xuICAgICAgICBub2RlSWRUb1NwbGl0Tm9kZVtpbnB1dC5pZF0gPSBuZXcgU3BsaXROb2RlKGlucHV0LmdyYXBoLCBpbnB1dFRlbnNvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEluamVjdCBhIHNwbGl0IG5vZGUgYWZ0ZXIgZWFjaCBub2RlIHRoYXQgaGFzIG11bHRpcGxlIGNvbnN1bWVycyBhbmRcbiAgLy8gcmV3aXJlIHRoZSBpbnB1dHMgb2YgdGhlIGNvbnN1bWVycyB0byBjb25zdW1lIHRoZSBvdXRwdXQgdGVuc29ycyBvZiB0aGVcbiAgLy8gc3BsaXQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBub2RlLiBFYWNoIGNvbnN1bWVyIGNvbnN1bWVzIGFcbiAgLy8gZGlmZmVyZW50IG91dHB1dCB0ZW5zb3Igc28gdGhhdCBkZXJpdmF0aXZlcyBhcmUgbm90IG92ZXJ3cml0dGVuLlxuICAvLyB4LS0+eSAgYmVjb21lcyB4LS0+cy0tPnkgICB3aGVyZSB5IGNvbnN1bWVzIHRoZSAxc3Qgb3V0cHV0IHRlbnNvciBvZiBzXG4gIC8vIHwtLT56ICAgICAgICAgICAgICB8LS0+eiAgICAgYW5kIHogY29uc3VtZXMgdGhlIDJuZCBvdXRwdXQgdGVuc29yIG9mIHNcbiAgY29uc3QgbmV3Tm9kZXM6IE5vZGVbXSA9IFtdO1xuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIG5ld05vZGVzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUuaWQgaW4gbm9kZUlkVG9TcGxpdE5vZGUpIHtcbiAgICAgIGNvbnN0IHNwbGl0Tm9kZSA9IG5vZGVJZFRvU3BsaXROb2RlW25vZGUuaWRdO1xuICAgICAgbmV3Tm9kZXMucHVzaChzcGxpdE5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpO1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRUZW5zb3IgPSBub2RlLmlucHV0c1trZXldO1xuICAgICAgY29uc3QgaW5wdXRJZCA9IGlucHV0VGVuc29yLm5vZGUuaWQ7XG4gICAgICBpZiAoaW5wdXRJZCBpbiBub2RlSWRUb1NwbGl0Tm9kZSkge1xuICAgICAgICBub2RlLmlucHV0c1trZXldID0gbm9kZUlkVG9TcGxpdE5vZGVbaW5wdXRJZF0uZ2V0TmV3T3V0cHV0VGVuc29yKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gbmV3Tm9kZXM7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7Tm9kZX0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge05EQXJyYXlNYXRofSBmcm9tICcuL21hdGgvbWF0aCc7XG5pbXBvcnQge05EQXJyYXksIFNjYWxhcn0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuaW1wb3J0IHtPcHRpbWl6ZXJ9IGZyb20gJy4vb3B0aW1pemVyJztcbmltcG9ydCB7U2Vzc2lvblJ1bnRpbWV9IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQgKiBhcyBzZXNzaW9uX3V0aWwgZnJvbSAnLi9zZXNzaW9uX3V0aWwnO1xuaW1wb3J0IHtUZW5zb3JBcnJheU1hcH0gZnJvbSAnLi90ZW5zb3JfYXJyYXlfbWFwJztcblxuZXhwb3J0IGNsYXNzIFNHRE9wdGltaXplciBleHRlbmRzIE9wdGltaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbGVhcm5pbmdSYXRlOiBudW1iZXIsIHNwZWNpZmllZFZhcmlhYmxlTGlzdD86IE5vZGVbXSkge1xuICAgIHN1cGVyKHNwZWNpZmllZFZhcmlhYmxlTGlzdCk7XG4gIH1cblxuICBiZWZvcmVCYXRjaChcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBiYXRjaFNpemU6IG51bWJlciwgcnVudGltZTogU2Vzc2lvblJ1bnRpbWUsXG4gICAgICBhY3RpdmF0aW9uQXJyYXlNYXA6IFRlbnNvckFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCkge1xuICAgIHRoaXMudmFyaWFibGVOb2RlcyA9IHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9PSBudWxsID9cbiAgICAgICAgc2Vzc2lvbl91dGlsLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChydW50aW1lLm5vZGVzKSA6XG4gICAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcztcbiAgICBpZiAoYmF0Y2hTaXplICE9PSB0aGlzLnByZXZCYXRjaFNpemUpIHtcbiAgICAgIHRoaXMucHJldkJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgIHRoaXMuYyA9IFNjYWxhci5uZXcoLXRoaXMubGVhcm5pbmdSYXRlIC8gYmF0Y2hTaXplKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goXG4gICAgICAgIG5vZGUgPT4gdGhpcy52YXJpYWJsZUdyYWRpZW50cy5zZXQoXG4gICAgICAgICAgICBub2RlLm91dHB1dCwgTkRBcnJheS56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpKTtcbiAgfVxuXG4gIGFmdGVyRXhhbXBsZShcbiAgICAgIG1hdGg6IE5EQXJyYXlNYXRoLCBydW50aW1lOiBTZXNzaW9uUnVudGltZSxcbiAgICAgIGFjdGl2YXRpb25BcnJheU1hcDogVGVuc29yQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXA6IFRlbnNvckFycmF5TWFwKSB7XG4gICAgbWF0aC5zY29wZSgoa2VlcCkgPT4ge1xuICAgICAgdGhpcy52YXJpYWJsZU5vZGVzIS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBncmFkaWVudCA9IGdyYWRpZW50QXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRHcmFkaWVudCA9IHRoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5zZXQoXG4gICAgICAgICAgICBub2RlLm91dHB1dCwga2VlcChtYXRoLmFkZChncmFkaWVudCwgYWNjdW11bGF0ZWRHcmFkaWVudCkpKTtcbiAgICAgICAgYWNjdW11bGF0ZWRHcmFkaWVudC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFmdGVyQmF0Y2goXG4gICAgICBtYXRoOiBOREFycmF5TWF0aCwgYmF0Y2hTaXplOiBudW1iZXIsIHJ1bnRpbWU6IFNlc3Npb25SdW50aW1lLFxuICAgICAgYWN0aXZhdGlvbkFycmF5TWFwOiBUZW5zb3JBcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcDogVGVuc29yQXJyYXlNYXApIHtcbiAgICBtYXRoLnNjb3BlKChrZWVwKSA9PiB7XG4gICAgICB0aGlzLnZhcmlhYmxlTm9kZXMhLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZSA9XG4gICAgICAgICAgICBtYXRoLnNjYWxlZEFycmF5QWRkKHRoaXMuYyEsIGdyYWRpZW50LCB0aGlzLm9uZSEsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgYWN0aXZhdGlvbkFycmF5TWFwLnNldChub2RlLm91dHB1dCwga2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICBub2RlLmRhdGEgPSB2YXJpYWJsZTtcblxuICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgVGVuc29yQXJyYXlNYXAoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLm9uZS5kaXNwb3NlKCk7XG4gIH1cblxuICBzZXRMZWFybmluZ1JhdGUobGVhcm5pbmdSYXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgfVxuXG4gIHByaXZhdGUgdmFyaWFibGVHcmFkaWVudHMgPSBuZXcgVGVuc29yQXJyYXlNYXAoKTtcbiAgcHJpdmF0ZSBwcmV2QmF0Y2hTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgb25lID0gU2NhbGFyLm5ldygxKTtcbiAgcHJpdmF0ZSBjOiBTY2FsYXI7XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnLi9tYXRoL25kYXJyYXknO1xuXG4vKipcbiAqIFRlbnNvckFycmF5TWFwIGlzIGFuIGludGVybmFsIG1hcCBmcm9tIFRlbnNvciBJRHMgdG8gTkRBcnJheXMuIFNpbmNlIE5EQXJyYXlzXG4gKiBjYW4gYmUgYmFja2VkIGJ5IFdlYkdMIHRleHR1cmVzLCB0aGUgVGVuc29yQXJyYXlNYXAgaXMgb25seSB1c2VkIGluc2lkZSBvZiBhXG4gKiBTZXNzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yQXJyYXlNYXAge1xuICAvKipcbiAgICogQWRkIG9yIHJlcGxhY2UgYW4gZW50cnkgaW4gdGhlIG1hcC5cbiAgICogQHBhcmFtIHRlbnNvciBUaGUgdGVuc29yIGtleS5cbiAgICogQHBhcmFtIGFycmF5IFRoZSBOREFycmF5IHZhbHVlLCBjYW4gYmUgbnVsbC5cbiAgICovXG4gIHNldCh0ZW5zb3I6IFRlbnNvciwgYXJyYXk6IE5EQXJyYXl8bnVsbCkge1xuICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgTkRBcnJheSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHRlbnNvci4gV2lsbCB0aHJvdyBhblxuICAgKiBleGNlcHRpb24gaWYgdGhlIHRlbnNvciBpcyBub3QgYSBrZXkgaW4gdGhlIG1hcCwgb3IgaWYgdGhlIGFzc29jaWF0ZWRcbiAgICogTkRBcnJheSBpcyBudWxsLlxuICAgKiBAcGFyYW0gdGVuc29yIFRoZSB0ZW5zb3Iga2V5LlxuICAgKiBAcGFyYW0gc2tpcENoZWNrcyBGYWxzZSBieSBkZWZhdWx0LiBJZiB0cnVlIHdpbGwgc2tpcCBhbGwgY2hlY2tzLlxuICAgKiBAcmV0dXJuIFRoZSBOREFycmF5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGVuc29yLlxuICAgKi9cbiAgZ2V0KHRlbnNvcjogVGVuc29yLCBza2lwQ2hlY2tzID0gZmFsc2UpOiBOREFycmF5IHtcbiAgICBpZiAoIXNraXBDaGVja3MgJiYgdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IgJyArIHRlbnNvci5pZCArICcgbm90IGluIGFycmF5IG1hcC4nKTtcbiAgICB9XG4gICAgY29uc3QgbmRhID0gdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgaWYgKCFza2lwQ2hlY2tzICYmIG5kYSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0ZW5zb3IgJyArIHRlbnNvci5pZCArICcgaGFzIG51bGwgYXJyYXkuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZGEhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB0ZW5zb3IvTkRBcnJheSBwYWlyIGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHRlbnNvciBUaGUgdGVuc29yIGtleS5cbiAgICovXG4gIGRlbGV0ZSh0ZW5zb3I6IFRlbnNvcikge1xuICAgIGRlbGV0ZSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgfVxuXG4gIGRpc3Bvc2VBcnJheSh0ZW5zb3I6IFRlbnNvcikge1xuICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5kYSA9IHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgIGlmIChuZGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmRhLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBUaGUgbnVtYmVyIG9mIHRlbnNvci9OREFycmF5IHBhaXJzIGluIHRoZSBtYXAuXG4gICAqL1xuICBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGljdCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgY29udGFpbmVkIE5EQXJyYXkgdmFsdWVzIGFuZCBkaXNwb3NlIHRoZW0uXG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZGljdCkuZm9yRWFjaCh0ZW5zb3JJRCA9PiB7XG4gICAgICBjb25zdCBuZGEgPSB0aGlzLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgIGlmIChuZGEpIHtcbiAgICAgICAgbmRhLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRpY3QgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyB0byBzZWUgaWYgYSB0ZW5zb3IgaGFzIGEgbnVsbCBhc3NvY2lhdGVkIHdpdGggaXQuIFRocm93c1xuICAgKiBpZiB0aGUgdGVuc29yIGlzIG5vdCBhIGtleSBpbiB0aGUgbWFwLlxuICAgKiBAcGFyYW0gdGVuc29yIFRoZSB0ZW5zb3Iga2V5LlxuICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIGFzc29jaWF0ZWQgTkRBcnJheSBpcyBudWxsLCBlbHNlIEZhbHNlLlxuICAgKi9cbiAgaGFzTnVsbEFycmF5KHRlbnNvcjogVGVuc29yKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVuc29yICcgKyB0ZW5zb3IuaWQgKyAnIG5vdCBpbiBhcnJheSBtYXAuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgZGljdDoge1t0ZW5zb3JJRDogbnVtYmVyXTogTkRBcnJheSB8IG51bGx9ID0ge307XG59XG4iLCIvKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmV4cG9ydCB0eXBlIFZlY3RvciA9IG51bWJlcltdIHwgRmxvYXQ2NEFycmF5IHwgRmxvYXQzMkFycmF5IHwgSW50MzJBcnJheSB8XG4gICAgSW50OEFycmF5IHwgSW50MTZBcnJheTtcblxuLyoqIFNodWZmbGVzIHRoZSBhcnJheSB1c2luZyBGaXNoZXItWWF0ZXMgYWxnb3JpdGhtLiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuZXhwb3J0IGZ1bmN0aW9uIHNodWZmbGUoYXJyYXk6IGFueVtdfFVpbnQzMkFycmF5fEludDMyQXJyYXl8XG4gICAgICAgICAgICAgICAgICAgICAgICBGbG9hdDMyQXJyYXkpOiB2b2lkIHtcbiAgbGV0IGNvdW50ZXIgPSBhcnJheS5sZW5ndGg7XG4gIGxldCB0ZW1wID0gMDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgLy8gV2hpbGUgdGhlcmUgYXJlIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICB3aGlsZSAoY291bnRlciA+IDApIHtcbiAgICAvLyBQaWNrIGEgcmFuZG9tIGluZGV4XG4gICAgaW5kZXggPSAoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpIHwgMDtcbiAgICAvLyBEZWNyZWFzZSBjb3VudGVyIGJ5IDFcbiAgICBjb3VudGVyLS07XG4gICAgLy8gQW5kIHN3YXAgdGhlIGxhc3QgZWxlbWVudCB3aXRoIGl0XG4gICAgdGVtcCA9IGFycmF5W2NvdW50ZXJdO1xuICAgIGFycmF5W2NvdW50ZXJdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHRlbXA7XG4gIH1cbn1cblxuLyoqIENsYW1wcyBhIHZhbHVlIHRvIGEgc3BlY2lmaWVkIHJhbmdlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKG1pbjogbnVtYmVyLCB4OiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4oeCwgbWF4KSk7XG59XG5cbi8qKiBSZXR1cm5zIGEgc2FtcGxlIGZyb20gYSB1bmlmb3JtIFthLCBiXSBkaXN0cmlidXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZFVuaWZvcm0oYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoYiAtIGEpICsgYTtcbn1cblxuLyoqXG4gKiBTYW1wbGVzIGZyb20gYSBnYXVzc2lhbiBkaXN0cmlidXRpb24uXG4gKlxuICogQHBhcmFtIG1lYW4gVGhlIG1lYW4uIERlZmF1bHQgaXMgMC5cbiAqIEBwYXJhbSBzdGREZXYgVGhlIHN0YW5kYXJkIGRldmlhdGlvbi4gRGVmYXVsdCBpcyAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZEdhdXNzKG1lYW4gPSAwLCBzdGREZXYgPSAxLCB0cnVuY2F0ZWQgPSBmYWxzZSk6IG51bWJlciB7XG4gIGxldCB2MTogbnVtYmVyLCB2MjogbnVtYmVyLCBzOiBudW1iZXI7XG4gIGRvIHtcbiAgICB2MSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgICB2MiA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTtcbiAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gIH0gd2hpbGUgKHMgPiAxKTtcblxuICBjb25zdCByZXN1bHQgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhzKSAvIHMpICogdjE7XG4gIGlmICh0cnVuY2F0ZWQgJiYgcmVzdWx0ID4gMikge1xuICAgIHJldHVybiByYW5kR2F1c3MobWVhbiwgc3RkRGV2LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gbWVhbiArIHN0ZERldiAqIHJlc3VsdDtcbn1cblxuLyoqIFJldHVybnMgc3F1YXJlZCBldWNsZWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjdG9ycy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0U3F1YXJlZChhOiBWZWN0b3IsIGI6IFZlY3Rvcik6IG51bWJlciB7XG4gIGxldCByZXN1bHQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaWZmID0gYVtpXSAtIGJbaV07XG4gICAgcmVzdWx0ICs9IGRpZmYgKiBkaWZmO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZXhwcjogYm9vbGVhbiwgbXNnOiBzdHJpbmcpIHtcbiAgaWYgKCFleHByKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNoYXBlc01hdGNoKFxuICAgIHNoYXBlQTogbnVtYmVyW10sIHNoYXBlQjogbnVtYmVyW10sIGVycm9yTWVzc2FnZVByZWZpeCA9ICcnKTogdm9pZCB7XG4gIGFzc2VydChcbiAgICAgIGFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSxcbiAgICAgIGVycm9yTWVzc2FnZVByZWZpeCArIGBTaGFwZXMgJHtzaGFwZUF9IGFuZCAke3NoYXBlQn0gbXVzdCBtYXRjaGApO1xufVxuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihhcnI6IGFueVtdLCByZXQ/OiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgcmV0ID0gKHJldCA9PT0gdW5kZWZpbmVkID8gW10gOiByZXQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcbiAgICAgIGZsYXR0ZW4oYXJyW2ldLCByZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgdHlwZSBBcnJheURhdGEgPSBudW1iZXJ8bnVtYmVyW118bnVtYmVyW11bXXxudW1iZXJbXVtdW118bnVtYmVyW11bXVtdW107XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmZlclNoYXBlKGFycjogQXJyYXlEYXRhKTogbnVtYmVyW10ge1xuICBjb25zdCBzaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgd2hpbGUgKGFyciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgc2hhcGUucHVzaChhcnIubGVuZ3RoKTtcbiAgICBhcnIgPSBhcnJbMF07XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2l6ZUZyb21TaGFwZShzaGFwZTogbnVtYmVyW10pOiBudW1iZXIge1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2NhbGFyLlxuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBzaXplID0gc2hhcGVbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICBzaXplICo9IHNoYXBlW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShzaGFwZTogbnVtYmVyW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNoYXBlLmxlbmd0aCA9PT0gMDtcbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5c0VxdWFsKG4xOiBhbnlbXXxGbG9hdDMyQXJyYXksIG4yOiBhbnlbXXxGbG9hdDMyQXJyYXkpIHtcbiAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnQoYTogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBhICUgMSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhbmgoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICBpZiAoKE1hdGggYXMgYW55KS50YW5oICE9IG51bGwpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcmV0dXJuIChNYXRoIGFzIGFueSkudGFuaCh4KTtcbiAgfVxuICBpZiAoeCA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh4ID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZTJ4ID0gTWF0aC5leHAoMiAqIHgpO1xuICAgIHJldHVybiAoZTJ4IC0gMSkgLyAoZTJ4ICsgMSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gIGZvciAobGV0IGEgPSBNYXRoLmZsb29yKE1hdGguc3FydChzaXplKSk7IGEgPiAxOyAtLWEpIHtcbiAgICBpZiAoc2l6ZSAlIGEgPT09IDApIHtcbiAgICAgIHJldHVybiBbYSwgc2l6ZSAvIGFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWzEsIHNpemVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzKG46IG51bWJlcik6IFVpbnQzMkFycmF5IHtcbiAgY29uc3Qgc2h1ZmZsZWRJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHNodWZmbGVkSW5kaWNlc1tpXSA9IGk7XG4gIH1cbiAgc2h1ZmZsZShzaHVmZmxlZEluZGljZXMpO1xuICByZXR1cm4gc2h1ZmZsZWRJbmRpY2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0ZWRTaGFwZShcbiAgICBzaGFwZUE6IG51bWJlcltdLCBzaGFwZUI6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGxldCBuZXh0QURpbU11c3RCZU9uZSA9IGZhbHNlO1xuICBsZXQgbmV4dEJEaW1NdXN0QmVPbmUgPSBmYWxzZTtcbiAgY29uc3QgZXJyTXNnID0gYE9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgYCArXG4gICAgICBgJHtzaGFwZUF9IGFuZCAke3NoYXBlQn0uIEN1cnJlbnRseSwgd2Ugb25seSBzdXBwb3J0IGEgYCArXG4gICAgICBgc3RyaWN0ZXIgdmVyc2lvbiBvZiBicm9hZGNhc3RpbmcgdGhhbiBudW1weS5gO1xuICBjb25zdCBsID0gTWF0aC5tYXgoc2hhcGVBLmxlbmd0aCwgc2hhcGVCLmxlbmd0aCk7XG5cbiAgc2hhcGVBID0gc2hhcGVBLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBzaGFwZUIgPSBzaGFwZUIuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgYSA9IHNoYXBlQVtpXSB8fCAxO1xuICAgIGNvbnN0IGIgPSBzaGFwZUJbaV0gfHwgMTtcbiAgICBpZiAoKGIgPiAxICYmIG5leHRCRGltTXVzdEJlT25lKSB8fCAoYSA+IDEgJiYgbmV4dEFEaW1NdXN0QmVPbmUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICBpZiAoYSA+IDEgJiYgYiA9PT0gMSkge1xuICAgICAgbmV4dEJEaW1NdXN0QmVPbmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYiA+IDEgJiYgYSA9PT0gMSkge1xuICAgICAgbmV4dEFEaW1NdXN0QmVPbmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYSA+IDEgJiYgYiA+IDEgJiYgYSAhPT0gYikge1xuICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goTWF0aC5tYXgoYSwgYikpO1xuICB9XG4gIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xufVxuIl19
